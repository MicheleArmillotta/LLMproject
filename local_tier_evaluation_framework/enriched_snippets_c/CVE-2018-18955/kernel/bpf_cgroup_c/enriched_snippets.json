[
  {
    "function_name": "cgroup_dev_is_valid_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "726-754",
    "snippet": "static bool cgroup_dev_is_valid_access(int off, int size,\n\t\t\t\t       enum bpf_access_type type,\n\t\t\t\t       const struct bpf_prog *prog,\n\t\t\t\t       struct bpf_insn_access_aux *info)\n{\n\tconst int size_default = sizeof(__u32);\n\n\tif (type == BPF_WRITE)\n\t\treturn false;\n\n\tif (off < 0 || off + size > sizeof(struct bpf_cgroup_dev_ctx))\n\t\treturn false;\n\t/* The verifier guarantees that size > 0. */\n\tif (off % size != 0)\n\t\treturn false;\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_cgroup_dev_ctx, access_type):\n\t\tbpf_ctx_record_field_size(info, size_default);\n\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_default))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (size != size_default)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_ctx_narrow_access_ok",
          "args": [
            "off",
            "size",
            "size_default"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_record_field_size",
          "args": [
            "info",
            "size_default"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_range",
          "args": [
            "structbpf_cgroup_dev_ctx",
            "access_type"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool cgroup_dev_is_valid_access(int off, int size,\n\t\t\t\t       enum bpf_access_type type,\n\t\t\t\t       const struct bpf_prog *prog,\n\t\t\t\t       struct bpf_insn_access_aux *info)\n{\n\tconst int size_default = sizeof(__u32);\n\n\tif (type == BPF_WRITE)\n\t\treturn false;\n\n\tif (off < 0 || off + size > sizeof(struct bpf_cgroup_dev_ctx))\n\t\treturn false;\n\t/* The verifier guarantees that size > 0. */\n\tif (off % size != 0)\n\t\treturn false;\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_cgroup_dev_ctx, access_type):\n\t\tbpf_ctx_record_field_size(info, size_default);\n\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_default))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (size != size_default)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgroup_dev_func_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "702-724",
    "snippet": "static const struct bpf_func_proto *\ncgroup_dev_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\tif (capable(CAP_SYS_ADMIN))\n\t\t\treturn bpf_get_trace_printk_proto();\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_trace_printk_proto",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_trace_printk_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1844-1847",
          "snippet": "const struct bpf_func_proto * __weak bpf_get_trace_printk_proto(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nconst struct bpf_func_proto * __weak bpf_get_trace_printk_proto(void)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto *\ncgroup_dev_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_local_storage:\n\t\treturn &bpf_get_local_storage_proto;\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\tif (capable(CAP_SYS_ADMIN))\n\t\t\treturn bpf_get_trace_printk_proto();\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "__cgroup_bpf_check_dev_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "681-699",
    "snippet": "int __cgroup_bpf_check_dev_permission(short dev_type, u32 major, u32 minor,\n\t\t\t\t      short access, enum bpf_attach_type type)\n{\n\tstruct cgroup *cgrp;\n\tstruct bpf_cgroup_dev_ctx ctx = {\n\t\t.access_type = (access << 16) | dev_type,\n\t\t.major = major,\n\t\t.minor = minor,\n\t};\n\tint allow = 1;\n\n\trcu_read_lock();\n\tcgrp = task_dfl_cgroup(current);\n\tallow = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx,\n\t\t\t\t   BPF_PROG_RUN);\n\trcu_read_unlock();\n\n\treturn !allow;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY",
          "args": [
            "cgrp->bpf.effective[type]",
            "&ctx",
            "BPF_PROG_RUN"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "current"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_check_dev_permission(short dev_type, u32 major, u32 minor,\n\t\t\t\t      short access, enum bpf_attach_type type)\n{\n\tstruct cgroup *cgrp;\n\tstruct bpf_cgroup_dev_ctx ctx = {\n\t\t.access_type = (access << 16) | dev_type,\n\t\t.major = major,\n\t\t.minor = minor,\n\t};\n\tint allow = 1;\n\n\trcu_read_lock();\n\tcgrp = task_dfl_cgroup(current);\n\tallow = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx,\n\t\t\t\t   BPF_PROG_RUN);\n\trcu_read_unlock();\n\n\treturn !allow;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_sock_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "668-678",
    "snippet": "int __cgroup_bpf_run_filter_sock_ops(struct sock *sk,\n\t\t\t\t     struct bpf_sock_ops_kern *sock_ops,\n\t\t\t\t     enum bpf_attach_type type)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tint ret;\n\n\tret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], sock_ops,\n\t\t\t\t BPF_PROG_RUN);\n\treturn ret == 1 ? 0 : -EPERM;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY",
          "args": [
            "cgrp->bpf.effective[type]",
            "sock_ops",
            "BPF_PROG_RUN"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_sock_ops(struct sock *sk,\n\t\t\t\t     struct bpf_sock_ops_kern *sock_ops,\n\t\t\t\t     enum bpf_attach_type type)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tint ret;\n\n\tret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], sock_ops,\n\t\t\t\t BPF_PROG_RUN);\n\treturn ret == 1 ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_sock_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "620-649",
    "snippet": "int __cgroup_bpf_run_filter_sock_addr(struct sock *sk,\n\t\t\t\t      struct sockaddr *uaddr,\n\t\t\t\t      enum bpf_attach_type type,\n\t\t\t\t      void *t_ctx)\n{\n\tstruct bpf_sock_addr_kern ctx = {\n\t\t.sk = sk,\n\t\t.uaddr = uaddr,\n\t\t.t_ctx = t_ctx,\n\t};\n\tstruct sockaddr_storage unspec;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* Check socket family since not all sockets represent network\n\t * endpoint (e.g. AF_UNIX).\n\t */\n\tif (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)\n\t\treturn 0;\n\n\tif (!ctx.uaddr) {\n\t\tmemset(&unspec, 0, sizeof(unspec));\n\t\tctx.uaddr = (struct sockaddr *)&unspec;\n\t}\n\n\tcgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx, BPF_PROG_RUN);\n\n\treturn ret == 1 ? 0 : -EPERM;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY",
          "args": [
            "cgrp->bpf.effective[type]",
            "&ctx",
            "BPF_PROG_RUN"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&unspec",
            "0",
            "sizeof(unspec)"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_sock_addr(struct sock *sk,\n\t\t\t\t      struct sockaddr *uaddr,\n\t\t\t\t      enum bpf_attach_type type,\n\t\t\t\t      void *t_ctx)\n{\n\tstruct bpf_sock_addr_kern ctx = {\n\t\t.sk = sk,\n\t\t.uaddr = uaddr,\n\t\t.t_ctx = t_ctx,\n\t};\n\tstruct sockaddr_storage unspec;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* Check socket family since not all sockets represent network\n\t * endpoint (e.g. AF_UNIX).\n\t */\n\tif (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)\n\t\treturn 0;\n\n\tif (!ctx.uaddr) {\n\t\tmemset(&unspec, 0, sizeof(unspec));\n\t\tctx.uaddr = (struct sockaddr *)&unspec;\n\t}\n\n\tcgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx, BPF_PROG_RUN);\n\n\treturn ret == 1 ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_sk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "596-604",
    "snippet": "int __cgroup_bpf_run_filter_sk(struct sock *sk,\n\t\t\t       enum bpf_attach_type type)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tint ret;\n\n\tret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], sk, BPF_PROG_RUN);\n\treturn ret == 1 ? 0 : -EPERM;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY",
          "args": [
            "cgrp->bpf.effective[type]",
            "sk",
            "BPF_PROG_RUN"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_sk(struct sock *sk,\n\t\t\t       enum bpf_attach_type type)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tint ret;\n\n\tret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], sk, BPF_PROG_RUN);\n\treturn ret == 1 ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "__cgroup_bpf_run_filter_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "550-580",
    "snippet": "int __cgroup_bpf_run_filter_skb(struct sock *sk,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tenum bpf_attach_type type)\n{\n\tunsigned int offset = skb->data - skb_network_header(skb);\n\tstruct sock *save_sk;\n\tvoid *saved_data_end;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tif (!sk || !sk_fullsock(sk))\n\t\treturn 0;\n\n\tif (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)\n\t\treturn 0;\n\n\tcgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tsave_sk = skb->sk;\n\tskb->sk = sk;\n\t__skb_push(skb, offset);\n\n\t/* compute pointers for the bpf prog */\n\tbpf_compute_and_save_data_end(skb, &saved_data_end);\n\n\tret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], skb,\n\t\t\t\t bpf_prog_run_save_cb);\n\tbpf_restore_data_end(skb, saved_data_end);\n\t__skb_pull(skb, offset);\n\tskb->sk = save_sk;\n\treturn ret == 1 ? 0 : -EPERM;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__skb_pull",
          "args": [
            "skb",
            "offset"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_restore_data_end",
          "args": [
            "skb",
            "saved_data_end"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY",
          "args": [
            "cgrp->bpf.effective[type]",
            "skb",
            "bpf_prog_run_save_cb"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_compute_and_save_data_end",
          "args": [
            "skb",
            "&saved_data_end"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__skb_push",
          "args": [
            "skb",
            "offset"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "&sk->sk_cgrp_data"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_fullsock",
          "args": [
            "sk"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_network_header",
          "args": [
            "skb"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_run_filter_skb(struct sock *sk,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tenum bpf_attach_type type)\n{\n\tunsigned int offset = skb->data - skb_network_header(skb);\n\tstruct sock *save_sk;\n\tvoid *saved_data_end;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tif (!sk || !sk_fullsock(sk))\n\t\treturn 0;\n\n\tif (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)\n\t\treturn 0;\n\n\tcgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);\n\tsave_sk = skb->sk;\n\tskb->sk = sk;\n\t__skb_push(skb, offset);\n\n\t/* compute pointers for the bpf prog */\n\tbpf_compute_and_save_data_end(skb, &saved_data_end);\n\n\tret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], skb,\n\t\t\t\t bpf_prog_run_save_cb);\n\tbpf_restore_data_end(skb, saved_data_end);\n\t__skb_pull(skb, offset);\n\tskb->sk = save_sk;\n\treturn ret == 1 ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "cgroup_bpf_prog_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "519-533",
    "snippet": "int cgroup_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_query(cgrp, attr, uattr);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_query",
          "args": [
            "cgrp",
            "attr",
            "uattr"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "436-479",
          "snippet": "int __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tu32 flags = cgrp->bpf.flags[type];\n\tint cnt, ret = 0, i;\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(cgrp->bpf.effective[type]);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(cgrp->bpf.effective[type],\n\t\t\t\t\t\t   prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tid = pl->prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tu32 flags = cgrp->bpf.flags[type];\n\tint cnt, ret = 0, i;\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(cgrp->bpf.effective[type]);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(cgrp->bpf.effective[type],\n\t\t\t\t\t\t   prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tid = pl->prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_fd",
          "args": [
            "attr->query.target_fd"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5843-5865",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_query(cgrp, attr, uattr);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_prog_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "497-517",
    "snippet": "int cgroup_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tstruct bpf_prog *prog;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\tprog = NULL;\n\n\tret = cgroup_bpf_detach(cgrp, prog, attr->attach_type, 0);\n\tif (prog)\n\t\tbpf_prog_put(prog);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_detach",
          "args": [
            "cgrp",
            "prog",
            "attr->attach_type",
            "0"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "365-433",
          "snippet": "int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 unused_flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tenum bpf_cgroup_storage_type stype;\n\tu32 flags = cgrp->bpf.flags[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_prog_list *pl;\n\tint err;\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tif (!prog)\n\t\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t\t * of the program to be detached\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\t/* find the prog and detach it */\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog != prog)\n\t\t\t\tcontinue;\n\t\t\told_prog = prog;\n\t\t\t/* mark it deleted, so it's ignored while\n\t\t\t * recomputing effective\n\t\t\t */\n\t\t\tpl->prog = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!old_prog)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL)\n\t\t */\n\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\told_prog = pl->prog;\n\t\tpl->prog = NULL;\n\t}\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t}\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[type] = 0;\n\n\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\treturn 0;\n\ncleanup:\n\t/* and restore back old_prog */\n\tpl->prog = old_prog;\n\treturn err;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 unused_flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tenum bpf_cgroup_storage_type stype;\n\tu32 flags = cgrp->bpf.flags[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_prog_list *pl;\n\tint err;\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tif (!prog)\n\t\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t\t * of the program to be detached\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\t/* find the prog and detach it */\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog != prog)\n\t\t\t\tcontinue;\n\t\t\told_prog = prog;\n\t\t\t/* mark it deleted, so it's ignored while\n\t\t\t * recomputing effective\n\t\t\t */\n\t\t\tpl->prog = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!old_prog)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL)\n\t\t */\n\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\told_prog = pl->prog;\n\t\tpl->prog = NULL;\n\t}\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t}\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[type] = 0;\n\n\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\treturn 0;\n\ncleanup:\n\t/* and restore back old_prog */\n\tpl->prog = old_prog;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_type",
          "args": [
            "attr->attach_bpf_fd",
            "ptype"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_type_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "542-554",
          "snippet": "struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_fd",
          "args": [
            "attr->target_fd"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5843-5865",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tstruct bpf_prog *prog;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\tprog = NULL;\n\n\tret = cgroup_bpf_detach(cgrp, prog, attr->attach_type, 0);\n\tif (prog)\n\t\tbpf_prog_put(prog);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_prog_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "481-495",
    "snippet": "int cgroup_bpf_prog_attach(const union bpf_attr *attr,\n\t\t\t   enum bpf_prog_type ptype, struct bpf_prog *prog)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_attach(cgrp, prog, attr->attach_type,\n\t\t\t\tattr->attach_flags);\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_attach",
          "args": [
            "cgrp",
            "prog",
            "attr->attach_type",
            "attr->attach_flags"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "236-354",
          "snippet": "int __cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE],\n\t\t*old_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {NULL};\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_list *pl;\n\tbool pl_was_allocated;\n\tint err;\n\n\tif ((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\n\tif (!hierarchy_allows_attach(cgrp, type, flags))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[type] != flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tstorage[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storage[stype])) {\n\t\t\tstorage[stype] = NULL;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == prog) {\n\t\t\t\t/* disallow attaching the same prog twice */\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpl_was_allocated = true;\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t\tlist_add_tail(&pl->node, progs);\n\t} else {\n\t\tif (list_empty(progs)) {\n\t\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\t\tif (!pl) {\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpl_was_allocated = true;\n\t\t\tlist_add_tail(&pl->node, progs);\n\t\t} else {\n\t\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\t\told_prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\told_storage[stype] = pl->storage[stype];\n\t\t\t\tbpf_cgroup_storage_unlink(old_storage[stype]);\n\t\t\t}\n\t\t\tpl_was_allocated = false;\n\t\t}\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t}\n\n\tcgrp->bpf.flags[type] = flags;\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\tstatic_branch_inc(&cgroup_bpf_enabled_key);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!old_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_free(old_storage[stype]);\n\t}\n\tif (old_prog) {\n\t\tbpf_prog_put(old_prog);\n\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t}\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storage[stype], cgrp, type);\n\treturn 0;\n\ncleanup:\n\t/* and cleanup the prog list */\n\tpl->prog = old_prog;\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\tpl->storage[stype] = old_storage[stype];\n\t\tbpf_cgroup_storage_link(old_storage[stype], cgrp, type);\n\t}\n\tif (pl_was_allocated) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BPF_CGROUP_MAX_PROGS 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define BPF_CGROUP_MAX_PROGS 64\n\nint __cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE],\n\t\t*old_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {NULL};\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_list *pl;\n\tbool pl_was_allocated;\n\tint err;\n\n\tif ((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\n\tif (!hierarchy_allows_attach(cgrp, type, flags))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[type] != flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tstorage[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storage[stype])) {\n\t\t\tstorage[stype] = NULL;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == prog) {\n\t\t\t\t/* disallow attaching the same prog twice */\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpl_was_allocated = true;\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t\tlist_add_tail(&pl->node, progs);\n\t} else {\n\t\tif (list_empty(progs)) {\n\t\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\t\tif (!pl) {\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpl_was_allocated = true;\n\t\t\tlist_add_tail(&pl->node, progs);\n\t\t} else {\n\t\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\t\told_prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\told_storage[stype] = pl->storage[stype];\n\t\t\t\tbpf_cgroup_storage_unlink(old_storage[stype]);\n\t\t\t}\n\t\t\tpl_was_allocated = false;\n\t\t}\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t}\n\n\tcgrp->bpf.flags[type] = flags;\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\tstatic_branch_inc(&cgroup_bpf_enabled_key);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!old_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_free(old_storage[stype]);\n\t}\n\tif (old_prog) {\n\t\tbpf_prog_put(old_prog);\n\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t}\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storage[stype], cgrp, type);\n\treturn 0;\n\ncleanup:\n\t/* and cleanup the prog list */\n\tpl->prog = old_prog;\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\tpl->storage[stype] = old_storage[stype];\n\t\tbpf_cgroup_storage_link(old_storage[stype], cgrp, type);\n\t}\n\tif (pl_was_allocated) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_fd",
          "args": [
            "attr->target_fd"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5843-5865",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_attach(const union bpf_attr *attr,\n\t\t\t   enum bpf_prog_type ptype, struct bpf_prog *prog)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_attach(cgrp, prog, attr->attach_type,\n\t\t\t\tattr->attach_flags);\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
  },
  {
    "function_name": "__cgroup_bpf_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "436-479",
    "snippet": "int __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tu32 flags = cgrp->bpf.flags[type];\n\tint cnt, ret = 0, i;\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(cgrp->bpf.effective[type]);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(cgrp->bpf.effective[type],\n\t\t\t\t\t\t   prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tid = pl->prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "prog_ids + i",
            "&id",
            "sizeof(id)"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "progs",
            "node"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prog_list_length",
          "args": [
            "progs"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "52-63",
          "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_length",
          "args": [
            "cgrp->bpf.effective[type]"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1603-1615",
          "snippet": "int bpf_prog_array_length(struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\trcu_read_lock();\n\titem = rcu_dereference(array)->items;\n\tfor (; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_length(struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\trcu_read_lock();\n\titem = rcu_dereference(array)->items;\n\tfor (; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->query.prog_ids"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tu32 flags = cgrp->bpf.flags[type];\n\tint cnt, ret = 0, i;\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(cgrp->bpf.effective[type]);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(cgrp->bpf.effective[type],\n\t\t\t\t\t\t   prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tid = pl->prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__cgroup_bpf_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "365-433",
    "snippet": "int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 unused_flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tenum bpf_cgroup_storage_type stype;\n\tu32 flags = cgrp->bpf.flags[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_prog_list *pl;\n\tint err;\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tif (!prog)\n\t\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t\t * of the program to be detached\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\t/* find the prog and detach it */\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog != prog)\n\t\t\t\tcontinue;\n\t\t\told_prog = prog;\n\t\t\t/* mark it deleted, so it's ignored while\n\t\t\t * recomputing effective\n\t\t\t */\n\t\t\tpl->prog = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!old_prog)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL)\n\t\t */\n\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\told_prog = pl->prog;\n\t\tpl->prog = NULL;\n\t}\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t}\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[type] = 0;\n\n\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\treturn 0;\n\ncleanup:\n\t/* and restore back old_prog */\n\tpl->prog = old_prog;\n\treturn err;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&cgroup_bpf_enabled_key"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "old_prog"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "progs"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pl"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_free",
          "args": [
            "pl->storage[stype]"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "438-457",
          "snippet": "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\tu32 pages;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\n\tbpf_cgroup_storage_calculate_size(map, &pages);\n\tbpf_map_uncharge_memlock(map, pages);\n\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\tu32 pages;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\n\tbpf_cgroup_storage_calculate_size(map, &pages);\n\tbpf_map_uncharge_memlock(map, pages);\n\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_unlink",
          "args": [
            "pl->storage[stype]"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "479-495",
          "snippet": "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list);\n\tspin_unlock_bh(&map->lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list);\n\tspin_unlock_bh(&map->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pl->node"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_effective_progs",
          "args": [
            "cgrp",
            "type"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "update_effective_progs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "186-223",
          "snippet": "static int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum bpf_attach_type type)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\terr = compute_effective_progs(desc, type, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tactivate_effective_progs(desc, type, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum bpf_attach_type type)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\terr = compute_effective_progs(desc, type, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tactivate_effective_progs(desc, type, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "progs",
            "typeof(*pl)",
            "node"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*pl"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "progs",
            "node"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 unused_flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tenum bpf_cgroup_storage_type stype;\n\tu32 flags = cgrp->bpf.flags[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_prog_list *pl;\n\tint err;\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tif (!prog)\n\t\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t\t * of the program to be detached\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\t/* find the prog and detach it */\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog != prog)\n\t\t\t\tcontinue;\n\t\t\told_prog = prog;\n\t\t\t/* mark it deleted, so it's ignored while\n\t\t\t * recomputing effective\n\t\t\t */\n\t\t\tpl->prog = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!old_prog)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL)\n\t\t */\n\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\told_prog = pl->prog;\n\t\tpl->prog = NULL;\n\t}\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t}\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[type] = 0;\n\n\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\treturn 0;\n\ncleanup:\n\t/* and restore back old_prog */\n\tpl->prog = old_prog;\n\treturn err;\n}"
  },
  {
    "function_name": "__cgroup_bpf_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "236-354",
    "snippet": "int __cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE],\n\t\t*old_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {NULL};\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_list *pl;\n\tbool pl_was_allocated;\n\tint err;\n\n\tif ((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\n\tif (!hierarchy_allows_attach(cgrp, type, flags))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[type] != flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tstorage[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storage[stype])) {\n\t\t\tstorage[stype] = NULL;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == prog) {\n\t\t\t\t/* disallow attaching the same prog twice */\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpl_was_allocated = true;\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t\tlist_add_tail(&pl->node, progs);\n\t} else {\n\t\tif (list_empty(progs)) {\n\t\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\t\tif (!pl) {\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpl_was_allocated = true;\n\t\t\tlist_add_tail(&pl->node, progs);\n\t\t} else {\n\t\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\t\told_prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\told_storage[stype] = pl->storage[stype];\n\t\t\t\tbpf_cgroup_storage_unlink(old_storage[stype]);\n\t\t\t}\n\t\t\tpl_was_allocated = false;\n\t\t}\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t}\n\n\tcgrp->bpf.flags[type] = flags;\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\tstatic_branch_inc(&cgroup_bpf_enabled_key);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!old_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_free(old_storage[stype]);\n\t}\n\tif (old_prog) {\n\t\tbpf_prog_put(old_prog);\n\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t}\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storage[stype], cgrp, type);\n\treturn 0;\n\ncleanup:\n\t/* and cleanup the prog list */\n\tpl->prog = old_prog;\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\tpl->storage[stype] = old_storage[stype];\n\t\tbpf_cgroup_storage_link(old_storage[stype], cgrp, type);\n\t}\n\tif (pl_was_allocated) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BPF_CGROUP_MAX_PROGS 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pl"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pl->node"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_link",
          "args": [
            "old_storage[stype]",
            "cgrp",
            "type"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "459-477",
          "snippet": "void bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,\n\t\t\t     struct cgroup *cgroup,\n\t\t\t     enum bpf_attach_type type)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tstorage->key.attach_type = type;\n\tstorage->key.cgroup_inode_id = cgroup->kn->id.id;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\tWARN_ON(cgroup_storage_insert(map, storage));\n\tlist_add(&storage->list, &map->list);\n\tspin_unlock_bh(&map->lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,\n\t\t\t     struct cgroup *cgroup,\n\t\t\t     enum bpf_attach_type type)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tstorage->key.attach_type = type;\n\tstorage->key.cgroup_inode_id = cgroup->kn->id.id;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\tWARN_ON(cgroup_storage_insert(map, storage));\n\tlist_add(&storage->list, &map->list);\n\tspin_unlock_bh(&map->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_free",
          "args": [
            "pl->storage[stype]"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "438-457",
          "snippet": "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\tu32 pages;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\n\tbpf_cgroup_storage_calculate_size(map, &pages);\n\tbpf_map_uncharge_memlock(map, pages);\n\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\tu32 pages;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\n\tbpf_cgroup_storage_calculate_size(map, &pages);\n\tbpf_map_uncharge_memlock(map, pages);\n\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&cgroup_bpf_enabled_key"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "old_prog"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&cgroup_bpf_enabled_key"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_effective_progs",
          "args": [
            "cgrp",
            "type"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "update_effective_progs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "186-223",
          "snippet": "static int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum bpf_attach_type type)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\terr = compute_effective_progs(desc, type, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tactivate_effective_progs(desc, type, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum bpf_attach_type type)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\terr = compute_effective_progs(desc, type, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tactivate_effective_progs(desc, type, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_unlink",
          "args": [
            "old_storage[stype]"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "479-495",
          "snippet": "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list);\n\tspin_unlock_bh(&map->lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list);\n\tspin_unlock_bh(&map->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "progs",
            "typeof(*pl)",
            "node"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*pl"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pl->node",
            "progs"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*pl)",
            "GFP_KERNEL"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "progs"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pl->node",
            "progs"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "progs",
            "node"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "storage[stype]"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_alloc",
          "args": [
            "prog",
            "stype"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "375-418",
          "snippet": "struct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tgfp_t flags;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tif (bpf_map_charge_memlock(map, pages))\n\t\treturn ERR_PTR(-EPERM);\n\n\tstorage = kmalloc_node(sizeof(struct bpf_cgroup_storage),\n\t\t\t       __GFP_ZERO | GFP_USER, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tflags = __GFP_ZERO | GFP_USER;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = kmalloc_node(size, flags, map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t} else {\n\t\tstorage->percpu_buf = __alloc_percpu_gfp(size, 8, flags);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tbpf_map_uncharge_memlock(map, pages);\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tgfp_t flags;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tif (bpf_map_charge_memlock(map, pages))\n\t\treturn ERR_PTR(-EPERM);\n\n\tstorage = kmalloc_node(sizeof(struct bpf_cgroup_storage),\n\t\t\t       __GFP_ZERO | GFP_USER, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tflags = __GFP_ZERO | GFP_USER;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = kmalloc_node(size, flags, map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t} else {\n\t\tstorage->percpu_buf = __alloc_percpu_gfp(size, 8, flags);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tbpf_map_uncharge_memlock(map, pages);\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prog_list_length",
          "args": [
            "progs"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "52-63",
          "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hierarchy_allows_attach",
          "args": [
            "cgrp",
            "type",
            "flags"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "hierarchy_allows_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "69-91",
          "snippet": "static bool hierarchy_allows_attach(struct cgroup *cgrp,\n\t\t\t\t    enum bpf_attach_type type,\n\t\t\t\t    u32 new_flags)\n{\n\tstruct cgroup *p;\n\n\tp = cgroup_parent(cgrp);\n\tif (!p)\n\t\treturn true;\n\tdo {\n\t\tu32 flags = p->bpf.flags[type];\n\t\tu32 cnt;\n\n\t\tif (flags & BPF_F_ALLOW_MULTI)\n\t\t\treturn true;\n\t\tcnt = prog_list_length(&p->bpf.progs[type]);\n\t\tWARN_ON_ONCE(cnt > 1);\n\t\tif (cnt == 1)\n\t\t\treturn !!(flags & BPF_F_ALLOW_OVERRIDE);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\treturn true;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool hierarchy_allows_attach(struct cgroup *cgrp,\n\t\t\t\t    enum bpf_attach_type type,\n\t\t\t\t    u32 new_flags)\n{\n\tstruct cgroup *p;\n\n\tp = cgroup_parent(cgrp);\n\tif (!p)\n\t\treturn true;\n\tdo {\n\t\tu32 flags = p->bpf.flags[type];\n\t\tu32 cnt;\n\n\t\tif (flags & BPF_F_ALLOW_MULTI)\n\t\t\treturn true;\n\t\tcnt = prog_list_length(&p->bpf.progs[type]);\n\t\tWARN_ON_ONCE(cnt > 1);\n\t\tif (cnt == 1)\n\t\t\treturn !!(flags & BPF_F_ALLOW_OVERRIDE);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define BPF_CGROUP_MAX_PROGS 64\n\nint __cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE],\n\t\t*old_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {NULL};\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_list *pl;\n\tbool pl_was_allocated;\n\tint err;\n\n\tif ((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\n\tif (!hierarchy_allows_attach(cgrp, type, flags))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[type] != flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tstorage[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storage[stype])) {\n\t\t\tstorage[stype] = NULL;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == prog) {\n\t\t\t\t/* disallow attaching the same prog twice */\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpl_was_allocated = true;\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t\tlist_add_tail(&pl->node, progs);\n\t} else {\n\t\tif (list_empty(progs)) {\n\t\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\t\tif (!pl) {\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpl_was_allocated = true;\n\t\t\tlist_add_tail(&pl->node, progs);\n\t\t} else {\n\t\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\t\told_prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\told_storage[stype] = pl->storage[stype];\n\t\t\t\tbpf_cgroup_storage_unlink(old_storage[stype]);\n\t\t\t}\n\t\t\tpl_was_allocated = false;\n\t\t}\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t}\n\n\tcgrp->bpf.flags[type] = flags;\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\tstatic_branch_inc(&cgroup_bpf_enabled_key);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!old_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_free(old_storage[stype]);\n\t}\n\tif (old_prog) {\n\t\tbpf_prog_put(old_prog);\n\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t}\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storage[stype], cgrp, type);\n\treturn 0;\n\ncleanup:\n\t/* and cleanup the prog list */\n\tpl->prog = old_prog;\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\tpl->storage[stype] = old_storage[stype];\n\t\tbpf_cgroup_storage_link(old_storage[stype], cgrp, type);\n\t}\n\tif (pl_was_allocated) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "update_effective_progs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "186-223",
    "snippet": "static int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum bpf_attach_type type)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\terr = compute_effective_progs(desc, type, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tactivate_effective_progs(desc, type, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "desc->bpf.inactive"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1595-1601",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcgroup",
            "self"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "activate_effective_progs",
          "args": [
            "desc",
            "type",
            "desc->bpf.inactive"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "activate_effective_progs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "143-154",
          "snippet": "static void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\n\told_array = xchg(&cgrp->bpf.effective[type], array);\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\n\told_array = xchg(&cgrp->bpf.effective[type], array);\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcgroup",
            "self"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compute_effective_progs",
          "args": [
            "desc",
            "type",
            "&desc->bpf.inactive"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "compute_effective_progs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "99-141",
          "snippet": "static int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum bpf_attach_type type,\n\t\t\t\t   struct bpf_prog_array __rcu **array)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[type]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[type], node) {\n\t\t\tif (!pl->prog)\n\t\t\t\tcontinue;\n\n\t\t\tprogs->items[cnt].prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tprogs->items[cnt].cgroup_storage[stype] =\n\t\t\t\t\tpl->storage[stype];\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\trcu_assign_pointer(*array, progs);\n\treturn 0;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum bpf_attach_type type,\n\t\t\t\t   struct bpf_prog_array __rcu **array)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[type]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[type], node) {\n\t\t\tif (!pl->prog)\n\t\t\t\tcontinue;\n\n\t\t\tprogs->items[cnt].prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tprogs->items[cnt].cgroup_storage[stype] =\n\t\t\t\t\tpl->storage[stype];\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\trcu_assign_pointer(*array, progs);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcgroup",
            "self"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int update_effective_progs(struct cgroup *cgrp,\n\t\t\t\t  enum bpf_attach_type type)\n{\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\t/* allocate and recompute effective prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\terr = compute_effective_progs(desc, type, &desc->bpf.inactive);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* all allocations were successful. Activate all prog arrays */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tactivate_effective_progs(desc, type, desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn 0;\n\ncleanup:\n\t/* oom while computing effective. Free all computed effective arrays\n\t * since they were not activated\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tstruct cgroup *desc = container_of(css, struct cgroup, self);\n\n\t\tbpf_prog_array_free(desc->bpf.inactive);\n\t\tdesc->bpf.inactive = NULL;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "cgroup_bpf_inherit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "160-184",
    "snippet": "int cgroup_bpf_inherit(struct cgroup *cgrp)\n{\n/* has to use marco instead of const int, since compiler thinks\n * that array below is variable length\n */\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\tstruct bpf_prog_array __rcu *arrays[NR] = {};\n\tint i;\n\n\tfor (i = 0; i < NR; i++)\n\t\tINIT_LIST_HEAD(&cgrp->bpf.progs[i]);\n\n\tfor (i = 0; i < NR; i++)\n\t\tif (compute_effective_progs(cgrp, i, &arrays[i]))\n\t\t\tgoto cleanup;\n\n\tfor (i = 0; i < NR; i++)\n\t\tactivate_effective_progs(cgrp, i, arrays[i]);\n\n\treturn 0;\ncleanup:\n\tfor (i = 0; i < NR; i++)\n\t\tbpf_prog_array_free(arrays[i]);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define\tNR ARRAY_SIZE(cgrp->bpf.effective)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "arrays[i]"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1595-1601",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_effective_progs",
          "args": [
            "cgrp",
            "i",
            "arrays[i]"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "activate_effective_progs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "143-154",
          "snippet": "static void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\n\told_array = xchg(&cgrp->bpf.effective[type], array);\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\n\told_array = xchg(&cgrp->bpf.effective[type], array);\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_effective_progs",
          "args": [
            "cgrp",
            "i",
            "&arrays[i]"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "compute_effective_progs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "99-141",
          "snippet": "static int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum bpf_attach_type type,\n\t\t\t\t   struct bpf_prog_array __rcu **array)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[type]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[type], node) {\n\t\t\tif (!pl->prog)\n\t\t\t\tcontinue;\n\n\t\t\tprogs->items[cnt].prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tprogs->items[cnt].cgroup_storage[stype] =\n\t\t\t\t\tpl->storage[stype];\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\trcu_assign_pointer(*array, progs);\n\treturn 0;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum bpf_attach_type type,\n\t\t\t\t   struct bpf_prog_array __rcu **array)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[type]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[type], node) {\n\t\t\tif (!pl->prog)\n\t\t\t\tcontinue;\n\n\t\t\tprogs->items[cnt].prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tprogs->items[cnt].cgroup_storage[stype] =\n\t\t\t\t\tpl->storage[stype];\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\trcu_assign_pointer(*array, progs);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->bpf.progs[i]"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\nint cgroup_bpf_inherit(struct cgroup *cgrp)\n{\n/* has to use marco instead of const int, since compiler thinks\n * that array below is variable length\n */\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\tstruct bpf_prog_array __rcu *arrays[NR] = {};\n\tint i;\n\n\tfor (i = 0; i < NR; i++)\n\t\tINIT_LIST_HEAD(&cgrp->bpf.progs[i]);\n\n\tfor (i = 0; i < NR; i++)\n\t\tif (compute_effective_progs(cgrp, i, &arrays[i]))\n\t\t\tgoto cleanup;\n\n\tfor (i = 0; i < NR; i++)\n\t\tactivate_effective_progs(cgrp, i, arrays[i]);\n\n\treturn 0;\ncleanup:\n\tfor (i = 0; i < NR; i++)\n\t\tbpf_prog_array_free(arrays[i]);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "activate_effective_progs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "143-154",
    "snippet": "static void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\n\told_array = xchg(&cgrp->bpf.effective[type], array);\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "old_array"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1595-1601",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&cgrp->bpf.effective[type]",
            "array"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic void activate_effective_progs(struct cgroup *cgrp,\n\t\t\t\t     enum bpf_attach_type type,\n\t\t\t\t     struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\n\told_array = xchg(&cgrp->bpf.effective[type], array);\n\t/* free prog array after grace period, since __cgroup_bpf_run_*()\n\t * might be still walking the array\n\t */\n\tbpf_prog_array_free(old_array);\n}"
  },
  {
    "function_name": "compute_effective_progs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "99-141",
    "snippet": "static int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum bpf_attach_type type,\n\t\t\t\t   struct bpf_prog_array __rcu **array)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[type]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[type], node) {\n\t\t\tif (!pl->prog)\n\t\t\t\tcontinue;\n\n\t\t\tprogs->items[cnt].prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tprogs->items[cnt].cgroup_storage[stype] =\n\t\t\t\t\tpl->storage[stype];\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\trcu_assign_pointer(*array, progs);\n\treturn 0;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*array",
            "progs"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "&p->bpf.progs[type]",
            "node"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_alloc",
          "args": [
            "cnt",
            "GFP_KERNEL"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1584-1593",
          "snippet": "struct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nstruct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prog_list_length",
          "args": [
            "&p->bpf.progs[type]"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "52-63",
          "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic int compute_effective_progs(struct cgroup *cgrp,\n\t\t\t\t   enum bpf_attach_type type,\n\t\t\t\t   struct bpf_prog_array __rcu **array)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_array *progs;\n\tstruct bpf_prog_list *pl;\n\tstruct cgroup *p = cgrp;\n\tint cnt = 0;\n\n\t/* count number of effective programs by walking parents */\n\tdo {\n\t\tif (cnt == 0 || (p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcnt += prog_list_length(&p->bpf.progs[type]);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\n\tprogs = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!progs)\n\t\treturn -ENOMEM;\n\n\t/* populate the array with effective progs */\n\tcnt = 0;\n\tp = cgrp;\n\tdo {\n\t\tif (cnt > 0 && !(p->bpf.flags[type] & BPF_F_ALLOW_MULTI))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(pl, &p->bpf.progs[type], node) {\n\t\t\tif (!pl->prog)\n\t\t\t\tcontinue;\n\n\t\t\tprogs->items[cnt].prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tprogs->items[cnt].cgroup_storage[stype] =\n\t\t\t\t\tpl->storage[stype];\n\t\t\tcnt++;\n\t\t}\n\t} while ((p = cgroup_parent(p)));\n\n\trcu_assign_pointer(*array, progs);\n\treturn 0;\n}"
  },
  {
    "function_name": "hierarchy_allows_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "69-91",
    "snippet": "static bool hierarchy_allows_attach(struct cgroup *cgrp,\n\t\t\t\t    enum bpf_attach_type type,\n\t\t\t\t    u32 new_flags)\n{\n\tstruct cgroup *p;\n\n\tp = cgroup_parent(cgrp);\n\tif (!p)\n\t\treturn true;\n\tdo {\n\t\tu32 flags = p->bpf.flags[type];\n\t\tu32 cnt;\n\n\t\tif (flags & BPF_F_ALLOW_MULTI)\n\t\t\treturn true;\n\t\tcnt = prog_list_length(&p->bpf.progs[type]);\n\t\tWARN_ON_ONCE(cnt > 1);\n\t\tif (cnt == 1)\n\t\t\treturn !!(flags & BPF_F_ALLOW_OVERRIDE);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\treturn true;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "p"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cnt > 1"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prog_list_length",
          "args": [
            "&p->bpf.progs[type]"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "prog_list_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "52-63",
          "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic bool hierarchy_allows_attach(struct cgroup *cgrp,\n\t\t\t\t    enum bpf_attach_type type,\n\t\t\t\t    u32 new_flags)\n{\n\tstruct cgroup *p;\n\n\tp = cgroup_parent(cgrp);\n\tif (!p)\n\t\treturn true;\n\tdo {\n\t\tu32 flags = p->bpf.flags[type];\n\t\tu32 cnt;\n\n\t\tif (flags & BPF_F_ALLOW_MULTI)\n\t\t\treturn true;\n\t\tcnt = prog_list_length(&p->bpf.progs[type]);\n\t\tWARN_ON_ONCE(cnt > 1);\n\t\tif (cnt == 1)\n\t\t\treturn !!(flags & BPF_F_ALLOW_OVERRIDE);\n\t\tp = cgroup_parent(p);\n\t} while (p);\n\treturn true;\n}"
  },
  {
    "function_name": "prog_list_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "52-63",
    "snippet": "static u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pl",
            "head",
            "node"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic u32 prog_list_length(struct list_head *head)\n{\n\tstruct bpf_prog_list *pl;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(pl, head, node) {\n\t\tif (!pl->prog)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}"
  },
  {
    "function_name": "cgroup_bpf_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
    "lines": "26-47",
    "snippet": "void cgroup_bpf_put(struct cgroup *cgrp)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tunsigned int type;\n\n\tfor (type = 0; type < ARRAY_SIZE(cgrp->bpf.progs); type++) {\n\t\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\t\tstruct bpf_prog_list *pl, *tmp;\n\n\t\tlist_for_each_entry_safe(pl, tmp, progs, node) {\n\t\t\tlist_del(&pl->node);\n\t\t\tbpf_prog_put(pl->prog);\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\t\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\t\t}\n\t\t\tkfree(pl);\n\t\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t\t}\n\t\tbpf_prog_array_free(cgrp->bpf.effective[type]);\n\t}\n}",
    "includes": [
      "#include <net/sock.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "cgrp->bpf.effective[type]"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1595-1601",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&cgroup_bpf_enabled_key"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pl"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_free",
          "args": [
            "pl->storage[stype]"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "438-457",
          "snippet": "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\tu32 pages;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\n\tbpf_cgroup_storage_calculate_size(map, &pages);\n\tbpf_map_uncharge_memlock(map, pages);\n\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\tu32 pages;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\n\tbpf_cgroup_storage_calculate_size(map, &pages);\n\tbpf_map_uncharge_memlock(map, pages);\n\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_unlink",
          "args": [
            "pl->storage[stype]"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "479-495",
          "snippet": "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list);\n\tspin_unlock_bh(&map->lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list);\n\tspin_unlock_bh(&map->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "pl->prog"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pl->node"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pl",
            "tmp",
            "progs",
            "node"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cgrp->bpf.progs"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nvoid cgroup_bpf_put(struct cgroup *cgrp)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tunsigned int type;\n\n\tfor (type = 0; type < ARRAY_SIZE(cgrp->bpf.progs); type++) {\n\t\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\t\tstruct bpf_prog_list *pl, *tmp;\n\n\t\tlist_for_each_entry_safe(pl, tmp, progs, node) {\n\t\t\tlist_del(&pl->node);\n\t\t\tbpf_prog_put(pl->prog);\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\t\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\t\t}\n\t\t\tkfree(pl);\n\t\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t\t}\n\t\tbpf_prog_array_free(cgrp->bpf.effective[type]);\n\t}\n}"
  }
]