[
  {
    "function_name": "proc_cap_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "622-680",
    "snippet": "static int proc_cap_handler(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long cap_array[_KERNEL_CAPABILITY_U32S];\n\tkernel_cap_t new_cap;\n\tint err, i;\n\n\tif (write && (!capable(CAP_SETPCAP) ||\n\t\t      !capable(CAP_SYS_MODULE)))\n\t\treturn -EPERM;\n\n\t/*\n\t * convert from the global kernel_cap_t to the ulong array to print to\n\t * userspace if this is a read.\n\t */\n\tspin_lock(&umh_sysctl_lock);\n\tfor (i = 0; i < _KERNEL_CAPABILITY_U32S; i++)  {\n\t\tif (table->data == CAP_BSET)\n\t\t\tcap_array[i] = usermodehelper_bset.cap[i];\n\t\telse if (table->data == CAP_PI)\n\t\t\tcap_array[i] = usermodehelper_inheritable.cap[i];\n\t\telse\n\t\t\tBUG();\n\t}\n\tspin_unlock(&umh_sysctl_lock);\n\n\tt = *table;\n\tt.data = &cap_array;\n\n\t/*\n\t * actually read or write and array of ulongs from userspace.  Remember\n\t * these are least significant 32 bits first\n\t */\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * convert from the sysctl array of ulongs to the kernel_cap_t\n\t * internal representation\n\t */\n\tfor (i = 0; i < _KERNEL_CAPABILITY_U32S; i++)\n\t\tnew_cap.cap[i] = cap_array[i];\n\n\t/*\n\t * Drop everything not in the new_cap (but don't add things)\n\t */\n\tif (write) {\n\t\tspin_lock(&umh_sysctl_lock);\n\t\tif (table->data == CAP_BSET)\n\t\t\tusermodehelper_bset = cap_intersect(usermodehelper_bset, new_cap);\n\t\tif (table->data == CAP_PI)\n\t\t\tusermodehelper_inheritable = cap_intersect(usermodehelper_inheritable, new_cap);\n\t\tspin_unlock(&umh_sysctl_lock);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define CAP_PI\t\t(void *)2",
      "#define CAP_BSET\t(void *)1"
    ],
    "globals_used": [
      "static kernel_cap_t usermodehelper_bset = CAP_FULL_SET;",
      "static kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;",
      "static DEFINE_SPINLOCK(umh_sysctl_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&umh_sysctl_lock"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "usermodehelper_inheritable",
            "new_cap"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "usermodehelper_bset",
            "new_cap"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&umh_sysctl_lock"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "&t",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "proc_doulongvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3230-3234",
          "snippet": "int proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_MODULE"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CAP_PI\t\t(void *)2\n#define CAP_BSET\t(void *)1\n\nstatic kernel_cap_t usermodehelper_bset = CAP_FULL_SET;\nstatic kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;\nstatic DEFINE_SPINLOCK(umh_sysctl_lock);\n\nstatic int proc_cap_handler(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long cap_array[_KERNEL_CAPABILITY_U32S];\n\tkernel_cap_t new_cap;\n\tint err, i;\n\n\tif (write && (!capable(CAP_SETPCAP) ||\n\t\t      !capable(CAP_SYS_MODULE)))\n\t\treturn -EPERM;\n\n\t/*\n\t * convert from the global kernel_cap_t to the ulong array to print to\n\t * userspace if this is a read.\n\t */\n\tspin_lock(&umh_sysctl_lock);\n\tfor (i = 0; i < _KERNEL_CAPABILITY_U32S; i++)  {\n\t\tif (table->data == CAP_BSET)\n\t\t\tcap_array[i] = usermodehelper_bset.cap[i];\n\t\telse if (table->data == CAP_PI)\n\t\t\tcap_array[i] = usermodehelper_inheritable.cap[i];\n\t\telse\n\t\t\tBUG();\n\t}\n\tspin_unlock(&umh_sysctl_lock);\n\n\tt = *table;\n\tt.data = &cap_array;\n\n\t/*\n\t * actually read or write and array of ulongs from userspace.  Remember\n\t * these are least significant 32 bits first\n\t */\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * convert from the sysctl array of ulongs to the kernel_cap_t\n\t * internal representation\n\t */\n\tfor (i = 0; i < _KERNEL_CAPABILITY_U32S; i++)\n\t\tnew_cap.cap[i] = cap_array[i];\n\n\t/*\n\t * Drop everything not in the new_cap (but don't add things)\n\t */\n\tif (write) {\n\t\tspin_lock(&umh_sysctl_lock);\n\t\tif (table->data == CAP_BSET)\n\t\t\tusermodehelper_bset = cap_intersect(usermodehelper_bset, new_cap);\n\t\tif (table->data == CAP_PI)\n\t\t\tusermodehelper_inheritable = cap_intersect(usermodehelper_inheritable, new_cap);\n\t\tspin_unlock(&umh_sysctl_lock);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "call_usermodehelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "608-619",
    "snippet": "int call_usermodehelper(const char *path, char **argv, char **envp, int wait)\n{\n\tstruct subprocess_info *info;\n\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\n\t\t\t\t\t NULL, NULL, NULL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\treturn call_usermodehelper_exec(info, wait);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_usermodehelper_exec",
          "args": [
            "info",
            "wait"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "538-592",
          "snippet": "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\n\nint call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_setup",
          "args": [
            "path",
            "argv",
            "envp",
            "gfp_mask",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "374-400",
          "snippet": "struct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint call_usermodehelper(const char *path, char **argv, char **envp, int wait)\n{\n\tstruct subprocess_info *info;\n\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\n\t\t\t\t\t NULL, NULL, NULL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\treturn call_usermodehelper_exec(info, wait);\n}"
  },
  {
    "function_name": "call_usermodehelper_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "538-592",
    "snippet": "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "helper_unlock",
          "args": [],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "helper_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "345-349",
          "snippet": "static void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t running_helpers = ATOMIC_INIT(0);",
            "static DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);\n\nstatic void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_freeinfo",
          "args": [
            "sub_info"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_freeinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "41-46",
          "snippet": "static void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&sub_info->complete",
            "NULL"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion_killable",
          "args": [
            "&done"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_completion_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "239-245",
          "snippet": "int __sched wait_for_completion_killable(struct completion *x)\n{\n\tlong t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_KILLABLE);\n\tif (t == -ERESTARTSYS)\n\t\treturn t;\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __sched wait_for_completion_killable(struct completion *x)\n{\n\tlong t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_KILLABLE);\n\tif (t == -ERESTARTSYS)\n\t\treturn t;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "system_unbound_wq",
            "&sub_info->work"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "77-97",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sub_info->path"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "helper_lock",
          "args": [],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "helper_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "339-343",
          "snippet": "static void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t running_helpers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\n\nstatic void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\n\nint call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "fork_usermode_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "493-523",
    "snippet": "int fork_usermode_blob(void *data, size_t len, struct umh_info *info)\n{\n\tstruct subprocess_info *sub_info;\n\tstruct file *file;\n\tssize_t written;\n\tloff_t pos = 0;\n\tint err;\n\n\tfile = shmem_kernel_file_setup(\"\", len, 0);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\twritten = kernel_write(file, data, len, &pos);\n\tif (written != len) {\n\t\terr = written;\n\t\tif (err >= 0)\n\t\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tsub_info = call_usermodehelper_setup_file(file, umh_pipe_setup,\n\t\t\t\t\t\t  umh_clean_and_save_pid, info);\n\tif (!sub_info)\n\t\tgoto out;\n\n\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);\nout:\n\tfput(file);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_exec",
          "args": [
            "sub_info",
            "UMH_WAIT_EXEC"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "538-592",
          "snippet": "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\n\nint call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_setup_file",
          "args": [
            "file",
            "umh_pipe_setup",
            "umh_clean_and_save_pid",
            "info"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_setup_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "403-428",
          "snippet": "struct subprocess_info *call_usermodehelper_setup_file(struct file *file,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info), void *data)\n{\n\tstruct subprocess_info *sub_info;\n\tstruct umh_info *info = data;\n\tconst char *cmdline = (info->cmdline) ? info->cmdline : \"usermodehelper\";\n\n\tsub_info = kzalloc(sizeof(struct subprocess_info), GFP_KERNEL);\n\tif (!sub_info)\n\t\treturn NULL;\n\n\tsub_info->argv = argv_split(GFP_KERNEL, cmdline, NULL);\n\tif (!sub_info->argv) {\n\t\tkfree(sub_info);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\tsub_info->path = \"none\";\n\tsub_info->file = file;\n\tsub_info->init = init;\n\tsub_info->cleanup = cleanup;\n\tsub_info->data = data;\n\treturn sub_info;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct subprocess_info *call_usermodehelper_setup_file(struct file *file,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info), void *data)\n{\n\tstruct subprocess_info *sub_info;\n\tstruct umh_info *info = data;\n\tconst char *cmdline = (info->cmdline) ? info->cmdline : \"usermodehelper\";\n\n\tsub_info = kzalloc(sizeof(struct subprocess_info), GFP_KERNEL);\n\tif (!sub_info)\n\t\treturn NULL;\n\n\tsub_info->argv = argv_split(GFP_KERNEL, cmdline, NULL);\n\tif (!sub_info->argv) {\n\t\tkfree(sub_info);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\tsub_info->path = \"none\";\n\tsub_info->file = file;\n\tsub_info->init = init;\n\tsub_info->cleanup = cleanup;\n\tsub_info->data = data;\n\treturn sub_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "file",
            "data",
            "len",
            "&pos"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_kernel_file_setup",
          "args": [
            "\"\"",
            "len",
            "0"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint fork_usermode_blob(void *data, size_t len, struct umh_info *info)\n{\n\tstruct subprocess_info *sub_info;\n\tstruct file *file;\n\tssize_t written;\n\tloff_t pos = 0;\n\tint err;\n\n\tfile = shmem_kernel_file_setup(\"\", len, 0);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\twritten = kernel_write(file, data, len, &pos);\n\tif (written != len) {\n\t\terr = written;\n\t\tif (err >= 0)\n\t\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tsub_info = call_usermodehelper_setup_file(file, umh_pipe_setup,\n\t\t\t\t\t\t  umh_clean_and_save_pid, info);\n\tif (!sub_info)\n\t\tgoto out;\n\n\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);\nout:\n\tfput(file);\n\treturn err;\n}"
  },
  {
    "function_name": "umh_clean_and_save_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "469-475",
    "snippet": "static void umh_clean_and_save_pid(struct subprocess_info *info)\n{\n\tstruct umh_info *umh_info = info->data;\n\n\targv_free(info->argv);\n\tumh_info->pid = info->pid;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "info->argv"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_clean_and_save_pid(struct subprocess_info *info)\n{\n\tstruct umh_info *umh_info = info->data;\n\n\targv_free(info->argv);\n\tumh_info->pid = info->pid;\n}"
  },
  {
    "function_name": "umh_pipe_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "430-467",
    "snippet": "static int umh_pipe_setup(struct subprocess_info *info, struct cred *new)\n{\n\tstruct umh_info *umh_info = info->data;\n\tstruct file *from_umh[2];\n\tstruct file *to_umh[2];\n\tint err;\n\n\t/* create pipe to send data to umh */\n\terr = create_pipe_files(to_umh, 0);\n\tif (err)\n\t\treturn err;\n\terr = replace_fd(0, to_umh[0], 0);\n\tfput(to_umh[0]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treturn err;\n\t}\n\n\t/* create pipe to receive data from umh */\n\terr = create_pipe_files(from_umh, 0);\n\tif (err) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\treturn err;\n\t}\n\terr = replace_fd(1, from_umh[1], 0);\n\tfput(from_umh[1]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\tfput(from_umh[0]);\n\t\treturn err;\n\t}\n\n\tumh_info->pipe_to_umh = to_umh[1];\n\tumh_info->pipe_from_umh = from_umh[0];\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "from_umh[0]"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "0",
            "NULL",
            "0"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "to_umh[1]"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "from_umh[1]"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "1",
            "from_umh[1]",
            "0"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "0",
            "NULL",
            "0"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "to_umh[1]"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_pipe_files",
          "args": [
            "from_umh",
            "0"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "to_umh[1]"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "to_umh[0]"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "0",
            "to_umh[0]",
            "0"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_pipe_files",
          "args": [
            "to_umh",
            "0"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int umh_pipe_setup(struct subprocess_info *info, struct cred *new)\n{\n\tstruct umh_info *umh_info = info->data;\n\tstruct file *from_umh[2];\n\tstruct file *to_umh[2];\n\tint err;\n\n\t/* create pipe to send data to umh */\n\terr = create_pipe_files(to_umh, 0);\n\tif (err)\n\t\treturn err;\n\terr = replace_fd(0, to_umh[0], 0);\n\tfput(to_umh[0]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treturn err;\n\t}\n\n\t/* create pipe to receive data from umh */\n\terr = create_pipe_files(from_umh, 0);\n\tif (err) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\treturn err;\n\t}\n\terr = replace_fd(1, from_umh[1], 0);\n\tfput(from_umh[1]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\tfput(from_umh[0]);\n\t\treturn err;\n\t}\n\n\tumh_info->pipe_to_umh = to_umh[1];\n\tumh_info->pipe_from_umh = from_umh[0];\n\treturn 0;\n}"
  },
  {
    "function_name": "call_usermodehelper_setup_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "403-428",
    "snippet": "struct subprocess_info *call_usermodehelper_setup_file(struct file *file,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info), void *data)\n{\n\tstruct subprocess_info *sub_info;\n\tstruct umh_info *info = data;\n\tconst char *cmdline = (info->cmdline) ? info->cmdline : \"usermodehelper\";\n\n\tsub_info = kzalloc(sizeof(struct subprocess_info), GFP_KERNEL);\n\tif (!sub_info)\n\t\treturn NULL;\n\n\tsub_info->argv = argv_split(GFP_KERNEL, cmdline, NULL);\n\tif (!sub_info->argv) {\n\t\tkfree(sub_info);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\tsub_info->path = \"none\";\n\tsub_info->file = file;\n\tsub_info->init = init;\n\tsub_info->cleanup = cleanup;\n\tsub_info->data = data;\n\treturn sub_info;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sub_info->work",
            "call_usermodehelper_exec_work"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sub_info"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "cmdline",
            "NULL"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct subprocess_info)",
            "GFP_KERNEL"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct subprocess_info *call_usermodehelper_setup_file(struct file *file,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info), void *data)\n{\n\tstruct subprocess_info *sub_info;\n\tstruct umh_info *info = data;\n\tconst char *cmdline = (info->cmdline) ? info->cmdline : \"usermodehelper\";\n\n\tsub_info = kzalloc(sizeof(struct subprocess_info), GFP_KERNEL);\n\tif (!sub_info)\n\t\treturn NULL;\n\n\tsub_info->argv = argv_split(GFP_KERNEL, cmdline, NULL);\n\tif (!sub_info->argv) {\n\t\tkfree(sub_info);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\tsub_info->path = \"none\";\n\tsub_info->file = file;\n\tsub_info->init = init;\n\tsub_info->cleanup = cleanup;\n\tsub_info->data = data;\n\treturn sub_info;\n}"
  },
  {
    "function_name": "call_usermodehelper_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "374-400",
    "snippet": "struct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sub_info->work",
            "call_usermodehelper_exec_work"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct subprocess_info)",
            "gfp_mask"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}"
  },
  {
    "function_name": "helper_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "345-349",
    "snippet": "static void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t running_helpers = ATOMIC_INIT(0);",
      "static DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&running_helpers_waitq"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&running_helpers"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);\n\nstatic void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}"
  },
  {
    "function_name": "helper_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "339-343",
    "snippet": "static void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t running_helpers = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&running_helpers"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\n\nstatic void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}"
  },
  {
    "function_name": "__usermodehelper_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "312-337",
    "snippet": "int __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -EINVAL;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t/*\n\t * From now on call_usermodehelper_exec() won't start any new\n\t * helpers, so it is sufficient if running_helpers turns out to\n\t * be zero at one point (it may be increased later, but that\n\t * doesn't matter).\n\t */\n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(UMH_ENABLED);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RUNNING_HELPERS_TIMEOUT\t(5 * HZ)"
    ],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);",
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
      "static atomic_t running_helpers = ATOMIC_INIT(0);",
      "static DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__usermodehelper_set_disable_depth",
          "args": [
            "UMH_ENABLED"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__usermodehelper_set_disable_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "298-304",
          "snippet": "void __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "running_helpers_waitq",
            "atomic_read(&running_helpers) == 0",
            "RUNNING_HELPERS_TIMEOUT"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&running_helpers"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&umhelper_sem"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&umhelper_sem"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define RUNNING_HELPERS_TIMEOUT\t(5 * HZ)\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);\n\nint __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -EINVAL;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t/*\n\t * From now on call_usermodehelper_exec() won't start any new\n\t * helpers, so it is sufficient if running_helpers turns out to\n\t * be zero at one point (it may be increased later, but that\n\t * doesn't matter).\n\t */\n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(UMH_ENABLED);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "__usermodehelper_set_disable_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "298-304",
    "snippet": "void __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);",
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
      "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&umhelper_sem"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&usermodehelper_disabled_waitq"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&umhelper_sem"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}"
  },
  {
    "function_name": "usermodehelper_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "285-288",
    "snippet": "void usermodehelper_read_unlock(void)\n{\n\tup_read(&umhelper_sem);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\n\nvoid usermodehelper_read_unlock(void)\n{\n\tup_read(&umhelper_sem);\n}"
  },
  {
    "function_name": "usermodehelper_read_lock_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "258-282",
    "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);",
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
      "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&usermodehelper_disabled_waitq",
            "&wait"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "347-370",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5119-5129",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&usermodehelper_disabled_waitq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "261-294",
          "snippet": "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
  },
  {
    "function_name": "usermodehelper_read_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "228-255",
    "snippet": "int usermodehelper_read_trylock(void)\n{\n\tDEFINE_WAIT(wait);\n\tint ret = 0;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tif (usermodehelper_disabled == UMH_DISABLED)\n\t\t\tret = -EAGAIN;\n\n\t\tup_read(&umhelper_sem);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tschedule();\n\t\ttry_to_freeze();\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);",
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
      "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&usermodehelper_disabled_waitq",
            "&wait"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "347-370",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&usermodehelper_disabled_waitq",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "261-294",
          "snippet": "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nint usermodehelper_read_trylock(void)\n{\n\tDEFINE_WAIT(wait);\n\tint ret = 0;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tif (usermodehelper_disabled == UMH_DISABLED)\n\t\t\tret = -EAGAIN;\n\n\t\tup_read(&umhelper_sem);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tschedule();\n\t\ttry_to_freeze();\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn ret;\n}"
  },
  {
    "function_name": "call_usermodehelper_exec_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "176-197",
    "snippet": "static void call_usermodehelper_exec_work(struct work_struct *work)\n{\n\tstruct subprocess_info *sub_info =\n\t\tcontainer_of(work, struct subprocess_info, work);\n\n\tif (sub_info->wait & UMH_WAIT_PROC) {\n\t\tcall_usermodehelper_exec_sync(sub_info);\n\t} else {\n\t\tpid_t pid;\n\t\t/*\n\t\t * Use CLONE_PARENT to reparent it to kthreadd; we do not\n\t\t * want to pollute current->children, and we need a parent\n\t\t * that always ignores SIGCHLD to ensure auto-reaping.\n\t\t */\n\t\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info,\n\t\t\t\t    CLONE_PARENT | SIGCHLD);\n\t\tif (pid < 0) {\n\t\t\tsub_info->retval = pid;\n\t\t\tumh_complete(sub_info);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umh_complete",
          "args": [
            "sub_info"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "umh_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "48-60",
          "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_thread",
          "args": [
            "call_usermodehelper_exec_async",
            "sub_info",
            "CLONE_PARENT | SIGCHLD"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "2273-2277",
          "snippet": "pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\treturn _do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,\n\t\t(unsigned long)arg, NULL, NULL, 0);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\treturn _do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,\n\t\t(unsigned long)arg, NULL, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_exec_sync",
          "args": [
            "sub_info"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_exec_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "124-160",
          "snippet": "static void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t/* If SIGCLD is ignored kernel_wait4 won't populate the status. */\n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0) {\n\t\tsub_info->retval = pid;\n\t} else {\n\t\tint ret = -ECHILD;\n\t\t/*\n\t\t * Normally it is bogus to call wait4() from in-kernel because\n\t\t * wait4() wants to write the exit code to a userspace address.\n\t\t * But call_usermodehelper_exec_sync() always runs as kernel\n\t\t * thread (workqueue) and put_user() to a kernel address works\n\t\t * OK for kernel threads, due to their having an mm_segment_t\n\t\t * which spans the entire address space.\n\t\t *\n\t\t * Thus the __user pointer cast is valid here.\n\t\t */\n\t\tkernel_wait4(pid, (int __user *)&ret, 0, NULL);\n\n\t\t/*\n\t\t * If ret is 0, either call_usermodehelper_exec_async failed and\n\t\t * the real error code is already in sub_info->retval or\n\t\t * sub_info->retval is 0 anyway, so don't mess with it then.\n\t\t */\n\t\tif (ret)\n\t\t\tsub_info->retval = ret;\n\t}\n\n\t/* Restore default kernel sig handler */\n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\n\tumh_complete(sub_info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t/* If SIGCLD is ignored kernel_wait4 won't populate the status. */\n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0) {\n\t\tsub_info->retval = pid;\n\t} else {\n\t\tint ret = -ECHILD;\n\t\t/*\n\t\t * Normally it is bogus to call wait4() from in-kernel because\n\t\t * wait4() wants to write the exit code to a userspace address.\n\t\t * But call_usermodehelper_exec_sync() always runs as kernel\n\t\t * thread (workqueue) and put_user() to a kernel address works\n\t\t * OK for kernel threads, due to their having an mm_segment_t\n\t\t * which spans the entire address space.\n\t\t *\n\t\t * Thus the __user pointer cast is valid here.\n\t\t */\n\t\tkernel_wait4(pid, (int __user *)&ret, 0, NULL);\n\n\t\t/*\n\t\t * If ret is 0, either call_usermodehelper_exec_async failed and\n\t\t * the real error code is already in sub_info->retval or\n\t\t * sub_info->retval is 0 anyway, so don't mess with it then.\n\t\t */\n\t\tif (ret)\n\t\t\tsub_info->retval = ret;\n\t}\n\n\t/* Restore default kernel sig handler */\n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\n\tumh_complete(sub_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsubprocess_info",
            "work"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_exec_work(struct work_struct *work)\n{\n\tstruct subprocess_info *sub_info =\n\t\tcontainer_of(work, struct subprocess_info, work);\n\n\tif (sub_info->wait & UMH_WAIT_PROC) {\n\t\tcall_usermodehelper_exec_sync(sub_info);\n\t} else {\n\t\tpid_t pid;\n\t\t/*\n\t\t * Use CLONE_PARENT to reparent it to kthreadd; we do not\n\t\t * want to pollute current->children, and we need a parent\n\t\t * that always ignores SIGCHLD to ensure auto-reaping.\n\t\t */\n\t\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info,\n\t\t\t\t    CLONE_PARENT | SIGCHLD);\n\t\tif (pid < 0) {\n\t\t\tsub_info->retval = pid;\n\t\t\tumh_complete(sub_info);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "call_usermodehelper_exec_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "124-160",
    "snippet": "static void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t/* If SIGCLD is ignored kernel_wait4 won't populate the status. */\n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0) {\n\t\tsub_info->retval = pid;\n\t} else {\n\t\tint ret = -ECHILD;\n\t\t/*\n\t\t * Normally it is bogus to call wait4() from in-kernel because\n\t\t * wait4() wants to write the exit code to a userspace address.\n\t\t * But call_usermodehelper_exec_sync() always runs as kernel\n\t\t * thread (workqueue) and put_user() to a kernel address works\n\t\t * OK for kernel threads, due to their having an mm_segment_t\n\t\t * which spans the entire address space.\n\t\t *\n\t\t * Thus the __user pointer cast is valid here.\n\t\t */\n\t\tkernel_wait4(pid, (int __user *)&ret, 0, NULL);\n\n\t\t/*\n\t\t * If ret is 0, either call_usermodehelper_exec_async failed and\n\t\t * the real error code is already in sub_info->retval or\n\t\t * sub_info->retval is 0 anyway, so don't mess with it then.\n\t\t */\n\t\tif (ret)\n\t\t\tsub_info->retval = ret;\n\t}\n\n\t/* Restore default kernel sig handler */\n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\n\tumh_complete(sub_info);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umh_complete",
          "args": [
            "sub_info"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "umh_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "48-60",
          "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_sigaction",
          "args": [
            "SIGCHLD",
            "SIG_IGN"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_sigaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3474-3489",
          "snippet": "void kernel_sigaction(int sig, __sighandler_t action)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;\n\tif (action == SIG_IGN) {\n\t\tsigset_t mask;\n\n\t\tsigemptyset(&mask);\n\t\tsigaddset(&mask, sig);\n\n\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);\n\t\tflush_sigqueue_mask(&mask, &current->pending);\n\t\trecalc_sigpending();\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid kernel_sigaction(int sig, __sighandler_t action)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;\n\tif (action == SIG_IGN) {\n\t\tsigset_t mask;\n\n\t\tsigemptyset(&mask);\n\t\tsigaddset(&mask, sig);\n\n\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);\n\t\tflush_sigqueue_mask(&mask, &current->pending);\n\t\trecalc_sigpending();\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_wait4",
          "args": [
            "pid",
            "(int __user *)&ret",
            "0",
            "NULL"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_thread",
          "args": [
            "call_usermodehelper_exec_async",
            "sub_info",
            "SIGCHLD"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "2273-2277",
          "snippet": "pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\treturn _do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,\n\t\t(unsigned long)arg, NULL, NULL, 0);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\treturn _do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,\n\t\t(unsigned long)arg, NULL, NULL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t/* If SIGCLD is ignored kernel_wait4 won't populate the status. */\n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0) {\n\t\tsub_info->retval = pid;\n\t} else {\n\t\tint ret = -ECHILD;\n\t\t/*\n\t\t * Normally it is bogus to call wait4() from in-kernel because\n\t\t * wait4() wants to write the exit code to a userspace address.\n\t\t * But call_usermodehelper_exec_sync() always runs as kernel\n\t\t * thread (workqueue) and put_user() to a kernel address works\n\t\t * OK for kernel threads, due to their having an mm_segment_t\n\t\t * which spans the entire address space.\n\t\t *\n\t\t * Thus the __user pointer cast is valid here.\n\t\t */\n\t\tkernel_wait4(pid, (int __user *)&ret, 0, NULL);\n\n\t\t/*\n\t\t * If ret is 0, either call_usermodehelper_exec_async failed and\n\t\t * the real error code is already in sub_info->retval or\n\t\t * sub_info->retval is 0 anyway, so don't mess with it then.\n\t\t */\n\t\tif (ret)\n\t\t\tsub_info->retval = ret;\n\t}\n\n\t/* Restore default kernel sig handler */\n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\n\tumh_complete(sub_info);\n}"
  },
  {
    "function_name": "call_usermodehelper_exec_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "65-121",
    "snippet": "static int call_usermodehelper_exec_async(void *data)\n{\n\tstruct subprocess_info *sub_info = data;\n\tstruct cred *new;\n\tint retval;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tflush_signal_handlers(current, 1);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/*\n\t * Our parent (unbound workqueue) runs with elevated scheduling\n\t * priority. Avoid propagating that into the userspace child.\n\t */\n\tset_user_nice(current, 0);\n\n\tretval = -ENOMEM;\n\tnew = prepare_kernel_cred(current);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock(&umh_sysctl_lock);\n\tnew->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);\n\tnew->cap_inheritable = cap_intersect(usermodehelper_inheritable,\n\t\t\t\t\t     new->cap_inheritable);\n\tspin_unlock(&umh_sysctl_lock);\n\n\tif (sub_info->init) {\n\t\tretval = sub_info->init(sub_info, new);\n\t\tif (retval) {\n\t\t\tabort_creds(new);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcommit_creds(new);\n\n\tsub_info->pid = task_pid_nr(current);\n\tif (sub_info->file)\n\t\tretval = do_execve_file(sub_info->file,\n\t\t\t\t\tsub_info->argv, sub_info->envp);\n\telse\n\t\tretval = do_execve(getname_kernel(sub_info->path),\n\t\t\t\t   (const char __user *const __user *)sub_info->argv,\n\t\t\t\t   (const char __user *const __user *)sub_info->envp);\nout:\n\tsub_info->retval = retval;\n\t/*\n\t * call_usermodehelper_exec_sync() will call umh_complete\n\t * if UHM_WAIT_PROC.\n\t */\n\tif (!(sub_info->wait & UMH_WAIT_PROC))\n\t\tumh_complete(sub_info);\n\tif (!retval)\n\t\treturn 0;\n\tdo_exit(0);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static kernel_cap_t usermodehelper_bset = CAP_FULL_SET;",
      "static kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;",
      "static DEFINE_SPINLOCK(umh_sysctl_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "0"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "765-925",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "umh_complete",
          "args": [
            "sub_info"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "umh_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "48-60",
          "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_execve",
          "args": [
            "getname_kernel(sub_info->path)",
            "(const char __user *const __user *)sub_info->argv",
            "(const char __user *const __user *)sub_info->envp"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getname_kernel",
          "args": [
            "sub_info->path"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_execve_file",
          "args": [
            "sub_info->file",
            "sub_info->argv",
            "sub_info->envp"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "commit_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "423-490",
          "snippet": "int commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(task);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(task);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user)\n\t\tatomic_inc(&new->user->processes);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user)\n\t\tatomic_dec(&old->user->processes);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(task);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(task);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user)\n\t\tatomic_inc(&new->user->processes);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user)\n\t\tatomic_dec(&old->user->processes);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "abort_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "500-511",
          "snippet": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_info->init",
          "args": [
            "sub_info",
            "new"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&umh_sysctl_lock"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "usermodehelper_inheritable",
            "new->cap_inheritable"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "usermodehelper_bset",
            "new->cap_bset"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&umh_sysctl_lock"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_kernel_cred",
          "args": [
            "current"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_kernel_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "595-642",
          "snippet": "struct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;",
            "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};\n\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "0"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_signal_handlers",
          "args": [
            "current",
            "1"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "flush_signal_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "522-537",
          "snippet": "void\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic kernel_cap_t usermodehelper_bset = CAP_FULL_SET;\nstatic kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;\nstatic DEFINE_SPINLOCK(umh_sysctl_lock);\n\nstatic int call_usermodehelper_exec_async(void *data)\n{\n\tstruct subprocess_info *sub_info = data;\n\tstruct cred *new;\n\tint retval;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tflush_signal_handlers(current, 1);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/*\n\t * Our parent (unbound workqueue) runs with elevated scheduling\n\t * priority. Avoid propagating that into the userspace child.\n\t */\n\tset_user_nice(current, 0);\n\n\tretval = -ENOMEM;\n\tnew = prepare_kernel_cred(current);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock(&umh_sysctl_lock);\n\tnew->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);\n\tnew->cap_inheritable = cap_intersect(usermodehelper_inheritable,\n\t\t\t\t\t     new->cap_inheritable);\n\tspin_unlock(&umh_sysctl_lock);\n\n\tif (sub_info->init) {\n\t\tretval = sub_info->init(sub_info, new);\n\t\tif (retval) {\n\t\t\tabort_creds(new);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcommit_creds(new);\n\n\tsub_info->pid = task_pid_nr(current);\n\tif (sub_info->file)\n\t\tretval = do_execve_file(sub_info->file,\n\t\t\t\t\tsub_info->argv, sub_info->envp);\n\telse\n\t\tretval = do_execve(getname_kernel(sub_info->path),\n\t\t\t\t   (const char __user *const __user *)sub_info->argv,\n\t\t\t\t   (const char __user *const __user *)sub_info->envp);\nout:\n\tsub_info->retval = retval;\n\t/*\n\t * call_usermodehelper_exec_sync() will call umh_complete\n\t * if UHM_WAIT_PROC.\n\t */\n\tif (!(sub_info->wait & UMH_WAIT_PROC))\n\t\tumh_complete(sub_info);\n\tif (!retval)\n\t\treturn 0;\n\tdo_exit(0);\n}"
  },
  {
    "function_name": "umh_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "48-60",
    "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_usermodehelper_freeinfo",
          "args": [
            "sub_info"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_freeinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "41-46",
          "snippet": "static void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "comp"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "umh_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "48-60",
          "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&sub_info->complete",
            "NULL"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}"
  },
  {
    "function_name": "call_usermodehelper_freeinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
    "lines": "41-46",
    "snippet": "static void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "info"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}"
  }
]