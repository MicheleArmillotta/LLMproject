[
  {
    "function_name": "debug_rt_mutex_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "170-181",
    "snippet": "void debug_rt_mutex_init(struct rt_mutex *lock, const char *name, struct lock_class_key *key)\n{\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlock->name = name;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tlockdep_init_map(&lock->dep_map, name, key, 0);\n#endif\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&lock->dep_map",
            "name",
            "key",
            "0"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)lock",
            "sizeof(*lock)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4322-4344",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_init(struct rt_mutex *lock, const char *name, struct lock_class_key *key)\n{\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlock->name = name;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tlockdep_init_map(&lock->dep_map, name, key, 0);\n#endif\n}"
  },
  {
    "function_name": "debug_rt_mutex_free_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "164-168",
    "snippet": "void debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter)\n{\n\tput_pid(waiter->deadlock_task_pid);\n\tmemset(waiter, 0x22, sizeof(*waiter));\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "waiter",
            "0x22",
            "sizeof(*waiter)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "waiter->deadlock_task_pid"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "117-121",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter)\n{\n\tput_pid(waiter->deadlock_task_pid);\n\tmemset(waiter, 0x22, sizeof(*waiter));\n}"
  },
  {
    "function_name": "debug_rt_mutex_init_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "158-162",
    "snippet": "void debug_rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tmemset(waiter, 0x11, sizeof(*waiter));\n\twaiter->deadlock_task_pid = NULL;\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "waiter",
            "0x11",
            "sizeof(*waiter)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tmemset(waiter, 0x11, sizeof(*waiter));\n\twaiter->deadlock_task_pid = NULL;\n}"
  },
  {
    "function_name": "debug_rt_mutex_proxy_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "153-156",
    "snippet": "void debug_rt_mutex_proxy_unlock(struct rt_mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(!rt_mutex_owner(lock));\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!rt_mutex_owner(lock)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "lock"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_proxy_unlock(struct rt_mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(!rt_mutex_owner(lock));\n}"
  },
  {
    "function_name": "debug_rt_mutex_proxy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "148-151",
    "snippet": "void\ndebug_rt_mutex_proxy_lock(struct rt_mutex *lock, struct task_struct *powner)\n{\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid\ndebug_rt_mutex_proxy_lock(struct rt_mutex *lock, struct task_struct *powner)\n{\n}"
  },
  {
    "function_name": "debug_rt_mutex_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "143-146",
    "snippet": "void debug_rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(rt_mutex_owner(lock) != current);\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "rt_mutex_owner(lock) != current"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "lock"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(rt_mutex_owner(lock) != current);\n}"
  },
  {
    "function_name": "debug_rt_mutex_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "139-141",
    "snippet": "void debug_rt_mutex_lock(struct rt_mutex *lock)\n{\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_lock(struct rt_mutex *lock)\n{\n}"
  },
  {
    "function_name": "debug_rt_mutex_print_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "87-137",
    "snippet": "void debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter)\n{\n\tstruct task_struct *task;\n\n\tif (!waiter->deadlock_lock || !debug_locks)\n\t\treturn;\n\n\trcu_read_lock();\n\ttask = pid_task(waiter->deadlock_task_pid, PIDTYPE_PID);\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (!debug_locks_off()) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: circular locking deadlock detected!\\n\");\n\tpr_warn(\"%s\\n\", print_tainted());\n\tpr_warn(\"--------------------------------------------\\n\");\n\tprintk(\"%s/%d is deadlocking current task %s/%d\\n\\n\",\n\t       task->comm, task_pid_nr(task),\n\t       current->comm, task_pid_nr(current));\n\n\tprintk(\"\\n1) %s/%d is trying to acquire this lock:\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprintk_lock(waiter->lock, 1);\n\n\tprintk(\"\\n2) %s/%d is blocked on this lock:\\n\",\n\t\ttask->comm, task_pid_nr(task));\n\tprintk_lock(waiter->deadlock_lock, 1);\n\n\tdebug_show_held_locks(current);\n\tdebug_show_held_locks(task);\n\n\tprintk(\"\\n%s/%d's [blocked] stackdump:\\n\\n\",\n\t\ttask->comm, task_pid_nr(task));\n\tshow_stack(task, NULL);\n\tprintk(\"\\n%s/%d's [current] stackdump:\\n\\n\",\n\t\tcurrent->comm, task_pid_nr(current));\n\tdump_stack();\n\tdebug_show_all_locks();\n\trcu_read_unlock();\n\n\tprintk(\"[ turning off deadlock detection.\"\n\t       \"Please report this trace. ]\\n\\n\");\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"[ turning off deadlock detection.\"\n\t       \"Please report this trace. ]\\n\\n\""
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_show_all_locks",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4373-4395",
          "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n%s/%d's [current] stackdump:\\n\\n\"",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_stack",
          "args": [
            "task",
            "NULL"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_show_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "22-41",
          "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "task"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_held_locks",
          "args": [
            "task"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4403-4410",
          "snippet": "void debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_lock",
          "args": [
            "waiter->deadlock_lock",
            "1"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "task"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "task"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"--------------------------------------------\\n\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "print_tainted()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "print_tainted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "344-365",
          "snippet": "const char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
            "const struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nconst struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};\n\nconst char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: circular locking deadlock detected!\\n\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"============================================\\n\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "waiter->deadlock_task_pid",
            "PIDTYPE_PID"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "376-385",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter)\n{\n\tstruct task_struct *task;\n\n\tif (!waiter->deadlock_lock || !debug_locks)\n\t\treturn;\n\n\trcu_read_lock();\n\ttask = pid_task(waiter->deadlock_task_pid, PIDTYPE_PID);\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (!debug_locks_off()) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: circular locking deadlock detected!\\n\");\n\tpr_warn(\"%s\\n\", print_tainted());\n\tpr_warn(\"--------------------------------------------\\n\");\n\tprintk(\"%s/%d is deadlocking current task %s/%d\\n\\n\",\n\t       task->comm, task_pid_nr(task),\n\t       current->comm, task_pid_nr(current));\n\n\tprintk(\"\\n1) %s/%d is trying to acquire this lock:\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprintk_lock(waiter->lock, 1);\n\n\tprintk(\"\\n2) %s/%d is blocked on this lock:\\n\",\n\t\ttask->comm, task_pid_nr(task));\n\tprintk_lock(waiter->deadlock_lock, 1);\n\n\tdebug_show_held_locks(current);\n\tdebug_show_held_locks(task);\n\n\tprintk(\"\\n%s/%d's [blocked] stackdump:\\n\\n\",\n\t\ttask->comm, task_pid_nr(task));\n\tshow_stack(task, NULL);\n\tprintk(\"\\n%s/%d's [current] stackdump:\\n\\n\",\n\t\tcurrent->comm, task_pid_nr(current));\n\tdump_stack();\n\tdebug_show_all_locks();\n\trcu_read_unlock();\n\n\tprintk(\"[ turning off deadlock detection.\"\n\t       \"Please report this trace. ]\\n\\n\");\n}"
  },
  {
    "function_name": "debug_rt_mutex_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "71-85",
    "snippet": "void debug_rt_mutex_deadlock(enum rtmutex_chainwalk chwalk,\n\t\t\t     struct rt_mutex_waiter *act_waiter,\n\t\t\t     struct rt_mutex *lock)\n{\n\tstruct task_struct *task;\n\n\tif (!debug_locks || chwalk == RT_MUTEX_FULL_CHAINWALK || !act_waiter)\n\t\treturn;\n\n\ttask = rt_mutex_owner(act_waiter->lock);\n\tif (task && task != current) {\n\t\tact_waiter->deadlock_task_pid = get_pid(task_pid(task));\n\t\tact_waiter->deadlock_lock = lock;\n\t}\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "task_pid(task)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "388-397",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "task"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "init_task_pid_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1631-1638",
          "snippet": "static inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "act_waiter->lock"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_deadlock(enum rtmutex_chainwalk chwalk,\n\t\t\t     struct rt_mutex_waiter *act_waiter,\n\t\t\t     struct rt_mutex *lock)\n{\n\tstruct task_struct *task;\n\n\tif (!debug_locks || chwalk == RT_MUTEX_FULL_CHAINWALK || !act_waiter)\n\t\treturn;\n\n\ttask = rt_mutex_owner(act_waiter->lock);\n\tif (task && task != current) {\n\t\tact_waiter->deadlock_task_pid = get_pid(task_pid(task));\n\t\tact_waiter->deadlock_lock = lock;\n\t}\n}"
  },
  {
    "function_name": "rt_mutex_debug_task_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "60-64",
    "snippet": "void rt_mutex_debug_task_free(struct task_struct *task)\n{\n\tDEBUG_LOCKS_WARN_ON(!RB_EMPTY_ROOT(&task->pi_waiters.rb_root));\n\tDEBUG_LOCKS_WARN_ON(task->pi_blocked_on);\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "task->pi_blocked_on"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!RB_EMPTY_ROOT(&task->pi_waiters.rb_root)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&task->pi_waiters.rb_root"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid rt_mutex_debug_task_free(struct task_struct *task)\n{\n\tDEBUG_LOCKS_WARN_ON(!RB_EMPTY_ROOT(&task->pi_waiters.rb_root));\n\tDEBUG_LOCKS_WARN_ON(task->pi_blocked_on);\n}"
  },
  {
    "function_name": "printk_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "43-58",
    "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "lock"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\".. ->owner: %p\\n\"",
            "lock->owner"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" [%p] {%s:%d}\\n\"",
            "lock",
            "lock->file",
            "lock->line"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "printk_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
    "lines": "35-41",
    "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
    "includes": [
      "#include \"rtmutex_common.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"<none>\""
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%16s:%5d [%p, %3d]\"",
            "p->comm",
            "task_pid_nr(p)",
            "p",
            "p->prio"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
  }
]