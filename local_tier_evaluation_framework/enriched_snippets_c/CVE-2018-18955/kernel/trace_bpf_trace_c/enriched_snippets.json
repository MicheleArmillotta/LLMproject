[
  {
    "function_name": "bpf_get_perf_event_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "1177-1222",
    "snippet": "int bpf_get_perf_event_info(const struct perf_event *event, u32 *prog_id,\n\t\t\t    u32 *fd_type, const char **buf,\n\t\t\t    u64 *probe_offset, u64 *probe_addr)\n{\n\tbool is_tracepoint, is_syscall_tp;\n\tstruct bpf_prog *prog;\n\tint flags, err = 0;\n\n\tprog = event->prog;\n\tif (!prog)\n\t\treturn -ENOENT;\n\n\t/* not supporting BPF_PROG_TYPE_PERF_EVENT yet */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT)\n\t\treturn -EOPNOTSUPP;\n\n\t*prog_id = prog->aux->id;\n\tflags = event->tp_event->flags;\n\tis_tracepoint = flags & TRACE_EVENT_FL_TRACEPOINT;\n\tis_syscall_tp = is_syscall_trace_event(event->tp_event);\n\n\tif (is_tracepoint || is_syscall_tp) {\n\t\t*buf = is_tracepoint ? event->tp_event->tp->name\n\t\t\t\t     : event->tp_event->name;\n\t\t*fd_type = BPF_FD_TYPE_TRACEPOINT;\n\t\t*probe_offset = 0x0;\n\t\t*probe_addr = 0x0;\n\t} else {\n\t\t/* kprobe/uprobe */\n\t\terr = -EOPNOTSUPP;\n#ifdef CONFIG_KPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_KPROBE)\n\t\t\terr = bpf_get_kprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset, probe_addr,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n#ifdef CONFIG_UPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_UPROBE)\n\t\t\terr = bpf_get_uprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_uprobe_info",
          "args": [
            "event",
            "fd_type",
            "buf",
            "probe_offset",
            "event->attr.type == PERF_TYPE_TRACEPOINT"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_uprobe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1180-1200",
          "snippet": "int bpf_get_uprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **filename, u64 *probe_offset,\n\t\t\tbool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_uprobe *tu;\n\n\tif (perf_type_tracepoint)\n\t\ttu = find_probe_event(pevent, group);\n\telse\n\t\ttu = event->tp_event->data;\n\tif (!tu)\n\t\treturn -EINVAL;\n\n\t*fd_type = is_ret_probe(tu) ? BPF_FD_TYPE_URETPROBE\n\t\t\t\t    : BPF_FD_TYPE_UPROBE;\n\t*filename = tu->filename;\n\t*probe_offset = tu->offset;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nint bpf_get_uprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **filename, u64 *probe_offset,\n\t\t\tbool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_uprobe *tu;\n\n\tif (perf_type_tracepoint)\n\t\ttu = find_probe_event(pevent, group);\n\telse\n\t\ttu = event->tp_event->data;\n\tif (!tu)\n\t\treturn -EINVAL;\n\n\t*fd_type = is_ret_probe(tu) ? BPF_FD_TYPE_URETPROBE\n\t\t\t\t    : BPF_FD_TYPE_UPROBE;\n\t*filename = tu->filename;\n\t*probe_offset = tu->offset;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_kprobe_info",
          "args": [
            "event",
            "fd_type",
            "buf",
            "probe_offset",
            "probe_addr",
            "event->attr.type == PERF_TYPE_TRACEPOINT"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_kprobe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1243-1270",
          "snippet": "int bpf_get_kprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **symbol, u64 *probe_offset,\n\t\t\tu64 *probe_addr, bool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_kprobe *tk;\n\n\tif (perf_type_tracepoint)\n\t\ttk = find_trace_kprobe(pevent, group);\n\telse\n\t\ttk = event->tp_event->data;\n\tif (!tk)\n\t\treturn -EINVAL;\n\n\t*fd_type = trace_kprobe_is_return(tk) ? BPF_FD_TYPE_KRETPROBE\n\t\t\t\t\t      : BPF_FD_TYPE_KPROBE;\n\tif (tk->symbol) {\n\t\t*symbol = tk->symbol;\n\t\t*probe_offset = tk->rp.kp.offset;\n\t\t*probe_addr = 0;\n\t} else {\n\t\t*symbol = NULL;\n\t\t*probe_offset = 0;\n\t\t*probe_addr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nint bpf_get_kprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **symbol, u64 *probe_offset,\n\t\t\tu64 *probe_addr, bool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_kprobe *tk;\n\n\tif (perf_type_tracepoint)\n\t\ttk = find_trace_kprobe(pevent, group);\n\telse\n\t\ttk = event->tp_event->data;\n\tif (!tk)\n\t\treturn -EINVAL;\n\n\t*fd_type = trace_kprobe_is_return(tk) ? BPF_FD_TYPE_KRETPROBE\n\t\t\t\t\t      : BPF_FD_TYPE_KPROBE;\n\tif (tk->symbol) {\n\t\t*symbol = tk->symbol;\n\t\t*probe_offset = tk->rp.kp.offset;\n\t\t*probe_addr = 0;\n\t} else {\n\t\t*symbol = NULL;\n\t\t*probe_offset = 0;\n\t\t*probe_addr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_syscall_trace_event",
          "args": [
            "event->tp_event"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint bpf_get_perf_event_info(const struct perf_event *event, u32 *prog_id,\n\t\t\t    u32 *fd_type, const char **buf,\n\t\t\t    u64 *probe_offset, u64 *probe_addr)\n{\n\tbool is_tracepoint, is_syscall_tp;\n\tstruct bpf_prog *prog;\n\tint flags, err = 0;\n\n\tprog = event->prog;\n\tif (!prog)\n\t\treturn -ENOENT;\n\n\t/* not supporting BPF_PROG_TYPE_PERF_EVENT yet */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT)\n\t\treturn -EOPNOTSUPP;\n\n\t*prog_id = prog->aux->id;\n\tflags = event->tp_event->flags;\n\tis_tracepoint = flags & TRACE_EVENT_FL_TRACEPOINT;\n\tis_syscall_tp = is_syscall_trace_event(event->tp_event);\n\n\tif (is_tracepoint || is_syscall_tp) {\n\t\t*buf = is_tracepoint ? event->tp_event->tp->name\n\t\t\t\t     : event->tp_event->name;\n\t\t*fd_type = BPF_FD_TYPE_TRACEPOINT;\n\t\t*probe_offset = 0x0;\n\t\t*probe_addr = 0x0;\n\t} else {\n\t\t/* kprobe/uprobe */\n\t\terr = -EOPNOTSUPP;\n#ifdef CONFIG_KPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_KPROBE)\n\t\t\terr = bpf_get_kprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset, probe_addr,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n#ifdef CONFIG_UPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_UPROBE)\n\t\t\terr = bpf_get_uprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_probe_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "1167-1175",
    "snippet": "int bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(bpf_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_probe_unregister",
          "args": [
            "btp->tp",
            "(void *)btp->bpf_func",
            "prog"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "360-371",
          "snippet": "int tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(bpf_event_mutex);\n\nint bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_probe_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "1157-1165",
    "snippet": "int bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = __bpf_probe_register(btp, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(bpf_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_probe_register",
          "args": [
            "btp",
            "prog"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_probe_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "1143-1155",
          "snippet": "static int __bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tstruct tracepoint *tp = btp->tp;\n\n\t/*\n\t * check that program doesn't access arguments beyond what's\n\t * available in this tracepoint\n\t */\n\tif (prog->aux->max_ctx_offset > btp->num_args * sizeof(u64))\n\t\treturn -EINVAL;\n\n\treturn tracepoint_probe_register(tp, (void *)btp->bpf_func, prog);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic int __bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tstruct tracepoint *tp = btp->tp;\n\n\t/*\n\t * check that program doesn't access arguments beyond what's\n\t * available in this tracepoint\n\t */\n\tif (prog->aux->max_ctx_offset > btp->num_args * sizeof(u64))\n\t\treturn -EINVAL;\n\n\treturn tracepoint_probe_register(tp, (void *)btp->bpf_func, prog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(bpf_event_mutex);\n\nint bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = __bpf_probe_register(btp, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "__bpf_probe_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "1143-1155",
    "snippet": "static int __bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tstruct tracepoint *tp = btp->tp;\n\n\t/*\n\t * check that program doesn't access arguments beyond what's\n\t * available in this tracepoint\n\t */\n\tif (prog->aux->max_ctx_offset > btp->num_args * sizeof(u64))\n\t\treturn -EINVAL;\n\n\treturn tracepoint_probe_register(tp, (void *)btp->bpf_func, prog);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_probe_register",
          "args": [
            "tp",
            "(void *)btp->bpf_func",
            "prog"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "346-349",
          "snippet": "int tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic int __bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tstruct tracepoint *tp = btp->tp;\n\n\t/*\n\t * check that program doesn't access arguments beyond what's\n\t * available in this tracepoint\n\t */\n\tif (prog->aux->max_ctx_offset > btp->num_args * sizeof(u64))\n\t\treturn -EINVAL;\n\n\treturn tracepoint_probe_register(tp, (void *)btp->bpf_func, prog);\n}"
  },
  {
    "function_name": "__bpf_trace_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "1088-1096",
    "snippet": "static __always_inline\nvoid __bpf_trace_run(struct bpf_prog *prog, u64 *args)\n{\n\trcu_read_lock();\n\tpreempt_disable();\n\t(void) BPF_PROG_RUN(prog, args);\n\tpreempt_enable();\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN",
          "args": [
            "prog",
            "args"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic __always_inline\nvoid __bpf_trace_run(struct bpf_prog *prog, u64 *args)\n{\n\trcu_read_lock();\n\tpreempt_disable();\n\t(void) BPF_PROG_RUN(prog, args);\n\tpreempt_enable();\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "bpf_find_raw_tracepoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "1077-1086",
    "snippet": "struct bpf_raw_event_map *bpf_find_raw_tracepoint(const char *name)\n{\n\tstruct bpf_raw_event_map *btp = __start__bpf_raw_tp;\n\n\tfor (; btp < __stop__bpf_raw_tp; btp++) {\n\t\tif (!strcmp(btp->tp->name, name))\n\t\t\treturn btp;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct bpf_raw_event_map __start__bpf_raw_tp[];",
      "extern struct bpf_raw_event_map __stop__bpf_raw_tp[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "btp->tp->name",
            "name"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nextern struct bpf_raw_event_map __start__bpf_raw_tp[];\nextern struct bpf_raw_event_map __stop__bpf_raw_tp[];\n\nstruct bpf_raw_event_map *bpf_find_raw_tracepoint(const char *name)\n{\n\tstruct bpf_raw_event_map *btp = __start__bpf_raw_tp;\n\n\tfor (; btp < __stop__bpf_raw_tp; btp++) {\n\t\tif (!strcmp(btp->tp->name, name))\n\t\t\treturn btp;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "perf_event_query_prog_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "1032-1072",
    "snippet": "int perf_event_query_prog_array(struct perf_event *event, void __user *info)\n{\n\tstruct perf_event_query_bpf __user *uquery = info;\n\tstruct perf_event_query_bpf query = {};\n\tu32 *ids, prog_cnt, ids_len;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&query, uquery, sizeof(query)))\n\t\treturn -EFAULT;\n\n\tids_len = query.ids_len;\n\tif (ids_len > BPF_TRACE_MAX_PROGS)\n\t\treturn -E2BIG;\n\tids = kcalloc(ids_len, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\t/*\n\t * The above kcalloc returns ZERO_SIZE_PTR when ids_len = 0, which\n\t * is required when user only wants to check for uquery->prog_cnt.\n\t * There is no need to check for it since the case is handled\n\t * gracefully in bpf_prog_array_copy_info.\n\t */\n\n\tmutex_lock(&bpf_event_mutex);\n\tret = bpf_prog_array_copy_info(event->tp_event->prog_array,\n\t\t\t\t       ids,\n\t\t\t\t       ids_len,\n\t\t\t\t       &prog_cnt);\n\tmutex_unlock(&bpf_event_mutex);\n\n\tif (copy_to_user(&uquery->prog_cnt, &prog_cnt, sizeof(prog_cnt)) ||\n\t    copy_to_user(uquery->ids, ids, ids_len * sizeof(u32)))\n\t\tret = -EFAULT;\n\n\tkfree(ids);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BPF_TRACE_MAX_PROGS 64"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(bpf_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ids"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uquery->ids",
            "ids",
            "ids_len * sizeof(u32)"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_copy_info",
          "args": [
            "event->tp_event->prog_array",
            "ids",
            "ids_len",
            "&prog_cnt"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1747-1765",
          "snippet": "int bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,\n\t\t\t     u32 *prog_ids, u32 request_cnt,\n\t\t\t     u32 *prog_cnt)\n{\n\tu32 cnt = 0;\n\n\tif (array)\n\t\tcnt = bpf_prog_array_length(array);\n\n\t*prog_cnt = cnt;\n\n\t/* return early if user requested only program count or nothing to copy */\n\tif (!request_cnt || !cnt)\n\t\treturn 0;\n\n\t/* this function is called under trace/bpf_trace.c: bpf_event_mutex */\n\treturn bpf_prog_array_copy_core(array, prog_ids, request_cnt) ? -ENOSPC\n\t\t\t\t\t\t\t\t     : 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,\n\t\t\t     u32 *prog_ids, u32 request_cnt,\n\t\t\t     u32 *prog_cnt)\n{\n\tu32 cnt = 0;\n\n\tif (array)\n\t\tcnt = bpf_prog_array_length(array);\n\n\t*prog_cnt = cnt;\n\n\t/* return early if user requested only program count or nothing to copy */\n\tif (!request_cnt || !cnt)\n\t\treturn 0;\n\n\t/* this function is called under trace/bpf_trace.c: bpf_event_mutex */\n\treturn bpf_prog_array_copy_core(array, prog_ids, request_cnt) ? -ENOSPC\n\t\t\t\t\t\t\t\t     : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "ids_len",
            "sizeof(u32)",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&query",
            "uquery",
            "sizeof(query)"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#define BPF_TRACE_MAX_PROGS 64\n\nstatic DEFINE_MUTEX(bpf_event_mutex);\n\nint perf_event_query_prog_array(struct perf_event *event, void __user *info)\n{\n\tstruct perf_event_query_bpf __user *uquery = info;\n\tstruct perf_event_query_bpf query = {};\n\tu32 *ids, prog_cnt, ids_len;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&query, uquery, sizeof(query)))\n\t\treturn -EFAULT;\n\n\tids_len = query.ids_len;\n\tif (ids_len > BPF_TRACE_MAX_PROGS)\n\t\treturn -E2BIG;\n\tids = kcalloc(ids_len, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\t/*\n\t * The above kcalloc returns ZERO_SIZE_PTR when ids_len = 0, which\n\t * is required when user only wants to check for uquery->prog_cnt.\n\t * There is no need to check for it since the case is handled\n\t * gracefully in bpf_prog_array_copy_info.\n\t */\n\n\tmutex_lock(&bpf_event_mutex);\n\tret = bpf_prog_array_copy_info(event->tp_event->prog_array,\n\t\t\t\t       ids,\n\t\t\t\t       ids_len,\n\t\t\t\t       &prog_cnt);\n\tmutex_unlock(&bpf_event_mutex);\n\n\tif (copy_to_user(&uquery->prog_cnt, &prog_cnt, sizeof(prog_cnt)) ||\n\t    copy_to_user(uquery->ids, ids, ids_len * sizeof(u32)))\n\t\tret = -EFAULT;\n\n\tkfree(ids);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_event_detach_bpf_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "1003-1030",
    "snippet": "void perf_event_detach_bpf_prog(struct perf_event *event)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\tstruct bpf_prog_array *new_array;\n\tint ret;\n\n\tmutex_lock(&bpf_event_mutex);\n\n\tif (!event->prog)\n\t\tgoto unlock;\n\n\told_array = event->tp_event->prog_array;\n\tret = bpf_prog_array_copy(old_array, event->prog, NULL, &new_array);\n\tif (ret == -ENOENT)\n\t\tgoto unlock;\n\tif (ret < 0) {\n\t\tbpf_prog_array_delete_safe(old_array, event->prog);\n\t} else {\n\t\trcu_assign_pointer(event->tp_event->prog_array, new_array);\n\t\tbpf_prog_array_free(old_array);\n\t}\n\n\tbpf_prog_put(event->prog);\n\tevent->prog = NULL;\n\nunlock:\n\tmutex_unlock(&bpf_event_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(bpf_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "event->prog"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "old_array"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1595-1601",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "event->tp_event->prog_array",
            "new_array"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_delete_safe",
          "args": [
            "old_array",
            "event->prog"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_delete_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1671-1681",
          "snippet": "void bpf_prog_array_delete_safe(struct bpf_prog_array __rcu *array,\n\t\t\t\tstruct bpf_prog *old_prog)\n{\n\tstruct bpf_prog_array_item *item = array->items;\n\n\tfor (; item->prog; item++)\n\t\tif (item->prog == old_prog) {\n\t\t\tWRITE_ONCE(item->prog, &dummy_bpf_prog.prog);\n\t\t\tbreak;\n\t\t}\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nvoid bpf_prog_array_delete_safe(struct bpf_prog_array __rcu *array,\n\t\t\t\tstruct bpf_prog *old_prog)\n{\n\tstruct bpf_prog_array_item *item = array->items;\n\n\tfor (; item->prog; item++)\n\t\tif (item->prog == old_prog) {\n\t\t\tWRITE_ONCE(item->prog, &dummy_bpf_prog.prog);\n\t\t\tbreak;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_copy",
          "args": [
            "old_array",
            "event->prog",
            "NULL",
            "&new_array"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1747-1765",
          "snippet": "int bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,\n\t\t\t     u32 *prog_ids, u32 request_cnt,\n\t\t\t     u32 *prog_cnt)\n{\n\tu32 cnt = 0;\n\n\tif (array)\n\t\tcnt = bpf_prog_array_length(array);\n\n\t*prog_cnt = cnt;\n\n\t/* return early if user requested only program count or nothing to copy */\n\tif (!request_cnt || !cnt)\n\t\treturn 0;\n\n\t/* this function is called under trace/bpf_trace.c: bpf_event_mutex */\n\treturn bpf_prog_array_copy_core(array, prog_ids, request_cnt) ? -ENOSPC\n\t\t\t\t\t\t\t\t     : 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,\n\t\t\t     u32 *prog_ids, u32 request_cnt,\n\t\t\t     u32 *prog_cnt)\n{\n\tu32 cnt = 0;\n\n\tif (array)\n\t\tcnt = bpf_prog_array_length(array);\n\n\t*prog_cnt = cnt;\n\n\t/* return early if user requested only program count or nothing to copy */\n\tif (!request_cnt || !cnt)\n\t\treturn 0;\n\n\t/* this function is called under trace/bpf_trace.c: bpf_event_mutex */\n\treturn bpf_prog_array_copy_core(array, prog_ids, request_cnt) ? -ENOSPC\n\t\t\t\t\t\t\t\t     : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(bpf_event_mutex);\n\nvoid perf_event_detach_bpf_prog(struct perf_event *event)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\tstruct bpf_prog_array *new_array;\n\tint ret;\n\n\tmutex_lock(&bpf_event_mutex);\n\n\tif (!event->prog)\n\t\tgoto unlock;\n\n\told_array = event->tp_event->prog_array;\n\tret = bpf_prog_array_copy(old_array, event->prog, NULL, &new_array);\n\tif (ret == -ENOENT)\n\t\tgoto unlock;\n\tif (ret < 0) {\n\t\tbpf_prog_array_delete_safe(old_array, event->prog);\n\t} else {\n\t\trcu_assign_pointer(event->tp_event->prog_array, new_array);\n\t\tbpf_prog_array_free(old_array);\n\t}\n\n\tbpf_prog_put(event->prog);\n\tevent->prog = NULL;\n\nunlock:\n\tmutex_unlock(&bpf_event_mutex);\n}"
  },
  {
    "function_name": "perf_event_attach_bpf_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "961-1001",
    "snippet": "int perf_event_attach_bpf_prog(struct perf_event *event,\n\t\t\t       struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\tstruct bpf_prog_array *new_array;\n\tint ret = -EEXIST;\n\n\t/*\n\t * Kprobe override only works if they are on the function entry,\n\t * and only if they are on the opt-in list.\n\t */\n\tif (prog->kprobe_override &&\n\t    (!trace_kprobe_on_func_entry(event->tp_event) ||\n\t     !trace_kprobe_error_injectable(event->tp_event)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bpf_event_mutex);\n\n\tif (event->prog)\n\t\tgoto unlock;\n\n\told_array = event->tp_event->prog_array;\n\tif (old_array &&\n\t    bpf_prog_array_length(old_array) >= BPF_TRACE_MAX_PROGS) {\n\t\tret = -E2BIG;\n\t\tgoto unlock;\n\t}\n\n\tret = bpf_prog_array_copy(old_array, NULL, prog, &new_array);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t/* set the new array to event->tp_event and set event->prog */\n\tevent->prog = prog;\n\trcu_assign_pointer(event->tp_event->prog_array, new_array);\n\tbpf_prog_array_free(old_array);\n\nunlock:\n\tmutex_unlock(&bpf_event_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BPF_TRACE_MAX_PROGS 64"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(bpf_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "old_array"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1595-1601",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "event->tp_event->prog_array",
            "new_array"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_copy",
          "args": [
            "old_array",
            "NULL",
            "prog",
            "&new_array"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1747-1765",
          "snippet": "int bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,\n\t\t\t     u32 *prog_ids, u32 request_cnt,\n\t\t\t     u32 *prog_cnt)\n{\n\tu32 cnt = 0;\n\n\tif (array)\n\t\tcnt = bpf_prog_array_length(array);\n\n\t*prog_cnt = cnt;\n\n\t/* return early if user requested only program count or nothing to copy */\n\tif (!request_cnt || !cnt)\n\t\treturn 0;\n\n\t/* this function is called under trace/bpf_trace.c: bpf_event_mutex */\n\treturn bpf_prog_array_copy_core(array, prog_ids, request_cnt) ? -ENOSPC\n\t\t\t\t\t\t\t\t     : 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,\n\t\t\t     u32 *prog_ids, u32 request_cnt,\n\t\t\t     u32 *prog_cnt)\n{\n\tu32 cnt = 0;\n\n\tif (array)\n\t\tcnt = bpf_prog_array_length(array);\n\n\t*prog_cnt = cnt;\n\n\t/* return early if user requested only program count or nothing to copy */\n\tif (!request_cnt || !cnt)\n\t\treturn 0;\n\n\t/* this function is called under trace/bpf_trace.c: bpf_event_mutex */\n\treturn bpf_prog_array_copy_core(array, prog_ids, request_cnt) ? -ENOSPC\n\t\t\t\t\t\t\t\t     : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_length",
          "args": [
            "old_array"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1603-1615",
          "snippet": "int bpf_prog_array_length(struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\trcu_read_lock();\n\titem = rcu_dereference(array)->items;\n\tfor (; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_length(struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\trcu_read_lock();\n\titem = rcu_dereference(array)->items;\n\tfor (; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bpf_event_mutex"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_error_injectable",
          "args": [
            "event->tp_event"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_error_injectable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "121-126",
          "snippet": "bool trace_kprobe_error_injectable(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)call->data;\n\n\treturn within_error_injection_list(trace_kprobe_address(tk));\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nbool trace_kprobe_error_injectable(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)call->data;\n\n\treturn within_error_injection_list(trace_kprobe_address(tk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_on_func_entry",
          "args": [
            "event->tp_event"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_on_func_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "112-119",
          "snippet": "bool trace_kprobe_on_func_entry(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)call->data;\n\n\treturn kprobe_on_func_entry(tk->rp.kp.addr,\n\t\t\ttk->rp.kp.addr ? NULL : tk->rp.kp.symbol_name,\n\t\t\ttk->rp.kp.addr ? 0 : tk->rp.kp.offset);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nbool trace_kprobe_on_func_entry(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)call->data;\n\n\treturn kprobe_on_func_entry(tk->rp.kp.addr,\n\t\t\ttk->rp.kp.addr ? NULL : tk->rp.kp.symbol_name,\n\t\t\ttk->rp.kp.addr ? 0 : tk->rp.kp.offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#define BPF_TRACE_MAX_PROGS 64\n\nstatic DEFINE_MUTEX(bpf_event_mutex);\n\nint perf_event_attach_bpf_prog(struct perf_event *event,\n\t\t\t       struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array __rcu *old_array;\n\tstruct bpf_prog_array *new_array;\n\tint ret = -EEXIST;\n\n\t/*\n\t * Kprobe override only works if they are on the function entry,\n\t * and only if they are on the opt-in list.\n\t */\n\tif (prog->kprobe_override &&\n\t    (!trace_kprobe_on_func_entry(event->tp_event) ||\n\t     !trace_kprobe_error_injectable(event->tp_event)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bpf_event_mutex);\n\n\tif (event->prog)\n\t\tgoto unlock;\n\n\told_array = event->tp_event->prog_array;\n\tif (old_array &&\n\t    bpf_prog_array_length(old_array) >= BPF_TRACE_MAX_PROGS) {\n\t\tret = -E2BIG;\n\t\tgoto unlock;\n\t}\n\n\tret = bpf_prog_array_copy(old_array, NULL, prog, &new_array);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t/* set the new array to event->tp_event and set event->prog */\n\tevent->prog = prog;\n\trcu_assign_pointer(event->tp_event->prog_array, new_array);\n\tbpf_prog_array_free(old_array);\n\nunlock:\n\tmutex_unlock(&bpf_event_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "pe_prog_convert_ctx_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "912-946",
    "snippet": "static u32 pe_prog_convert_ctx_access(enum bpf_access_type type,\n\t\t\t\t      const struct bpf_insn *si,\n\t\t\t\t      struct bpf_insn *insn_buf,\n\t\t\t\t      struct bpf_prog *prog, u32 *target_size)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\n\tswitch (si->off) {\n\tcase offsetof(struct bpf_perf_event_data, sample_period):\n\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       data), si->dst_reg, si->src_reg,\n\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, data));\n\t\t*insn++ = BPF_LDX_MEM(BPF_DW, si->dst_reg, si->dst_reg,\n\t\t\t\t      bpf_target_off(struct perf_sample_data, period, 8,\n\t\t\t\t\t\t     target_size));\n\t\tbreak;\n\tcase offsetof(struct bpf_perf_event_data, addr):\n\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       data), si->dst_reg, si->src_reg,\n\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, data));\n\t\t*insn++ = BPF_LDX_MEM(BPF_DW, si->dst_reg, si->dst_reg,\n\t\t\t\t      bpf_target_off(struct perf_sample_data, addr, 8,\n\t\t\t\t\t\t     target_size));\n\t\tbreak;\n\tdefault:\n\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       regs), si->dst_reg, si->src_reg,\n\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, regs));\n\t\t*insn++ = BPF_LDX_MEM(BPF_SIZEOF(long), si->dst_reg, si->dst_reg,\n\t\t\t\t      si->off);\n\t\tbreak;\n\t}\n\n\treturn insn - insn_buf;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_SIZEOF(long)",
            "si->dst_reg",
            "si->dst_reg",
            "si->off"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZEOF",
          "args": [
            "long"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       regs)",
            "si->dst_reg",
            "si->src_reg",
            "offsetof(struct bpf_perf_event_data_kern, regs)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_FIELD_SIZEOF",
          "args": [
            "structbpf_perf_event_data_kern",
            "regs"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_DW",
            "si->dst_reg",
            "si->dst_reg",
            "bpf_target_off(struct perf_sample_data, addr, 8,\n\t\t\t\t\t\t     target_size)"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_target_off",
          "args": [
            "structperf_sample_data",
            "addr",
            "8",
            "target_size"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       data)",
            "si->dst_reg",
            "si->src_reg",
            "offsetof(struct bpf_perf_event_data_kern, data)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_FIELD_SIZEOF",
          "args": [
            "structbpf_perf_event_data_kern",
            "data"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_DW",
            "si->dst_reg",
            "si->dst_reg",
            "bpf_target_off(struct perf_sample_data, period, 8,\n\t\t\t\t\t\t     target_size)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_target_off",
          "args": [
            "structperf_sample_data",
            "period",
            "8",
            "target_size"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       data)",
            "si->dst_reg",
            "si->src_reg",
            "offsetof(struct bpf_perf_event_data_kern, data)"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_FIELD_SIZEOF",
          "args": [
            "structbpf_perf_event_data_kern",
            "data"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic u32 pe_prog_convert_ctx_access(enum bpf_access_type type,\n\t\t\t\t      const struct bpf_insn *si,\n\t\t\t\t      struct bpf_insn *insn_buf,\n\t\t\t\t      struct bpf_prog *prog, u32 *target_size)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\n\tswitch (si->off) {\n\tcase offsetof(struct bpf_perf_event_data, sample_period):\n\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       data), si->dst_reg, si->src_reg,\n\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, data));\n\t\t*insn++ = BPF_LDX_MEM(BPF_DW, si->dst_reg, si->dst_reg,\n\t\t\t\t      bpf_target_off(struct perf_sample_data, period, 8,\n\t\t\t\t\t\t     target_size));\n\t\tbreak;\n\tcase offsetof(struct bpf_perf_event_data, addr):\n\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       data), si->dst_reg, si->src_reg,\n\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, data));\n\t\t*insn++ = BPF_LDX_MEM(BPF_DW, si->dst_reg, si->dst_reg,\n\t\t\t\t      bpf_target_off(struct perf_sample_data, addr, 8,\n\t\t\t\t\t\t     target_size));\n\t\tbreak;\n\tdefault:\n\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,\n\t\t\t\t\t\t       regs), si->dst_reg, si->src_reg,\n\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, regs));\n\t\t*insn++ = BPF_LDX_MEM(BPF_SIZEOF(long), si->dst_reg, si->dst_reg,\n\t\t\t\t      si->off);\n\t\tbreak;\n\t}\n\n\treturn insn - insn_buf;\n}"
  },
  {
    "function_name": "pe_prog_is_valid_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "874-910",
    "snippet": "static bool pe_prog_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t\t    const struct bpf_prog *prog,\n\t\t\t\t    struct bpf_insn_access_aux *info)\n{\n\tconst int size_u64 = sizeof(u64);\n\n\tif (off < 0 || off >= sizeof(struct bpf_perf_event_data))\n\t\treturn false;\n\tif (type != BPF_READ)\n\t\treturn false;\n\tif (off % size != 0) {\n\t\tif (sizeof(unsigned long) != 4)\n\t\t\treturn false;\n\t\tif (size != 8)\n\t\t\treturn false;\n\t\tif (off % size != 4)\n\t\t\treturn false;\n\t}\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_perf_event_data, sample_period):\n\t\tbpf_ctx_record_field_size(info, size_u64);\n\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_u64))\n\t\t\treturn false;\n\t\tbreak;\n\tcase bpf_ctx_range(struct bpf_perf_event_data, addr):\n\t\tbpf_ctx_record_field_size(info, size_u64);\n\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_u64))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (size != sizeof(long))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_ctx_narrow_access_ok",
          "args": [
            "off",
            "size",
            "size_u64"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_record_field_size",
          "args": [
            "info",
            "size_u64"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_range",
          "args": [
            "structbpf_perf_event_data",
            "addr"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_narrow_access_ok",
          "args": [
            "off",
            "size",
            "size_u64"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_record_field_size",
          "args": [
            "info",
            "size_u64"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ctx_range",
          "args": [
            "structbpf_perf_event_data",
            "sample_period"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic bool pe_prog_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t\t    const struct bpf_prog *prog,\n\t\t\t\t    struct bpf_insn_access_aux *info)\n{\n\tconst int size_u64 = sizeof(u64);\n\n\tif (off < 0 || off >= sizeof(struct bpf_perf_event_data))\n\t\treturn false;\n\tif (type != BPF_READ)\n\t\treturn false;\n\tif (off % size != 0) {\n\t\tif (sizeof(unsigned long) != 4)\n\t\t\treturn false;\n\t\tif (size != 8)\n\t\t\treturn false;\n\t\tif (off % size != 4)\n\t\t\treturn false;\n\t}\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_perf_event_data, sample_period):\n\t\tbpf_ctx_record_field_size(info, size_u64);\n\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_u64))\n\t\t\treturn false;\n\t\tbreak;\n\tcase bpf_ctx_range(struct bpf_perf_event_data, addr):\n\t\tbpf_ctx_record_field_size(info, size_u64);\n\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_u64))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (size != sizeof(long))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "raw_tp_prog_is_valid_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "851-864",
    "snippet": "static bool raw_tp_prog_is_valid_access(int off, int size,\n\t\t\t\t\tenum bpf_access_type type,\n\t\t\t\t\tconst struct bpf_prog *prog,\n\t\t\t\t\tstruct bpf_insn_access_aux *info)\n{\n\t/* largest tracepoint in the kernel has 12 args */\n\tif (off < 0 || off >= sizeof(__u64) * 12)\n\t\treturn false;\n\tif (type != BPF_READ)\n\t\treturn false;\n\tif (off % size != 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic bool raw_tp_prog_is_valid_access(int off, int size,\n\t\t\t\t\tenum bpf_access_type type,\n\t\t\t\t\tconst struct bpf_prog *prog,\n\t\t\t\t\tstruct bpf_insn_access_aux *info)\n{\n\t/* largest tracepoint in the kernel has 12 args */\n\tif (off < 0 || off >= sizeof(__u64) * 12)\n\t\treturn false;\n\tif (type != BPF_READ)\n\t\treturn false;\n\tif (off % size != 0)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "raw_tp_prog_func_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "836-849",
    "snippet": "static const struct bpf_func_proto *\nraw_tp_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_perf_event_output_proto_raw_tp;\n\tcase BPF_FUNC_get_stackid:\n\t\treturn &bpf_get_stackid_proto_raw_tp;\n\tcase BPF_FUNC_get_stack:\n\t\treturn &bpf_get_stack_proto_raw_tp;\n\tdefault:\n\t\treturn tracing_func_proto(func_id, prog);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_perf_event_output_proto_raw_tp = {\n\t.func\t\t= bpf_perf_event_output_raw_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_MEM,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};",
      "static const struct bpf_func_proto bpf_get_stackid_proto_raw_tp = {\n\t.func\t\t= bpf_get_stackid_raw_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_get_stack_proto_raw_tp = {\n\t.func\t\t= bpf_get_stack_raw_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg4_type\t= ARG_ANYTHING,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_func_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "524-571",
          "snippet": "static const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};",
            "static const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};\nstatic const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\n\nstatic const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_perf_event_output_proto_raw_tp = {\n\t.func\t\t= bpf_perf_event_output_raw_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_MEM,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};\nstatic const struct bpf_func_proto bpf_get_stackid_proto_raw_tp = {\n\t.func\t\t= bpf_get_stackid_raw_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_get_stack_proto_raw_tp = {\n\t.func\t\t= bpf_get_stack_raw_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg4_type\t= ARG_ANYTHING,\n};\n\nstatic const struct bpf_func_proto *\nraw_tp_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_perf_event_output_proto_raw_tp;\n\tcase BPF_FUNC_get_stackid:\n\t\treturn &bpf_get_stackid_proto_raw_tp;\n\tcase BPF_FUNC_get_stack:\n\t\treturn &bpf_get_stack_proto_raw_tp;\n\tdefault:\n\t\treturn tracing_func_proto(func_id, prog);\n\t}\n}"
  },
  {
    "function_name": "BPF_CALL_5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "775-783",
    "snippet": "static DEFINE_PER_CPU(struct pt_regs, bpf_raw_tp_regs);\nBPF_CALL_5(bpf_perf_event_output_raw_tp, struct bpf_raw_tracepoint_args *, args,\n\t   struct bpf_map *, map, u64, flags, void *, data, u64, size)\n{\n\tstruct pt_regs *regs = this_cpu_ptr(&bpf_raw_tp_regs);\n\n\tperf_fetch_caller_regs(regs);\n\treturn ____bpf_perf_event_output(regs, map, flags, data, size);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "____bpf_perf_event_output",
          "args": [
            "regs",
            "map",
            "flags",
            "data",
            "size"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_fetch_caller_regs",
          "args": [
            "regs"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bpf_raw_tp_regs"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct pt_regs, bpf_raw_tp_regs);\nBPF_CALL_5(bpf_perf_event_output_raw_tp, struct bpf_raw_tracepoint_args *, args,\n\t   struct bpf_map *, map, u64, flags, void *, data, u64, size)\n{\n\tstruct pt_regs *regs = this_cpu_ptr(&bpf_raw_tp_regs);\n\n\tperf_fetch_caller_regs(regs);\n\treturn ____bpf_perf_event_output(regs, map, flags, data, size);\n}"
  },
  {
    "function_name": "pe_prog_func_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "753-768",
    "snippet": "static const struct bpf_func_proto *\npe_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_perf_event_output_proto_tp;\n\tcase BPF_FUNC_get_stackid:\n\t\treturn &bpf_get_stackid_proto_tp;\n\tcase BPF_FUNC_get_stack:\n\t\treturn &bpf_get_stack_proto_tp;\n\tcase BPF_FUNC_perf_prog_read_value:\n\t\treturn &bpf_perf_prog_read_value_proto;\n\tdefault:\n\t\treturn tracing_func_proto(func_id, prog);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_perf_event_output_proto_tp = {\n\t.func\t\t= bpf_perf_event_output_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_MEM,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};",
      "static const struct bpf_func_proto bpf_get_stackid_proto_tp = {\n\t.func\t\t= bpf_get_stackid_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_get_stack_proto_tp = {\n\t.func\t\t= bpf_get_stack_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg4_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_perf_prog_read_value_proto = {\n         .func           = bpf_perf_prog_read_value,\n         .gpl_only       = true,\n         .ret_type       = RET_INTEGER,\n         .arg1_type      = ARG_PTR_TO_CTX,\n         .arg2_type      = ARG_PTR_TO_UNINIT_MEM,\n         .arg3_type      = ARG_CONST_SIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_func_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "524-571",
          "snippet": "static const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};",
            "static const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};\nstatic const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\n\nstatic const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_perf_event_output_proto_tp = {\n\t.func\t\t= bpf_perf_event_output_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_MEM,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};\nstatic const struct bpf_func_proto bpf_get_stackid_proto_tp = {\n\t.func\t\t= bpf_get_stackid_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_get_stack_proto_tp = {\n\t.func\t\t= bpf_get_stack_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg4_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_perf_prog_read_value_proto = {\n         .func           = bpf_perf_prog_read_value,\n         .gpl_only       = true,\n         .ret_type       = RET_INTEGER,\n         .arg1_type      = ARG_PTR_TO_CTX,\n         .arg2_type      = ARG_PTR_TO_UNINIT_MEM,\n         .arg3_type      = ARG_CONST_SIZE,\n};\n\nstatic const struct bpf_func_proto *\npe_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_perf_event_output_proto_tp;\n\tcase BPF_FUNC_get_stackid:\n\t\treturn &bpf_get_stackid_proto_tp;\n\tcase BPF_FUNC_get_stack:\n\t\treturn &bpf_get_stack_proto_tp;\n\tcase BPF_FUNC_perf_prog_read_value:\n\t\treturn &bpf_perf_prog_read_value_proto;\n\tdefault:\n\t\treturn tracing_func_proto(func_id, prog);\n\t}\n}"
  },
  {
    "function_name": "tp_prog_is_valid_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "704-717",
    "snippet": "static bool tp_prog_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t\t    const struct bpf_prog *prog,\n\t\t\t\t    struct bpf_insn_access_aux *info)\n{\n\tif (off < sizeof(void *) || off >= PERF_MAX_TRACE_SIZE)\n\t\treturn false;\n\tif (type != BPF_READ)\n\t\treturn false;\n\tif (off % size != 0)\n\t\treturn false;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(__u64));\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PERF_MAX_TRACE_SIZE % sizeof(__u64)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic bool tp_prog_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t\t    const struct bpf_prog *prog,\n\t\t\t\t    struct bpf_insn_access_aux *info)\n{\n\tif (off < sizeof(void *) || off >= PERF_MAX_TRACE_SIZE)\n\t\treturn false;\n\tif (type != BPF_READ)\n\t\treturn false;\n\tif (off % size != 0)\n\t\treturn false;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(__u64));\n\treturn true;\n}"
  },
  {
    "function_name": "tp_prog_func_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "689-702",
    "snippet": "static const struct bpf_func_proto *\ntp_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_perf_event_output_proto_tp;\n\tcase BPF_FUNC_get_stackid:\n\t\treturn &bpf_get_stackid_proto_tp;\n\tcase BPF_FUNC_get_stack:\n\t\treturn &bpf_get_stack_proto_tp;\n\tdefault:\n\t\treturn tracing_func_proto(func_id, prog);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_perf_event_output_proto_tp = {\n\t.func\t\t= bpf_perf_event_output_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_MEM,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};",
      "static const struct bpf_func_proto bpf_get_stackid_proto_tp = {\n\t.func\t\t= bpf_get_stackid_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_get_stack_proto_tp = {\n\t.func\t\t= bpf_get_stack_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg4_type\t= ARG_ANYTHING,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_func_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "524-571",
          "snippet": "static const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};",
            "static const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};\nstatic const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\n\nstatic const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_perf_event_output_proto_tp = {\n\t.func\t\t= bpf_perf_event_output_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_MEM,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};\nstatic const struct bpf_func_proto bpf_get_stackid_proto_tp = {\n\t.func\t\t= bpf_get_stackid_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_get_stack_proto_tp = {\n\t.func\t\t= bpf_get_stack_tp,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg4_type\t= ARG_ANYTHING,\n};\n\nstatic const struct bpf_func_proto *\ntp_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_perf_event_output_proto_tp;\n\tcase BPF_FUNC_get_stackid:\n\t\treturn &bpf_get_stackid_proto_tp;\n\tcase BPF_FUNC_get_stack:\n\t\treturn &bpf_get_stack_proto_tp;\n\tdefault:\n\t\treturn tracing_func_proto(func_id, prog);\n\t}\n}"
  },
  {
    "function_name": "kprobe_prog_is_valid_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "595-613",
    "snippet": "static bool kprobe_prog_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t\t\tconst struct bpf_prog *prog,\n\t\t\t\t\tstruct bpf_insn_access_aux *info)\n{\n\tif (off < 0 || off >= sizeof(struct pt_regs))\n\t\treturn false;\n\tif (type != BPF_READ)\n\t\treturn false;\n\tif (off % size != 0)\n\t\treturn false;\n\t/*\n\t * Assertion for 32 bit to make sure last 8 byte access\n\t * (BPF_DW) to the last 4 byte member is disallowed.\n\t */\n\tif (off + size > sizeof(struct pt_regs))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic bool kprobe_prog_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t\t\tconst struct bpf_prog *prog,\n\t\t\t\t\tstruct bpf_insn_access_aux *info)\n{\n\tif (off < 0 || off >= sizeof(struct pt_regs))\n\t\treturn false;\n\tif (type != BPF_READ)\n\t\treturn false;\n\tif (off % size != 0)\n\t\treturn false;\n\t/*\n\t * Assertion for 32 bit to make sure last 8 byte access\n\t * (BPF_DW) to the last 4 byte member is disallowed.\n\t */\n\tif (off + size > sizeof(struct pt_regs))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "kprobe_prog_func_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "573-592",
    "snippet": "static const struct bpf_func_proto *\nkprobe_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_perf_event_output_proto;\n\tcase BPF_FUNC_get_stackid:\n\t\treturn &bpf_get_stackid_proto;\n\tcase BPF_FUNC_get_stack:\n\t\treturn &bpf_get_stack_proto;\n\tcase BPF_FUNC_perf_event_read_value:\n\t\treturn &bpf_perf_event_read_value_proto;\n#ifdef CONFIG_BPF_KPROBE_OVERRIDE\n\tcase BPF_FUNC_override_return:\n\t\treturn &bpf_override_return_proto;\n#endif\n\tdefault:\n\t\treturn tracing_func_proto(func_id, prog);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_perf_event_read_value_proto = {\n\t.func\t\t= bpf_perf_event_read_value,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg4_type\t= ARG_CONST_SIZE,\n};",
      "static const struct bpf_func_proto bpf_perf_event_output_proto = {\n\t.func\t\t= bpf_perf_event_output,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_MEM,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_func_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "524-571",
          "snippet": "static const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};",
            "static const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};\nstatic const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\n\nstatic const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_perf_event_read_value_proto = {\n\t.func\t\t= bpf_perf_event_read_value,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg4_type\t= ARG_CONST_SIZE,\n};\nstatic const struct bpf_func_proto bpf_perf_event_output_proto = {\n\t.func\t\t= bpf_perf_event_output,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_MEM,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};\n\nstatic const struct bpf_func_proto *\nkprobe_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn &bpf_perf_event_output_proto;\n\tcase BPF_FUNC_get_stackid:\n\t\treturn &bpf_get_stackid_proto;\n\tcase BPF_FUNC_get_stack:\n\t\treturn &bpf_get_stack_proto;\n\tcase BPF_FUNC_perf_event_read_value:\n\t\treturn &bpf_perf_event_read_value_proto;\n#ifdef CONFIG_BPF_KPROBE_OVERRIDE\n\tcase BPF_FUNC_override_return:\n\t\treturn &bpf_override_return_proto;\n#endif\n\tdefault:\n\t\treturn tracing_func_proto(func_id, prog);\n\t}\n}"
  },
  {
    "function_name": "tracing_func_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "524-571",
    "snippet": "static const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};",
      "static const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_probe_write_proto",
          "args": [],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_probe_write_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "151-157",
          "snippet": "static const struct bpf_func_proto *bpf_get_probe_write_proto(void)\n{\n\tpr_warn_ratelimited(\"%s[%d] is installing a program with bpf_probe_write_user helper that may corrupt user memory!\",\n\t\t\t    current->comm, task_pid_nr(current));\n\n\treturn &bpf_probe_write_user_proto;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_func_proto bpf_probe_write_user_proto = {\n\t.func\t\t= bpf_probe_write_user,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n\t.arg2_type\t= ARG_PTR_TO_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_probe_write_user_proto = {\n\t.func\t\t= bpf_probe_write_user,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n\t.arg2_type\t= ARG_PTR_TO_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};\n\nstatic const struct bpf_func_proto *bpf_get_probe_write_proto(void)\n{\n\tpr_warn_ratelimited(\"%s[%d] is installing a program with bpf_probe_write_user helper that may corrupt user memory!\",\n\t\t\t    current->comm, task_pid_nr(current));\n\n\treturn &bpf_probe_write_user_proto;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_trace_printk_proto",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_trace_printk_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "282-291",
          "snippet": "const struct bpf_func_proto *bpf_get_trace_printk_proto(void)\n{\n\t/*\n\t * this program might be calling bpf_trace_printk,\n\t * so allocate per-cpu printk buffers\n\t */\n\ttrace_printk_init_buffers();\n\n\treturn &bpf_trace_printk_proto;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_func_proto bpf_trace_printk_proto = {\n\t.func\t\t= bpf_trace_printk,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_trace_printk_proto = {\n\t.func\t\t= bpf_trace_printk,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n};\n\nconst struct bpf_func_proto *bpf_get_trace_printk_proto(void)\n{\n\t/*\n\t * this program might be calling bpf_trace_printk,\n\t * so allocate per-cpu printk buffers\n\t */\n\ttrace_printk_init_buffers();\n\n\treturn &bpf_trace_printk_proto;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_probe_read_proto = {\n\t.func\t\t= bpf_probe_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_perf_event_read_proto = {\n\t.func\t\t= bpf_perf_event_read,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_get_current_task_proto = {\n\t.func\t\t= bpf_get_current_task,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n};\nstatic const struct bpf_func_proto bpf_current_task_under_cgroup_proto = {\n\t.func           = bpf_current_task_under_cgroup,\n\t.gpl_only       = false,\n\t.ret_type       = RET_INTEGER,\n\t.arg1_type      = ARG_CONST_MAP_PTR,\n\t.arg2_type      = ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_probe_read_str_proto = {\n\t.func\t\t= bpf_probe_read_str,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\n\nstatic const struct bpf_func_proto *\ntracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_probe_read:\n\t\treturn &bpf_probe_read_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_current_pid_tgid:\n\t\treturn &bpf_get_current_pid_tgid_proto;\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_uid_gid:\n\t\treturn &bpf_get_current_uid_gid_proto;\n\tcase BPF_FUNC_get_current_comm:\n\t\treturn &bpf_get_current_comm_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_perf_event_read:\n\t\treturn &bpf_perf_event_read_proto;\n\tcase BPF_FUNC_probe_write_user:\n\t\treturn bpf_get_probe_write_proto();\n\tcase BPF_FUNC_current_task_under_cgroup:\n\t\treturn &bpf_current_task_under_cgroup_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_probe_read_str:\n\t\treturn &bpf_probe_read_str_proto;\n#ifdef CONFIG_CGROUPS\n\tcase BPF_FUNC_get_current_cgroup_id:\n\t\treturn &bpf_get_current_cgroup_id_proto;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "bpf_event_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "433-458",
    "snippet": "u64 bpf_event_output(struct bpf_map *map, u64 flags, void *meta, u64 meta_size,\n\t\t     void *ctx, u64 ctx_size, bpf_ctx_copy_t ctx_copy)\n{\n\tstruct perf_sample_data *sd = this_cpu_ptr(&bpf_misc_sd);\n\tstruct pt_regs *regs = this_cpu_ptr(&bpf_pt_regs);\n\tstruct perf_raw_frag frag = {\n\t\t.copy\t\t= ctx_copy,\n\t\t.size\t\t= ctx_size,\n\t\t.data\t\t= ctx,\n\t};\n\tstruct perf_raw_record raw = {\n\t\t.frag = {\n\t\t\t{\n\t\t\t\t.next\t= ctx_size ? &frag : NULL,\n\t\t\t},\n\t\t\t.size\t= meta_size,\n\t\t\t.data\t= meta,\n\t\t},\n\t};\n\n\tperf_fetch_caller_regs(regs);\n\tperf_sample_data_init(sd, 0, 0);\n\tsd->raw = &raw;\n\n\treturn __bpf_perf_event_output(regs, map, flags, sd);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct pt_regs, bpf_pt_regs);",
      "static DEFINE_PER_CPU(struct perf_sample_data, bpf_misc_sd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_perf_event_output",
          "args": [
            "regs",
            "map",
            "flags",
            "sd"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_perf_event_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "368-397",
          "snippet": "static __always_inline u64\n__bpf_perf_event_output(struct pt_regs *regs, struct bpf_map *map,\n\t\t\tu64 flags, struct perf_sample_data *sd)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tunsigned int cpu = smp_processor_id();\n\tu64 index = flags & BPF_F_INDEX_MASK;\n\tstruct bpf_event_entry *ee;\n\tstruct perf_event *event;\n\n\tif (index == BPF_F_CURRENT_CPU)\n\t\tindex = cpu;\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -E2BIG;\n\n\tee = READ_ONCE(array->ptrs[index]);\n\tif (!ee)\n\t\treturn -ENOENT;\n\n\tevent = ee->event;\n\tif (unlikely(event->attr.type != PERF_TYPE_SOFTWARE ||\n\t\t     event->attr.config != PERF_COUNT_SW_BPF_OUTPUT))\n\t\treturn -EINVAL;\n\n\tif (unlikely(event->oncpu != cpu))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_event_output(event, sd, regs);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic __always_inline u64\n__bpf_perf_event_output(struct pt_regs *regs, struct bpf_map *map,\n\t\t\tu64 flags, struct perf_sample_data *sd)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tunsigned int cpu = smp_processor_id();\n\tu64 index = flags & BPF_F_INDEX_MASK;\n\tstruct bpf_event_entry *ee;\n\tstruct perf_event *event;\n\n\tif (index == BPF_F_CURRENT_CPU)\n\t\tindex = cpu;\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -E2BIG;\n\n\tee = READ_ONCE(array->ptrs[index]);\n\tif (!ee)\n\t\treturn -ENOENT;\n\n\tevent = ee->event;\n\tif (unlikely(event->attr.type != PERF_TYPE_SOFTWARE ||\n\t\t     event->attr.config != PERF_COUNT_SW_BPF_OUTPUT))\n\t\treturn -EINVAL;\n\n\tif (unlikely(event->oncpu != cpu))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_event_output(event, sd, regs);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_sample_data_init",
          "args": [
            "sd",
            "0",
            "0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_fetch_caller_regs",
          "args": [
            "regs"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bpf_pt_regs"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bpf_misc_sd"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct pt_regs, bpf_pt_regs);\nstatic DEFINE_PER_CPU(struct perf_sample_data, bpf_misc_sd);\n\nu64 bpf_event_output(struct bpf_map *map, u64 flags, void *meta, u64 meta_size,\n\t\t     void *ctx, u64 ctx_size, bpf_ctx_copy_t ctx_copy)\n{\n\tstruct perf_sample_data *sd = this_cpu_ptr(&bpf_misc_sd);\n\tstruct pt_regs *regs = this_cpu_ptr(&bpf_pt_regs);\n\tstruct perf_raw_frag frag = {\n\t\t.copy\t\t= ctx_copy,\n\t\t.size\t\t= ctx_size,\n\t\t.data\t\t= ctx,\n\t};\n\tstruct perf_raw_record raw = {\n\t\t.frag = {\n\t\t\t{\n\t\t\t\t.next\t= ctx_size ? &frag : NULL,\n\t\t\t},\n\t\t\t.size\t= meta_size,\n\t\t\t.data\t= meta,\n\t\t},\n\t};\n\n\tperf_fetch_caller_regs(regs);\n\tperf_sample_data_init(sd, 0, 0);\n\tsd->raw = &raw;\n\n\treturn __bpf_perf_event_output(regs, map, flags, sd);\n}"
  },
  {
    "function_name": "__bpf_perf_event_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "368-397",
    "snippet": "static __always_inline u64\n__bpf_perf_event_output(struct pt_regs *regs, struct bpf_map *map,\n\t\t\tu64 flags, struct perf_sample_data *sd)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tunsigned int cpu = smp_processor_id();\n\tu64 index = flags & BPF_F_INDEX_MASK;\n\tstruct bpf_event_entry *ee;\n\tstruct perf_event *event;\n\n\tif (index == BPF_F_CURRENT_CPU)\n\t\tindex = cpu;\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -E2BIG;\n\n\tee = READ_ONCE(array->ptrs[index]);\n\tif (!ee)\n\t\treturn -ENOENT;\n\n\tevent = ee->event;\n\tif (unlikely(event->attr.type != PERF_TYPE_SOFTWARE ||\n\t\t     event->attr.config != PERF_COUNT_SW_BPF_OUTPUT))\n\t\treturn -EINVAL;\n\n\tif (unlikely(event->oncpu != cpu))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_event_output(event, sd, regs);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_output",
          "args": [
            "event",
            "sd",
            "regs"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "6535-6541",
          "snippet": "void\nperf_event_output(struct perf_event *event,\n\t\t  struct perf_sample_data *data,\n\t\t  struct pt_regs *regs)\n{\n\t__perf_event_output(event, data, regs, perf_output_begin);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid\nperf_event_output(struct perf_event *event,\n\t\t  struct perf_sample_data *data,\n\t\t  struct pt_regs *regs)\n{\n\t__perf_event_output(event, data, regs, perf_output_begin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "event->oncpu != cpu"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "event->attr.type != PERF_TYPE_SOFTWARE ||\n\t\t     event->attr.config != PERF_COUNT_SW_BPF_OUTPUT"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "array->ptrs[index]"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic __always_inline u64\n__bpf_perf_event_output(struct pt_regs *regs, struct bpf_map *map,\n\t\t\tu64 flags, struct perf_sample_data *sd)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tunsigned int cpu = smp_processor_id();\n\tu64 index = flags & BPF_F_INDEX_MASK;\n\tstruct bpf_event_entry *ee;\n\tstruct perf_event *event;\n\n\tif (index == BPF_F_CURRENT_CPU)\n\t\tindex = cpu;\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -E2BIG;\n\n\tee = READ_ONCE(array->ptrs[index]);\n\tif (!ee)\n\t\treturn -ENOENT;\n\n\tevent = ee->event;\n\tif (unlikely(event->attr.type != PERF_TYPE_SOFTWARE ||\n\t\t     event->attr.config != PERF_COUNT_SW_BPF_OUTPUT))\n\t\treturn -EINVAL;\n\n\tif (unlikely(event->oncpu != cpu))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_event_output(event, sd, regs);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_map_perf_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "293-314",
    "snippet": "static __always_inline int\nget_map_perf_counter(struct bpf_map *map, u64 flags,\n\t\t     u64 *value, u64 *enabled, u64 *running)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tunsigned int cpu = smp_processor_id();\n\tu64 index = flags & BPF_F_INDEX_MASK;\n\tstruct bpf_event_entry *ee;\n\n\tif (unlikely(flags & ~(BPF_F_INDEX_MASK)))\n\t\treturn -EINVAL;\n\tif (index == BPF_F_CURRENT_CPU)\n\t\tindex = cpu;\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -E2BIG;\n\n\tee = READ_ONCE(array->ptrs[index]);\n\tif (!ee)\n\t\treturn -ENOENT;\n\n\treturn perf_event_read_local(ee->event, value, enabled, running);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_read_local",
          "args": [
            "ee->event",
            "value",
            "enabled",
            "running"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_read_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "3903-3967",
          "snippet": "int perf_event_read_local(struct perf_event *event, u64 *value,\n\t\t\t  u64 *enabled, u64 *running)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\t/*\n\t * Disabling interrupts avoids all counter scheduling (context\n\t * switches, timer based rotation and IPIs).\n\t */\n\tlocal_irq_save(flags);\n\n\t/*\n\t * It must not be an event with inherit set, we cannot read\n\t * all child counters from atomic context.\n\t */\n\tif (event->attr.inherit) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* If this is a per-task event, it must be for current */\n\tif ((event->attach_state & PERF_ATTACH_TASK) &&\n\t    event->hw.target != current) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If this is a per-CPU event, it must be for this CPU */\n\tif (!(event->attach_state & PERF_ATTACH_TASK) &&\n\t    event->cpu != smp_processor_id()) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If this is a pinned event it must be running on this CPU */\n\tif (event->attr.pinned && event->oncpu != smp_processor_id()) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If the event is currently on this CPU, its either a per-task event,\n\t * or local to this CPU. Furthermore it means its ACTIVE (otherwise\n\t * oncpu == -1).\n\t */\n\tif (event->oncpu == smp_processor_id())\n\t\tevent->pmu->read(event);\n\n\t*value = local64_read(&event->count);\n\tif (enabled || running) {\n\t\tu64 now = event->shadow_ctx_time + perf_clock();\n\t\tu64 __enabled, __running;\n\n\t\t__perf_update_times(event, now, &__enabled, &__running);\n\t\tif (enabled)\n\t\t\t*enabled = __enabled;\n\t\tif (running)\n\t\t\t*running = __running;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nint perf_event_read_local(struct perf_event *event, u64 *value,\n\t\t\t  u64 *enabled, u64 *running)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\t/*\n\t * Disabling interrupts avoids all counter scheduling (context\n\t * switches, timer based rotation and IPIs).\n\t */\n\tlocal_irq_save(flags);\n\n\t/*\n\t * It must not be an event with inherit set, we cannot read\n\t * all child counters from atomic context.\n\t */\n\tif (event->attr.inherit) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* If this is a per-task event, it must be for current */\n\tif ((event->attach_state & PERF_ATTACH_TASK) &&\n\t    event->hw.target != current) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If this is a per-CPU event, it must be for this CPU */\n\tif (!(event->attach_state & PERF_ATTACH_TASK) &&\n\t    event->cpu != smp_processor_id()) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If this is a pinned event it must be running on this CPU */\n\tif (event->attr.pinned && event->oncpu != smp_processor_id()) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If the event is currently on this CPU, its either a per-task event,\n\t * or local to this CPU. Furthermore it means its ACTIVE (otherwise\n\t * oncpu == -1).\n\t */\n\tif (event->oncpu == smp_processor_id())\n\t\tevent->pmu->read(event);\n\n\t*value = local64_read(&event->count);\n\tif (enabled || running) {\n\t\tu64 now = event->shadow_ctx_time + perf_clock();\n\t\tu64 __enabled, __running;\n\n\t\t__perf_update_times(event, now, &__enabled, &__running);\n\t\tif (enabled)\n\t\t\t*enabled = __enabled;\n\t\tif (running)\n\t\t\t*running = __running;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "array->ptrs[index]"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & ~(BPF_F_INDEX_MASK)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic __always_inline int\nget_map_perf_counter(struct bpf_map *map, u64 flags,\n\t\t     u64 *value, u64 *enabled, u64 *running)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tunsigned int cpu = smp_processor_id();\n\tu64 index = flags & BPF_F_INDEX_MASK;\n\tstruct bpf_event_entry *ee;\n\n\tif (unlikely(flags & ~(BPF_F_INDEX_MASK)))\n\t\treturn -EINVAL;\n\tif (index == BPF_F_CURRENT_CPU)\n\t\tindex = cpu;\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -E2BIG;\n\n\tee = READ_ONCE(array->ptrs[index]);\n\tif (!ee)\n\t\treturn -ENOENT;\n\n\treturn perf_event_read_local(ee->event, value, enabled, running);\n}"
  },
  {
    "function_name": "bpf_get_trace_printk_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "282-291",
    "snippet": "const struct bpf_func_proto *bpf_get_trace_printk_proto(void)\n{\n\t/*\n\t * this program might be calling bpf_trace_printk,\n\t * so allocate per-cpu printk buffers\n\t */\n\ttrace_printk_init_buffers();\n\n\treturn &bpf_trace_printk_proto;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_trace_printk_proto = {\n\t.func\t\t= bpf_trace_printk,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_printk_init_buffers",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_init_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2842-2880",
          "snippet": "void trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t/* trace_printk() is for debug use only. Don't use it in production. */\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** trace_printk() being used. Allocating extra memory.  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** This means that this is a DEBUG kernel and it is     **\\n\");\n\tpr_warn(\"** unsafe for production use.                           **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** If you see this message and you are not debugging    **\\n\");\n\tpr_warn(\"** the kernel, report this immediately to your vendor!  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\n\t/* Expand the buffers to set size */\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t/*\n\t * trace_printk_init_buffers() can be called by modules.\n\t * If that happens, then we need to start cmdline recording\n\t * directly here. If the global_trace.buffer is already\n\t * allocated here, then this was called by module code.\n\t */\n\tif (global_trace.trace_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static int buffers_allocated;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic int buffers_allocated;\n\nvoid trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t/* trace_printk() is for debug use only. Don't use it in production. */\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** trace_printk() being used. Allocating extra memory.  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** This means that this is a DEBUG kernel and it is     **\\n\");\n\tpr_warn(\"** unsafe for production use.                           **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** If you see this message and you are not debugging    **\\n\");\n\tpr_warn(\"** the kernel, report this immediately to your vendor!  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\n\t/* Expand the buffers to set size */\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t/*\n\t * trace_printk_init_buffers() can be called by modules.\n\t * If that happens, then we need to start cmdline recording\n\t * directly here. If the global_trace.buffer is already\n\t * allocated here, then this was called by module code.\n\t */\n\tif (global_trace.trace_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_trace_printk_proto = {\n\t.func\t\t= bpf_trace_printk,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n};\n\nconst struct bpf_func_proto *bpf_get_trace_printk_proto(void)\n{\n\t/*\n\t * this program might be calling bpf_trace_printk,\n\t * so allocate per-cpu printk buffers\n\t */\n\ttrace_printk_init_buffers();\n\n\treturn &bpf_trace_printk_proto;\n}"
  },
  {
    "function_name": "bpf_get_probe_write_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "151-157",
    "snippet": "static const struct bpf_func_proto *bpf_get_probe_write_proto(void)\n{\n\tpr_warn_ratelimited(\"%s[%d] is installing a program with bpf_probe_write_user helper that may corrupt user memory!\",\n\t\t\t    current->comm, task_pid_nr(current));\n\n\treturn &bpf_probe_write_user_proto;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_probe_write_user_proto = {\n\t.func\t\t= bpf_probe_write_user,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n\t.arg2_type\t= ARG_PTR_TO_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"%s[%d] is installing a program with bpf_probe_write_user helper that may corrupt user memory!\"",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_func_proto bpf_probe_write_user_proto = {\n\t.func\t\t= bpf_probe_write_user,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n\t.arg2_type\t= ARG_PTR_TO_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};\n\nstatic const struct bpf_func_proto *bpf_get_probe_write_proto(void)\n{\n\tpr_warn_ratelimited(\"%s[%d] is installing a program with bpf_probe_write_user helper that may corrupt user memory!\",\n\t\t\t    current->comm, task_pid_nr(current));\n\n\treturn &bpf_probe_write_user_proto;\n}"
  },
  {
    "function_name": "trace_call_bpf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
    "lines": "37-79",
    "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_perf_event.h>",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "bpf_prog_active"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN_ARRAY_CHECK",
          "args": [
            "call->prog_array",
            "ctx",
            "BPF_PROG_RUN"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__this_cpu_inc_return(bpf_prog_active) != 1"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "bpf_prog_active"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}"
  }
]