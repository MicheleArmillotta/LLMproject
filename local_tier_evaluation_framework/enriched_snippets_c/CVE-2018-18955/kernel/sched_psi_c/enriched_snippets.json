[
  {
    "function_name": "psi_proc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "751-758",
    "snippet": "static int __init psi_proc_init(void)\n{\n\tproc_mkdir(\"pressure\", NULL);\n\tproc_create(\"pressure/io\", 0, NULL, &psi_io_fops);\n\tproc_create(\"pressure/memory\", 0, NULL, &psi_memory_fops);\n\tproc_create(\"pressure/cpu\", 0, NULL, &psi_cpu_fops);\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations psi_io_fops = {\n\t.open           = psi_io_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};",
      "static const struct file_operations psi_memory_fops = {\n\t.open           = psi_memory_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};",
      "static const struct file_operations psi_cpu_fops = {\n\t.open           = psi_cpu_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"pressure/cpu\"",
            "0",
            "NULL",
            "&psi_cpu_fops"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"pressure/memory\"",
            "0",
            "NULL",
            "&psi_memory_fops"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"pressure/io\"",
            "0",
            "NULL",
            "&psi_io_fops"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"pressure\"",
            "NULL"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic const struct file_operations psi_io_fops = {\n\t.open           = psi_io_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};\nstatic const struct file_operations psi_memory_fops = {\n\t.open           = psi_memory_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};\nstatic const struct file_operations psi_cpu_fops = {\n\t.open           = psi_cpu_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};\n\nstatic int __init psi_proc_init(void)\n{\n\tproc_mkdir(\"pressure\", NULL);\n\tproc_create(\"pressure/io\", 0, NULL, &psi_io_fops);\n\tproc_create(\"pressure/memory\", 0, NULL, &psi_memory_fops);\n\tproc_create(\"pressure/cpu\", 0, NULL, &psi_cpu_fops);\n\treturn 0;\n}"
  },
  {
    "function_name": "psi_cpu_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "725-728",
    "snippet": "static int psi_cpu_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, psi_cpu_show, NULL);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "psi_cpu_show",
            "NULL"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic int psi_cpu_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, psi_cpu_show, NULL);\n}"
  },
  {
    "function_name": "psi_memory_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "720-723",
    "snippet": "static int psi_memory_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, psi_memory_show, NULL);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "psi_memory_show",
            "NULL"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic int psi_memory_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, psi_memory_show, NULL);\n}"
  },
  {
    "function_name": "psi_io_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "715-718",
    "snippet": "static int psi_io_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, psi_io_show, NULL);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "psi_io_show",
            "NULL"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic int psi_io_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, psi_io_show, NULL);\n}"
  },
  {
    "function_name": "psi_cpu_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "710-713",
    "snippet": "static int psi_cpu_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_CPU);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "m",
            "&psi_system",
            "PSI_CPU"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "psi_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "671-698",
          "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool psi_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic int psi_cpu_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_CPU);\n}"
  },
  {
    "function_name": "psi_memory_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "705-708",
    "snippet": "static int psi_memory_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_MEM);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "m",
            "&psi_system",
            "PSI_MEM"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "psi_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "671-698",
          "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool psi_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic int psi_memory_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_MEM);\n}"
  },
  {
    "function_name": "psi_io_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "700-703",
    "snippet": "static int psi_io_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_IO);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "m",
            "&psi_system",
            "PSI_IO"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "psi_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "671-698",
          "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool psi_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic int psi_io_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_IO);\n}"
  },
  {
    "function_name": "psi_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "671-698",
    "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool psi_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\"",
            "full ? \"full\" : \"some\"",
            "LOAD_INT(avg[0])",
            "LOAD_FRAC(avg[0])",
            "LOAD_INT(avg[1])",
            "LOAD_FRAC(avg[1])",
            "LOAD_INT(avg[2])",
            "LOAD_FRAC(avg[2])",
            "total"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "avg[2]"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "avg[2]"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "avg[1]"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "avg[1]"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "avg[0]"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "avg[0]"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "group->total[res * 2 + full]",
            "NSEC_PER_USEC"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stats",
          "args": [
            "group"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "update_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "259-355",
          "snippet": "static bool update_stats(struct psi_group *group)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long missed_periods = 0;\n\tunsigned long nonidle_total = 0;\n\tu64 now, expires, period;\n\tint cpu;\n\tint s;\n\n\tmutex_lock(&group->stat_lock);\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\n\t\tget_recent_times(group, cpu, times);\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[s] += div_u64(deltas[s], max(nonidle_total, 1UL));\n\n\t/* avgX= */\n\tnow = sched_clock();\n\texpires = group->next_update;\n\tif (now < expires)\n\t\tgoto out;\n\tif (now - expires > psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tgroup->next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->last_update + (missed_periods * psi_period));\n\tgroup->last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[s] - group->total_prev[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->total_prev[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\nout:\n\tmutex_unlock(&group->stat_lock);\n\treturn nonidle_total;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [
            "static u64 psi_period"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic u64 psi_period;\n\nstatic bool update_stats(struct psi_group *group)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long missed_periods = 0;\n\tunsigned long nonidle_total = 0;\n\tu64 now, expires, period;\n\tint cpu;\n\tint s;\n\n\tmutex_lock(&group->stat_lock);\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\n\t\tget_recent_times(group, cpu, times);\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[s] += div_u64(deltas[s], max(nonidle_total, 1UL));\n\n\t/* avgX= */\n\tnow = sched_clock();\n\texpires = group->next_update;\n\tif (now < expires)\n\t\tgoto out;\n\tif (now - expires > psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tgroup->next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->last_update + (missed_periods * psi_period));\n\tgroup->last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[s] - group->total_prev[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->total_prev[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\nout:\n\tmutex_unlock(&group->stat_lock);\n\treturn nonidle_total;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_move_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "634-668",
    "snippet": "void cgroup_move_task(struct task_struct *task, struct css_set *to)\n{\n\tbool move_psi = !psi_disabled;\n\tunsigned int task_flags = 0;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (move_psi) {\n\t\trq = task_rq_lock(task, &rf);\n\n\t\tif (task_on_rq_queued(task))\n\t\t\ttask_flags = TSK_RUNNING;\n\t\telse if (task->in_iowait)\n\t\t\ttask_flags = TSK_IOWAIT;\n\n\t\tif (task->flags & PF_MEMSTALL)\n\t\t\ttask_flags |= TSK_MEMSTALL;\n\n\t\tif (task_flags)\n\t\t\tpsi_task_change(task, task_flags, 0);\n\t}\n\n\t/*\n\t * Lame to do this here, but the scheduler cannot be locked\n\t * from the outside, so we move cgroups from inside sched/.\n\t */\n\trcu_assign_pointer(task->cgroups, to);\n\n\tif (move_psi) {\n\t\tif (task_flags)\n\t\t\tpsi_task_change(task, 0, task_flags);\n\n\t\ttask_rq_unlock(rq, task, &rf);\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool psi_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "task",
            "&rf"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_task_change",
          "args": [
            "task",
            "0",
            "task_flags"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "psi_task_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "500-523",
          "snippet": "void psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, cpu,\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nvoid psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, cpu,\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "task->cgroups",
            "to"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "task"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "task",
            "&rf"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nvoid cgroup_move_task(struct task_struct *task, struct css_set *to)\n{\n\tbool move_psi = !psi_disabled;\n\tunsigned int task_flags = 0;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (move_psi) {\n\t\trq = task_rq_lock(task, &rf);\n\n\t\tif (task_on_rq_queued(task))\n\t\t\ttask_flags = TSK_RUNNING;\n\t\telse if (task->in_iowait)\n\t\t\ttask_flags = TSK_IOWAIT;\n\n\t\tif (task->flags & PF_MEMSTALL)\n\t\t\ttask_flags |= TSK_MEMSTALL;\n\n\t\tif (task_flags)\n\t\t\tpsi_task_change(task, task_flags, 0);\n\t}\n\n\t/*\n\t * Lame to do this here, but the scheduler cannot be locked\n\t * from the outside, so we move cgroups from inside sched/.\n\t */\n\trcu_assign_pointer(task->cgroups, to);\n\n\tif (move_psi) {\n\t\tif (task_flags)\n\t\t\tpsi_task_change(task, 0, task_flags);\n\n\t\ttask_rq_unlock(rq, task, &rf);\n\t}\n}"
  },
  {
    "function_name": "psi_cgroup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "613-620",
    "snippet": "void psi_cgroup_free(struct cgroup *cgroup)\n{\n\tif (psi_disabled)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&cgroup->psi.clock_work);\n\tfree_percpu(cgroup->psi.pcpu);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool psi_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cgroup->psi.pcpu"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&cgroup->psi.clock_work"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_delayed_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3134-3137",
          "snippet": "bool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nvoid psi_cgroup_free(struct cgroup *cgroup)\n{\n\tif (psi_disabled)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&cgroup->psi.clock_work);\n\tfree_percpu(cgroup->psi.pcpu);\n}"
  },
  {
    "function_name": "psi_cgroup_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "601-611",
    "snippet": "int psi_cgroup_alloc(struct cgroup *cgroup)\n{\n\tif (psi_disabled)\n\t\treturn 0;\n\n\tcgroup->psi.pcpu = alloc_percpu(struct psi_group_cpu);\n\tif (!cgroup->psi.pcpu)\n\t\treturn -ENOMEM;\n\tgroup_init(&cgroup->psi);\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool psi_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "group_init",
          "args": [
            "&cgroup->psi"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "group_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "159-168",
          "snippet": "static void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->next_update = sched_clock() + psi_period;\n\tINIT_DELAYED_WORK(&group->clock_work, psi_update_work);\n\tmutex_init(&group->stat_lock);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 psi_period"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic u64 psi_period;\n\nstatic void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->next_update = sched_clock() + psi_period;\n\tINIT_DELAYED_WORK(&group->clock_work, psi_update_work);\n\tmutex_init(&group->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structpsi_group_cpu"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nint psi_cgroup_alloc(struct cgroup *cgroup)\n{\n\tif (psi_disabled)\n\t\treturn 0;\n\n\tcgroup->psi.pcpu = alloc_percpu(struct psi_group_cpu);\n\tif (!cgroup->psi.pcpu)\n\t\treturn -ENOMEM;\n\tgroup_init(&cgroup->psi);\n\treturn 0;\n}"
  },
  {
    "function_name": "psi_memstall_leave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "577-598",
    "snippet": "void psi_memstall_leave(unsigned long *flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (psi_disabled)\n\t\treturn;\n\n\tif (*flags)\n\t\treturn;\n\t/*\n\t * PF_MEMSTALL clearing & accounting needs to be atomic wrt\n\t * changes to the task's scheduling state, otherwise we could\n\t * race with CPU migration.\n\t */\n\trq = this_rq_lock_irq(&rf);\n\n\tcurrent->flags &= ~PF_MEMSTALL;\n\tpsi_task_change(current, TSK_MEMSTALL, 0);\n\n\trq_unlock_irq(rq, &rf);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool psi_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unlock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1146-1152",
          "snippet": "static inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_task_change",
          "args": [
            "current",
            "TSK_MEMSTALL",
            "0"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "psi_task_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "500-523",
          "snippet": "void psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, cpu,\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nvoid psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, cpu,\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq_lock_irq",
          "args": [
            "&rf"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "this_rq_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1162-1172",
          "snippet": "static inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nvoid psi_memstall_leave(unsigned long *flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (psi_disabled)\n\t\treturn;\n\n\tif (*flags)\n\t\treturn;\n\t/*\n\t * PF_MEMSTALL clearing & accounting needs to be atomic wrt\n\t * changes to the task's scheduling state, otherwise we could\n\t * race with CPU migration.\n\t */\n\trq = this_rq_lock_irq(&rf);\n\n\tcurrent->flags &= ~PF_MEMSTALL;\n\tpsi_task_change(current, TSK_MEMSTALL, 0);\n\n\trq_unlock_irq(rq, &rf);\n}"
  },
  {
    "function_name": "psi_memstall_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "547-569",
    "snippet": "void psi_memstall_enter(unsigned long *flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (psi_disabled)\n\t\treturn;\n\n\t*flags = current->flags & PF_MEMSTALL;\n\tif (*flags)\n\t\treturn;\n\t/*\n\t * PF_MEMSTALL setting & accounting needs to be atomic wrt\n\t * changes to the task's scheduling state, otherwise we can\n\t * race with CPU migration.\n\t */\n\trq = this_rq_lock_irq(&rf);\n\n\tcurrent->flags |= PF_MEMSTALL;\n\tpsi_task_change(current, 0, TSK_MEMSTALL);\n\n\trq_unlock_irq(rq, &rf);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool psi_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unlock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1146-1152",
          "snippet": "static inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_task_change",
          "args": [
            "current",
            "0",
            "TSK_MEMSTALL"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "psi_task_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "500-523",
          "snippet": "void psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, cpu,\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nvoid psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, cpu,\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq_lock_irq",
          "args": [
            "&rf"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "this_rq_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1162-1172",
          "snippet": "static inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nvoid psi_memstall_enter(unsigned long *flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (psi_disabled)\n\t\treturn;\n\n\t*flags = current->flags & PF_MEMSTALL;\n\tif (*flags)\n\t\treturn;\n\t/*\n\t * PF_MEMSTALL setting & accounting needs to be atomic wrt\n\t * changes to the task's scheduling state, otherwise we can\n\t * race with CPU migration.\n\t */\n\trq = this_rq_lock_irq(&rf);\n\n\tcurrent->flags |= PF_MEMSTALL;\n\tpsi_task_change(current, 0, TSK_MEMSTALL);\n\n\trq_unlock_irq(rq, &rf);\n}"
  },
  {
    "function_name": "psi_memstall_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "525-538",
    "snippet": "void psi_memstall_tick(struct task_struct *task, int cpu)\n{\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\twhile ((group = iterate_groups(task, &iter))) {\n\t\tstruct psi_group_cpu *groupc;\n\n\t\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\t\twrite_seqcount_begin(&groupc->seq);\n\t\trecord_times(groupc, cpu, true);\n\t\twrite_seqcount_end(&groupc->seq);\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&groupc->seq"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_times",
          "args": [
            "groupc",
            "cpu",
            "true"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "record_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "387-431",
          "snippet": "static void record_times(struct psi_group_cpu *groupc, int cpu,\n\t\t\t bool memstall_tick)\n{\n\tu32 delta;\n\tu64 now;\n\n\tnow = cpu_clock(cpu);\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (test_state(groupc->tasks, PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (test_state(groupc->tasks, PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t\telse if (memstall_tick) {\n\t\t\tu32 sample;\n\t\t\t/*\n\t\t\t * Since we care about lost potential, a\n\t\t\t * memstall is FULL when there are no other\n\t\t\t * working tasks, but also when the CPU is\n\t\t\t * actively reclaiming and nothing productive\n\t\t\t * could run even if it were runnable.\n\t\t\t *\n\t\t\t * When the timer tick sees a reclaiming CPU,\n\t\t\t * regardless of runnable tasks, sample a FULL\n\t\t\t * tick (or less if it hasn't been a full tick\n\t\t\t * since the last state change).\n\t\t\t */\n\t\t\tsample = min(delta, (u32)jiffies_to_nsecs(1));\n\t\t\tgroupc->times[PSI_MEM_FULL] += sample;\n\t\t}\n\t}\n\n\tif (test_state(groupc->tasks, PSI_CPU_SOME))\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\n\tif (test_state(groupc->tasks, PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic void record_times(struct psi_group_cpu *groupc, int cpu,\n\t\t\t bool memstall_tick)\n{\n\tu32 delta;\n\tu64 now;\n\n\tnow = cpu_clock(cpu);\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (test_state(groupc->tasks, PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (test_state(groupc->tasks, PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t\telse if (memstall_tick) {\n\t\t\tu32 sample;\n\t\t\t/*\n\t\t\t * Since we care about lost potential, a\n\t\t\t * memstall is FULL when there are no other\n\t\t\t * working tasks, but also when the CPU is\n\t\t\t * actively reclaiming and nothing productive\n\t\t\t * could run even if it were runnable.\n\t\t\t *\n\t\t\t * When the timer tick sees a reclaiming CPU,\n\t\t\t * regardless of runnable tasks, sample a FULL\n\t\t\t * tick (or less if it hasn't been a full tick\n\t\t\t * since the last state change).\n\t\t\t */\n\t\t\tsample = min(delta, (u32)jiffies_to_nsecs(1));\n\t\t\tgroupc->times[PSI_MEM_FULL] += sample;\n\t\t}\n\t}\n\n\tif (test_state(groupc->tasks, PSI_CPU_SOME))\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\n\tif (test_state(groupc->tasks, PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&groupc->seq"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "group->pcpu",
            "cpu"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_groups",
          "args": [
            "task",
            "&iter"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "476-498",
          "snippet": "static struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n#ifdef CONFIG_CGROUPS\n\tstruct cgroup *cgroup = NULL;\n\n\tif (!*iter)\n\t\tcgroup = task->cgroups->dfl_cgrp;\n\telse if (*iter == &psi_system)\n\t\treturn NULL;\n\telse\n\t\tcgroup = cgroup_parent(*iter);\n\n\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t*iter = cgroup;\n\t\treturn cgroup_psi(cgroup);\n\t}\n#else\n\tif (*iter)\n\t\treturn NULL;\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n#ifdef CONFIG_CGROUPS\n\tstruct cgroup *cgroup = NULL;\n\n\tif (!*iter)\n\t\tcgroup = task->cgroups->dfl_cgrp;\n\telse if (*iter == &psi_system)\n\t\treturn NULL;\n\telse\n\t\tcgroup = cgroup_parent(*iter);\n\n\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t*iter = cgroup;\n\t\treturn cgroup_psi(cgroup);\n\t}\n#else\n\tif (*iter)\n\t\treturn NULL;\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nvoid psi_memstall_tick(struct task_struct *task, int cpu)\n{\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\twhile ((group = iterate_groups(task, &iter))) {\n\t\tstruct psi_group_cpu *groupc;\n\n\t\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\t\twrite_seqcount_begin(&groupc->seq);\n\t\trecord_times(groupc, cpu, true);\n\t\twrite_seqcount_end(&groupc->seq);\n\t}\n}"
  },
  {
    "function_name": "psi_task_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "500-523",
    "snippet": "void psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, cpu,\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_group_change",
          "args": [
            "group",
            "cpu",
            "clear",
            "set"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "psi_group_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "433-474",
          "snippet": "static void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set)\n{\n\tstruct psi_group_cpu *groupc;\n\tunsigned int t, m;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, cpu, false);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t] == 0 && !psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t\tgroupc->tasks[t]--;\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (!delayed_work_pending(&group->clock_work))\n\t\tschedule_delayed_work(&group->clock_work, PSI_FREQ);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set)\n{\n\tstruct psi_group_cpu *groupc;\n\tunsigned int t, m;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, cpu, false);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t] == 0 && !psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t\tgroupc->tasks[t]--;\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (!delayed_work_pending(&group->clock_work))\n\t\tschedule_delayed_work(&group->clock_work, PSI_FREQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_groups",
          "args": [
            "task",
            "&iter"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "476-498",
          "snippet": "static struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n#ifdef CONFIG_CGROUPS\n\tstruct cgroup *cgroup = NULL;\n\n\tif (!*iter)\n\t\tcgroup = task->cgroups->dfl_cgrp;\n\telse if (*iter == &psi_system)\n\t\treturn NULL;\n\telse\n\t\tcgroup = cgroup_parent(*iter);\n\n\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t*iter = cgroup;\n\t\treturn cgroup_psi(cgroup);\n\t}\n#else\n\tif (*iter)\n\t\treturn NULL;\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n#ifdef CONFIG_CGROUPS\n\tstruct cgroup *cgroup = NULL;\n\n\tif (!*iter)\n\t\tcgroup = task->cgroups->dfl_cgrp;\n\telse if (*iter == &psi_system)\n\t\treturn NULL;\n\telse\n\t\tcgroup = cgroup_parent(*iter);\n\n\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t*iter = cgroup;\n\t\treturn cgroup_psi(cgroup);\n\t}\n#else\n\tif (*iter)\n\t\treturn NULL;\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\"",
            "task->pid",
            "task->comm",
            "cpu",
            "task->psi_flags",
            "clear",
            "set"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "task"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nvoid psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tvoid *iter = NULL;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, cpu,\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set);\n}"
  },
  {
    "function_name": "iterate_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "476-498",
    "snippet": "static struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n#ifdef CONFIG_CGROUPS\n\tstruct cgroup *cgroup = NULL;\n\n\tif (!*iter)\n\t\tcgroup = task->cgroups->dfl_cgrp;\n\telse if (*iter == &psi_system)\n\t\treturn NULL;\n\telse\n\t\tcgroup = cgroup_parent(*iter);\n\n\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t*iter = cgroup;\n\t\treturn cgroup_psi(cgroup);\n\t}\n#else\n\tif (*iter)\n\t\treturn NULL;\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_psi",
          "args": [
            "cgroup"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgroup"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "*iter"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n#ifdef CONFIG_CGROUPS\n\tstruct cgroup *cgroup = NULL;\n\n\tif (!*iter)\n\t\tcgroup = task->cgroups->dfl_cgrp;\n\telse if (*iter == &psi_system)\n\t\treturn NULL;\n\telse\n\t\tcgroup = cgroup_parent(*iter);\n\n\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t*iter = cgroup;\n\t\treturn cgroup_psi(cgroup);\n\t}\n#else\n\tif (*iter)\n\t\treturn NULL;\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}"
  },
  {
    "function_name": "psi_group_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "433-474",
    "snippet": "static void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set)\n{\n\tstruct psi_group_cpu *groupc;\n\tunsigned int t, m;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, cpu, false);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t] == 0 && !psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t\tgroupc->tasks[t]--;\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (!delayed_work_pending(&group->clock_work))\n\t\tschedule_delayed_work(&group->clock_work, PSI_FREQ);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [
      "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&group->clock_work",
            "PSI_FREQ"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayed_work_pending",
          "args": [
            "&group->clock_work"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&groupc->seq"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\"",
            "cpu",
            "t",
            "groupc->tasks[0]",
            "groupc->tasks[1]",
            "groupc->tasks[2]",
            "clear",
            "set"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_times",
          "args": [
            "groupc",
            "cpu",
            "false"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "record_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "387-431",
          "snippet": "static void record_times(struct psi_group_cpu *groupc, int cpu,\n\t\t\t bool memstall_tick)\n{\n\tu32 delta;\n\tu64 now;\n\n\tnow = cpu_clock(cpu);\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (test_state(groupc->tasks, PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (test_state(groupc->tasks, PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t\telse if (memstall_tick) {\n\t\t\tu32 sample;\n\t\t\t/*\n\t\t\t * Since we care about lost potential, a\n\t\t\t * memstall is FULL when there are no other\n\t\t\t * working tasks, but also when the CPU is\n\t\t\t * actively reclaiming and nothing productive\n\t\t\t * could run even if it were runnable.\n\t\t\t *\n\t\t\t * When the timer tick sees a reclaiming CPU,\n\t\t\t * regardless of runnable tasks, sample a FULL\n\t\t\t * tick (or less if it hasn't been a full tick\n\t\t\t * since the last state change).\n\t\t\t */\n\t\t\tsample = min(delta, (u32)jiffies_to_nsecs(1));\n\t\t\tgroupc->times[PSI_MEM_FULL] += sample;\n\t\t}\n\t}\n\n\tif (test_state(groupc->tasks, PSI_CPU_SOME))\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\n\tif (test_state(groupc->tasks, PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic void record_times(struct psi_group_cpu *groupc, int cpu,\n\t\t\t bool memstall_tick)\n{\n\tu32 delta;\n\tu64 now;\n\n\tnow = cpu_clock(cpu);\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (test_state(groupc->tasks, PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (test_state(groupc->tasks, PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t\telse if (memstall_tick) {\n\t\t\tu32 sample;\n\t\t\t/*\n\t\t\t * Since we care about lost potential, a\n\t\t\t * memstall is FULL when there are no other\n\t\t\t * working tasks, but also when the CPU is\n\t\t\t * actively reclaiming and nothing productive\n\t\t\t * could run even if it were runnable.\n\t\t\t *\n\t\t\t * When the timer tick sees a reclaiming CPU,\n\t\t\t * regardless of runnable tasks, sample a FULL\n\t\t\t * tick (or less if it hasn't been a full tick\n\t\t\t * since the last state change).\n\t\t\t */\n\t\t\tsample = min(delta, (u32)jiffies_to_nsecs(1));\n\t\t\tgroupc->times[PSI_MEM_FULL] += sample;\n\t\t}\n\t}\n\n\tif (test_state(groupc->tasks, PSI_CPU_SOME))\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\n\tif (test_state(groupc->tasks, PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&groupc->seq"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "group->pcpu",
            "cpu"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set)\n{\n\tstruct psi_group_cpu *groupc;\n\tunsigned int t, m;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, cpu, false);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t] == 0 && !psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t\tgroupc->tasks[t]--;\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (!delayed_work_pending(&group->clock_work))\n\t\tschedule_delayed_work(&group->clock_work, PSI_FREQ);\n}"
  },
  {
    "function_name": "record_times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "387-431",
    "snippet": "static void record_times(struct psi_group_cpu *groupc, int cpu,\n\t\t\t bool memstall_tick)\n{\n\tu32 delta;\n\tu64 now;\n\n\tnow = cpu_clock(cpu);\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (test_state(groupc->tasks, PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (test_state(groupc->tasks, PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t\telse if (memstall_tick) {\n\t\t\tu32 sample;\n\t\t\t/*\n\t\t\t * Since we care about lost potential, a\n\t\t\t * memstall is FULL when there are no other\n\t\t\t * working tasks, but also when the CPU is\n\t\t\t * actively reclaiming and nothing productive\n\t\t\t * could run even if it were runnable.\n\t\t\t *\n\t\t\t * When the timer tick sees a reclaiming CPU,\n\t\t\t * regardless of runnable tasks, sample a FULL\n\t\t\t * tick (or less if it hasn't been a full tick\n\t\t\t * since the last state change).\n\t\t\t */\n\t\t\tsample = min(delta, (u32)jiffies_to_nsecs(1));\n\t\t\tgroupc->times[PSI_MEM_FULL] += sample;\n\t\t}\n\t}\n\n\tif (test_state(groupc->tasks, PSI_CPU_SOME))\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\n\tif (test_state(groupc->tasks, PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_state",
          "args": [
            "groupc->tasks",
            "PSI_NONIDLE"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "test_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "179-198",
          "snippet": "static bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn tasks[NR_IOWAIT];\n\tcase PSI_IO_FULL:\n\t\treturn tasks[NR_IOWAIT] && !tasks[NR_RUNNING];\n\tcase PSI_MEM_SOME:\n\t\treturn tasks[NR_MEMSTALL];\n\tcase PSI_MEM_FULL:\n\t\treturn tasks[NR_MEMSTALL] && !tasks[NR_RUNNING];\n\tcase PSI_CPU_SOME:\n\t\treturn tasks[NR_RUNNING] > 1;\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn tasks[NR_IOWAIT];\n\tcase PSI_IO_FULL:\n\t\treturn tasks[NR_IOWAIT] && !tasks[NR_RUNNING];\n\tcase PSI_MEM_SOME:\n\t\treturn tasks[NR_MEMSTALL];\n\tcase PSI_MEM_FULL:\n\t\treturn tasks[NR_MEMSTALL] && !tasks[NR_RUNNING];\n\tcase PSI_CPU_SOME:\n\t\treturn tasks[NR_RUNNING] > 1;\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "delta",
            "(u32)jiffies_to_nsecs(1)"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "248-251",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_nsecs",
          "args": [
            "1"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_clock",
          "args": [
            "cpu"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "9268-9285",
          "snippet": "static int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic DEVICE_ATTR_RO(type);\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic void record_times(struct psi_group_cpu *groupc, int cpu,\n\t\t\t bool memstall_tick)\n{\n\tu32 delta;\n\tu64 now;\n\n\tnow = cpu_clock(cpu);\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (test_state(groupc->tasks, PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (test_state(groupc->tasks, PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (test_state(groupc->tasks, PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t\telse if (memstall_tick) {\n\t\t\tu32 sample;\n\t\t\t/*\n\t\t\t * Since we care about lost potential, a\n\t\t\t * memstall is FULL when there are no other\n\t\t\t * working tasks, but also when the CPU is\n\t\t\t * actively reclaiming and nothing productive\n\t\t\t * could run even if it were runnable.\n\t\t\t *\n\t\t\t * When the timer tick sees a reclaiming CPU,\n\t\t\t * regardless of runnable tasks, sample a FULL\n\t\t\t * tick (or less if it hasn't been a full tick\n\t\t\t * since the last state change).\n\t\t\t */\n\t\t\tsample = min(delta, (u32)jiffies_to_nsecs(1));\n\t\t\tgroupc->times[PSI_MEM_FULL] += sample;\n\t\t}\n\t}\n\n\tif (test_state(groupc->tasks, PSI_CPU_SOME))\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\n\tif (test_state(groupc->tasks, PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}"
  },
  {
    "function_name": "psi_update_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "357-385",
    "snippet": "static void psi_update_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct psi_group *group;\n\tbool nonidle;\n\n\tdwork = to_delayed_work(work);\n\tgroup = container_of(dwork, struct psi_group, clock_work);\n\n\t/*\n\t * If there is task activity, periodically fold the per-cpu\n\t * times and feed samples into the running averages. If things\n\t * are idle and there is no data to process, stop the clock.\n\t * Once restarted, we'll catch up the running averages in one\n\t * go - see calc_avgs() and missed_periods.\n\t */\n\n\tnonidle = update_stats(group);\n\n\tif (nonidle) {\n\t\tunsigned long delay = 0;\n\t\tu64 now;\n\n\t\tnow = sched_clock();\n\t\tif (group->next_update > now)\n\t\t\tdelay = nsecs_to_jiffies(group->next_update - now) + 1;\n\t\tschedule_delayed_work(dwork, delay);\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void psi_update_work(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "dwork",
            "delay"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsecs_to_jiffies",
          "args": [
            "group->next_update - now"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "nsecs_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "805-808",
          "snippet": "unsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_stats",
          "args": [
            "group"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "update_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "259-355",
          "snippet": "static bool update_stats(struct psi_group *group)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long missed_periods = 0;\n\tunsigned long nonidle_total = 0;\n\tu64 now, expires, period;\n\tint cpu;\n\tint s;\n\n\tmutex_lock(&group->stat_lock);\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\n\t\tget_recent_times(group, cpu, times);\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[s] += div_u64(deltas[s], max(nonidle_total, 1UL));\n\n\t/* avgX= */\n\tnow = sched_clock();\n\texpires = group->next_update;\n\tif (now < expires)\n\t\tgoto out;\n\tif (now - expires > psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tgroup->next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->last_update + (missed_periods * psi_period));\n\tgroup->last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[s] - group->total_prev[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->total_prev[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\nout:\n\tmutex_unlock(&group->stat_lock);\n\treturn nonidle_total;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [
            "static u64 psi_period"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic u64 psi_period;\n\nstatic bool update_stats(struct psi_group *group)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long missed_periods = 0;\n\tunsigned long nonidle_total = 0;\n\tu64 now, expires, period;\n\tint cpu;\n\tint s;\n\n\tmutex_lock(&group->stat_lock);\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\n\t\tget_recent_times(group, cpu, times);\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[s] += div_u64(deltas[s], max(nonidle_total, 1UL));\n\n\t/* avgX= */\n\tnow = sched_clock();\n\texpires = group->next_update;\n\tif (now < expires)\n\t\tgoto out;\n\tif (now - expires > psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tgroup->next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->last_update + (missed_periods * psi_period));\n\tgroup->last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[s] - group->total_prev[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->total_prev[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\nout:\n\tmutex_unlock(&group->stat_lock);\n\treturn nonidle_total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dwork",
            "structpsi_group",
            "clock_work"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic void psi_update_work(struct work_struct *work);\n\nstatic void psi_update_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct psi_group *group;\n\tbool nonidle;\n\n\tdwork = to_delayed_work(work);\n\tgroup = container_of(dwork, struct psi_group, clock_work);\n\n\t/*\n\t * If there is task activity, periodically fold the per-cpu\n\t * times and feed samples into the running averages. If things\n\t * are idle and there is no data to process, stop the clock.\n\t * Once restarted, we'll catch up the running averages in one\n\t * go - see calc_avgs() and missed_periods.\n\t */\n\n\tnonidle = update_stats(group);\n\n\tif (nonidle) {\n\t\tunsigned long delay = 0;\n\t\tu64 now;\n\n\t\tnow = sched_clock();\n\t\tif (group->next_update > now)\n\t\t\tdelay = nsecs_to_jiffies(group->next_update - now) + 1;\n\t\tschedule_delayed_work(dwork, delay);\n\t}\n}"
  },
  {
    "function_name": "update_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "259-355",
    "snippet": "static bool update_stats(struct psi_group *group)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long missed_periods = 0;\n\tunsigned long nonidle_total = 0;\n\tu64 now, expires, period;\n\tint cpu;\n\tint s;\n\n\tmutex_lock(&group->stat_lock);\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\n\t\tget_recent_times(group, cpu, times);\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[s] += div_u64(deltas[s], max(nonidle_total, 1UL));\n\n\t/* avgX= */\n\tnow = sched_clock();\n\texpires = group->next_update;\n\tif (now < expires)\n\t\tgoto out;\n\tif (now - expires > psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tgroup->next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->last_update + (missed_periods * psi_period));\n\tgroup->last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[s] - group->total_prev[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->total_prev[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\nout:\n\tmutex_unlock(&group->stat_lock);\n\treturn nonidle_total;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [
      "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
    ],
    "globals_used": [
      "static u64 psi_period"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->stat_lock"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_avgs",
          "args": [
            "group->avg[s]",
            "missed_periods",
            "sample",
            "period"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "calc_avgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "239-257",
          "snippet": "static void calc_avgs(unsigned long avg[3], int missed_periods,\n\t\t      u64 time, u64 period)\n{\n\tunsigned long pct;\n\n\t/* Fill in zeroes for periods of no activity */\n\tif (missed_periods) {\n\t\tavg[0] = calc_load_n(avg[0], EXP_10s, 0, missed_periods);\n\t\tavg[1] = calc_load_n(avg[1], EXP_60s, 0, missed_periods);\n\t\tavg[2] = calc_load_n(avg[2], EXP_300s, 0, missed_periods);\n\t}\n\n\t/* Sample the most recent active period */\n\tpct = div_u64(time * 100, period);\n\tpct *= FIXED_1;\n\tavg[0] = calc_load(avg[0], EXP_10s, pct);\n\tavg[1] = calc_load(avg[1], EXP_60s, pct);\n\tavg[2] = calc_load(avg[2], EXP_300s, pct);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [
            "#define EXP_300s\t2034\t\t/* 1/exp(2s/300s) */",
            "#define EXP_60s\t\t1981\t\t/* 1/exp(2s/60s) */",
            "#define EXP_10s\t\t1677\t\t/* 1/exp(2s/10s) as fixed-point */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define EXP_300s\t2034\t\t/* 1/exp(2s/300s) */\n#define EXP_60s\t\t1981\t\t/* 1/exp(2s/60s) */\n#define EXP_10s\t\t1677\t\t/* 1/exp(2s/10s) as fixed-point */\n\nstatic void calc_avgs(unsigned long avg[3], int missed_periods,\n\t\t      u64 time, u64 period)\n{\n\tunsigned long pct;\n\n\t/* Fill in zeroes for periods of no activity */\n\tif (missed_periods) {\n\t\tavg[0] = calc_load_n(avg[0], EXP_10s, 0, missed_periods);\n\t\tavg[1] = calc_load_n(avg[1], EXP_60s, 0, missed_periods);\n\t\tavg[2] = calc_load_n(avg[2], EXP_300s, 0, missed_periods);\n\t}\n\n\t/* Sample the most recent active period */\n\tpct = div_u64(time * 100, period);\n\tpct *= FIXED_1;\n\tavg[0] = calc_load(avg[0], EXP_10s, pct);\n\tavg[1] = calc_load(avg[1], EXP_60s, pct);\n\tavg[2] = calc_load(avg[2], EXP_300s, pct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "now - expires",
            "psi_period"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "deltas[s]",
            "max(nonidle_total, 1UL)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nonidle_total",
            "1UL"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "253-256",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsecs_to_jiffies",
          "args": [
            "times[PSI_NONIDLE]"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "nsecs_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "805-808",
          "snippet": "unsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_recent_times",
          "args": [
            "group",
            "cpu",
            "times"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "get_recent_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "200-237",
          "snippet": "static void get_recent_times(struct psi_group *group, int cpu, u32 *times)\n{\n\tstruct psi_group_cpu *groupc = per_cpu_ptr(group->pcpu, cpu);\n\tunsigned int tasks[NR_PSI_TASK_COUNTS];\n\tu64 now, state_start;\n\tunsigned int seq;\n\tint s;\n\n\t/* Snapshot a coherent view of the CPU state */\n\tdo {\n\t\tseq = read_seqcount_begin(&groupc->seq);\n\t\tnow = cpu_clock(cpu);\n\t\tmemcpy(times, groupc->times, sizeof(groupc->times));\n\t\tmemcpy(tasks, groupc->tasks, sizeof(groupc->tasks));\n\t\tstate_start = groupc->state_start;\n\t} while (read_seqcount_retry(&groupc->seq, seq));\n\n\t/* Calculate state time deltas against the previous snapshot */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tu32 delta;\n\t\t/*\n\t\t * In addition to already concluded states, we also\n\t\t * incorporate currently active states on the CPU,\n\t\t * since states may last for many sampling periods.\n\t\t *\n\t\t * This way we keep our delta sampling buckets small\n\t\t * (u32) and our reported pressure close to what's\n\t\t * actually happening.\n\t\t */\n\t\tif (test_state(tasks, s))\n\t\t\ttimes[s] += now - state_start;\n\n\t\tdelta = times[s] - groupc->times_prev[s];\n\t\tgroupc->times_prev[s] = times[s];\n\n\t\ttimes[s] = delta;\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic void get_recent_times(struct psi_group *group, int cpu, u32 *times)\n{\n\tstruct psi_group_cpu *groupc = per_cpu_ptr(group->pcpu, cpu);\n\tunsigned int tasks[NR_PSI_TASK_COUNTS];\n\tu64 now, state_start;\n\tunsigned int seq;\n\tint s;\n\n\t/* Snapshot a coherent view of the CPU state */\n\tdo {\n\t\tseq = read_seqcount_begin(&groupc->seq);\n\t\tnow = cpu_clock(cpu);\n\t\tmemcpy(times, groupc->times, sizeof(groupc->times));\n\t\tmemcpy(tasks, groupc->tasks, sizeof(groupc->tasks));\n\t\tstate_start = groupc->state_start;\n\t} while (read_seqcount_retry(&groupc->seq, seq));\n\n\t/* Calculate state time deltas against the previous snapshot */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tu32 delta;\n\t\t/*\n\t\t * In addition to already concluded states, we also\n\t\t * incorporate currently active states on the CPU,\n\t\t * since states may last for many sampling periods.\n\t\t *\n\t\t * This way we keep our delta sampling buckets small\n\t\t * (u32) and our reported pressure close to what's\n\t\t * actually happening.\n\t\t */\n\t\tif (test_state(tasks, s))\n\t\t\ttimes[s] += now - state_start;\n\n\t\tdelta = times[s] - groupc->times_prev[s];\n\t\tgroupc->times_prev[s] = times[s];\n\n\t\ttimes[s] = delta;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->stat_lock"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic u64 psi_period;\n\nstatic bool update_stats(struct psi_group *group)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long missed_periods = 0;\n\tunsigned long nonidle_total = 0;\n\tu64 now, expires, period;\n\tint cpu;\n\tint s;\n\n\tmutex_lock(&group->stat_lock);\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\n\t\tget_recent_times(group, cpu, times);\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[s] += div_u64(deltas[s], max(nonidle_total, 1UL));\n\n\t/* avgX= */\n\tnow = sched_clock();\n\texpires = group->next_update;\n\tif (now < expires)\n\t\tgoto out;\n\tif (now - expires > psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tgroup->next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->last_update + (missed_periods * psi_period));\n\tgroup->last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[s] - group->total_prev[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->total_prev[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\nout:\n\tmutex_unlock(&group->stat_lock);\n\treturn nonidle_total;\n}"
  },
  {
    "function_name": "calc_avgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "239-257",
    "snippet": "static void calc_avgs(unsigned long avg[3], int missed_periods,\n\t\t      u64 time, u64 period)\n{\n\tunsigned long pct;\n\n\t/* Fill in zeroes for periods of no activity */\n\tif (missed_periods) {\n\t\tavg[0] = calc_load_n(avg[0], EXP_10s, 0, missed_periods);\n\t\tavg[1] = calc_load_n(avg[1], EXP_60s, 0, missed_periods);\n\t\tavg[2] = calc_load_n(avg[2], EXP_300s, 0, missed_periods);\n\t}\n\n\t/* Sample the most recent active period */\n\tpct = div_u64(time * 100, period);\n\tpct *= FIXED_1;\n\tavg[0] = calc_load(avg[0], EXP_10s, pct);\n\tavg[1] = calc_load(avg[1], EXP_60s, pct);\n\tavg[2] = calc_load(avg[2], EXP_300s, pct);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [
      "#define EXP_300s\t2034\t\t/* 1/exp(2s/300s) */",
      "#define EXP_60s\t\t1981\t\t/* 1/exp(2s/60s) */",
      "#define EXP_10s\t\t1677\t\t/* 1/exp(2s/10s) as fixed-point */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avg[2]",
            "EXP_300s",
            "pct"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avg[1]",
            "EXP_60s",
            "pct"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avg[0]",
            "EXP_10s",
            "pct"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "time * 100",
            "period"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_n",
          "args": [
            "avg[2]",
            "EXP_300s",
            "0",
            "missed_periods"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/loadavg.c",
          "lines": "156-161",
          "snippet": "unsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nunsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define EXP_300s\t2034\t\t/* 1/exp(2s/300s) */\n#define EXP_60s\t\t1981\t\t/* 1/exp(2s/60s) */\n#define EXP_10s\t\t1677\t\t/* 1/exp(2s/10s) as fixed-point */\n\nstatic void calc_avgs(unsigned long avg[3], int missed_periods,\n\t\t      u64 time, u64 period)\n{\n\tunsigned long pct;\n\n\t/* Fill in zeroes for periods of no activity */\n\tif (missed_periods) {\n\t\tavg[0] = calc_load_n(avg[0], EXP_10s, 0, missed_periods);\n\t\tavg[1] = calc_load_n(avg[1], EXP_60s, 0, missed_periods);\n\t\tavg[2] = calc_load_n(avg[2], EXP_300s, 0, missed_periods);\n\t}\n\n\t/* Sample the most recent active period */\n\tpct = div_u64(time * 100, period);\n\tpct *= FIXED_1;\n\tavg[0] = calc_load(avg[0], EXP_10s, pct);\n\tavg[1] = calc_load(avg[1], EXP_60s, pct);\n\tavg[2] = calc_load(avg[2], EXP_300s, pct);\n}"
  },
  {
    "function_name": "get_recent_times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "200-237",
    "snippet": "static void get_recent_times(struct psi_group *group, int cpu, u32 *times)\n{\n\tstruct psi_group_cpu *groupc = per_cpu_ptr(group->pcpu, cpu);\n\tunsigned int tasks[NR_PSI_TASK_COUNTS];\n\tu64 now, state_start;\n\tunsigned int seq;\n\tint s;\n\n\t/* Snapshot a coherent view of the CPU state */\n\tdo {\n\t\tseq = read_seqcount_begin(&groupc->seq);\n\t\tnow = cpu_clock(cpu);\n\t\tmemcpy(times, groupc->times, sizeof(groupc->times));\n\t\tmemcpy(tasks, groupc->tasks, sizeof(groupc->tasks));\n\t\tstate_start = groupc->state_start;\n\t} while (read_seqcount_retry(&groupc->seq, seq));\n\n\t/* Calculate state time deltas against the previous snapshot */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tu32 delta;\n\t\t/*\n\t\t * In addition to already concluded states, we also\n\t\t * incorporate currently active states on the CPU,\n\t\t * since states may last for many sampling periods.\n\t\t *\n\t\t * This way we keep our delta sampling buckets small\n\t\t * (u32) and our reported pressure close to what's\n\t\t * actually happening.\n\t\t */\n\t\tif (test_state(tasks, s))\n\t\t\ttimes[s] += now - state_start;\n\n\t\tdelta = times[s] - groupc->times_prev[s];\n\t\tgroupc->times_prev[s] = times[s];\n\n\t\ttimes[s] = delta;\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_state",
          "args": [
            "tasks",
            "s"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "test_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "179-198",
          "snippet": "static bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn tasks[NR_IOWAIT];\n\tcase PSI_IO_FULL:\n\t\treturn tasks[NR_IOWAIT] && !tasks[NR_RUNNING];\n\tcase PSI_MEM_SOME:\n\t\treturn tasks[NR_MEMSTALL];\n\tcase PSI_MEM_FULL:\n\t\treturn tasks[NR_MEMSTALL] && !tasks[NR_RUNNING];\n\tcase PSI_CPU_SOME:\n\t\treturn tasks[NR_RUNNING] > 1;\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn tasks[NR_IOWAIT];\n\tcase PSI_IO_FULL:\n\t\treturn tasks[NR_IOWAIT] && !tasks[NR_RUNNING];\n\tcase PSI_MEM_SOME:\n\t\treturn tasks[NR_MEMSTALL];\n\tcase PSI_MEM_FULL:\n\t\treturn tasks[NR_MEMSTALL] && !tasks[NR_RUNNING];\n\tcase PSI_CPU_SOME:\n\t\treturn tasks[NR_RUNNING] > 1;\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&groupc->seq",
            "seq"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tasks",
            "groupc->tasks",
            "sizeof(groupc->tasks)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock",
          "args": [
            "cpu"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "9268-9285",
          "snippet": "static int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic DEVICE_ATTR_RO(type);\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&groupc->seq"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "group->pcpu",
            "cpu"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic void get_recent_times(struct psi_group *group, int cpu, u32 *times)\n{\n\tstruct psi_group_cpu *groupc = per_cpu_ptr(group->pcpu, cpu);\n\tunsigned int tasks[NR_PSI_TASK_COUNTS];\n\tu64 now, state_start;\n\tunsigned int seq;\n\tint s;\n\n\t/* Snapshot a coherent view of the CPU state */\n\tdo {\n\t\tseq = read_seqcount_begin(&groupc->seq);\n\t\tnow = cpu_clock(cpu);\n\t\tmemcpy(times, groupc->times, sizeof(groupc->times));\n\t\tmemcpy(tasks, groupc->tasks, sizeof(groupc->tasks));\n\t\tstate_start = groupc->state_start;\n\t} while (read_seqcount_retry(&groupc->seq, seq));\n\n\t/* Calculate state time deltas against the previous snapshot */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tu32 delta;\n\t\t/*\n\t\t * In addition to already concluded states, we also\n\t\t * incorporate currently active states on the CPU,\n\t\t * since states may last for many sampling periods.\n\t\t *\n\t\t * This way we keep our delta sampling buckets small\n\t\t * (u32) and our reported pressure close to what's\n\t\t * actually happening.\n\t\t */\n\t\tif (test_state(tasks, s))\n\t\t\ttimes[s] += now - state_start;\n\n\t\tdelta = times[s] - groupc->times_prev[s];\n\t\tgroupc->times_prev[s] = times[s];\n\n\t\ttimes[s] = delta;\n\t}\n}"
  },
  {
    "function_name": "test_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "179-198",
    "snippet": "static bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn tasks[NR_IOWAIT];\n\tcase PSI_IO_FULL:\n\t\treturn tasks[NR_IOWAIT] && !tasks[NR_RUNNING];\n\tcase PSI_MEM_SOME:\n\t\treturn tasks[NR_MEMSTALL];\n\tcase PSI_MEM_FULL:\n\t\treturn tasks[NR_MEMSTALL] && !tasks[NR_RUNNING];\n\tcase PSI_CPU_SOME:\n\t\treturn tasks[NR_RUNNING] > 1;\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn tasks[NR_IOWAIT];\n\tcase PSI_IO_FULL:\n\t\treturn tasks[NR_IOWAIT] && !tasks[NR_RUNNING];\n\tcase PSI_MEM_SOME:\n\t\treturn tasks[NR_MEMSTALL];\n\tcase PSI_MEM_FULL:\n\t\treturn tasks[NR_MEMSTALL] && !tasks[NR_RUNNING];\n\tcase PSI_CPU_SOME:\n\t\treturn tasks[NR_RUNNING] > 1;\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "psi_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "170-177",
    "snippet": "void __init psi_init(void)\n{\n\tif (psi_disabled)\n\t\treturn;\n\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [
      "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
    ],
    "globals_used": [
      "bool psi_disabled",
      "static u64 psi_period",
      "static struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "group_init",
          "args": [
            "&psi_system"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "group_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "159-168",
          "snippet": "static void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->next_update = sched_clock() + psi_period;\n\tINIT_DELAYED_WORK(&group->clock_work, psi_update_work);\n\tmutex_init(&group->stat_lock);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 psi_period"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic u64 psi_period;\n\nstatic void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->next_update = sched_clock() + psi_period;\n\tINIT_DELAYED_WORK(&group->clock_work, psi_update_work);\n\tmutex_init(&group->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_nsecs",
          "args": [
            "PSI_FREQ"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nbool psi_disabled;\nstatic u64 psi_period;\nstatic struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nvoid __init psi_init(void)\n{\n\tif (psi_disabled)\n\t\treturn;\n\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}"
  },
  {
    "function_name": "group_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
    "lines": "159-168",
    "snippet": "static void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->next_update = sched_clock() + psi_period;\n\tINIT_DELAYED_WORK(&group->clock_work, psi_update_work);\n\tmutex_init(&group->stat_lock);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 psi_period"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&group->stat_lock"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&group->clock_work",
            "psi_update_work"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "group->pcpu",
            "cpu"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nstatic u64 psi_period;\n\nstatic void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->next_update = sched_clock() + psi_period;\n\tINIT_DELAYED_WORK(&group->clock_work, psi_update_work);\n\tmutex_init(&group->stat_lock);\n}"
  }
]