[
  {
    "function_name": "__wake_up_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1484-1488",
    "snippet": "void __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\tTASK_INTERRUPTIBLE, 1, p);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_sync_key",
          "args": [
            "&parent->signal->wait_chldexit",
            "TASK_INTERRUPTIBLE",
            "1",
            "p"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_sync_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "188-200",
          "snippet": "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\tTASK_INTERRUPTIBLE, 1, p);\n}"
  },
  {
    "function_name": "child_wait_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1468-1482",
    "snippet": "static int child_wait_callback(wait_queue_entry_t *wait, unsigned mode,\n\t\t\t\tint sync, void *key)\n{\n\tstruct wait_opts *wo = container_of(wait, struct wait_opts,\n\t\t\t\t\t\tchild_wait);\n\tstruct task_struct *p = key;\n\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\tif ((wo->wo_flags & __WNOTHREAD) && wait->private != p->parent)\n\t\treturn 0;\n\n\treturn default_wake_function(wait, mode, sync, key);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_wake_function",
          "args": [
            "wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "default_wake_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3707-3711",
          "snippet": "int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eligible_pid",
          "args": [
            "wo",
            "p"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "eligible_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1006-1010",
          "snippet": "static int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structwait_opts",
            "child_wait"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int child_wait_callback(wait_queue_entry_t *wait, unsigned mode,\n\t\t\t\tint sync, void *key)\n{\n\tstruct wait_opts *wo = container_of(wait, struct wait_opts,\n\t\t\t\t\t\tchild_wait);\n\tstruct task_struct *p = key;\n\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\tif ((wo->wo_flags & __WNOTHREAD) && wait->private != p->parent)\n\t\treturn 0;\n\n\treturn default_wake_function(wait, mode, sync, key);\n}"
  },
  {
    "function_name": "ptrace_do_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1454-1466",
    "snippet": "static int ptrace_do_wait(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->ptraced, ptrace_entry) {\n\t\tint ret = wait_consider_task(wo, 1, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_consider_task",
          "args": [
            "wo",
            "1",
            "p"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "wait_consider_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1328-1429",
          "snippet": "static int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&tsk->ptraced",
            "ptrace_entry"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int ptrace_do_wait(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->ptraced, ptrace_entry) {\n\t\tint ret = wait_consider_task(wo, 1, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_wait_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1440-1452",
    "snippet": "static int do_wait_thread(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->children, sibling) {\n\t\tint ret = wait_consider_task(wo, 0, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_consider_task",
          "args": [
            "wo",
            "0",
            "p"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "wait_consider_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1328-1429",
          "snippet": "static int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&tsk->children",
            "sibling"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int do_wait_thread(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->children, sibling) {\n\t\tint ret = wait_consider_task(wo, 0, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wait_consider_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1328-1429",
    "snippet": "static int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_task_continued",
          "args": [
            "wo",
            "p"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_continued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1276-1317",
          "snippet": "static int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tinfop = wo->wo_info;\n\tif (!infop) {\n\t\two->wo_stat = 0xffff;\n\t} else {\n\t\tinfop->cause = CLD_CONTINUED;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t\tinfop->status = SIGCONT;\n\t}\n\treturn pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tinfop = wo->wo_info;\n\tif (!infop) {\n\t\two->wo_stat = 0xffff;\n\t} else {\n\t\tinfop->cause = CLD_CONTINUED;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t\tinfop->status = SIGCONT;\n\t}\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_task_stopped",
          "args": [
            "wo",
            "ptrace",
            "p"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1204-1268",
          "snippet": "static int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tint exit_code, *p_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\tif (!ptrace && !(wo->wo_flags & WUNTRACED))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tif (likely(!(wo->wo_flags & WNOWAIT)))\n\t\two->wo_stat = (exit_code << 8) | 0x7f;\n\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tinfop->cause = why;\n\t\tinfop->status = exit_code;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\treturn pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tint exit_code, *p_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\tif (!ptrace && !(wo->wo_flags & WUNTRACED))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tif (likely(!(wo->wo_flags & WNOWAIT)))\n\t\two->wo_stat = (exit_code << 8) | 0x7f;\n\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tinfop->cause = why;\n\t\tinfop->status = exit_code;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ptrace"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_task_zombie",
          "args": [
            "wo",
            "p"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_zombie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1045-1172",
          "snippet": "static int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct waitid_info *infop;\n\n\tif (!likely(wo->wo_flags & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & WNOWAIT)) {\n\t\tstatus = p->exit_code;\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\t\tif (wo->wo_rusage)\n\t\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\t\tput_task_struct(p);\n\t\tgoto out_info;\n\t}\n\t/*\n\t * Move the task's state to DEAD/TRACE, only one thread can do this.\n\t */\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\tEXIT_TRACE : EXIT_DEAD;\n\tif (cmpxchg(&p->exit_state, EXIT_ZOMBIE, state) != EXIT_ZOMBIE)\n\t\treturn 0;\n\t/*\n\t * We own this thread, nobody else can reap it.\n\t */\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t/*\n\t * Check thread_group_leader() to exclude the traced sub-threads.\n\t */\n\tif (state == EXIT_DEAD && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tu64 tgutime, tgstime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields because the whole thread group is dead\n\t\t * and nobody can change them.\n\t\t *\n\t\t * psig->stats_lock also protects us from our sub-theads\n\t\t * which can reap other children at the same time. Until\n\t\t * we change k_getrusage()-like users to rely on this lock\n\t\t * we have to take ->siglock as well.\n\t\t *\n\t\t * We use thread_group_cputime_adjusted() to get times for\n\t\t * the thread group, which consolidates times for all threads\n\t\t * in the group including the group leader.\n\t\t */\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\two->wo_stat = status;\n\n\tif (state == EXIT_TRACE) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\n\t\t/* If parent wants a zombie, don't release it now */\n\t\tstate = EXIT_ZOMBIE;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = EXIT_DEAD;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == EXIT_DEAD)\n\t\trelease_task(p);\n\nout_info:\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif ((status & 0x7f) == 0) {\n\t\t\tinfop->cause = CLD_EXITED;\n\t\t\tinfop->status = status >> 8;\n\t\t} else {\n\t\t\tinfop->cause = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tinfop->status = status & 0x7f;\n\t\t}\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\n\treturn pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct waitid_info *infop;\n\n\tif (!likely(wo->wo_flags & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & WNOWAIT)) {\n\t\tstatus = p->exit_code;\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\t\tif (wo->wo_rusage)\n\t\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\t\tput_task_struct(p);\n\t\tgoto out_info;\n\t}\n\t/*\n\t * Move the task's state to DEAD/TRACE, only one thread can do this.\n\t */\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\tEXIT_TRACE : EXIT_DEAD;\n\tif (cmpxchg(&p->exit_state, EXIT_ZOMBIE, state) != EXIT_ZOMBIE)\n\t\treturn 0;\n\t/*\n\t * We own this thread, nobody else can reap it.\n\t */\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t/*\n\t * Check thread_group_leader() to exclude the traced sub-threads.\n\t */\n\tif (state == EXIT_DEAD && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tu64 tgutime, tgstime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields because the whole thread group is dead\n\t\t * and nobody can change them.\n\t\t *\n\t\t * psig->stats_lock also protects us from our sub-theads\n\t\t * which can reap other children at the same time. Until\n\t\t * we change k_getrusage()-like users to rely on this lock\n\t\t * we have to take ->siglock as well.\n\t\t *\n\t\t * We use thread_group_cputime_adjusted() to get times for\n\t\t * the thread group, which consolidates times for all threads\n\t\t * in the group including the group leader.\n\t\t */\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\two->wo_stat = status;\n\n\tif (state == EXIT_TRACE) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\n\t\t/* If parent wants a zombie, don't release it now */\n\t\tstate = EXIT_ZOMBIE;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = EXIT_DEAD;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == EXIT_DEAD)\n\t\trelease_task(p);\n\nout_info:\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif ((status & 0x7f) == 0) {\n\t\t\tinfop->cause = CLD_EXITED;\n\t\t\tinfop->status = status >> 8;\n\t\t} else {\n\t\t\tinfop->cause = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tinfop->status = status & 0x7f;\n\t\t}\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!p->ptrace"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ptrace"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay_group_leader",
          "args": [
            "p"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "p"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->ptrace"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ptrace"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ptrace"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "exit_state == EXIT_TRACE"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eligible_child",
          "args": [
            "wo",
            "ptrace",
            "p"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "eligible_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1012-1037",
          "snippet": "static int\neligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\t/*\n\t * Wait for all children (clone and not) if __WALL is set or\n\t * if it is traced by us.\n\t */\n\tif (ptrace || (wo->wo_flags & __WALL))\n\t\treturn 1;\n\n\t/*\n\t * Otherwise, wait for clone children *only* if __WCLONE is set;\n\t * otherwise, wait for non-clone children *only*.\n\t *\n\t * Note: a \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD, or a non-leader thread which\n\t * we can only see if it is traced by us.\n\t */\n\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int\neligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\t/*\n\t * Wait for all children (clone and not) if __WALL is set or\n\t * if it is traced by us.\n\t */\n\tif (ptrace || (wo->wo_flags & __WALL))\n\t\treturn 1;\n\n\t/*\n\t * Otherwise, wait for clone children *only* if __WCLONE is set;\n\t * otherwise, wait for non-clone children *only*.\n\t *\n\t * Note: a \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD, or a non-leader thread which\n\t * we can only see if it is traced by us.\n\t */\n\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "exit_state == EXIT_DEAD"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->exit_state"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}"
  },
  {
    "function_name": "wait_task_continued",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1276-1317",
    "snippet": "static int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tinfop = wo->wo_info;\n\tif (!infop) {\n\t\two->wo_stat = 0xffff;\n\t} else {\n\t\tinfop->cause = CLD_CONTINUED;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t\tinfop->status = SIGCONT;\n\t}\n\treturn pid;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "175-182",
          "snippet": "static void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrusage",
          "args": [
            "p",
            "RUSAGE_BOTH",
            "wo->wo_rusage"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "task_uid(p)"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "p"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wo->wo_flags & WNOWAIT"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wo->wo_flags & WCONTINUED"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tinfop = wo->wo_info;\n\tif (!infop) {\n\t\two->wo_stat = 0xffff;\n\t} else {\n\t\tinfop->cause = CLD_CONTINUED;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t\tinfop->status = SIGCONT;\n\t}\n\treturn pid;\n}"
  },
  {
    "function_name": "wait_task_stopped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1204-1268",
    "snippet": "static int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tint exit_code, *p_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\tif (!ptrace && !(wo->wo_flags & WUNTRACED))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tif (likely(!(wo->wo_flags & WNOWAIT)))\n\t\two->wo_stat = (exit_code << 8) | 0x7f;\n\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tinfop->cause = why;\n\t\tinfop->status = exit_code;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\treturn pid;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(wo->wo_flags & WNOWAIT)"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "175-182",
          "snippet": "static void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrusage",
          "args": [
            "p",
            "RUSAGE_BOTH",
            "wo->wo_rusage"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "task_uid(p)"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "p"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wo->wo_flags & WNOWAIT"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p_code"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stopped_code",
          "args": [
            "p",
            "ptrace"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "task_stopped_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1174-1184",
          "snippet": "static int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_traced(p) && !(p->jobctl & JOBCTL_LISTENING))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_traced(p) && !(p->jobctl & JOBCTL_LISTENING))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tint exit_code, *p_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\tif (!ptrace && !(wo->wo_flags & WUNTRACED))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tif (likely(!(wo->wo_flags & WNOWAIT)))\n\t\two->wo_stat = (exit_code << 8) | 0x7f;\n\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tinfop->cause = why;\n\t\tinfop->status = exit_code;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\treturn pid;\n}"
  },
  {
    "function_name": "task_stopped_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1174-1184",
    "snippet": "static int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_traced(p) && !(p->jobctl & JOBCTL_LISTENING))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_is_traced",
          "args": [
            "p"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_traced(p) && !(p->jobctl & JOBCTL_LISTENING))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "wait_task_zombie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1045-1172",
    "snippet": "static int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct waitid_info *infop;\n\n\tif (!likely(wo->wo_flags & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & WNOWAIT)) {\n\t\tstatus = p->exit_code;\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\t\tif (wo->wo_rusage)\n\t\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\t\tput_task_struct(p);\n\t\tgoto out_info;\n\t}\n\t/*\n\t * Move the task's state to DEAD/TRACE, only one thread can do this.\n\t */\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\tEXIT_TRACE : EXIT_DEAD;\n\tif (cmpxchg(&p->exit_state, EXIT_ZOMBIE, state) != EXIT_ZOMBIE)\n\t\treturn 0;\n\t/*\n\t * We own this thread, nobody else can reap it.\n\t */\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t/*\n\t * Check thread_group_leader() to exclude the traced sub-threads.\n\t */\n\tif (state == EXIT_DEAD && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tu64 tgutime, tgstime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields because the whole thread group is dead\n\t\t * and nobody can change them.\n\t\t *\n\t\t * psig->stats_lock also protects us from our sub-theads\n\t\t * which can reap other children at the same time. Until\n\t\t * we change k_getrusage()-like users to rely on this lock\n\t\t * we have to take ->siglock as well.\n\t\t *\n\t\t * We use thread_group_cputime_adjusted() to get times for\n\t\t * the thread group, which consolidates times for all threads\n\t\t * in the group including the group leader.\n\t\t */\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\two->wo_stat = status;\n\n\tif (state == EXIT_TRACE) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\n\t\t/* If parent wants a zombie, don't release it now */\n\t\tstate = EXIT_ZOMBIE;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = EXIT_DEAD;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == EXIT_DEAD)\n\t\trelease_task(p);\n\nout_info:\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif ((status & 0x7f) == 0) {\n\t\t\tinfop->cause = CLD_EXITED;\n\t\t\tinfop->status = status >> 8;\n\t\t} else {\n\t\t\tinfop->cause = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tinfop->status = status & 0x7f;\n\t\t}\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\n\treturn pid;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_task",
          "args": [
            "p"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "release_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "185-228",
          "snippet": "void release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tatomic_dec(&__task_cred(p)->user->processes);\n\trcu_read_unlock();\n\n\tproc_flush_task(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tatomic_dec(&__task_cred(p)->user->processes);\n\trcu_read_unlock();\n\n\tproc_flush_task(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "334-337",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "p",
            "p->exit_signal"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1767-1856",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_unlink",
          "args": [
            "p"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "113-165",
          "snippet": "void __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t/*\n\t * Clear all pending traps and TRAPPING.  TRAPPING should be\n\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.\n\t */\n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t/*\n\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and\n\t * @child isn't dead.\n\t */\n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t/*\n\t\t * This is only possible if this thread was cloned by the\n\t\t * traced task running in the stopped group, set the signal\n\t\t * for the future reports.\n\t\t * FIXME: we should change ptrace_init_task() to handle this\n\t\t * case.\n\t\t */\n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t/*\n\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick\n\t * @child in the butt.  Note that @resume should be used iff @child\n\t * is in TASK_TRACED; otherwise, we might unduly disrupt\n\t * TASK_KILLABLE sleeps.\n\t */\n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t/*\n\t * Clear all pending traps and TRAPPING.  TRAPPING should be\n\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.\n\t */\n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t/*\n\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and\n\t * @child isn't dead.\n\t */\n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t/*\n\t\t * This is only possible if this thread was cloned by the\n\t\t * traced task running in the stopped group, set the signal\n\t\t * for the future reports.\n\t\t * FIXME: we should change ptrace_init_task() to handle this\n\t\t * case.\n\t\t */\n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t/*\n\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick\n\t * @child in the butt.  Note that @resume should be used iff @child\n\t * is in TASK_TRACED; otherwise, we might unduly disrupt\n\t * TASK_KILLABLE sleeps.\n\t */\n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "302-305",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrusage",
          "args": [
            "p",
            "RUSAGE_BOTH",
            "wo->wo_rusage"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&psig->stats_lock"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_accounting_add",
          "args": [
            "&psig->ioac",
            "&sig->ioac"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_accounting_add",
          "args": [
            "&psig->ioac",
            "&p->ioac"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "sig->maxrss",
            "sig->cmaxrss"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_io_get_oublock",
          "args": [
            "p"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_get_inblock",
          "args": [
            "p"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_gtime",
          "args": [
            "p"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "task_gtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "835-854",
          "snippet": "u64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_SYS && t->flags & PF_VCPU)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nu64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_SYS && t->flags & PF_VCPU)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&psig->stats_lock"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputime_adjusted",
          "args": [
            "p",
            "&tgutime",
            "&tgstime"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputime_adjusted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "673-679",
          "snippet": "void thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "p"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&p->exit_state",
            "EXIT_ZOMBIE",
            "state"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "p"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "p"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "175-182",
          "snippet": "static void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrusage",
          "args": [
            "p",
            "RUSAGE_BOTH",
            "wo->wo_rusage"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wo->wo_flags & WNOWAIT"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "wo->wo_flags & WEXITED"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "task_uid(p)"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "p"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct waitid_info *infop;\n\n\tif (!likely(wo->wo_flags & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & WNOWAIT)) {\n\t\tstatus = p->exit_code;\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\t\tif (wo->wo_rusage)\n\t\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\t\tput_task_struct(p);\n\t\tgoto out_info;\n\t}\n\t/*\n\t * Move the task's state to DEAD/TRACE, only one thread can do this.\n\t */\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\tEXIT_TRACE : EXIT_DEAD;\n\tif (cmpxchg(&p->exit_state, EXIT_ZOMBIE, state) != EXIT_ZOMBIE)\n\t\treturn 0;\n\t/*\n\t * We own this thread, nobody else can reap it.\n\t */\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t/*\n\t * Check thread_group_leader() to exclude the traced sub-threads.\n\t */\n\tif (state == EXIT_DEAD && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tu64 tgutime, tgstime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields because the whole thread group is dead\n\t\t * and nobody can change them.\n\t\t *\n\t\t * psig->stats_lock also protects us from our sub-theads\n\t\t * which can reap other children at the same time. Until\n\t\t * we change k_getrusage()-like users to rely on this lock\n\t\t * we have to take ->siglock as well.\n\t\t *\n\t\t * We use thread_group_cputime_adjusted() to get times for\n\t\t * the thread group, which consolidates times for all threads\n\t\t * in the group including the group leader.\n\t\t */\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\two->wo_stat = status;\n\n\tif (state == EXIT_TRACE) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\n\t\t/* If parent wants a zombie, don't release it now */\n\t\tstate = EXIT_ZOMBIE;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = EXIT_DEAD;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == EXIT_DEAD)\n\t\trelease_task(p);\n\nout_info:\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif ((status & 0x7f) == 0) {\n\t\t\tinfop->cause = CLD_EXITED;\n\t\t\tinfop->status = status >> 8;\n\t\t} else {\n\t\t\tinfop->cause = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tinfop->status = status & 0x7f;\n\t\t}\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\n\treturn pid;\n}"
  },
  {
    "function_name": "eligible_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1012-1037",
    "snippet": "static int\neligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\t/*\n\t * Wait for all children (clone and not) if __WALL is set or\n\t * if it is traced by us.\n\t */\n\tif (ptrace || (wo->wo_flags & __WALL))\n\t\treturn 1;\n\n\t/*\n\t * Otherwise, wait for clone children *only* if __WCLONE is set;\n\t * otherwise, wait for non-clone children *only*.\n\t *\n\t * Note: a \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD, or a non-leader thread which\n\t * we can only see if it is traced by us.\n\t */\n\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eligible_pid",
          "args": [
            "wo",
            "p"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "eligible_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1006-1010",
          "snippet": "static int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int\neligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\t/*\n\t * Wait for all children (clone and not) if __WALL is set or\n\t * if it is traced by us.\n\t */\n\tif (ptrace || (wo->wo_flags & __WALL))\n\t\treturn 1;\n\n\t/*\n\t * Otherwise, wait for clone children *only* if __WCLONE is set;\n\t * otherwise, wait for non-clone children *only*.\n\t *\n\t * Note: a \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD, or a non-leader thread which\n\t * we can only see if it is traced by us.\n\t */\n\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "eligible_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1006-1010",
    "snippet": "static int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_pid_type",
          "args": [
            "p",
            "wo->wo_type"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}"
  },
  {
    "function_name": "do_group_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "946-972",
    "snippet": "void\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tBUG_ON(exit_code & 0x80); /* core dumps don't get here */\n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "exit_code"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "765-925",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&sighand->siglock"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zap_other_threads",
          "args": [
            "current"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "zap_other_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1263-1282",
          "snippet": "int zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_group_exit",
          "args": [
            "sig"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&sighand->siglock"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "current"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_group_exit",
          "args": [
            "sig"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "exit_code & 0x80"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tBUG_ON(exit_code & 0x80); /* core dumps don't get here */\n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "complete_and_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "928-934",
    "snippet": "void complete_and_exit(struct completion *comp, long code)\n{\n\tif (comp)\n\t\tcomplete(comp);\n\n\tdo_exit(code);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "code"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "765-925",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "comp"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid complete_and_exit(struct completion *comp, long code)\n{\n\tif (comp)\n\t\tcomplete(comp);\n\n\tdo_exit(code);\n}"
  },
  {
    "function_name": "do_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "765-925",
    "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_task_dead",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "do_task_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3481-3495",
          "snippet": "void __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(false);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(false);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_free_task",
          "args": [
            "tsk"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_tasks_rcu_finish",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "exit_tasks_rcu_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "841-846",
          "snippet": "void exit_tasks_rcu_finish(void)\n{\n\tpreempt_disable();\n\t__srcu_read_unlock(&tasks_rcu_exit_srcu, current->rcu_tasks_idx);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid exit_tasks_rcu_finish(void)\n{\n\tpreempt_disable();\n\t__srcu_read_unlock(&tasks_rcu_exit_srcu, current->rcu_tasks_idx);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_rcu",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "exit_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1125-1127",
          "snippet": "void exit_rcu(void)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid exit_rcu(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "dirty_throttle_leaks",
            "tsk->nr_dirtied"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_usage",
          "args": [],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "check_stack_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "762-762",
          "snippet": "static inline void check_stack_usage(void) {}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_stack_usage(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "validate_creds_for_do_exit",
          "args": [
            "tsk"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "808-816",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "tsk->task_frag.page"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pipe_info",
          "args": [
            "tsk->splice_pipe"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_io_context",
          "args": [
            "tsk"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_held",
          "args": [],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4365-4369",
          "snippet": "void debug_check_no_locks_held(void)\n{\n\tif (unlikely(current->lockdep_depth > 0))\n\t\tprint_held_locks_bug();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_held(void)\n{\n\tif (unlikely(current->lockdep_depth > 0))\n\t\tprint_held_locks_bug();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "current->pi_state_cache"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->pi_state_cache"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_put_task_policy",
          "args": [
            "tsk"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_exit_connector",
          "args": [
            "tsk"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_notify",
          "args": [
            "tsk",
            "group_dead"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "exit_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "701-739",
          "snippet": "static void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tLIST_HEAD(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : SIGCHLD;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\ttsk->exit_state = autoreap ? EXIT_DEAD : EXIT_ZOMBIE;\n\tif (tsk->exit_state == EXIT_DEAD)\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\n\t/* mt-exec, de_thread() is waiting for group leader */\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exit_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tLIST_HEAD(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : SIGCHLD;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\ttsk->exit_state = autoreap ? EXIT_DEAD : EXIT_ZOMBIE;\n\tif (tsk->exit_state == EXIT_DEAD)\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\n\t/* mt-exec, de_thread() is waiting for group leader */\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exit_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_tasks_rcu_start",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "exit_tasks_rcu_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "833-838",
          "snippet": "void exit_tasks_rcu_start(void)\n{\n\tpreempt_disable();\n\tcurrent->rcu_tasks_idx = __srcu_read_lock(&tasks_rcu_exit_srcu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid exit_tasks_rcu_start(void)\n{\n\tpreempt_disable();\n\tcurrent->rcu_tasks_idx = __srcu_read_lock(&tasks_rcu_exit_srcu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_ptrace_hw_breakpoint",
          "args": [
            "tsk"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit",
          "args": [
            "tsk"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5685-5710",
          "snippet": "void cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\t/*\n\t * Unlink from @tsk from its css_set.  As migration path can't race\n\t * with us, we can check css_set and cg_list without synchronization.\n\t */\n\tcset = task_css_set(tsk);\n\n\tif (!list_empty(&tsk->cg_list)) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcss_set_move_task(tsk, cset, NULL, false);\n\t\tcset->nr_tasks--;\n\t\tspin_unlock_irq(&css_set_lock);\n\t} else {\n\t\tget_css_set(cset);\n\t}\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 have_exit_callback",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_exit_callback;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\t/*\n\t * Unlink from @tsk from its css_set.  As migration path can't race\n\t * with us, we can check css_set and cg_list without synchronization.\n\t */\n\tcset = task_css_set(tsk);\n\n\tif (!list_empty(&tsk->cg_list)) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcss_set_move_task(tsk, cset, NULL, false);\n\t\tcset->nr_tasks--;\n\t\tspin_unlock_irq(&css_set_lock);\n\t} else {\n\t\tget_css_set(cset);\n\t}\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_autogroup_exit_task",
          "args": [
            "tsk"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "sched_autogroup_exit_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/autogroup.c",
          "lines": "125-133",
          "snippet": "void sched_autogroup_exit_task(struct task_struct *p)\n{\n\t/*\n\t * We are going to call exit_notify() and autogroup_move_group() can't\n\t * see this thread after that: we can no longer use signal->autogroup.\n\t * See the PF_EXITING check in task_wants_autogroup().\n\t */\n\tsched_move_task(p);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nvoid sched_autogroup_exit_task(struct task_struct *p)\n{\n\t/*\n\t * We are going to call exit_notify() and autogroup_move_group() can't\n\t * see this thread after that: we can no longer use signal->autogroup.\n\t * See the PF_EXITING check in task_wants_autogroup().\n\t */\n\tsched_move_task(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_exit_task",
          "args": [
            "tsk"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_exit_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "11137-11166",
          "snippet": "void perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t/*\n\t\t * Ensure the list deletion is visible before we clear\n\t\t * the owner, closes a race against perf_release() where\n\t\t * we need to serialize on the owner->perf_event_mutex.\n\t\t */\n\t\tsmp_store_release(&event->owner, NULL);\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n\n\t/*\n\t * The perf_event_exit_task_context calls perf_event_task\n\t * with child's task_ctx, which generates EXIT events for\n\t * child contexts and sets child->perf_event_ctxp[] to NULL.\n\t * At this point we need to send EXIT events to cpu contexts.\n\t */\n\tperf_event_task(child, NULL, 0);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t/*\n\t\t * Ensure the list deletion is visible before we clear\n\t\t * the owner, closes a race against perf_release() where\n\t\t * we need to serialize on the owner->perf_event_mutex.\n\t\t */\n\t\tsmp_store_release(&event->owner, NULL);\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n\n\t/*\n\t * The perf_event_exit_task_context calls perf_event_task\n\t * with child's task_ctx, which generates EXIT events for\n\t * child contexts and sets child->perf_event_ctxp[] to NULL.\n\t * At this point we need to send EXIT events to cpu contexts.\n\t */\n\tperf_event_task(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_thread",
          "args": [
            "tsk"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_task_work",
          "args": [
            "tsk"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_task_namespaces",
          "args": [
            "tsk"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "exit_task_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
          "lines": "232-235",
          "snippet": "void exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disassociate_ctty",
          "args": [
            "1"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_fs",
          "args": [
            "tsk"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_files",
          "args": [
            "tsk"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_shm",
          "args": [
            "tsk"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_sem",
          "args": [
            "tsk"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_process_exit",
          "args": [
            "tsk"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_process",
          "args": [],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "acct_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "591-606",
          "snippet": "void acct_process(void)\n{\n\tstruct pid_namespace *ns;\n\n\t/*\n\t * This loop is safe lockless, since current is still\n\t * alive and holds its namespace, which in turn holds\n\t * its parent.\n\t */\n\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {\n\t\tif (ns->bacct)\n\t\t\tbreak;\n\t}\n\tif (unlikely(ns))\n\t\tslow_acct_process(ns);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid acct_process(void)\n{\n\tstruct pid_namespace *ns;\n\n\t/*\n\t * This loop is safe lockless, since current is still\n\t * alive and holds its namespace, which in turn holds\n\t * its parent.\n\t */\n\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {\n\t\tif (ns->bacct)\n\t\t\tbreak;\n\t}\n\tif (unlikely(ns))\n\t\tslow_acct_process(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_mm",
          "args": [],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "exit_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "495-548",
          "snippet": "static void exit_mm(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct core_state *core_state;\n\n\tmm_release(current, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold mmap_sem around checking core_state\n\t * and clearing tsk->mm.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group with ->mm != NULL.\n\t */\n\tdown_read(&mm->mmap_sem);\n\tcore_state = mm->core_state;\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tup_read(&mm->mmap_sem);\n\n\t\tself.task = current;\n\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\tmmgrab(mm);\n\tBUG_ON(mm != current->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(current);\n\tcurrent->mm = NULL;\n\tup_read(&mm->mmap_sem);\n\tenter_lazy_tlb(mm, current);\n\ttask_unlock(current);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(TIF_MEMDIE))\n\t\texit_oom_victim();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void exit_mm(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct core_state *core_state;\n\n\tmm_release(current, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold mmap_sem around checking core_state\n\t * and clearing tsk->mm.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group with ->mm != NULL.\n\t */\n\tdown_read(&mm->mmap_sem);\n\tcore_state = mm->core_state;\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tup_read(&mm->mmap_sem);\n\n\t\tself.task = current;\n\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\tmmgrab(mm);\n\tBUG_ON(mm != current->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(current);\n\tcurrent->mm = NULL;\n\tup_read(&mm->mmap_sem);\n\tenter_lazy_tlb(mm, current);\n\ttask_unlock(current);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(TIF_MEMDIE))\n\t\texit_oom_victim();\n}"
        }
      },
      {
        "call_info": {
          "callee": "taskstats_exit",
          "args": [
            "tsk",
            "group_dead"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "taskstats_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "589-647",
          "snippet": "void taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t/*\n\t * Size includes space for nested attributes\n\t */\n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t/* PID + STATS + TGID + STATS */\n\t\tsize = 2 * size;\n\t\t/* fill the tsk->signal->stats structure */\n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = raw_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\n\t/*\n\t * Doesn't matter if tsk is the leader or the last group member leaving\n\t */\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int family_registered;",
            "static DEFINE_PER_CPU(struct listener_list, listener_array);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int family_registered;\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nvoid taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t/*\n\t * Size includes space for nested attributes\n\t */\n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t/* PID + STATS + TGID + STATS */\n\t\tsize = 2 * size;\n\t\t/* fill the tsk->signal->stats structure */\n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = raw_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\n\t/*\n\t * Doesn't matter if tsk is the leader or the last group member leaving\n\t */\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free",
          "args": [
            "tsk"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "110-114",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tty_audit_exit",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_collect",
          "args": [
            "code",
            "group_dead"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "acct_collect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "533-572",
          "snippet": "void acct_collect(long exitcode, int group_dead)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 utime, stime;\n\tunsigned long vsize = 0;\n\n\tif (group_dead && current->mm) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tvma = current->mm->mmap;\n\t\twhile (vma) {\n\t\t\tvsize += vma->vm_end - vma->vm_start;\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t\tup_read(&current->mm->mmap_sem);\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (group_dead)\n\t\tpacct->ac_mem = vsize / 1024;\n\tif (thread_group_leader(current)) {\n\t\tpacct->ac_exitcode = exitcode;\n\t\tif (current->flags & PF_FORKNOEXEC)\n\t\t\tpacct->ac_flag |= AFORK;\n\t}\n\tif (current->flags & PF_SUPERPRIV)\n\t\tpacct->ac_flag |= ASU;\n\tif (current->flags & PF_DUMPCORE)\n\t\tpacct->ac_flag |= ACORE;\n\tif (current->flags & PF_SIGNALED)\n\t\tpacct->ac_flag |= AXSIG;\n\n\ttask_cputime(current, &utime, &stime);\n\tpacct->ac_utime += utime;\n\tpacct->ac_stime += stime;\n\tpacct->ac_minflt += current->min_flt;\n\tpacct->ac_majflt += current->maj_flt;\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid acct_collect(long exitcode, int group_dead)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 utime, stime;\n\tunsigned long vsize = 0;\n\n\tif (group_dead && current->mm) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tvma = current->mm->mmap;\n\t\twhile (vma) {\n\t\t\tvsize += vma->vm_end - vma->vm_start;\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t\tup_read(&current->mm->mmap_sem);\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (group_dead)\n\t\tpacct->ac_mem = vsize / 1024;\n\tif (thread_group_leader(current)) {\n\t\tpacct->ac_exitcode = exitcode;\n\t\tif (current->flags & PF_FORKNOEXEC)\n\t\t\tpacct->ac_flag |= AFORK;\n\t}\n\tif (current->flags & PF_SUPERPRIV)\n\t\tpacct->ac_flag |= ASU;\n\tif (current->flags & PF_DUMPCORE)\n\t\tpacct->ac_flag |= ACORE;\n\tif (current->flags & PF_SIGNALED)\n\t\tpacct->ac_flag |= AXSIG;\n\n\ttask_cputime(current, &utime, &stime);\n\tpacct->ac_utime += utime;\n\tpacct->ac_stime += stime;\n\tpacct->ac_minflt += current->min_flt;\n\tpacct->ac_majflt += current->maj_flt;\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setmax_mm_hiwater_rss",
          "args": [
            "&tsk->signal->maxrss",
            "tsk->mm"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_itimers",
          "args": [
            "tsk->signal"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "exit_itimers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "1031-1039",
          "snippet": "void exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&tsk->signal->real_timer"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&tsk->signal->live"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_update_integrals",
          "args": [
            "tsk"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "acct_update_integrals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tsacct.c",
          "lines": "155-164",
          "snippet": "void acct_update_integrals(struct task_struct *tsk)\n{\n\tu64 utime, stime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\ttask_cputime(tsk, &utime, &stime);\n\t__acct_update_integrals(tsk, utime, stime);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_update_integrals(struct task_struct *tsk)\n{\n\tu64 utime, stime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\ttask_cputime(tsk, &utime, &stime);\n\t__acct_update_integrals(tsk, utime, stime);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "tsk->mm"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count_set",
          "args": [
            "PREEMPT_ENABLED"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"note: %s[%d] exited with preempt_count %d\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "preempt_count()"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_atomic()"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&tsk->pi_lock"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&tsk->pi_lock"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_signals",
          "args": [
            "tsk"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "exit_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2593-2641",
          "snippet": "void exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Fixing recursive fault but reboot is needed!\\n\""
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->flags & PF_EXITING"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_event",
          "args": [
            "PTRACE_EVENT_EXIT",
            "code"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "USER_DS"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Attempted to kill the idle task!\""
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "181-185",
          "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tsk->pid"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_interrupt()"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "blk_needs_flush_plug(tsk)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_needs_flush_plug",
          "args": [
            "tsk"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_task_exit",
          "args": [
            "tsk"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_task_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "251-269",
          "snippet": "void kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\tspin_lock(&kcov->lock);\n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock(&kcov->lock);\n\t\treturn;\n\t}\n\t/* Just to not leave dangling references behind. */\n\tkcov_task_init(t);\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tspin_unlock(&kcov->lock);\n\tkcov_put(kcov);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\tspin_lock(&kcov->lock);\n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock(&kcov->lock);\n\t\treturn;\n\t}\n\t/* Just to not leave dangling references behind. */\n\tkcov_task_init(t);\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tspin_unlock(&kcov->lock);\n\tkcov_put(kcov);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_task_exit",
          "args": [
            "tsk"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "profile_task_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
          "lines": "140-143",
          "snippet": "void profile_task_exit(struct task_struct *task)\n{\n\tblocking_notifier_call_chain(&task_exit_notifier, 0, task);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(task_exit_notifier);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(task_exit_notifier);\n\nvoid profile_task_exit(struct task_struct *task)\n{\n\tblocking_notifier_call_chain(&task_exit_notifier, 0, task);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
  },
  {
    "function_name": "check_stack_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "762-762",
    "snippet": "static inline void check_stack_usage(void) {}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_stack_usage(void) {}"
  },
  {
    "function_name": "check_stack_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "742-760",
    "snippet": "static void check_stack_usage(void)\n{\n\tstatic DEFINE_SPINLOCK(low_water_lock);\n\tstatic int lowest_to_date = THREAD_SIZE;\n\tunsigned long free;\n\n\tfree = stack_not_used(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tpr_info(\"%s (%d) used greatest stack depth: %lu bytes left\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current), free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&low_water_lock"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s (%d) used greatest stack depth: %lu bytes left\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "free"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&low_water_lock"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_not_used",
          "args": [
            "current"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void check_stack_usage(void)\n{\n\tstatic DEFINE_SPINLOCK(low_water_lock);\n\tstatic int lowest_to_date = THREAD_SIZE;\n\tunsigned long free;\n\n\tfree = stack_not_used(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tpr_info(\"%s (%d) used greatest stack depth: %lu bytes left\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current), free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}"
  },
  {
    "function_name": "exit_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "701-739",
    "snippet": "static void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tLIST_HEAD(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : SIGCHLD;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\ttsk->exit_state = autoreap ? EXIT_DEAD : EXIT_ZOMBIE;\n\tif (tsk->exit_state == EXIT_DEAD)\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\n\t/* mt-exec, de_thread() is waiting for group leader */\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exit_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_task",
          "args": [
            "p"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "release_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "185-228",
          "snippet": "void release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tatomic_dec(&__task_cred(p)->user->processes);\n\trcu_read_unlock();\n\n\tproc_flush_task(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tatomic_dec(&__task_cred(p)->user->processes);\n\trcu_read_unlock();\n\n\tproc_flush_task(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->ptrace_entry"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "&dead",
            "ptrace_entry"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "334-337",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tsk->signal->group_exit_task"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->signal->notify_count < 0"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tsk->ptrace_entry",
            "&dead"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "tsk",
            "tsk->exit_signal"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1767-1856",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "tsk"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->ptrace"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_orphaned_pgrp",
          "args": [
            "tsk->group_leader",
            "NULL"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "kill_orphaned_pgrp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "377-401",
          "snippet": "static void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "forget_original_parent",
          "args": [
            "tsk",
            "&dead"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "forget_original_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "662-695",
          "snippet": "static void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t/* Can drop and reacquire tasklist_lock */\n\treaper = find_child_reaper(father);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tt->real_parent = reaper;\n\t\t\tBUG_ON((!t->ptrace) != (t->parent == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    SEND_SIG_NOINFO, t,\n\t\t\t\t\t\t    PIDTYPE_TGID);\n\t\t}\n\t\t/*\n\t\t * If this is a threaded reparent there is no need to\n\t\t * notify anyone anything has happened.\n\t\t */\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t/* Can drop and reacquire tasklist_lock */\n\treaper = find_child_reaper(father);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tt->real_parent = reaper;\n\t\t\tBUG_ON((!t->ptrace) != (t->parent == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    SEND_SIG_NOINFO, t,\n\t\t\t\t\t\t    PIDTYPE_TGID);\n\t\t}\n\t\t/*\n\t\t * If this is a threaded reparent there is no need to\n\t\t * notify anyone anything has happened.\n\t\t */\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "302-305",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dead"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tLIST_HEAD(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : SIGCHLD;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\ttsk->exit_state = autoreap ? EXIT_DEAD : EXIT_ZOMBIE;\n\tif (tsk->exit_state == EXIT_DEAD)\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\n\t/* mt-exec, de_thread() is waiting for group leader */\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exit_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}"
  },
  {
    "function_name": "forget_original_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "662-695",
    "snippet": "static void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t/* Can drop and reacquire tasklist_lock */\n\treaper = find_child_reaper(father);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tt->real_parent = reaper;\n\t\t\tBUG_ON((!t->ptrace) != (t->parent == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    SEND_SIG_NOINFO, t,\n\t\t\t\t\t\t    PIDTYPE_TGID);\n\t\t}\n\t\t/*\n\t\t * If this is a threaded reparent there is no need to\n\t\t * notify anyone anything has happened.\n\t\t */\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&father->children",
            "&reaper->children"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reparent_leader",
          "args": [
            "father",
            "p",
            "dead"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "reparent_leader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "633-652",
          "snippet": "static void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == EXIT_DEAD))\n\t\treturn;\n\n\t/* We don't want people slaying init. */\n\tp->exit_signal = SIGCHLD;\n\n\t/* If it has exited notify the new parent about this child's death. */\n\tif (!p->ptrace &&\n\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == EXIT_DEAD))\n\t\treturn;\n\n\t/* We don't want people slaying init. */\n\tp->exit_signal = SIGCHLD;\n\n\t/* If it has exited notify the new parent about this child's death. */\n\tif (!p->ptrace &&\n\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "reaper",
            "father"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "t->pdeath_signal",
            "SEND_SIG_NOINFO",
            "t",
            "PIDTYPE_TGID"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1319-1332",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!t->ptrace"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(!t->ptrace) != (t->parent == father)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&father->children",
            "sibling"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_new_reaper",
          "args": [
            "father",
            "reaper"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "find_new_reaper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "595-628",
          "snippet": "static struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\tunsigned int ns_level = task_pid(father)->level;\n\t\t/*\n\t\t * Find the first ->is_child_subreaper ancestor in our pid_ns.\n\t\t * We can't check reaper != child_reaper to ensure we do not\n\t\t * cross the namespaces, the exiting parent could be injected\n\t\t * by setns() + fork().\n\t\t * We check pid->level, this is slightly more efficient than\n\t\t * task_active_pid_ns(reaper) != task_active_pid_ns(father).\n\t\t */\n\t\tfor (reaper = father->real_parent;\n\t\t     task_pid(reaper)->level == ns_level;\n\t\t     reaper = reaper->real_parent) {\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\tunsigned int ns_level = task_pid(father)->level;\n\t\t/*\n\t\t * Find the first ->is_child_subreaper ancestor in our pid_ns.\n\t\t * We can't check reaper != child_reaper to ensure we do not\n\t\t * cross the namespaces, the exiting parent could be injected\n\t\t * by setns() + fork().\n\t\t * We check pid->level, this is slightly more efficient than\n\t\t * task_active_pid_ns(reaper) != task_active_pid_ns(father).\n\t\t */\n\t\tfor (reaper = father->real_parent;\n\t\t     task_pid(reaper)->level == ns_level;\n\t\t     reaper = reaper->real_parent) {\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&father->children"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_child_reaper",
          "args": [
            "father"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "find_child_reaper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "561-586",
          "snippet": "static struct task_struct *find_child_reaper(struct task_struct *father)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (unlikely(pid_ns == &init_pid_ns)) {\n\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\tfather->signal->group_exit_code ?: father->exit_code);\n\t}\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_child_reaper(struct task_struct *father)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (unlikely(pid_ns == &init_pid_ns)) {\n\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\tfather->signal->group_exit_code ?: father->exit_code);\n\t}\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_ptrace",
          "args": [
            "father",
            "dead"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "exit_ptrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "570-581",
          "snippet": "void exit_ptrace(struct task_struct *tracer, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {\n\t\tif (unlikely(p->ptrace & PT_EXITKILL))\n\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);\n\n\t\tif (__ptrace_detach(tracer, p))\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t}\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid exit_ptrace(struct task_struct *tracer, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {\n\t\tif (unlikely(p->ptrace & PT_EXITKILL))\n\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);\n\n\t\tif (__ptrace_detach(tracer, p))\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&father->ptraced)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t/* Can drop and reacquire tasklist_lock */\n\treaper = find_child_reaper(father);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tt->real_parent = reaper;\n\t\t\tBUG_ON((!t->ptrace) != (t->parent == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    SEND_SIG_NOINFO, t,\n\t\t\t\t\t\t    PIDTYPE_TGID);\n\t\t}\n\t\t/*\n\t\t * If this is a threaded reparent there is no need to\n\t\t * notify anyone anything has happened.\n\t\t */\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}"
  },
  {
    "function_name": "reparent_leader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "633-652",
    "snippet": "static void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == EXIT_DEAD))\n\t\treturn;\n\n\t/* We don't want people slaying init. */\n\tp->exit_signal = SIGCHLD;\n\n\t/* If it has exited notify the new parent about this child's death. */\n\tif (!p->ptrace &&\n\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_orphaned_pgrp",
          "args": [
            "p",
            "father"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "kill_orphaned_pgrp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "377-401",
          "snippet": "static void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&p->ptrace_entry",
            "dead"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "p",
            "p->exit_signal"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1767-1856",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "p"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->exit_state == EXIT_DEAD"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == EXIT_DEAD))\n\t\treturn;\n\n\t/* We don't want people slaying init. */\n\tp->exit_signal = SIGCHLD;\n\n\t/* If it has exited notify the new parent about this child's death. */\n\tif (!p->ptrace &&\n\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}"
  },
  {
    "function_name": "find_new_reaper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "595-628",
    "snippet": "static struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\tunsigned int ns_level = task_pid(father)->level;\n\t\t/*\n\t\t * Find the first ->is_child_subreaper ancestor in our pid_ns.\n\t\t * We can't check reaper != child_reaper to ensure we do not\n\t\t * cross the namespaces, the exiting parent could be injected\n\t\t * by setns() + fork().\n\t\t * We check pid->level, this is slightly more efficient than\n\t\t * task_active_pid_ns(reaper) != task_active_pid_ns(father).\n\t\t */\n\t\tfor (reaper = father->real_parent;\n\t\t     task_pid(reaper)->level == ns_level;\n\t\t     reaper = reaper->real_parent) {\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_alive_thread",
          "args": [
            "reaper"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "find_alive_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "550-559",
          "snippet": "static struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "reaper"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "init_task_pid_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1631-1638",
          "snippet": "static inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\tunsigned int ns_level = task_pid(father)->level;\n\t\t/*\n\t\t * Find the first ->is_child_subreaper ancestor in our pid_ns.\n\t\t * We can't check reaper != child_reaper to ensure we do not\n\t\t * cross the namespaces, the exiting parent could be injected\n\t\t * by setns() + fork().\n\t\t * We check pid->level, this is slightly more efficient than\n\t\t * task_active_pid_ns(reaper) != task_active_pid_ns(father).\n\t\t */\n\t\tfor (reaper = father->real_parent;\n\t\t     task_pid(reaper)->level == ns_level;\n\t\t     reaper = reaper->real_parent) {\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}"
  },
  {
    "function_name": "find_child_reaper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "561-586",
    "snippet": "static struct task_struct *find_child_reaper(struct task_struct *father)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (unlikely(pid_ns == &init_pid_ns)) {\n\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\tfather->signal->group_exit_code ?: father->exit_code);\n\t}\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "302-305",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zap_pid_ns_processes",
          "args": [
            "pid_ns"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "zap_pid_ns_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "180-263",
          "snippet": "void zap_pid_ns_processes(struct pid_namespace *pid_ns)\n{\n\tint nr;\n\tint rc;\n\tstruct task_struct *task, *me = current;\n\tint init_pids = thread_group_leader(me) ? 1 : 2;\n\tstruct pid *pid;\n\n\t/* Don't allow any more processes into the pid namespace */\n\tdisable_pid_allocation(pid_ns);\n\n\t/*\n\t * Ignore SIGCHLD causing any terminated children to autoreap.\n\t * This speeds up the namespace shutdown, plus see the comment\n\t * below.\n\t */\n\tspin_lock_irq(&me->sighand->siglock);\n\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;\n\tspin_unlock_irq(&me->sighand->siglock);\n\n\t/*\n\t * The last thread in the cgroup-init thread group is terminating.\n\t * Find remaining pid_ts in the namespace, signal and wait for them\n\t * to exit.\n\t *\n\t * Note:  This signals each threads in the namespace - even those that\n\t * \t  belong to the same thread group, To avoid this, we would have\n\t * \t  to walk the entire tasklist looking a processes in this\n\t * \t  namespace, but that could be unnecessarily expensive if the\n\t * \t  pid namespace has just a few processes. Or we need to\n\t * \t  maintain a tasklist for each pid namespace.\n\t *\n\t */\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tnr = 2;\n\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {\n\t\ttask = pid_task(pid, PIDTYPE_PID);\n\t\tif (task && !__fatal_signal_pending(task))\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);\n\t}\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\t/*\n\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.\n\t * kernel_wait4() will also block until our children traced from the\n\t * parent namespace are detached and become EXIT_DEAD.\n\t */\n\tdo {\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);\n\t} while (rc != -ECHILD);\n\n\t/*\n\t * kernel_wait4() above can't reap the EXIT_DEAD children but we do not\n\t * really care, we could reparent them to the global init. We could\n\t * exit and reap ->child_reaper even if it is not the last thread in\n\t * this pid_ns, free_pid(pid_allocated == 0) calls proc_cleanup_work(),\n\t * pid_ns can not go away until proc_kill_sb() drops the reference.\n\t *\n\t * But this ns can also have other tasks injected by setns()+fork().\n\t * Again, ignoring the user visible semantics we do not really need\n\t * to wait until they are all reaped, but they can be reparented to\n\t * us and thus we need to ensure that pid->child_reaper stays valid\n\t * until they all go away. See free_pid()->wake_up_process().\n\t *\n\t * We rely on ignored SIGCHLD, an injected zombie must be autoreaped\n\t * if reparented.\n\t */\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (pid_ns->pid_allocated == init_pids)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (pid_ns->reboot)\n\t\tcurrent->signal->group_exit_code = pid_ns->reboot;\n\n\tacct_exit_ns(pid_ns);\n\treturn;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid zap_pid_ns_processes(struct pid_namespace *pid_ns)\n{\n\tint nr;\n\tint rc;\n\tstruct task_struct *task, *me = current;\n\tint init_pids = thread_group_leader(me) ? 1 : 2;\n\tstruct pid *pid;\n\n\t/* Don't allow any more processes into the pid namespace */\n\tdisable_pid_allocation(pid_ns);\n\n\t/*\n\t * Ignore SIGCHLD causing any terminated children to autoreap.\n\t * This speeds up the namespace shutdown, plus see the comment\n\t * below.\n\t */\n\tspin_lock_irq(&me->sighand->siglock);\n\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;\n\tspin_unlock_irq(&me->sighand->siglock);\n\n\t/*\n\t * The last thread in the cgroup-init thread group is terminating.\n\t * Find remaining pid_ts in the namespace, signal and wait for them\n\t * to exit.\n\t *\n\t * Note:  This signals each threads in the namespace - even those that\n\t * \t  belong to the same thread group, To avoid this, we would have\n\t * \t  to walk the entire tasklist looking a processes in this\n\t * \t  namespace, but that could be unnecessarily expensive if the\n\t * \t  pid namespace has just a few processes. Or we need to\n\t * \t  maintain a tasklist for each pid namespace.\n\t *\n\t */\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tnr = 2;\n\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {\n\t\ttask = pid_task(pid, PIDTYPE_PID);\n\t\tif (task && !__fatal_signal_pending(task))\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);\n\t}\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\t/*\n\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.\n\t * kernel_wait4() will also block until our children traced from the\n\t * parent namespace are detached and become EXIT_DEAD.\n\t */\n\tdo {\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);\n\t} while (rc != -ECHILD);\n\n\t/*\n\t * kernel_wait4() above can't reap the EXIT_DEAD children but we do not\n\t * really care, we could reparent them to the global init. We could\n\t * exit and reap ->child_reaper even if it is not the last thread in\n\t * this pid_ns, free_pid(pid_allocated == 0) calls proc_cleanup_work(),\n\t * pid_ns can not go away until proc_kill_sb() drops the reference.\n\t *\n\t * But this ns can also have other tasks injected by setns()+fork().\n\t * Again, ignoring the user visible semantics we do not really need\n\t * to wait until they are all reaped, but they can be reparented to\n\t * us and thus we need to ensure that pid->child_reaper stays valid\n\t * until they all go away. See free_pid()->wake_up_process().\n\t *\n\t * We rely on ignored SIGCHLD, an injected zombie must be autoreaped\n\t * if reparented.\n\t */\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (pid_ns->pid_allocated == init_pids)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (pid_ns->reboot)\n\t\tcurrent->signal->group_exit_code = pid_ns->reboot;\n\n\tacct_exit_ns(pid_ns);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Attempted to kill init! exitcode=0x%08x\\n\"",
            "father->signal->group_exit_code ?: father->exit_code"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "135-307",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\tprintk_safe_flush_on_panic();\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\t/* Call flush even twice. It tries harder with a single online CPU */\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tbust_spinlocks(0);\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\t{\n\t\tunsigned long caller;\n\n\t\tcaller = (unsigned long)__builtin_return_address(0);\n\t\tdisabled_wait(caller);\n\t}\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\tprintk_safe_flush_on_panic();\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\t/* Call flush even twice. It tries harder with a single online CPU */\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tbust_spinlocks(0);\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\t{\n\t\tunsigned long caller;\n\n\t\tcaller = (unsigned long)__builtin_return_address(0);\n\t\tdisabled_wait(caller);\n\t}\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pid_ns == &init_pid_ns"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "334-337",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_alive_thread",
          "args": [
            "father"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "find_alive_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "550-559",
          "snippet": "static struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "reaper != father"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "father"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&tasklist_lock"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&tasklist_lock"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_child_reaper(struct task_struct *father)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (unlikely(pid_ns == &init_pid_ns)) {\n\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\tfather->signal->group_exit_code ?: father->exit_code);\n\t}\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}"
  },
  {
    "function_name": "find_alive_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "550-559",
    "snippet": "static struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "exit_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "495-548",
    "snippet": "static void exit_mm(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct core_state *core_state;\n\n\tmm_release(current, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold mmap_sem around checking core_state\n\t * and clearing tsk->mm.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group with ->mm != NULL.\n\t */\n\tdown_read(&mm->mmap_sem);\n\tcore_state = mm->core_state;\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tup_read(&mm->mmap_sem);\n\n\t\tself.task = current;\n\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\tmmgrab(mm);\n\tBUG_ON(mm != current->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(current);\n\tcurrent->mm = NULL;\n\tup_read(&mm->mmap_sem);\n\tenter_lazy_tlb(mm, current);\n\ttask_unlock(current);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(TIF_MEMDIE))\n\t\texit_oom_victim();\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_oom_victim",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_MEMDIE"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1079-1085",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_update_next_owner",
          "args": [
            "mm"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "mm_update_next_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "407-488",
          "snippet": "void mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t/*\n\t * If the exiting or execing task is not the owner, it's\n\t * someone else's problem.\n\t */\n\tif (mm->owner != p)\n\t\treturn;\n\t/*\n\t * The current owner is exiting/execing and there are no other\n\t * candidates.  Do not leave the mm pointing to a possibly\n\t * freed task structure.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tmm->owner = NULL;\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else, we should not get here often.\n\t */\n\tfor_each_process(g) {\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.\n\t */\n\tmm->owner = NULL;\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\t/*\n\t * Delay read_unlock() till we have the task_lock()\n\t * to ensure that c does not slip away underneath us\n\t */\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tmm->owner = c;\n\ttask_unlock(c);\n\tput_task_struct(c);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t/*\n\t * If the exiting or execing task is not the owner, it's\n\t * someone else's problem.\n\t */\n\tif (mm->owner != p)\n\t\treturn;\n\t/*\n\t * The current owner is exiting/execing and there are no other\n\t * candidates.  Do not leave the mm pointing to a possibly\n\t * freed task structure.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tmm->owner = NULL;\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else, we should not get here often.\n\t */\n\tfor_each_process(g) {\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.\n\t */\n\tmm->owner = NULL;\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\t/*\n\t * Delay read_unlock() till we have the task_lock()\n\t * to ensure that c does not slip away underneath us\n\t */\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tmm->owner = c;\n\ttask_unlock(c);\n\tput_task_struct(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_lazy_tlb",
          "args": [
            "mm",
            "current"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mm != current->active_mm"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "mm"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&core_state->startup"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&core_state->nr_threads"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&core_state->dumper.next",
            "&self"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "mm"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_release",
          "args": [
            "current",
            "mm"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "mm_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1250-1298",
          "snippet": "void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\t/* Get rid of any futexes when releasing the mm */\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list)) {\n\t\texit_robust_list(tsk);\n\t\ttsk->robust_list = NULL;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list)) {\n\t\tcompat_exit_robust_list(tsk);\n\t\ttsk->compat_robust_list = NULL;\n\t}\n#endif\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n#endif\n\n\tuprobe_free_utask(tsk);\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/*\n\t * Signal userspace if we're not exiting with a core dump\n\t * because we want to leave the value intact for debugging\n\t * purposes.\n\t */\n\tif (tsk->clear_child_tid) {\n\t\tif (!(tsk->signal->flags & SIGNAL_GROUP_COREDUMP) &&\n\t\t    atomic_read(&mm->mm_users) > 1) {\n\t\t\t/*\n\t\t\t * We don't check the error code - if userspace has\n\t\t\t * not set up a proper pointer then tough luck.\n\t\t\t */\n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tdo_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n\n\t/*\n\t * All done, finally we can wake up parent and return this mm to him.\n\t * Also kthread_stop() uses this completion for synchronization.\n\t */\n\tif (tsk->vfork_done)\n\t\tcomplete_vfork_done(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\t/* Get rid of any futexes when releasing the mm */\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list)) {\n\t\texit_robust_list(tsk);\n\t\ttsk->robust_list = NULL;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list)) {\n\t\tcompat_exit_robust_list(tsk);\n\t\ttsk->compat_robust_list = NULL;\n\t}\n#endif\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n#endif\n\n\tuprobe_free_utask(tsk);\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/*\n\t * Signal userspace if we're not exiting with a core dump\n\t * because we want to leave the value intact for debugging\n\t * purposes.\n\t */\n\tif (tsk->clear_child_tid) {\n\t\tif (!(tsk->signal->flags & SIGNAL_GROUP_COREDUMP) &&\n\t\t    atomic_read(&mm->mm_users) > 1) {\n\t\t\t/*\n\t\t\t * We don't check the error code - if userspace has\n\t\t\t * not set up a proper pointer then tough luck.\n\t\t\t */\n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tdo_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n\n\t/*\n\t * All done, finally we can wake up parent and return this mm to him.\n\t * Also kthread_stop() uses this completion for synchronization.\n\t */\n\tif (tsk->vfork_done)\n\t\tcomplete_vfork_done(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void exit_mm(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct core_state *core_state;\n\n\tmm_release(current, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold mmap_sem around checking core_state\n\t * and clearing tsk->mm.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group with ->mm != NULL.\n\t */\n\tdown_read(&mm->mmap_sem);\n\tcore_state = mm->core_state;\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tup_read(&mm->mmap_sem);\n\n\t\tself.task = current;\n\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\tmmgrab(mm);\n\tBUG_ON(mm != current->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(current);\n\tcurrent->mm = NULL;\n\tup_read(&mm->mmap_sem);\n\tenter_lazy_tlb(mm, current);\n\ttask_unlock(current);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(TIF_MEMDIE))\n\t\texit_oom_victim();\n}"
  },
  {
    "function_name": "mm_update_next_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "407-488",
    "snippet": "void mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t/*\n\t * If the exiting or execing task is not the owner, it's\n\t * someone else's problem.\n\t */\n\tif (mm->owner != p)\n\t\treturn;\n\t/*\n\t * The current owner is exiting/execing and there are no other\n\t * candidates.  Do not leave the mm pointing to a possibly\n\t * freed task structure.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tmm->owner = NULL;\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else, we should not get here often.\n\t */\n\tfor_each_process(g) {\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.\n\t */\n\tmm->owner = NULL;\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\t/*\n\t * Delay read_unlock() till we have the task_lock()\n\t * to ensure that c does not slip away underneath us\n\t */\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tmm->owner = c;\n\ttask_unlock(c);\n\tput_task_struct(c);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "c"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "175-182",
          "snippet": "static void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "c"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "c"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "c"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "c"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "c == p"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "g",
            "c"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "c",
            "&p->real_parent->children",
            "sibling"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "c",
            "&p->children",
            "sibling"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t/*\n\t * If the exiting or execing task is not the owner, it's\n\t * someone else's problem.\n\t */\n\tif (mm->owner != p)\n\t\treturn;\n\t/*\n\t * The current owner is exiting/execing and there are no other\n\t * candidates.  Do not leave the mm pointing to a possibly\n\t * freed task structure.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tmm->owner = NULL;\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else, we should not get here often.\n\t */\n\tfor_each_process(g) {\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.\n\t */\n\tmm->owner = NULL;\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\t/*\n\t * Delay read_unlock() till we have the task_lock()\n\t * to ensure that c does not slip away underneath us\n\t */\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tmm->owner = c;\n\ttask_unlock(c);\n\tput_task_struct(c);\n}"
  },
  {
    "function_name": "kill_orphaned_pgrp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "377-401",
    "snippet": "static void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kill_pgrp_info",
          "args": [
            "SIGCONT",
            "SEND_SIG_PRIV",
            "pgrp"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "__kill_pgrp_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1339-1352",
          "snippet": "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_stopped_jobs",
          "args": [
            "pgrp"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "has_stopped_jobs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "360-370",
          "snippet": "static bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "will_become_orphaned_pgrp",
          "args": [
            "pgrp",
            "ignored_task"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "will_become_orphaned_pgrp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "330-347",
          "snippet": "static int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "tsk"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "parent"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "parent"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "tsk"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}"
  },
  {
    "function_name": "has_stopped_jobs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "360-370",
    "snippet": "static bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn false;\n}"
  },
  {
    "function_name": "is_current_pgrp_orphaned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "349-358",
    "snippet": "int is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "will_become_orphaned_pgrp",
          "args": [
            "task_pgrp(current)",
            "NULL"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "will_become_orphaned_pgrp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "330-347",
          "snippet": "static int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "current"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "will_become_orphaned_pgrp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "330-347",
    "snippet": "static int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "p"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "p->real_parent"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "p->real_parent"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "p->real_parent"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "p"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "rcuwait_wake_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "293-320",
    "snippet": "void rcuwait_wake_up(struct rcuwait *w)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_trywake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_rmb(); /* (B) */\n\n\t/*\n\t * Avoid using task_rcu_dereference() magic as long as we are careful,\n\t * see comment in rcuwait_wait_event() regarding ->exit_state.\n\t */\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\twake_up_process(task);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "w->task"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid rcuwait_wake_up(struct rcuwait *w)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_trywake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_rmb(); /* (B) */\n\n\t/*\n\t * Avoid using task_rcu_dereference() magic as long as we are careful,\n\t * see comment in rcuwait_wait_event() regarding ->exit_state.\n\t */\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\twake_up_process(task);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "task_rcu_dereference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "234-291",
    "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task != READ_ONCE(*ptask)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*ptask"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_address",
          "args": [
            "&task->sighand",
            "sighand"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*ptask"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
  },
  {
    "function_name": "release_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "185-228",
    "snippet": "void release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tatomic_dec(&__task_cred(p)->user->processes);\n\trcu_read_unlock();\n\n\tproc_flush_task(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "zap_leader"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&p->rcu",
            "delayed_put_task_struct"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_thread",
          "args": [
            "p"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "arch_release_thread_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "167-169",
          "snippet": "void __weak arch_release_thread_stack(unsigned long *stack)\n{\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nvoid __weak arch_release_thread_stack(unsigned long *stack)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "334-337",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "leader",
            "leader->exit_signal"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1767-1856",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "leader"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__exit_signal",
          "args": [
            "p"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__exit_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "91-173",
          "snippet": "static void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *uninitialized_var(tty);\n\tu64 utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead) {\n\t\tposix_cpu_timers_exit_group(tsk);\n\t} else {\n\t\t/*\n\t\t * This can only happen if the caller is de_thread().\n\t\t * FIXME: this is the temporary hack, we should teach\n\t\t * posix-cpu-timers to handle this case correctly.\n\t\t */\n\t\tif (unlikely(has_group_leader_pid(tsk)))\n\t\t\tposix_cpu_timers_exit_group(tsk);\n\t}\n#endif\n\n\tif (group_dead) {\n\t\ttty = sig->tty;\n\t\tsig->tty = NULL;\n\t} else {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exit_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t      sizeof(unsigned long long));\n\n\t/*\n\t * Accumulate here the counters for all threads as they die. We could\n\t * skip the group leader because it is the last user of signal_struct,\n\t * but we want to avoid the race with thread_group_cputime() which can\n\t * see the empty ->thread_head list.\n\t */\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *uninitialized_var(tty);\n\tu64 utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead) {\n\t\tposix_cpu_timers_exit_group(tsk);\n\t} else {\n\t\t/*\n\t\t * This can only happen if the caller is de_thread().\n\t\t * FIXME: this is the temporary hack, we should teach\n\t\t * posix-cpu-timers to handle this case correctly.\n\t\t */\n\t\tif (unlikely(has_group_leader_pid(tsk)))\n\t\t\tposix_cpu_timers_exit_group(tsk);\n\t}\n#endif\n\n\tif (group_dead) {\n\t\ttty = sig->tty;\n\t\tsig->tty = NULL;\n\t} else {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exit_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t      sizeof(unsigned long long));\n\n\t/*\n\t * Accumulate here the counters for all threads as they die. We could\n\t * skip the group leader because it is the last user of signal_struct,\n\t * but we want to avoid the race with thread_group_cputime() which can\n\t * see the empty ->thread_head list.\n\t */\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_release_task",
          "args": [
            "p"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "302-305",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_flush_task",
          "args": [
            "p"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&__task_cred(p)->user->processes"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "p"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tatomic_dec(&__task_cred(p)->user->processes);\n\trcu_read_unlock();\n\n\tproc_flush_task(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}"
  },
  {
    "function_name": "delayed_put_task_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "175-182",
    "snippet": "static void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tsk"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "175-182",
          "snippet": "static void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_process_free",
          "args": [
            "tsk"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_delayed_put",
          "args": [
            "tsk"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_delayed_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "11228-11234",
          "snippet": "void perf_event_delayed_put(struct task_struct *task)\n{\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn)\n\t\tWARN_ON_ONCE(task->perf_event_ctxp[ctxn]);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static __must_check struct",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic __must_check struct;\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\n\nvoid perf_event_delayed_put(struct task_struct *task)\n{\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn)\n\t\tWARN_ON_ONCE(task->perf_event_ctxp[ctxn]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structtask_struct",
            "rcu"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}"
  },
  {
    "function_name": "__exit_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "91-173",
    "snippet": "static void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *uninitialized_var(tty);\n\tu64 utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead) {\n\t\tposix_cpu_timers_exit_group(tsk);\n\t} else {\n\t\t/*\n\t\t * This can only happen if the caller is de_thread().\n\t\t * FIXME: this is the temporary hack, we should teach\n\t\t * posix-cpu-timers to handle this case correctly.\n\t\t */\n\t\tif (unlikely(has_group_leader_pid(tsk)))\n\t\t\tposix_cpu_timers_exit_group(tsk);\n\t}\n#endif\n\n\tif (group_dead) {\n\t\ttty = sig->tty;\n\t\tsig->tty = NULL;\n\t} else {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exit_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t      sizeof(unsigned long long));\n\n\t/*\n\t * Accumulate here the counters for all threads as they die. We could\n\t * skip the group leader because it is the last user of signal_struct,\n\t * but we want to avoid the race with thread_group_cputime() which can\n\t * see the empty ->thread_head list.\n\t */\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tty_kref_put",
          "args": [
            "tty"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_sigqueue",
          "args": [
            "&sig->shared_pending"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "445-455",
          "snippet": "void flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "tsk",
            "TIF_SIGPENDING"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cleanup_sighand",
          "args": [
            "sighand"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__cleanup_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1479-1489",
          "snippet": "void __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (atomic_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t/*\n\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it\n\t\t * without an RCU grace period, see __lock_task_sighand().\n\t\t */\n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *sighand_cachep;",
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *sighand_cachep;\nstatic __latent_entropy struct;\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (atomic_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t/*\n\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it\n\t\t * without an RCU grace period, see __lock_task_sighand().\n\t\t */\n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sighand->siglock"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&sig->stats_lock"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unhash_process",
          "args": [
            "tsk",
            "group_dead"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__unhash_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "71-86",
          "snippet": "static void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (group_dead) {\n\t\tdetach_pid(p, PIDTYPE_TGID);\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (group_dead) {\n\t\tdetach_pid(p, PIDTYPE_TGID);\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_io_accounting_add",
          "args": [
            "&sig->ioac",
            "&tsk->ioac"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_get_oublock",
          "args": [
            "tsk"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_get_inblock",
          "args": [
            "tsk"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_gtime",
          "args": [
            "tsk"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "task_gtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "835-854",
          "snippet": "u64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_SYS && t->flags & PF_VCPU)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nu64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_SYS && t->flags & PF_VCPU)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&sig->stats_lock"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_device_randomness",
          "args": [
            "(const void*) &tsk->se.sum_exec_runtime",
            "sizeof(unsigned long long)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_thread",
          "args": [
            "tsk"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "sig->group_exit_task"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_cpu_timers_exit_group",
          "args": [
            "tsk"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timers_exit_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "436-439",
          "snippet": "void posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->signal->cpu_timers);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->signal->cpu_timers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "has_group_leader_pid(tsk)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_group_leader_pid",
          "args": [
            "tsk"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sighand->siglock"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "tsk->sighand",
            "lockdep_tasklist_lock_is_held()"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_tasklist_lock_is_held",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_tasklist_lock_is_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "131-134",
          "snippet": "int lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);\n\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *uninitialized_var(tty);\n\tu64 utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead) {\n\t\tposix_cpu_timers_exit_group(tsk);\n\t} else {\n\t\t/*\n\t\t * This can only happen if the caller is de_thread().\n\t\t * FIXME: this is the temporary hack, we should teach\n\t\t * posix-cpu-timers to handle this case correctly.\n\t\t */\n\t\tif (unlikely(has_group_leader_pid(tsk)))\n\t\t\tposix_cpu_timers_exit_group(tsk);\n\t}\n#endif\n\n\tif (group_dead) {\n\t\ttty = sig->tty;\n\t\tsig->tty = NULL;\n\t} else {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exit_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t      sizeof(unsigned long long));\n\n\t/*\n\t * Accumulate here the counters for all threads as they die. We could\n\t * skip the group leader because it is the last user of signal_struct,\n\t * but we want to avoid the race with thread_group_cputime() which can\n\t * see the empty ->thread_head list.\n\t */\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}"
  },
  {
    "function_name": "__unhash_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "71-86",
    "snippet": "static void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (group_dead) {\n\t\tdetach_pid(p, PIDTYPE_TGID);\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->thread_node"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->thread_group"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "process_counts"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->sibling"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->tasks"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "detach_pid",
          "args": [
            "p",
            "PIDTYPE_SID"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "detach_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "303-306",
          "snippet": "void detach_pid(struct task_struct *task, enum pid_type type)\n{\n\t__change_pid(task, type, NULL);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid detach_pid(struct task_struct *task, enum pid_type type)\n{\n\t__change_pid(task, type, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (group_dead) {\n\t\tdetach_pid(p, PIDTYPE_TGID);\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}"
  },
  {
    "function_name": "exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "937-940",
    "snippet": "SYSCALL_DEFINE1(exit, int, error_code)\n{\n\tdo_exit((error_code&0xff)<<8);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE1(exit, int, error_code)\n{\n\tdo_exit((error_code&0xff)<<8);\n}"
  },
  {
    "function_name": "exit_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "979-984",
    "snippet": "SYSCALL_DEFINE1(exit_group, int, error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n\t/* NOTREACHED */\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE1(exit_group, int, error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n\t/* NOTREACHED */\n\treturn 0;\n}"
  },
  {
    "function_name": "waitid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1590-1622",
    "snippet": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\n\tif (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\n\tif (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "wait4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1667-1678",
    "snippet": "SYSCALL_DEFINE4(wait4, pid_t, upid, int __user *, stat_addr,\n\t\tint, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tlong err = kernel_wait4(upid, stat_addr, options, ru ? &r : NULL);\n\n\tif (err > 0) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE4(wait4, pid_t, upid, int __user *, stat_addr,\n\t\tint, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tlong err = kernel_wait4(upid, stat_addr, options, ru ? &r : NULL);\n\n\tif (err > 0) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "waitpid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1686-1689",
    "snippet": "SYSCALL_DEFINE3(waitpid, pid_t, pid, int __user *, stat_addr, int, options)\n{\n\treturn kernel_wait4(pid, stat_addr, options, NULL);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(waitpid, pid_t, pid, int __user *, stat_addr, int, options)\n{\n\treturn kernel_wait4(pid, stat_addr, options, NULL);\n}"
  },
  {
    "function_name": "wait4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1694-1707",
    "snippet": "SYSCALL_DEFINE4(wait4,\n\tcompat_pid_t, pid,\n\tcompat_uint_t __user *, stat_addr,\n\tint, options,\n\tstruct compat_rusage __user *, ru)\n{\n\tstruct rusage r;\n\tlong err = kernel_wait4(pid, stat_addr, options, ru ? &r : NULL);\n\tif (err > 0) {\n\t\tif (ru && put_compat_rusage(&r, ru))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE4(wait4,\n\tcompat_pid_t, pid,\n\tcompat_uint_t __user *, stat_addr,\n\tint, options,\n\tstruct compat_rusage __user *, ru)\n{\n\tstruct rusage r;\n\tlong err = kernel_wait4(pid, stat_addr, options, ru ? &r : NULL);\n\tif (err > 0) {\n\t\tif (ru && put_compat_rusage(&r, ru))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "waitid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
    "lines": "1709-1750",
    "snippet": "SYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (uru) {\n\t\t\t/* kernel_waitid() overwrites everything in ru */\n\t\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\t\telse\n\t\t\t\terr = put_compat_rusage(&ru, uru);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (!infop)\n\t\treturn err;\n\n\tif (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (uru) {\n\t\t\t/* kernel_waitid() overwrites everything in ru */\n\t\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\t\telse\n\t\t\t\terr = put_compat_rusage(&ru, uru);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (!infop)\n\t\treturn err;\n\n\tif (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}"
  }
]