[
  {
    "function_name": "pm_wake_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "248-282",
    "snippet": "int pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(&wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wakelocks_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakelocks_gc",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "147-147",
          "snippet": "static inline void wakelocks_gc(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_gc(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "wakelocks_lru_most_recent",
          "args": [
            "wl"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_lru_most_recent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "146-146",
          "snippet": "static inline void wakelocks_lru_most_recent(struct wakelock *wl) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl) {}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "&wl->ws"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "wl"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "wl"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelock_lookup_add",
          "args": [
            "buf",
            "len",
            "false"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "wakelock_lookup_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "150-198",
          "snippet": "static struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws.name = wl->name;\n\twl->ws.last_time = ktime_get();\n\twakeup_source_add(&wl->ws);\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root wakelocks_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nstatic struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws.name = wl->name;\n\twl->ws.last_time = ktime_get();\n\twakeup_source_add(&wl->ws);\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_BLOCK_SUSPEND"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nint pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(&wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "pm_wake_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "200-246",
    "snippet": "int pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t/* Find out if there's a valid timeout string appended. */\n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(&wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(&wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wakelocks_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakelocks_lru_most_recent",
          "args": [
            "wl"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_lru_most_recent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "146-146",
          "snippet": "static inline void wakelocks_lru_most_recent(struct wakelock *wl) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl) {}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "&wl->ws"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_wakeup_event",
          "args": [
            "&wl->ws",
            "timeout_ms"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "timeout_ms",
            "NSEC_PER_MSEC"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "wl"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "wl"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelock_lookup_add",
          "args": [
            "buf",
            "len",
            "true"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "wakelock_lookup_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "150-198",
          "snippet": "static struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws.name = wl->name;\n\twl->ws.last_time = ktime_get();\n\twakeup_source_add(&wl->ws);\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root wakelocks_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nstatic struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws.name = wl->name;\n\twl->ws.last_time = ktime_get();\n\twakeup_source_add(&wl->ws);\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtou64",
          "args": [
            "skip_spaces(str)",
            "10",
            "&timeout_ns"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "str"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "2061-2068",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*str"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_BLOCK_SUSPEND"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nint pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t/* Find out if there's a valid timeout string appended. */\n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(&wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(&wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "wakelock_lookup_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "150-198",
    "snippet": "static struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws.name = wl->name;\n\twl->ws.last_time = ktime_get();\n\twakeup_source_add(&wl->ws);\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root wakelocks_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "increment_wakelocks_number",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "increment_wakelocks_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "80-80",
          "snippet": "static inline void increment_wakelocks_number(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void increment_wakelocks_number(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "wakelocks_lru_add",
          "args": [
            "wl"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_lru_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "145-145",
          "snippet": "static inline void wakelocks_lru_add(struct wakelock *wl) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_add(struct wakelock *wl) {}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&wl->node",
            "&wakelocks_tree"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&wl->node",
            "parent",
            "node"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_add",
          "args": [
            "&wl->ws"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wl"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "name",
            "len",
            "GFP_KERNEL"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wl)",
            "GFP_KERNEL"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelocks_limit_exceeded",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "wakelocks_limit_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "79-79",
          "snippet": "static inline bool wakelocks_limit_exceeded(void) { return false; }",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline bool wakelocks_limit_exceeded(void) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "wl->name",
            "len"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*node",
            "structwakelock",
            "node"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nstatic struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* Not found, we have to add a new one. */\n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws.name = wl->name;\n\twl->ws.last_time = ktime_get();\n\twakeup_source_add(&wl->ws);\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}"
  },
  {
    "function_name": "wakelocks_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "147-147",
    "snippet": "static inline void wakelocks_gc(void) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_gc(void) {}"
  },
  {
    "function_name": "wakelocks_lru_most_recent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "146-146",
    "snippet": "static inline void wakelocks_lru_most_recent(struct wakelock *wl) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl) {}"
  },
  {
    "function_name": "wakelocks_lru_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "145-145",
    "snippet": "static inline void wakelocks_lru_add(struct wakelock *wl) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_add(struct wakelock *wl) {}"
  },
  {
    "function_name": "wakelocks_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "137-143",
    "snippet": "static void wakelocks_gc(void)\n{\n\tif (++wakelocks_gc_count <= WL_GC_COUNT_MAX)\n\t\treturn;\n\n\tschedule_work(&wakelock_work);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define WL_GC_COUNT_MAX\t100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&wakelock_work"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\n#define WL_GC_COUNT_MAX\t100\n\nstatic void wakelocks_gc(void)\n{\n\tif (++wakelocks_gc_count <= WL_GC_COUNT_MAX)\n\t\treturn;\n\n\tschedule_work(&wakelock_work);\n}"
  },
  {
    "function_name": "__wakelocks_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "103-135",
    "snippet": "static void __wakelocks_gc(struct work_struct *work)\n{\n\tstruct wakelock *wl, *aux;\n\tktime_t now;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tnow = ktime_get();\n\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {\n\t\tu64 idle_time_ns;\n\t\tbool active;\n\n\t\tspin_lock_irq(&wl->ws.lock);\n\t\tidle_time_ns = ktime_to_ns(ktime_sub(now, wl->ws.last_time));\n\t\tactive = wl->ws.active;\n\t\tspin_unlock_irq(&wl->ws.lock);\n\n\t\tif (idle_time_ns < ((u64)WL_GC_TIME_SEC * NSEC_PER_SEC))\n\t\t\tbreak;\n\n\t\tif (!active) {\n\t\t\twakeup_source_remove(&wl->ws);\n\t\t\trb_erase(&wl->node, &wakelocks_tree);\n\t\t\tlist_del(&wl->lru);\n\t\t\tkfree(wl->name);\n\t\t\tkfree(wl);\n\t\t\tdecrement_wakelocks_number();\n\t\t}\n\t}\n\twakelocks_gc_count = 0;\n\n\tmutex_unlock(&wakelocks_lock);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define WL_GC_TIME_SEC\t300"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(wakelocks_lock);",
      "static struct rb_root wakelocks_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decrement_wakelocks_number",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "decrement_wakelocks_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "81-81",
          "snippet": "static inline void decrement_wakelocks_number(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void decrement_wakelocks_number(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wl"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&wl->lru"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&wl->node",
            "&wakelocks_tree"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_remove",
          "args": [
            "&wl->ws"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&wl->ws.lock"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(now, wl->ws.last_time)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "wl->ws.last_time"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&wl->ws.lock"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "wl",
            "aux",
            "&wakelocks_lru_list",
            "lru"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\n#define WL_GC_TIME_SEC\t300\n\nstatic DEFINE_MUTEX(wakelocks_lock);\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nstatic void __wakelocks_gc(struct work_struct *work)\n{\n\tstruct wakelock *wl, *aux;\n\tktime_t now;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tnow = ktime_get();\n\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {\n\t\tu64 idle_time_ns;\n\t\tbool active;\n\n\t\tspin_lock_irq(&wl->ws.lock);\n\t\tidle_time_ns = ktime_to_ns(ktime_sub(now, wl->ws.last_time));\n\t\tactive = wl->ws.active;\n\t\tspin_unlock_irq(&wl->ws.lock);\n\n\t\tif (idle_time_ns < ((u64)WL_GC_TIME_SEC * NSEC_PER_SEC))\n\t\t\tbreak;\n\n\t\tif (!active) {\n\t\t\twakeup_source_remove(&wl->ws);\n\t\t\trb_erase(&wl->node, &wakelocks_tree);\n\t\t\tlist_del(&wl->lru);\n\t\t\tkfree(wl->name);\n\t\t\tkfree(wl);\n\t\t\tdecrement_wakelocks_number();\n\t\t}\n\t}\n\twakelocks_gc_count = 0;\n\n\tmutex_unlock(&wakelocks_lock);\n}"
  },
  {
    "function_name": "wakelocks_lru_most_recent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "98-101",
    "snippet": "static inline void wakelocks_lru_most_recent(struct wakelock *wl)\n{\n\tlist_move(&wl->lru, &wakelocks_lru_list);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&wl->lru",
            "&wakelocks_lru_list"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl)\n{\n\tlist_move(&wl->lru, &wakelocks_lru_list);\n}"
  },
  {
    "function_name": "wakelocks_lru_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "93-96",
    "snippet": "static inline void wakelocks_lru_add(struct wakelock *wl)\n{\n\tlist_add(&wl->lru, &wakelocks_lru_list);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&wl->lru",
            "&wakelocks_lru_list"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void wakelocks_lru_add(struct wakelock *wl)\n{\n\tlist_add(&wl->lru, &wakelocks_lru_list);\n}"
  },
  {
    "function_name": "decrement_wakelocks_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "81-81",
    "snippet": "static inline void decrement_wakelocks_number(void) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void decrement_wakelocks_number(void) {}"
  },
  {
    "function_name": "increment_wakelocks_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "80-80",
    "snippet": "static inline void increment_wakelocks_number(void) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void increment_wakelocks_number(void) {}"
  },
  {
    "function_name": "wakelocks_limit_exceeded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "79-79",
    "snippet": "static inline bool wakelocks_limit_exceeded(void) { return false; }",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline bool wakelocks_limit_exceeded(void) { return false; }"
  },
  {
    "function_name": "decrement_wakelocks_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "74-77",
    "snippet": "static inline void decrement_wakelocks_number(void)\n{\n\tnumber_of_wakelocks--;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void decrement_wakelocks_number(void)\n{\n\tnumber_of_wakelocks--;\n}"
  },
  {
    "function_name": "increment_wakelocks_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "69-72",
    "snippet": "static inline void increment_wakelocks_number(void)\n{\n\tnumber_of_wakelocks++;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void increment_wakelocks_number(void)\n{\n\tnumber_of_wakelocks++;\n}"
  },
  {
    "function_name": "wakelocks_limit_exceeded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "64-67",
    "snippet": "static inline bool wakelocks_limit_exceeded(void)\n{\n\treturn number_of_wakelocks > CONFIG_PM_WAKELOCKS_LIMIT;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline bool wakelocks_limit_exceeded(void)\n{\n\treturn number_of_wakelocks > CONFIG_PM_WAKELOCKS_LIMIT;\n}"
  },
  {
    "function_name": "pm_show_wakelocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
    "lines": "38-59",
    "snippet": "ssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws.active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/list.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wakelocks_lock);",
      "static struct rb_root wakelocks_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "str",
            "end - str",
            "\"\\n\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "str",
            "end - str",
            "\"%s \"",
            "wl->name"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structwakelock",
            "node"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&wakelocks_tree"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wakelocks_lock"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws.active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}"
  }
]