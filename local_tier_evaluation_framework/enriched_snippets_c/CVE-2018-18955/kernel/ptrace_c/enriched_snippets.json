[
  {
    "function_name": "compat_ptrace_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "1188-1264",
    "snippet": "int compat_ptrace_request(struct task_struct *child, compat_long_t request,\n\t\t\t  compat_ulong_t addr, compat_ulong_t data)\n{\n\tcompat_ulong_t __user *datap = compat_ptr(data);\n\tcompat_ulong_t word;\n\tkernel_siginfo_t siginfo;\n\tint ret;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\tret = ptrace_access_vm(child, addr, &word, sizeof(word),\n\t\t\t\tFOLL_FORCE);\n\t\tif (ret != sizeof(word))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = put_user(word, datap);\n\t\tbreak;\n\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\tret = ptrace_access_vm(child, addr, &data, sizeof(data),\n\t\t\t\tFOLL_FORCE | FOLL_WRITE);\n\t\tret = (ret != sizeof(data) ? -EIO : 0);\n\t\tbreak;\n\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user((compat_ulong_t) child->ptrace_message, datap);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user32(\n\t\t\t\t(struct compat_siginfo __user *) datap,\n\t\t\t\t&siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tret = copy_siginfo_from_user32(\n\t\t\t&siginfo, (struct compat_siginfo __user *) datap);\n\t\tif (!ret)\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET:\n\t{\n\t\tstruct iovec kiov;\n\t\tstruct compat_iovec __user *uiov =\n\t\t\t(struct compat_iovec __user *) datap;\n\t\tcompat_uptr_t ptr;\n\t\tcompat_size_t len;\n\n\t\tif (!access_ok(VERIFY_WRITE, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(ptr, &uiov->iov_base) ||\n\t\t    __get_user(len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tkiov.iov_base = compat_ptr(ptr);\n\t\tkiov.iov_len = len;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_request",
          "args": [
            "child",
            "request",
            "addr",
            "data"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "compat_ptrace_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "1188-1264",
          "snippet": "int compat_ptrace_request(struct task_struct *child, compat_long_t request,\n\t\t\t  compat_ulong_t addr, compat_ulong_t data)\n{\n\tcompat_ulong_t __user *datap = compat_ptr(data);\n\tcompat_ulong_t word;\n\tkernel_siginfo_t siginfo;\n\tint ret;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\tret = ptrace_access_vm(child, addr, &word, sizeof(word),\n\t\t\t\tFOLL_FORCE);\n\t\tif (ret != sizeof(word))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = put_user(word, datap);\n\t\tbreak;\n\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\tret = ptrace_access_vm(child, addr, &data, sizeof(data),\n\t\t\t\tFOLL_FORCE | FOLL_WRITE);\n\t\tret = (ret != sizeof(data) ? -EIO : 0);\n\t\tbreak;\n\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user((compat_ulong_t) child->ptrace_message, datap);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user32(\n\t\t\t\t(struct compat_siginfo __user *) datap,\n\t\t\t\t&siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tret = copy_siginfo_from_user32(\n\t\t\t&siginfo, (struct compat_siginfo __user *) datap);\n\t\tif (!ret)\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET:\n\t{\n\t\tstruct iovec kiov;\n\t\tstruct compat_iovec __user *uiov =\n\t\t\t(struct compat_iovec __user *) datap;\n\t\tcompat_uptr_t ptr;\n\t\tcompat_size_t len;\n\n\t\tif (!access_ok(VERIFY_WRITE, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(ptr, &uiov->iov_base) ||\n\t\t    __get_user(len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tkiov.iov_base = compat_ptr(ptr);\n\t\tkiov.iov_len = len;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kiov.iov_len",
            "&uiov->iov_len"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_regset",
          "args": [
            "child",
            "request",
            "addr",
            "&kiov"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_regset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "863-883",
          "snippet": "static int ptrace_regset(struct task_struct *task, int req, unsigned int type,\n\t\t\t struct iovec *kiov)\n{\n\tconst struct user_regset_view *view = task_user_regset_view(task);\n\tconst struct user_regset *regset = find_regset(view, type);\n\tint regset_no;\n\n\tif (!regset || (kiov->iov_len % regset->size) != 0)\n\t\treturn -EINVAL;\n\n\tregset_no = regset - view->regsets;\n\tkiov->iov_len = min(kiov->iov_len,\n\t\t\t    (__kernel_size_t) (regset->n * regset->size));\n\n\tif (req == PTRACE_GETREGSET)\n\t\treturn copy_regset_to_user(task, view, regset_no, 0,\n\t\t\t\t\t   kiov->iov_len, kiov->iov_base);\n\telse\n\t\treturn copy_regset_from_user(task, view, regset_no, 0,\n\t\t\t\t\t     kiov->iov_len, kiov->iov_base);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_regset(struct task_struct *task, int req, unsigned int type,\n\t\t\t struct iovec *kiov)\n{\n\tconst struct user_regset_view *view = task_user_regset_view(task);\n\tconst struct user_regset *regset = find_regset(view, type);\n\tint regset_no;\n\n\tif (!regset || (kiov->iov_len % regset->size) != 0)\n\t\treturn -EINVAL;\n\n\tregset_no = regset - view->regsets;\n\tkiov->iov_len = min(kiov->iov_len,\n\t\t\t    (__kernel_size_t) (regset->n * regset->size));\n\n\tif (req == PTRACE_GETREGSET)\n\t\treturn copy_regset_to_user(task, view, regset_no, 0,\n\t\t\t\t\t   kiov->iov_len, kiov->iov_base);\n\telse\n\t\treturn copy_regset_from_user(task, view, regset_no, 0,\n\t\t\t\t\t     kiov->iov_len, kiov->iov_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "ptr"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "len",
            "&uiov->iov_len"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "ptr",
            "&uiov->iov_base"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "uiov",
            "sizeof(*uiov)"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_setsiginfo",
          "args": [
            "child",
            "&siginfo"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_setsiginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "680-694",
          "snippet": "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(child->last_siginfo, info);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(child->last_siginfo, info);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo_from_user32",
          "args": [
            "&siginfo",
            "(struct compat_siginfo __user *) datap"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3149-3158",
          "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_user32",
          "args": [
            "(struct compat_siginfo __user *) datap",
            "&siginfo"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_getsiginfo",
          "args": [
            "child",
            "&siginfo"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_getsiginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "664-678",
          "snippet": "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(info, child->last_siginfo);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(info, child->last_siginfo);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(compat_ulong_t) child->ptrace_message",
            "datap"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_access_vm",
          "args": [
            "child",
            "addr",
            "&data",
            "sizeof(data)",
            "FOLL_FORCE | FOLL_WRITE"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_access_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "38-60",
          "snippet": "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "word",
            "datap"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "data"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint compat_ptrace_request(struct task_struct *child, compat_long_t request,\n\t\t\t  compat_ulong_t addr, compat_ulong_t data)\n{\n\tcompat_ulong_t __user *datap = compat_ptr(data);\n\tcompat_ulong_t word;\n\tkernel_siginfo_t siginfo;\n\tint ret;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\tret = ptrace_access_vm(child, addr, &word, sizeof(word),\n\t\t\t\tFOLL_FORCE);\n\t\tif (ret != sizeof(word))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = put_user(word, datap);\n\t\tbreak;\n\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\tret = ptrace_access_vm(child, addr, &data, sizeof(data),\n\t\t\t\tFOLL_FORCE | FOLL_WRITE);\n\t\tret = (ret != sizeof(data) ? -EIO : 0);\n\t\tbreak;\n\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user((compat_ulong_t) child->ptrace_message, datap);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user32(\n\t\t\t\t(struct compat_siginfo __user *) datap,\n\t\t\t\t&siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tret = copy_siginfo_from_user32(\n\t\t\t&siginfo, (struct compat_siginfo __user *) datap);\n\t\tif (!ret)\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET:\n\t{\n\t\tstruct iovec kiov;\n\t\tstruct compat_iovec __user *uiov =\n\t\t\t(struct compat_iovec __user *) datap;\n\t\tcompat_uptr_t ptr;\n\t\tcompat_size_t len;\n\n\t\tif (!access_ok(VERIFY_WRITE, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(ptr, &uiov->iov_base) ||\n\t\t    __get_user(len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tkiov.iov_base = compat_ptr(ptr);\n\t\tkiov.iov_len = len;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_ptrace_pokedata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "1176-1184",
    "snippet": "int generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &data, sizeof(data),\n\t\t\tFOLL_FORCE | FOLL_WRITE);\n\treturn (copied == sizeof(data)) ? 0 : -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_access_vm",
          "args": [
            "tsk",
            "addr",
            "&data",
            "sizeof(data)",
            "FOLL_FORCE | FOLL_WRITE"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_access_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "38-60",
          "snippet": "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &data, sizeof(data),\n\t\t\tFOLL_FORCE | FOLL_WRITE);\n\treturn (copied == sizeof(data)) ? 0 : -EIO;\n}"
  },
  {
    "function_name": "generic_ptrace_peekdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "1164-1174",
    "snippet": "int generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tunsigned long tmp;\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE);\n\tif (copied != sizeof(tmp))\n\t\treturn -EIO;\n\treturn put_user(tmp, (unsigned long __user *)data);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "tmp",
            "(unsigned long __user *)data"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_access_vm",
          "args": [
            "tsk",
            "addr",
            "&tmp",
            "sizeof(tmp)",
            "FOLL_FORCE"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_access_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "38-60",
          "snippet": "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tunsigned long tmp;\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE);\n\tif (copied != sizeof(tmp))\n\t\treturn -EIO;\n\treturn put_user(tmp, (unsigned long __user *)data);\n}"
  },
  {
    "function_name": "ptrace_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "893-1113",
    "snippet": "int ptrace_request(struct task_struct *child, long request,\n\t\t   unsigned long addr, unsigned long data)\n{\n\tbool seized = child->ptrace & PT_SEIZED;\n\tint ret = -EIO;\n\tkernel_siginfo_t siginfo, *si;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\tunsigned long flags;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\treturn generic_ptrace_peekdata(child, addr, data);\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\treturn generic_ptrace_pokedata(child, addr, data);\n\n#ifdef PTRACE_OLDSETOPTIONS\n\tcase PTRACE_OLDSETOPTIONS:\n#endif\n\tcase PTRACE_SETOPTIONS:\n\t\tret = ptrace_setoptions(child, data);\n\t\tbreak;\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user(child->ptrace_message, datalp);\n\t\tbreak;\n\n\tcase PTRACE_PEEKSIGINFO:\n\t\tret = ptrace_peek_siginfo(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tret = copy_siginfo_from_user(&siginfo, datavp);\n\t\tif (!ret)\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGMASK:\n\t\tif (addr != sizeof(sigset_t)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(datavp, &child->blocked, sizeof(sigset_t)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = 0;\n\n\t\tbreak;\n\n\tcase PTRACE_SETSIGMASK: {\n\t\tsigset_t new_set;\n\n\t\tif (addr != sizeof(sigset_t)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&new_set, datavp, sizeof(sigset_t))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\t/*\n\t\t * Every thread does recalc_sigpending() after resume, so\n\t\t * retarget_shared_pending() and recalc_sigpending() are not\n\t\t * called here.\n\t\t */\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tchild->blocked = new_set;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tcase PTRACE_INTERRUPT:\n\t\t/*\n\t\t * Stop tracee without any side-effect on signal or job\n\t\t * control.  At least one trap is guaranteed to happen\n\t\t * after this request.  If @child is already trapped, the\n\t\t * current trap is not disturbed and another trap will\n\t\t * happen after the current trap is ended with PTRACE_CONT.\n\t\t *\n\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but\n\t\t * the pending condition is cleared regardless.\n\t\t */\n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * INTERRUPT doesn't disturb existing trap sans one\n\t\t * exception.  If ptracer issued LISTEN for the current\n\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap\n\t\t * tracee into STOP.\n\t\t */\n\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))\n\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);\n\n\t\tunlock_task_sighand(child, &flags);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase PTRACE_LISTEN:\n\t\t/*\n\t\t * Listen for events.  Tracee must be in STOP.  It's not\n\t\t * resumed per-se but is not considered to be in TRACED by\n\t\t * wait(2) or ptrace(2).  If an async event (e.g. group\n\t\t * stop state change) happens, tracee will enter STOP trap\n\t\t * again.  Alternatively, ptracer can issue INTERRUPT to\n\t\t * finish listening and re-trap tracee into STOP.\n\t\t */\n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\tsi = child->last_siginfo;\n\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {\n\t\t\tchild->jobctl |= JOBCTL_LISTENING;\n\t\t\t/*\n\t\t\t * If NOTIFY is set, it means event happened between\n\t\t\t * start of this trap and now.  Trigger re-trap.\n\t\t\t */\n\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)\n\t\t\t\tptrace_signal_wake_up(child, true);\n\t\t\tret = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t\tbreak;\n\n\tcase PTRACE_DETACH:\t /* detach a process that was attached. */\n\t\tret = ptrace_detach(child, data);\n\t\tbreak;\n\n#ifdef CONFIG_BINFMT_ELF_FDPIC\n\tcase PTRACE_GETFDPIC: {\n\t\tstruct mm_struct *mm = get_task_mm(child);\n\t\tunsigned long tmp = 0;\n\n\t\tret = -ESRCH;\n\t\tif (!mm)\n\t\t\tbreak;\n\n\t\tswitch (addr) {\n\t\tcase PTRACE_GETFDPIC_EXEC:\n\t\t\ttmp = mm->context.exec_fdpic_loadmap;\n\t\t\tbreak;\n\t\tcase PTRACE_GETFDPIC_INTERP:\n\t\t\ttmp = mm->context.interp_fdpic_loadmap;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmmput(mm);\n\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n#endif\n\n#ifdef PTRACE_SINGLESTEP\n\tcase PTRACE_SINGLESTEP:\n#endif\n#ifdef PTRACE_SINGLEBLOCK\n\tcase PTRACE_SINGLEBLOCK:\n#endif\n#ifdef PTRACE_SYSEMU\n\tcase PTRACE_SYSEMU:\n\tcase PTRACE_SYSEMU_SINGLESTEP:\n#endif\n\tcase PTRACE_SYSCALL:\n\tcase PTRACE_CONT:\n\t\treturn ptrace_resume(child, request, data);\n\n\tcase PTRACE_KILL:\n\t\tif (child->exit_state)\t/* already dead */\n\t\t\treturn 0;\n\t\treturn ptrace_resume(child, request, SIGKILL);\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET: {\n\t\tstruct iovec kiov;\n\t\tstruct iovec __user *uiov = datavp;\n\n\t\tif (!access_ok(VERIFY_WRITE, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||\n\t\t    __get_user(kiov.iov_len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n#endif\n\n\tcase PTRACE_SECCOMP_GET_FILTER:\n\t\tret = seccomp_get_filter(child, addr, datavp);\n\t\tbreak;\n\n\tcase PTRACE_SECCOMP_GET_METADATA:\n\t\tret = seccomp_get_metadata(child, addr, datavp);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_get_metadata",
          "args": [
            "child",
            "addr",
            "datavp"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_get_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1071-1104",
          "snippet": "long seccomp_get_metadata(struct task_struct *task,\n\t\t\t  unsigned long size, void __user *data)\n{\n\tlong ret;\n\tstruct seccomp_filter *filter;\n\tstruct seccomp_metadata kmd = {};\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tsize = min_t(unsigned long, size, sizeof(kmd));\n\n\tif (size < sizeof(kmd.filter_off))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))\n\t\treturn -EFAULT;\n\n\tfilter = get_nth_filter(task, kmd.filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tif (filter->log)\n\t\tkmd.flags |= SECCOMP_FILTER_FLAG_LOG;\n\n\tret = size;\n\tif (copy_to_user(data, &kmd, size))\n\t\tret = -EFAULT;\n\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong seccomp_get_metadata(struct task_struct *task,\n\t\t\t  unsigned long size, void __user *data)\n{\n\tlong ret;\n\tstruct seccomp_filter *filter;\n\tstruct seccomp_metadata kmd = {};\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tsize = min_t(unsigned long, size, sizeof(kmd));\n\n\tif (size < sizeof(kmd.filter_off))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))\n\t\treturn -EFAULT;\n\n\tfilter = get_nth_filter(task, kmd.filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tif (filter->log)\n\t\tkmd.flags |= SECCOMP_FILTER_FLAG_LOG;\n\n\tret = size;\n\tif (copy_to_user(data, &kmd, size))\n\t\tret = -EFAULT;\n\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_get_filter",
          "args": [
            "child",
            "addr",
            "datavp"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_get_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1033-1069",
          "snippet": "long seccomp_get_filter(struct task_struct *task, unsigned long filter_off,\n\t\t\tvoid __user *data)\n{\n\tstruct seccomp_filter *filter;\n\tstruct sock_fprog_kern *fprog;\n\tlong ret;\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tfilter = get_nth_filter(task, filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tfprog = filter->prog->orig_prog;\n\tif (!fprog) {\n\t\t/* This must be a new non-cBPF filter, since we save\n\t\t * every cBPF filter's orig_prog above when\n\t\t * CONFIG_CHECKPOINT_RESTORE is enabled.\n\t\t */\n\t\tret = -EMEDIUMTYPE;\n\t\tgoto out;\n\t}\n\n\tret = fprog->len;\n\tif (!data)\n\t\tgoto out;\n\n\tif (copy_to_user(data, fprog->filter, bpf_classic_proglen(fprog)))\n\t\tret = -EFAULT;\n\nout:\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong seccomp_get_filter(struct task_struct *task, unsigned long filter_off,\n\t\t\tvoid __user *data)\n{\n\tstruct seccomp_filter *filter;\n\tstruct sock_fprog_kern *fprog;\n\tlong ret;\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tfilter = get_nth_filter(task, filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tfprog = filter->prog->orig_prog;\n\tif (!fprog) {\n\t\t/* This must be a new non-cBPF filter, since we save\n\t\t * every cBPF filter's orig_prog above when\n\t\t * CONFIG_CHECKPOINT_RESTORE is enabled.\n\t\t */\n\t\tret = -EMEDIUMTYPE;\n\t\tgoto out;\n\t}\n\n\tret = fprog->len;\n\tif (!data)\n\t\tgoto out;\n\n\tif (copy_to_user(data, fprog->filter, bpf_classic_proglen(fprog)))\n\t\tret = -EFAULT;\n\nout:\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kiov.iov_len",
            "&uiov->iov_len"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_regset",
          "args": [
            "child",
            "request",
            "addr",
            "&kiov"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_regset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "863-883",
          "snippet": "static int ptrace_regset(struct task_struct *task, int req, unsigned int type,\n\t\t\t struct iovec *kiov)\n{\n\tconst struct user_regset_view *view = task_user_regset_view(task);\n\tconst struct user_regset *regset = find_regset(view, type);\n\tint regset_no;\n\n\tif (!regset || (kiov->iov_len % regset->size) != 0)\n\t\treturn -EINVAL;\n\n\tregset_no = regset - view->regsets;\n\tkiov->iov_len = min(kiov->iov_len,\n\t\t\t    (__kernel_size_t) (regset->n * regset->size));\n\n\tif (req == PTRACE_GETREGSET)\n\t\treturn copy_regset_to_user(task, view, regset_no, 0,\n\t\t\t\t\t   kiov->iov_len, kiov->iov_base);\n\telse\n\t\treturn copy_regset_from_user(task, view, regset_no, 0,\n\t\t\t\t\t     kiov->iov_len, kiov->iov_base);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_regset(struct task_struct *task, int req, unsigned int type,\n\t\t\t struct iovec *kiov)\n{\n\tconst struct user_regset_view *view = task_user_regset_view(task);\n\tconst struct user_regset *regset = find_regset(view, type);\n\tint regset_no;\n\n\tif (!regset || (kiov->iov_len % regset->size) != 0)\n\t\treturn -EINVAL;\n\n\tregset_no = regset - view->regsets;\n\tkiov->iov_len = min(kiov->iov_len,\n\t\t\t    (__kernel_size_t) (regset->n * regset->size));\n\n\tif (req == PTRACE_GETREGSET)\n\t\treturn copy_regset_to_user(task, view, regset_no, 0,\n\t\t\t\t\t   kiov->iov_len, kiov->iov_base);\n\telse\n\t\treturn copy_regset_from_user(task, view, regset_no, 0,\n\t\t\t\t\t     kiov->iov_len, kiov->iov_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "kiov.iov_len",
            "&uiov->iov_len"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "kiov.iov_base",
            "&uiov->iov_base"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "uiov",
            "sizeof(*uiov)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_resume",
          "args": [
            "child",
            "request",
            "SIGKILL"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "790-844",
          "snippet": "static int ptrace_resume(struct task_struct *child, long request,\n\t\t\t unsigned long data)\n{\n\tbool need_siglock;\n\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\tif (request == PTRACE_SYSCALL)\n\t\tset_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\telse\n\t\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n#ifdef TIF_SYSCALL_EMU\n\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)\n\t\tset_tsk_thread_flag(child, TIF_SYSCALL_EMU);\n\telse\n\t\tclear_tsk_thread_flag(child, TIF_SYSCALL_EMU);\n#endif\n\n\tif (is_singleblock(request)) {\n\t\tif (unlikely(!arch_has_block_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_block_step(child);\n\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {\n\t\tif (unlikely(!arch_has_single_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_single_step(child);\n\t} else {\n\t\tuser_disable_single_step(child);\n\t}\n\n\t/*\n\t * Change ->exit_code and ->state under siglock to avoid the race\n\t * with wait_task_stopped() in between; a non-zero ->exit_code will\n\t * wrongly look like another report from tracee.\n\t *\n\t * Note that we need siglock even if ->exit_code == data and/or this\n\t * status was not reported yet, the new status must not be cleared by\n\t * wait_task_stopped() after resume.\n\t *\n\t * If data == 0 we do not care if wait_task_stopped() reports the old\n\t * status and clears the code too; this can't race with the tracee, it\n\t * takes siglock after resume.\n\t */\n\tneed_siglock = data && !thread_group_empty(current);\n\tif (need_siglock)\n\t\tspin_lock_irq(&child->sighand->siglock);\n\tchild->exit_code = data;\n\twake_up_state(child, __TASK_TRACED);\n\tif (need_siglock)\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_resume(struct task_struct *child, long request,\n\t\t\t unsigned long data)\n{\n\tbool need_siglock;\n\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\tif (request == PTRACE_SYSCALL)\n\t\tset_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\telse\n\t\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n#ifdef TIF_SYSCALL_EMU\n\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)\n\t\tset_tsk_thread_flag(child, TIF_SYSCALL_EMU);\n\telse\n\t\tclear_tsk_thread_flag(child, TIF_SYSCALL_EMU);\n#endif\n\n\tif (is_singleblock(request)) {\n\t\tif (unlikely(!arch_has_block_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_block_step(child);\n\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {\n\t\tif (unlikely(!arch_has_single_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_single_step(child);\n\t} else {\n\t\tuser_disable_single_step(child);\n\t}\n\n\t/*\n\t * Change ->exit_code and ->state under siglock to avoid the race\n\t * with wait_task_stopped() in between; a non-zero ->exit_code will\n\t * wrongly look like another report from tracee.\n\t *\n\t * Note that we need siglock even if ->exit_code == data and/or this\n\t * status was not reported yet, the new status must not be cleared by\n\t * wait_task_stopped() after resume.\n\t *\n\t * If data == 0 we do not care if wait_task_stopped() reports the old\n\t * status and clears the code too; this can't race with the tracee, it\n\t * takes siglock after resume.\n\t */\n\tneed_siglock = data && !thread_group_empty(current);\n\tif (need_siglock)\n\t\tspin_lock_irq(&child->sighand->siglock);\n\tchild->exit_code = data;\n\twake_up_state(child, __TASK_TRACED);\n\tif (need_siglock)\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "tmp",
            "datalp"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1079-1085",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "child"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1168-1182",
          "snippet": "struct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_detach",
          "args": [
            "child",
            "data"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "539-564",
          "snippet": "static int ptrace_detach(struct task_struct *child, unsigned int data)\n{\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\t/* Architecture-specific hardware disable .. */\n\tptrace_disable(child);\n\n\twrite_lock_irq(&tasklist_lock);\n\t/*\n\t * We rely on ptrace_freeze_traced(). It can't be killed and\n\t * untraced by another thread, it can't be a zombie.\n\t */\n\tWARN_ON(!child->ptrace || child->exit_state);\n\t/*\n\t * tasklist_lock avoids the race with wait_task_stopped(), see\n\t * the comment in ptrace_resume().\n\t */\n\tchild->exit_code = data;\n\t__ptrace_detach(current, child);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_ptrace_connector(child, PTRACE_DETACH);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_detach(struct task_struct *child, unsigned int data)\n{\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\t/* Architecture-specific hardware disable .. */\n\tptrace_disable(child);\n\n\twrite_lock_irq(&tasklist_lock);\n\t/*\n\t * We rely on ptrace_freeze_traced(). It can't be killed and\n\t * untraced by another thread, it can't be a zombie.\n\t */\n\tWARN_ON(!child->ptrace || child->exit_state);\n\t/*\n\t * tasklist_lock avoids the race with wait_task_stopped(), see\n\t * the comment in ptrace_resume().\n\t */\n\tchild->exit_code = data;\n\t__ptrace_detach(current, child);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_ptrace_connector(child, PTRACE_DETACH);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "child",
            "&flags"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_signal_wake_up",
          "args": [
            "child",
            "true"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "si && (si->si_code >> 8) == PTRACE_EVENT_STOP"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!seized || !lock_task_sighand(child, &flags)"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "child",
            "&flags"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "child",
            "&flags"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_signal_wake_up",
          "args": [
            "child",
            "child->jobctl & JOBCTL_LISTENING"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_set_jobctl_pending",
          "args": [
            "child",
            "JOBCTL_TRAP_STOP"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "task_set_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "275-289",
          "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!seized || !lock_task_sighand(child, &flags)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "&new_set",
            "sigmask(SIGKILL)|sigmask(SIGSTOP)"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&new_set",
            "datavp",
            "sizeof(sigset_t)"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "datavp",
            "&child->blocked",
            "sizeof(sigset_t)"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_setsiginfo",
          "args": [
            "child",
            "&siginfo"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_setsiginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "680-694",
          "snippet": "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(child->last_siginfo, info);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(child->last_siginfo, info);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo_from_user",
          "args": [
            "&siginfo",
            "datavp"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3149-3158",
          "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_user",
          "args": [
            "datavp",
            "&siginfo"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2918-2926",
          "snippet": "int copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from)\n{\n\tchar __user *expansion = si_expansion(to);\n\tif (copy_to_user(to, from , sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tif (clear_user(expansion, SI_EXPANSION_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from)\n{\n\tchar __user *expansion = si_expansion(to);\n\tif (copy_to_user(to, from , sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tif (clear_user(expansion, SI_EXPANSION_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_getsiginfo",
          "args": [
            "child",
            "&siginfo"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_getsiginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "664-678",
          "snippet": "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(info, child->last_siginfo);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(info, child->last_siginfo);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_peek_siginfo",
          "args": [
            "child",
            "addr",
            "data"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_peek_siginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "696-770",
          "snippet": "static int ptrace_peek_siginfo(struct task_struct *child,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long data)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint ret, i;\n\n\tret = copy_from_user(&arg, (void __user *) addr,\n\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)\n\t\treturn -EINVAL; /* unknown flags */\n\n\tif (arg.nr < 0)\n\t\treturn -EINVAL;\n\n\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)\n\t\tpending = &child->signal->shared_pending;\n\telse\n\t\tpending = &child->pending;\n\n\tfor (i = 0; i < arg.nr; ) {\n\t\tkernel_siginfo_t info;\n\t\ts32 off = arg.off + i;\n\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tlist_for_each_entry(q, &pending->list, list) {\n\t\t\tif (!off--) {\n\t\t\t\tcopy_siginfo(&info, &q->info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tif (off >= 0) /* beyond the end of the list */\n\t\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\t\tif (unlikely(in_compat_syscall())) {\n\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);\n\n\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else\n#endif\n\t\t{\n\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;\n\n\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(siginfo_t);\n\t\ti++;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (i > 0)\n\t\treturn i;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_peek_siginfo(struct task_struct *child,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long data)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint ret, i;\n\n\tret = copy_from_user(&arg, (void __user *) addr,\n\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)\n\t\treturn -EINVAL; /* unknown flags */\n\n\tif (arg.nr < 0)\n\t\treturn -EINVAL;\n\n\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)\n\t\tpending = &child->signal->shared_pending;\n\telse\n\t\tpending = &child->pending;\n\n\tfor (i = 0; i < arg.nr; ) {\n\t\tkernel_siginfo_t info;\n\t\ts32 off = arg.off + i;\n\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tlist_for_each_entry(q, &pending->list, list) {\n\t\t\tif (!off--) {\n\t\t\t\tcopy_siginfo(&info, &q->info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tif (off >= 0) /* beyond the end of the list */\n\t\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\t\tif (unlikely(in_compat_syscall())) {\n\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);\n\n\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else\n#endif\n\t\t{\n\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;\n\n\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(siginfo_t);\n\t\ti++;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (i > 0)\n\t\treturn i;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "child->ptrace_message",
            "datalp"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_setoptions",
          "args": [
            "child",
            "data"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_setoptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "635-662",
          "snippet": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Avoid intermediate state when all opts are cleared */\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Avoid intermediate state when all opts are cleared */\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_ptrace_pokedata",
          "args": [
            "child",
            "addr",
            "data"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "generic_ptrace_pokedata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "1176-1184",
          "snippet": "int generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &data, sizeof(data),\n\t\t\tFOLL_FORCE | FOLL_WRITE);\n\treturn (copied == sizeof(data)) ? 0 : -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &data, sizeof(data),\n\t\t\tFOLL_FORCE | FOLL_WRITE);\n\treturn (copied == sizeof(data)) ? 0 : -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_ptrace_peekdata",
          "args": [
            "child",
            "addr",
            "data"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "generic_ptrace_peekdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "1164-1174",
          "snippet": "int generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tunsigned long tmp;\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE);\n\tif (copied != sizeof(tmp))\n\t\treturn -EIO;\n\treturn put_user(tmp, (unsigned long __user *)data);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tunsigned long tmp;\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE);\n\tif (copied != sizeof(tmp))\n\t\treturn -EIO;\n\treturn put_user(tmp, (unsigned long __user *)data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_request(struct task_struct *child, long request,\n\t\t   unsigned long addr, unsigned long data)\n{\n\tbool seized = child->ptrace & PT_SEIZED;\n\tint ret = -EIO;\n\tkernel_siginfo_t siginfo, *si;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\tunsigned long flags;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\treturn generic_ptrace_peekdata(child, addr, data);\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\treturn generic_ptrace_pokedata(child, addr, data);\n\n#ifdef PTRACE_OLDSETOPTIONS\n\tcase PTRACE_OLDSETOPTIONS:\n#endif\n\tcase PTRACE_SETOPTIONS:\n\t\tret = ptrace_setoptions(child, data);\n\t\tbreak;\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user(child->ptrace_message, datalp);\n\t\tbreak;\n\n\tcase PTRACE_PEEKSIGINFO:\n\t\tret = ptrace_peek_siginfo(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tret = copy_siginfo_from_user(&siginfo, datavp);\n\t\tif (!ret)\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGMASK:\n\t\tif (addr != sizeof(sigset_t)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(datavp, &child->blocked, sizeof(sigset_t)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = 0;\n\n\t\tbreak;\n\n\tcase PTRACE_SETSIGMASK: {\n\t\tsigset_t new_set;\n\n\t\tif (addr != sizeof(sigset_t)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&new_set, datavp, sizeof(sigset_t))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\t/*\n\t\t * Every thread does recalc_sigpending() after resume, so\n\t\t * retarget_shared_pending() and recalc_sigpending() are not\n\t\t * called here.\n\t\t */\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tchild->blocked = new_set;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tcase PTRACE_INTERRUPT:\n\t\t/*\n\t\t * Stop tracee without any side-effect on signal or job\n\t\t * control.  At least one trap is guaranteed to happen\n\t\t * after this request.  If @child is already trapped, the\n\t\t * current trap is not disturbed and another trap will\n\t\t * happen after the current trap is ended with PTRACE_CONT.\n\t\t *\n\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but\n\t\t * the pending condition is cleared regardless.\n\t\t */\n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * INTERRUPT doesn't disturb existing trap sans one\n\t\t * exception.  If ptracer issued LISTEN for the current\n\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap\n\t\t * tracee into STOP.\n\t\t */\n\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))\n\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);\n\n\t\tunlock_task_sighand(child, &flags);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase PTRACE_LISTEN:\n\t\t/*\n\t\t * Listen for events.  Tracee must be in STOP.  It's not\n\t\t * resumed per-se but is not considered to be in TRACED by\n\t\t * wait(2) or ptrace(2).  If an async event (e.g. group\n\t\t * stop state change) happens, tracee will enter STOP trap\n\t\t * again.  Alternatively, ptracer can issue INTERRUPT to\n\t\t * finish listening and re-trap tracee into STOP.\n\t\t */\n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\tsi = child->last_siginfo;\n\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {\n\t\t\tchild->jobctl |= JOBCTL_LISTENING;\n\t\t\t/*\n\t\t\t * If NOTIFY is set, it means event happened between\n\t\t\t * start of this trap and now.  Trigger re-trap.\n\t\t\t */\n\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)\n\t\t\t\tptrace_signal_wake_up(child, true);\n\t\t\tret = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t\tbreak;\n\n\tcase PTRACE_DETACH:\t /* detach a process that was attached. */\n\t\tret = ptrace_detach(child, data);\n\t\tbreak;\n\n#ifdef CONFIG_BINFMT_ELF_FDPIC\n\tcase PTRACE_GETFDPIC: {\n\t\tstruct mm_struct *mm = get_task_mm(child);\n\t\tunsigned long tmp = 0;\n\n\t\tret = -ESRCH;\n\t\tif (!mm)\n\t\t\tbreak;\n\n\t\tswitch (addr) {\n\t\tcase PTRACE_GETFDPIC_EXEC:\n\t\t\ttmp = mm->context.exec_fdpic_loadmap;\n\t\t\tbreak;\n\t\tcase PTRACE_GETFDPIC_INTERP:\n\t\t\ttmp = mm->context.interp_fdpic_loadmap;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmmput(mm);\n\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n#endif\n\n#ifdef PTRACE_SINGLESTEP\n\tcase PTRACE_SINGLESTEP:\n#endif\n#ifdef PTRACE_SINGLEBLOCK\n\tcase PTRACE_SINGLEBLOCK:\n#endif\n#ifdef PTRACE_SYSEMU\n\tcase PTRACE_SYSEMU:\n\tcase PTRACE_SYSEMU_SINGLESTEP:\n#endif\n\tcase PTRACE_SYSCALL:\n\tcase PTRACE_CONT:\n\t\treturn ptrace_resume(child, request, data);\n\n\tcase PTRACE_KILL:\n\t\tif (child->exit_state)\t/* already dead */\n\t\t\treturn 0;\n\t\treturn ptrace_resume(child, request, SIGKILL);\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET: {\n\t\tstruct iovec kiov;\n\t\tstruct iovec __user *uiov = datavp;\n\n\t\tif (!access_ok(VERIFY_WRITE, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||\n\t\t    __get_user(kiov.iov_len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n#endif\n\n\tcase PTRACE_SECCOMP_GET_FILTER:\n\t\tret = seccomp_get_filter(child, addr, datavp);\n\t\tbreak;\n\n\tcase PTRACE_SECCOMP_GET_METADATA:\n\t\tret = seccomp_get_metadata(child, addr, datavp);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace_regset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "863-883",
    "snippet": "static int ptrace_regset(struct task_struct *task, int req, unsigned int type,\n\t\t\t struct iovec *kiov)\n{\n\tconst struct user_regset_view *view = task_user_regset_view(task);\n\tconst struct user_regset *regset = find_regset(view, type);\n\tint regset_no;\n\n\tif (!regset || (kiov->iov_len % regset->size) != 0)\n\t\treturn -EINVAL;\n\n\tregset_no = regset - view->regsets;\n\tkiov->iov_len = min(kiov->iov_len,\n\t\t\t    (__kernel_size_t) (regset->n * regset->size));\n\n\tif (req == PTRACE_GETREGSET)\n\t\treturn copy_regset_to_user(task, view, regset_no, 0,\n\t\t\t\t\t   kiov->iov_len, kiov->iov_base);\n\telse\n\t\treturn copy_regset_from_user(task, view, regset_no, 0,\n\t\t\t\t\t     kiov->iov_len, kiov->iov_base);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "task",
            "view",
            "regset_no",
            "0",
            "kiov->iov_len",
            "kiov->iov_base"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "task",
            "view",
            "regset_no",
            "0",
            "kiov->iov_len",
            "kiov->iov_base"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "kiov->iov_len",
            "(__kernel_size_t) (regset->n * regset->size)"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "regset->n * regset->size"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_regset",
          "args": [
            "view",
            "type"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "find_regset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "848-861",
          "snippet": "static const struct user_regset *\nfind_regset(const struct user_regset_view *view, unsigned int type)\n{\n\tconst struct user_regset *regset;\n\tint n;\n\n\tfor (n = 0; n < view->n; ++n) {\n\t\tregset = view->regsets + n;\n\t\tif (regset->core_note_type == type)\n\t\t\treturn regset;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic const struct user_regset *\nfind_regset(const struct user_regset_view *view, unsigned int type)\n{\n\tconst struct user_regset *regset;\n\tint n;\n\n\tfor (n = 0; n < view->n; ++n) {\n\t\tregset = view->regsets + n;\n\t\tif (regset->core_note_type == type)\n\t\t\treturn regset;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_user_regset_view",
          "args": [
            "task"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_regset(struct task_struct *task, int req, unsigned int type,\n\t\t\t struct iovec *kiov)\n{\n\tconst struct user_regset_view *view = task_user_regset_view(task);\n\tconst struct user_regset *regset = find_regset(view, type);\n\tint regset_no;\n\n\tif (!regset || (kiov->iov_len % regset->size) != 0)\n\t\treturn -EINVAL;\n\n\tregset_no = regset - view->regsets;\n\tkiov->iov_len = min(kiov->iov_len,\n\t\t\t    (__kernel_size_t) (regset->n * regset->size));\n\n\tif (req == PTRACE_GETREGSET)\n\t\treturn copy_regset_to_user(task, view, regset_no, 0,\n\t\t\t\t\t   kiov->iov_len, kiov->iov_base);\n\telse\n\t\treturn copy_regset_from_user(task, view, regset_no, 0,\n\t\t\t\t\t     kiov->iov_len, kiov->iov_base);\n}"
  },
  {
    "function_name": "find_regset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "848-861",
    "snippet": "static const struct user_regset *\nfind_regset(const struct user_regset_view *view, unsigned int type)\n{\n\tconst struct user_regset *regset;\n\tint n;\n\n\tfor (n = 0; n < view->n; ++n) {\n\t\tregset = view->regsets + n;\n\t\tif (regset->core_note_type == type)\n\t\t\treturn regset;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic const struct user_regset *\nfind_regset(const struct user_regset_view *view, unsigned int type)\n{\n\tconst struct user_regset *regset;\n\tint n;\n\n\tfor (n = 0; n < view->n; ++n) {\n\t\tregset = view->regsets + n;\n\t\tif (regset->core_note_type == type)\n\t\t\treturn regset;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ptrace_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "790-844",
    "snippet": "static int ptrace_resume(struct task_struct *child, long request,\n\t\t\t unsigned long data)\n{\n\tbool need_siglock;\n\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\tif (request == PTRACE_SYSCALL)\n\t\tset_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\telse\n\t\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n#ifdef TIF_SYSCALL_EMU\n\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)\n\t\tset_tsk_thread_flag(child, TIF_SYSCALL_EMU);\n\telse\n\t\tclear_tsk_thread_flag(child, TIF_SYSCALL_EMU);\n#endif\n\n\tif (is_singleblock(request)) {\n\t\tif (unlikely(!arch_has_block_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_block_step(child);\n\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {\n\t\tif (unlikely(!arch_has_single_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_single_step(child);\n\t} else {\n\t\tuser_disable_single_step(child);\n\t}\n\n\t/*\n\t * Change ->exit_code and ->state under siglock to avoid the race\n\t * with wait_task_stopped() in between; a non-zero ->exit_code will\n\t * wrongly look like another report from tracee.\n\t *\n\t * Note that we need siglock even if ->exit_code == data and/or this\n\t * status was not reported yet, the new status must not be cleared by\n\t * wait_task_stopped() after resume.\n\t *\n\t * If data == 0 we do not care if wait_task_stopped() reports the old\n\t * status and clears the code too; this can't race with the tracee, it\n\t * takes siglock after resume.\n\t */\n\tneed_siglock = data && !thread_group_empty(current);\n\tif (need_siglock)\n\t\tspin_lock_irq(&child->sighand->siglock);\n\tchild->exit_code = data;\n\twake_up_state(child, __TASK_TRACED);\n\tif (need_siglock)\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "child",
            "__TASK_TRACED"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "current"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_disable_single_step",
          "args": [
            "child"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_enable_single_step",
          "args": [
            "child"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!arch_has_single_step()"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_has_single_step",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sysemu_singlestep",
          "args": [
            "request"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_singlestep",
          "args": [
            "request"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_enable_block_step",
          "args": [
            "child"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!arch_has_block_step()"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_has_block_step",
          "args": [],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_singleblock",
          "args": [
            "request"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "child",
            "TIF_SYSCALL_EMU"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "child",
            "TIF_SYSCALL_EMU"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "child",
            "TIF_SYSCALL_TRACE"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "child",
            "TIF_SYSCALL_TRACE"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "data"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_resume(struct task_struct *child, long request,\n\t\t\t unsigned long data)\n{\n\tbool need_siglock;\n\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\tif (request == PTRACE_SYSCALL)\n\t\tset_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\telse\n\t\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n#ifdef TIF_SYSCALL_EMU\n\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)\n\t\tset_tsk_thread_flag(child, TIF_SYSCALL_EMU);\n\telse\n\t\tclear_tsk_thread_flag(child, TIF_SYSCALL_EMU);\n#endif\n\n\tif (is_singleblock(request)) {\n\t\tif (unlikely(!arch_has_block_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_block_step(child);\n\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {\n\t\tif (unlikely(!arch_has_single_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_single_step(child);\n\t} else {\n\t\tuser_disable_single_step(child);\n\t}\n\n\t/*\n\t * Change ->exit_code and ->state under siglock to avoid the race\n\t * with wait_task_stopped() in between; a non-zero ->exit_code will\n\t * wrongly look like another report from tracee.\n\t *\n\t * Note that we need siglock even if ->exit_code == data and/or this\n\t * status was not reported yet, the new status must not be cleared by\n\t * wait_task_stopped() after resume.\n\t *\n\t * If data == 0 we do not care if wait_task_stopped() reports the old\n\t * status and clears the code too; this can't race with the tracee, it\n\t * takes siglock after resume.\n\t */\n\tneed_siglock = data && !thread_group_empty(current);\n\tif (need_siglock)\n\t\tspin_lock_irq(&child->sighand->siglock);\n\tchild->exit_code = data;\n\twake_up_state(child, __TASK_TRACED);\n\tif (need_siglock)\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ptrace_peek_siginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "696-770",
    "snippet": "static int ptrace_peek_siginfo(struct task_struct *child,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long data)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint ret, i;\n\n\tret = copy_from_user(&arg, (void __user *) addr,\n\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)\n\t\treturn -EINVAL; /* unknown flags */\n\n\tif (arg.nr < 0)\n\t\treturn -EINVAL;\n\n\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)\n\t\tpending = &child->signal->shared_pending;\n\telse\n\t\tpending = &child->pending;\n\n\tfor (i = 0; i < arg.nr; ) {\n\t\tkernel_siginfo_t info;\n\t\ts32 off = arg.off + i;\n\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tlist_for_each_entry(q, &pending->list, list) {\n\t\t\tif (!off--) {\n\t\t\t\tcopy_siginfo(&info, &q->info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tif (off >= 0) /* beyond the end of the list */\n\t\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\t\tif (unlikely(in_compat_syscall())) {\n\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);\n\n\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else\n#endif\n\t\t{\n\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;\n\n\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(siginfo_t);\n\t\ti++;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (i > 0)\n\t\treturn i;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_user",
          "args": [
            "uinfo",
            "&info"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2918-2926",
          "snippet": "int copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from)\n{\n\tchar __user *expansion = si_expansion(to);\n\tif (copy_to_user(to, from , sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tif (clear_user(expansion, SI_EXPANSION_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from)\n{\n\tchar __user *expansion = si_expansion(to);\n\tif (copy_to_user(to, from , sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tif (clear_user(expansion, SI_EXPANSION_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_user32",
          "args": [
            "uinfo",
            "&info"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "data"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_compat_syscall()"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo",
          "args": [
            "&info",
            "&q->info"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3149-3158",
          "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "q",
            "&pending->list",
            "list"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&arg",
            "(void __user *) addr",
            "sizeof(struct ptrace_peeksiginfo_args)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_peek_siginfo(struct task_struct *child,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long data)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint ret, i;\n\n\tret = copy_from_user(&arg, (void __user *) addr,\n\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)\n\t\treturn -EINVAL; /* unknown flags */\n\n\tif (arg.nr < 0)\n\t\treturn -EINVAL;\n\n\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)\n\t\tpending = &child->signal->shared_pending;\n\telse\n\t\tpending = &child->pending;\n\n\tfor (i = 0; i < arg.nr; ) {\n\t\tkernel_siginfo_t info;\n\t\ts32 off = arg.off + i;\n\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tlist_for_each_entry(q, &pending->list, list) {\n\t\t\tif (!off--) {\n\t\t\t\tcopy_siginfo(&info, &q->info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tif (off >= 0) /* beyond the end of the list */\n\t\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\t\tif (unlikely(in_compat_syscall())) {\n\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);\n\n\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else\n#endif\n\t\t{\n\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;\n\n\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(siginfo_t);\n\t\ti++;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (i > 0)\n\t\treturn i;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace_setsiginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "680-694",
    "snippet": "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(child->last_siginfo, info);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "child",
            "&flags"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_siginfo",
          "args": [
            "child->last_siginfo",
            "info"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3149-3158",
          "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "child->last_siginfo != NULL"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "child",
            "&flags"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(child->last_siginfo, info);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ptrace_getsiginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "664-678",
    "snippet": "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(info, child->last_siginfo);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "child",
            "&flags"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_siginfo",
          "args": [
            "info",
            "child->last_siginfo"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3149-3158",
          "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "child->last_siginfo != NULL"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "child",
            "&flags"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(info, child->last_siginfo);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ptrace_setoptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "635-662",
    "snippet": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Avoid intermediate state when all opts are cleared */\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_mode",
          "args": [
            "&current->seccomp"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SECCOMP"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CHECKPOINT_RESTORE"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "data & PTRACE_O_SUSPEND_SECCOMP"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Avoid intermediate state when all opts are cleared */\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ptrace_writedata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "609-633",
    "snippet": "int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)\n{\n\tint copied = 0;\n\n\twhile (len > 0) {\n\t\tchar buf[128];\n\t\tint this_len, retval;\n\n\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;\n\t\tif (copy_from_user(buf, src, this_len))\n\t\t\treturn -EFAULT;\n\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,\n\t\t\t\tFOLL_FORCE | FOLL_WRITE);\n\t\tif (!retval) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\treturn -EIO;\n\t\t}\n\t\tcopied += retval;\n\t\tsrc += retval;\n\t\tdst += retval;\n\t\tlen -= retval;\n\t}\n\treturn copied;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_access_vm",
          "args": [
            "tsk",
            "dst",
            "buf",
            "this_len",
            "FOLL_FORCE | FOLL_WRITE"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_access_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "38-60",
          "snippet": "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "src",
            "this_len"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)\n{\n\tint copied = 0;\n\n\twhile (len > 0) {\n\t\tchar buf[128];\n\t\tint this_len, retval;\n\n\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;\n\t\tif (copy_from_user(buf, src, this_len))\n\t\t\treturn -EFAULT;\n\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,\n\t\t\t\tFOLL_FORCE | FOLL_WRITE);\n\t\tif (!retval) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\treturn -EIO;\n\t\t}\n\t\tcopied += retval;\n\t\tsrc += retval;\n\t\tdst += retval;\n\t\tlen -= retval;\n\t}\n\treturn copied;\n}"
  },
  {
    "function_name": "ptrace_readdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "583-607",
    "snippet": "int ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len)\n{\n\tint copied = 0;\n\n\twhile (len > 0) {\n\t\tchar buf[128];\n\t\tint this_len, retval;\n\n\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;\n\t\tretval = ptrace_access_vm(tsk, src, buf, this_len, FOLL_FORCE);\n\n\t\tif (!retval) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_to_user(dst, buf, retval))\n\t\t\treturn -EFAULT;\n\t\tcopied += retval;\n\t\tsrc += retval;\n\t\tdst += retval;\n\t\tlen -= retval;\n\t}\n\treturn copied;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "dst",
            "buf",
            "retval"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_access_vm",
          "args": [
            "tsk",
            "src",
            "buf",
            "this_len",
            "FOLL_FORCE"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_access_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "38-60",
          "snippet": "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len)\n{\n\tint copied = 0;\n\n\twhile (len > 0) {\n\t\tchar buf[128];\n\t\tint this_len, retval;\n\n\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;\n\t\tretval = ptrace_access_vm(tsk, src, buf, this_len, FOLL_FORCE);\n\n\t\tif (!retval) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_to_user(dst, buf, retval))\n\t\t\treturn -EFAULT;\n\t\tcopied += retval;\n\t\tsrc += retval;\n\t\tdst += retval;\n\t\tlen -= retval;\n\t}\n\treturn copied;\n}"
  },
  {
    "function_name": "exit_ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "570-581",
    "snippet": "void exit_ptrace(struct task_struct *tracer, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {\n\t\tif (unlikely(p->ptrace & PT_EXITKILL))\n\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);\n\n\t\tif (__ptrace_detach(tracer, p))\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t}\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&p->ptrace_entry",
            "dead"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ptrace_detach",
          "args": [
            "tracer",
            "p"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "514-537",
          "snippet": "static bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)\n{\n\tbool dead;\n\n\t__ptrace_unlink(p);\n\n\tif (p->exit_state != EXIT_ZOMBIE)\n\t\treturn false;\n\n\tdead = !thread_group_leader(p);\n\n\tif (!dead && thread_group_empty(p)) {\n\t\tif (!same_thread_group(p->real_parent, tracer))\n\t\t\tdead = do_notify_parent(p, p->exit_signal);\n\t\telse if (ignoring_children(tracer->sighand)) {\n\t\t\t__wake_up_parent(p, tracer);\n\t\t\tdead = true;\n\t\t}\n\t}\n\t/* Mark it as in the process of being reaped. */\n\tif (dead)\n\t\tp->exit_state = EXIT_DEAD;\n\treturn dead;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)\n{\n\tbool dead;\n\n\t__ptrace_unlink(p);\n\n\tif (p->exit_state != EXIT_ZOMBIE)\n\t\treturn false;\n\n\tdead = !thread_group_leader(p);\n\n\tif (!dead && thread_group_empty(p)) {\n\t\tif (!same_thread_group(p->real_parent, tracer))\n\t\t\tdead = do_notify_parent(p, p->exit_signal);\n\t\telse if (ignoring_children(tracer->sighand)) {\n\t\t\t__wake_up_parent(p, tracer);\n\t\t\tdead = true;\n\t\t}\n\t}\n\t/* Mark it as in the process of being reaped. */\n\tif (dead)\n\t\tp->exit_state = EXIT_DEAD;\n\treturn dead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "SIGKILL",
            "SEND_SIG_PRIV",
            "p"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1485-1495",
          "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->ptrace & PT_EXITKILL"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "&tracer->ptraced",
            "ptrace_entry"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid exit_ptrace(struct task_struct *tracer, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {\n\t\tif (unlikely(p->ptrace & PT_EXITKILL))\n\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);\n\n\t\tif (__ptrace_detach(tracer, p))\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t}\n}"
  },
  {
    "function_name": "ptrace_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "539-564",
    "snippet": "static int ptrace_detach(struct task_struct *child, unsigned int data)\n{\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\t/* Architecture-specific hardware disable .. */\n\tptrace_disable(child);\n\n\twrite_lock_irq(&tasklist_lock);\n\t/*\n\t * We rely on ptrace_freeze_traced(). It can't be killed and\n\t * untraced by another thread, it can't be a zombie.\n\t */\n\tWARN_ON(!child->ptrace || child->exit_state);\n\t/*\n\t * tasklist_lock avoids the race with wait_task_stopped(), see\n\t * the comment in ptrace_resume().\n\t */\n\tchild->exit_code = data;\n\t__ptrace_detach(current, child);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_ptrace_connector(child, PTRACE_DETACH);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_ptrace_connector",
          "args": [
            "child",
            "PTRACE_DETACH"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "334-337",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ptrace_detach",
          "args": [
            "current",
            "child"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "514-537",
          "snippet": "static bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)\n{\n\tbool dead;\n\n\t__ptrace_unlink(p);\n\n\tif (p->exit_state != EXIT_ZOMBIE)\n\t\treturn false;\n\n\tdead = !thread_group_leader(p);\n\n\tif (!dead && thread_group_empty(p)) {\n\t\tif (!same_thread_group(p->real_parent, tracer))\n\t\t\tdead = do_notify_parent(p, p->exit_signal);\n\t\telse if (ignoring_children(tracer->sighand)) {\n\t\t\t__wake_up_parent(p, tracer);\n\t\t\tdead = true;\n\t\t}\n\t}\n\t/* Mark it as in the process of being reaped. */\n\tif (dead)\n\t\tp->exit_state = EXIT_DEAD;\n\treturn dead;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)\n{\n\tbool dead;\n\n\t__ptrace_unlink(p);\n\n\tif (p->exit_state != EXIT_ZOMBIE)\n\t\treturn false;\n\n\tdead = !thread_group_leader(p);\n\n\tif (!dead && thread_group_empty(p)) {\n\t\tif (!same_thread_group(p->real_parent, tracer))\n\t\t\tdead = do_notify_parent(p, p->exit_signal);\n\t\telse if (ignoring_children(tracer->sighand)) {\n\t\t\t__wake_up_parent(p, tracer);\n\t\t\tdead = true;\n\t\t}\n\t}\n\t/* Mark it as in the process of being reaped. */\n\tif (dead)\n\t\tp->exit_state = EXIT_DEAD;\n\treturn dead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!child->ptrace || child->exit_state"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "302-305",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_disable",
          "args": [
            "child"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "data"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_detach(struct task_struct *child, unsigned int data)\n{\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\t/* Architecture-specific hardware disable .. */\n\tptrace_disable(child);\n\n\twrite_lock_irq(&tasklist_lock);\n\t/*\n\t * We rely on ptrace_freeze_traced(). It can't be killed and\n\t * untraced by another thread, it can't be a zombie.\n\t */\n\tWARN_ON(!child->ptrace || child->exit_state);\n\t/*\n\t * tasklist_lock avoids the race with wait_task_stopped(), see\n\t * the comment in ptrace_resume().\n\t */\n\tchild->exit_code = data;\n\t__ptrace_detach(current, child);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_ptrace_connector(child, PTRACE_DETACH);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ptrace_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "514-537",
    "snippet": "static bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)\n{\n\tbool dead;\n\n\t__ptrace_unlink(p);\n\n\tif (p->exit_state != EXIT_ZOMBIE)\n\t\treturn false;\n\n\tdead = !thread_group_leader(p);\n\n\tif (!dead && thread_group_empty(p)) {\n\t\tif (!same_thread_group(p->real_parent, tracer))\n\t\t\tdead = do_notify_parent(p, p->exit_signal);\n\t\telse if (ignoring_children(tracer->sighand)) {\n\t\t\t__wake_up_parent(p, tracer);\n\t\t\tdead = true;\n\t\t}\n\t}\n\t/* Mark it as in the process of being reaped. */\n\tif (dead)\n\t\tp->exit_state = EXIT_DEAD;\n\treturn dead;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_parent",
          "args": [
            "p",
            "tracer"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1484-1488",
          "snippet": "void __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\tTASK_INTERRUPTIBLE, 1, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\tTASK_INTERRUPTIBLE, 1, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignoring_children",
          "args": [
            "tracer->sighand"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ignoring_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "489-497",
          "snippet": "static int ignoring_children(struct sighand_struct *sigh)\n{\n\tint ret;\n\tspin_lock(&sigh->siglock);\n\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||\n\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);\n\tspin_unlock(&sigh->siglock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ignoring_children(struct sighand_struct *sigh)\n{\n\tint ret;\n\tspin_lock(&sigh->siglock);\n\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||\n\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);\n\tspin_unlock(&sigh->siglock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "p",
            "p->exit_signal"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1767-1856",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "p->real_parent",
            "tracer"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "p"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "p"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ptrace_unlink",
          "args": [
            "p"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "113-165",
          "snippet": "void __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t/*\n\t * Clear all pending traps and TRAPPING.  TRAPPING should be\n\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.\n\t */\n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t/*\n\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and\n\t * @child isn't dead.\n\t */\n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t/*\n\t\t * This is only possible if this thread was cloned by the\n\t\t * traced task running in the stopped group, set the signal\n\t\t * for the future reports.\n\t\t * FIXME: we should change ptrace_init_task() to handle this\n\t\t * case.\n\t\t */\n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t/*\n\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick\n\t * @child in the butt.  Note that @resume should be used iff @child\n\t * is in TASK_TRACED; otherwise, we might unduly disrupt\n\t * TASK_KILLABLE sleeps.\n\t */\n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t/*\n\t * Clear all pending traps and TRAPPING.  TRAPPING should be\n\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.\n\t */\n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t/*\n\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and\n\t * @child isn't dead.\n\t */\n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t/*\n\t\t * This is only possible if this thread was cloned by the\n\t\t * traced task running in the stopped group, set the signal\n\t\t * for the future reports.\n\t\t * FIXME: we should change ptrace_init_task() to handle this\n\t\t * case.\n\t\t */\n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t/*\n\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick\n\t * @child in the butt.  Note that @resume should be used iff @child\n\t * is in TASK_TRACED; otherwise, we might unduly disrupt\n\t * TASK_KILLABLE sleeps.\n\t */\n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)\n{\n\tbool dead;\n\n\t__ptrace_unlink(p);\n\n\tif (p->exit_state != EXIT_ZOMBIE)\n\t\treturn false;\n\n\tdead = !thread_group_leader(p);\n\n\tif (!dead && thread_group_empty(p)) {\n\t\tif (!same_thread_group(p->real_parent, tracer))\n\t\t\tdead = do_notify_parent(p, p->exit_signal);\n\t\telse if (ignoring_children(tracer->sighand)) {\n\t\t\t__wake_up_parent(p, tracer);\n\t\t\tdead = true;\n\t\t}\n\t}\n\t/* Mark it as in the process of being reaped. */\n\tif (dead)\n\t\tp->exit_state = EXIT_DEAD;\n\treturn dead;\n}"
  },
  {
    "function_name": "ignoring_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "489-497",
    "snippet": "static int ignoring_children(struct sighand_struct *sigh)\n{\n\tint ret;\n\tspin_lock(&sigh->siglock);\n\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||\n\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);\n\tspin_unlock(&sigh->siglock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sigh->siglock"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sigh->siglock"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ignoring_children(struct sighand_struct *sigh)\n{\n\tint ret;\n\tspin_lock(&sigh->siglock);\n\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||\n\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);\n\tspin_unlock(&sigh->siglock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace_traceme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "463-484",
    "snippet": "static int ptrace_traceme(void)\n{\n\tint ret = -EPERM;\n\n\twrite_lock_irq(&tasklist_lock);\n\t/* Are we already being traced? */\n\tif (!current->ptrace) {\n\t\tret = security_ptrace_traceme(current->parent);\n\t\t/*\n\t\t * Check PF_EXITING to ensure ->real_parent has not passed\n\t\t * exit_ptrace(). Otherwise we don't report the error but\n\t\t * pretend ->real_parent untraces us right after return.\n\t\t */\n\t\tif (!ret && !(current->real_parent->flags & PF_EXITING)) {\n\t\t\tcurrent->ptrace = PT_PTRACED;\n\t\t\tptrace_link(current, current->real_parent);\n\t\t}\n\t}\n\twrite_unlock_irq(&tasklist_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "334-337",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_link",
          "args": [
            "current",
            "current->real_parent"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "78-83",
          "snippet": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_ptrace_traceme",
          "args": [
            "current->parent"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "302-305",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_traceme(void)\n{\n\tint ret = -EPERM;\n\n\twrite_lock_irq(&tasklist_lock);\n\t/* Are we already being traced? */\n\tif (!current->ptrace) {\n\t\tret = security_ptrace_traceme(current->parent);\n\t\t/*\n\t\t * Check PF_EXITING to ensure ->real_parent has not passed\n\t\t * exit_ptrace(). Otherwise we don't report the error but\n\t\t * pretend ->real_parent untraces us right after return.\n\t\t */\n\t\tif (!ret && !(current->real_parent->flags & PF_EXITING)) {\n\t\t\tcurrent->ptrace = PT_PTRACED;\n\t\t\tptrace_link(current, current->real_parent);\n\t\t}\n\t}\n\twrite_unlock_irq(&tasklist_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "353-455",
    "snippet": "static int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\n\t/*\n\t * Protect exec's credential calculations against our interference;\n\t * SUID, SGID and LSM creds get determined differently\n\t * under ptrace.\n\t */\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\n\tif (seize)\n\t\tflags |= PT_SEIZED;\n\ttask->ptrace = flags;\n\n\tptrace_link(task, current);\n\n\t/* SEIZE doesn't trap tracee on attach */\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\n\tspin_lock(&task->sighand->siglock);\n\n\t/*\n\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and\n\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING\n\t * will be cleared if the child completes the transition or any\n\t * event which clears the group stop states happens.  We'll wait\n\t * for the transition to complete before returning from this\n\t * function.\n\t *\n\t * This hides STOPPED -> RUNNING -> TRACED transition from the\n\t * attaching thread but a different thread in the same group can\n\t * still observe the transient RUNNING state.  IOW, if another\n\t * thread's WNOHANG wait(2) on the stopped tracee races against\n\t * ATTACH, the wait(2) may fail due to the transient RUNNING.\n\t *\n\t * The following task_is_stopped() test is safe as both transitions\n\t * in and out of STOPPED are protected by siglock.\n\t */\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\n\tspin_unlock(&task->sighand->siglock);\n\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\t/*\n\t\t * We do not bother to change retval or clear JOBCTL_TRAPPING\n\t\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will\n\t\t * not return to user-mode, it will exit and clear this bit in\n\t\t * __ptrace_unlink() if it wasn't already cleared by the tracee;\n\t\t * and until then nobody can ptrace this task.\n\t\t */\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_ptrace_connector",
          "args": [
            "task",
            "PTRACE_ATTACH"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&task->jobctl",
            "JOBCTL_TRAPPING_BIT",
            "TASK_KILLABLE"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "334-337",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_wake_up_state",
          "args": [
            "task",
            "__TASK_STOPPED"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_set_jobctl_pending",
          "args": [
            "task",
            "JOBCTL_TRAP_STOP | JOBCTL_TRAPPING"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "task_set_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "275-289",
          "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_is_stopped",
          "args": [
            "task"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "SIGSTOP",
            "SEND_SIG_PRIV",
            "task"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1485-1495",
          "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_link",
          "args": [
            "task",
            "current"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "78-83",
          "snippet": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task->exit_state"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "302-305",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_ATTACH_REALCREDS"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_may_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "274-337",
          "snippet": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn 0;\n\treturn security_ptrace_access_check(task, mode);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn 0;\n\treturn security_ptrace_access_check(task, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "task",
            "current"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task->flags & PF_KTHREAD"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ptrace",
          "args": [
            "task"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "__audit_ptrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2266-2276",
          "snippet": "void __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->target_pid = task_tgid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->target_pid = task_tgid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\n\t/*\n\t * Protect exec's credential calculations against our interference;\n\t * SUID, SGID and LSM creds get determined differently\n\t * under ptrace.\n\t */\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\n\tif (seize)\n\t\tflags |= PT_SEIZED;\n\ttask->ptrace = flags;\n\n\tptrace_link(task, current);\n\n\t/* SEIZE doesn't trap tracee on attach */\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\n\tspin_lock(&task->sighand->siglock);\n\n\t/*\n\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and\n\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING\n\t * will be cleared if the child completes the transition or any\n\t * event which clears the group stop states happens.  We'll wait\n\t * for the transition to complete before returning from this\n\t * function.\n\t *\n\t * This hides STOPPED -> RUNNING -> TRACED transition from the\n\t * attaching thread but a different thread in the same group can\n\t * still observe the transient RUNNING state.  IOW, if another\n\t * thread's WNOHANG wait(2) on the stopped tracee races against\n\t * ATTACH, the wait(2) may fail due to the transient RUNNING.\n\t *\n\t * The following task_is_stopped() test is safe as both transitions\n\t * in and out of STOPPED are protected by siglock.\n\t */\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\n\tspin_unlock(&task->sighand->siglock);\n\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\t/*\n\t\t * We do not bother to change retval or clear JOBCTL_TRAPPING\n\t\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will\n\t\t * not return to user-mode, it will exit and clear this bit in\n\t\t * __ptrace_unlink() if it wasn't already cleared by the tracee;\n\t\t * and until then nobody can ptrace this task.\n\t\t */\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "ptrace_may_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "344-351",
    "snippet": "bool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ptrace_may_access",
          "args": [
            "task",
            "mode"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_may_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "274-337",
          "snippet": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn 0;\n\treturn security_ptrace_access_check(task, mode);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn 0;\n\treturn security_ptrace_access_check(task, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nbool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}"
  },
  {
    "function_name": "ptrace_may_access_sched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "339-342",
    "snippet": "bool ptrace_may_access_sched(struct task_struct *task, unsigned int mode)\n{\n\treturn __ptrace_may_access(task, mode | PTRACE_MODE_SCHED);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ptrace_may_access",
          "args": [
            "task",
            "mode | PTRACE_MODE_SCHED"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_may_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "274-337",
          "snippet": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn 0;\n\treturn security_ptrace_access_check(task, mode);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn 0;\n\treturn security_ptrace_access_check(task, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nbool ptrace_may_access_sched(struct task_struct *task, unsigned int mode)\n{\n\treturn __ptrace_may_access(task, mode | PTRACE_MODE_SCHED);\n}"
  },
  {
    "function_name": "__ptrace_may_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "274-337",
    "snippet": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn 0;\n\treturn security_ptrace_access_check(task, mode);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_ptrace_access_check",
          "args": [
            "task",
            "mode"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_has_cap",
          "args": [
            "mm->user_ns",
            "mode"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_has_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "262-271",
          "snippet": "static int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn false;\n\n\tif (mode & PTRACE_MODE_NOAUDIT)\n\t\treturn has_ns_capability_noaudit(current, ns, CAP_SYS_PTRACE);\n\telse\n\t\treturn has_ns_capability(current, ns, CAP_SYS_PTRACE);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn false;\n\n\tif (mode & PTRACE_MODE_NOAUDIT)\n\t\treturn has_ns_capability_noaudit(current, ns, CAP_SYS_PTRACE);\n\telse\n\t\treturn has_ns_capability(current, ns, CAP_SYS_PTRACE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dumpable",
          "args": [
            "mm"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "caller_gid",
            "tcred->gid"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "caller_gid",
            "tcred->sgid"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "caller_gid",
            "tcred->egid"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "caller_uid",
            "tcred->uid"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "caller_uid",
            "tcred->suid"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "caller_uid",
            "tcred->euid"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "task"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "task",
            "current"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"denying ptrace access check without PTRACE_MODE_*CREDS\\n\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn 0;\n\treturn security_ptrace_access_check(task, mode);\n}"
  },
  {
    "function_name": "ptrace_has_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "262-271",
    "snippet": "static int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn false;\n\n\tif (mode & PTRACE_MODE_NOAUDIT)\n\t\treturn has_ns_capability_noaudit(current, ns, CAP_SYS_PTRACE);\n\telse\n\t\treturn has_ns_capability(current, ns, CAP_SYS_PTRACE);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_ns_capability",
          "args": [
            "current",
            "ns",
            "CAP_SYS_PTRACE"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "has_ns_capability_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "337-347",
          "snippet": "bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_SCHED)\n\t\treturn false;\n\n\tif (mode & PTRACE_MODE_NOAUDIT)\n\t\treturn has_ns_capability_noaudit(current, ns, CAP_SYS_PTRACE);\n\telse\n\t\treturn has_ns_capability(current, ns, CAP_SYS_PTRACE);\n}"
  },
  {
    "function_name": "ptrace_check_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "224-260",
    "snippet": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\t/*\n\t * We take the read lock around doing both checks to close a\n\t * possible race where someone else was tracing our child and\n\t * detached between these two checks.  After this locked check,\n\t * we are sure that this is our traced child and that can only\n\t * be changed by us so it's not changing right after this.\n\t */\n\tread_lock(&tasklist_lock);\n\tif (child->ptrace && child->parent == current) {\n\t\tWARN_ON(child->state == __TASK_TRACED);\n\t\t/*\n\t\t * child->sighand can't be NULL, release_task()\n\t\t * does ptrace_unlink() before __exit_signal().\n\t\t */\n\t\tif (ignore_state || ptrace_freeze_traced(child))\n\t\t\tret = 0;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tif (!ret && !ignore_state) {\n\t\tif (!wait_task_inactive(child, __TASK_TRACED)) {\n\t\t\t/*\n\t\t\t * This can only happen if may_ptrace_stop() fails and\n\t\t\t * ptrace_stop() changes ->state back to TASK_RUNNING,\n\t\t\t * so we should not worry about leaking __TASK_TRACED.\n\t\t\t */\n\t\t\tWARN_ON(child->state == __TASK_TRACED);\n\t\t\tret = -ESRCH;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "child->state == __TASK_TRACED"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_task_inactive",
          "args": [
            "child",
            "__TASK_TRACED"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1319-1409",
          "snippet": "unsigned long wait_task_inactive(struct task_struct *p, long match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(p->state != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || p->state == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nunsigned long wait_task_inactive(struct task_struct *p, long match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(p->state != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || p->state == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_freeze_traced",
          "args": [
            "child"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_freeze_traced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "168-184",
          "snippet": "static bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\n\t/* Lockless, nobody but us can set this flag */\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\n\t/* Lockless, nobody but us can set this flag */\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "child->state == __TASK_TRACED"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\t/*\n\t * We take the read lock around doing both checks to close a\n\t * possible race where someone else was tracing our child and\n\t * detached between these two checks.  After this locked check,\n\t * we are sure that this is our traced child and that can only\n\t * be changed by us so it's not changing right after this.\n\t */\n\tread_lock(&tasklist_lock);\n\tif (child->ptrace && child->parent == current) {\n\t\tWARN_ON(child->state == __TASK_TRACED);\n\t\t/*\n\t\t * child->sighand can't be NULL, release_task()\n\t\t * does ptrace_unlink() before __exit_signal().\n\t\t */\n\t\tif (ignore_state || ptrace_freeze_traced(child))\n\t\t\tret = 0;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tif (!ret && !ignore_state) {\n\t\tif (!wait_task_inactive(child, __TASK_TRACED)) {\n\t\t\t/*\n\t\t\t * This can only happen if may_ptrace_stop() fails and\n\t\t\t * ptrace_stop() changes ->state back to TASK_RUNNING,\n\t\t\t * so we should not worry about leaking __TASK_TRACED.\n\t\t\t */\n\t\t\tWARN_ON(child->state == __TASK_TRACED);\n\t\t\tret = -ESRCH;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace_unfreeze_traced",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "186-205",
    "snippet": "static void ptrace_unfreeze_traced(struct task_struct *task)\n{\n\tif (task->state != __TASK_TRACED)\n\t\treturn;\n\n\tWARN_ON(!task->ptrace || task->parent != current);\n\n\t/*\n\t * PTRACE_LISTEN can allow ptrace_trap_notify to wake us up remotely.\n\t * Recheck state under the lock to close this race.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task->state == __TASK_TRACED) {\n\t\tif (__fatal_signal_pending(task))\n\t\t\twake_up_state(task, __TASK_TRACED);\n\t\telse\n\t\t\ttask->state = TASK_TRACED;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "task",
            "__TASK_TRACED"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "task"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!task->ptrace || task->parent != current"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic void ptrace_unfreeze_traced(struct task_struct *task)\n{\n\tif (task->state != __TASK_TRACED)\n\t\treturn;\n\n\tWARN_ON(!task->ptrace || task->parent != current);\n\n\t/*\n\t * PTRACE_LISTEN can allow ptrace_trap_notify to wake us up remotely.\n\t * Recheck state under the lock to close this race.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task->state == __TASK_TRACED) {\n\t\tif (__fatal_signal_pending(task))\n\t\t\twake_up_state(task, __TASK_TRACED);\n\t\telse\n\t\t\ttask->state = TASK_TRACED;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n}"
  },
  {
    "function_name": "ptrace_freeze_traced",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "168-184",
    "snippet": "static bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\n\t/* Lockless, nobody but us can set this flag */\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "task"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_is_traced",
          "args": [
            "task"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\n\t/* Lockless, nobody but us can set this flag */\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__ptrace_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "113-165",
    "snippet": "void __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t/*\n\t * Clear all pending traps and TRAPPING.  TRAPPING should be\n\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.\n\t */\n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t/*\n\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and\n\t * @child isn't dead.\n\t */\n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t/*\n\t\t * This is only possible if this thread was cloned by the\n\t\t * traced task running in the stopped group, set the signal\n\t\t * for the future reports.\n\t\t * FIXME: we should change ptrace_init_task() to handle this\n\t\t * case.\n\t\t */\n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t/*\n\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick\n\t * @child in the butt.  Note that @resume should be used iff @child\n\t * is in TASK_TRACED; otherwise, we might unduly disrupt\n\t * TASK_KILLABLE sleeps.\n\t */\n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_signal_wake_up",
          "args": [
            "child",
            "true"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_is_traced",
          "args": [
            "child"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_trapping",
          "args": [
            "child"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_trapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "303-310",
          "snippet": "void task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "child",
            "JOBCTL_TRAP_MASK"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "327-338",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "old_cred"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "135-151",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&child->ptrace_entry"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "child",
            "TIF_SYSCALL_TRACE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!child->ptrace"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t/*\n\t * Clear all pending traps and TRAPPING.  TRAPPING should be\n\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.\n\t */\n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t/*\n\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and\n\t * @child isn't dead.\n\t */\n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t/*\n\t\t * This is only possible if this thread was cloned by the\n\t\t * traced task running in the stopped group, set the signal\n\t\t * for the future reports.\n\t\t * FIXME: we should change ptrace_init_task() to handle this\n\t\t * case.\n\t\t */\n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t/*\n\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick\n\t * @child in the butt.  Note that @resume should be used iff @child\n\t * is in TASK_TRACED; otherwise, we might unduly disrupt\n\t * TASK_KILLABLE sleeps.\n\t */\n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}"
  },
  {
    "function_name": "ptrace_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "78-83",
    "snippet": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ptrace_link",
          "args": [
            "child",
            "new_parent",
            "__task_cred(new_parent)"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
          "lines": "63-70",
          "snippet": "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n\t\t   const struct cred *ptracer_cred)\n{\n\tBUG_ON(!list_empty(&child->ptrace_entry));\n\tlist_add(&child->ptrace_entry, &new_parent->ptraced);\n\tchild->parent = new_parent;\n\tchild->ptracer_cred = get_cred(ptracer_cred);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n\t\t   const struct cred *ptracer_cred)\n{\n\tBUG_ON(!list_empty(&child->ptrace_entry));\n\tlist_add(&child->ptrace_entry, &new_parent->ptraced);\n\tchild->parent = new_parent;\n\tchild->ptracer_cred = get_cred(ptracer_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "new_parent"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "__ptrace_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "63-70",
    "snippet": "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n\t\t   const struct cred *ptracer_cred)\n{\n\tBUG_ON(!list_empty(&child->ptrace_entry));\n\tlist_add(&child->ptrace_entry, &new_parent->ptraced);\n\tchild->parent = new_parent;\n\tchild->ptracer_cred = get_cred(ptracer_cred);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "ptracer_cred"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&child->ptrace_entry",
            "&new_parent->ptraced"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&child->ptrace_entry)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child->ptrace_entry"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n\t\t   const struct cred *ptracer_cred)\n{\n\tBUG_ON(!list_empty(&child->ptrace_entry));\n\tlist_add(&child->ptrace_entry, &new_parent->ptraced);\n\tchild->parent = new_parent;\n\tchild->ptracer_cred = get_cred(ptracer_cred);\n}"
  },
  {
    "function_name": "ptrace_access_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "38-60",
    "snippet": "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1079-1085",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__access_remote_vm",
          "args": [
            "tsk",
            "mm",
            "addr",
            "buf",
            "len",
            "gup_flags"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptracer_capable",
          "args": [
            "tsk",
            "mm->user_ns"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ptracer_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "499-509",
          "snippet": "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n{\n\tint ret = 0;  /* An absent tracer adds no restrictions */\n\tconst struct cred *cred;\n\trcu_read_lock();\n\tcred = rcu_dereference(tsk->ptracer_cred);\n\tif (cred)\n\t\tret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);\n\trcu_read_unlock();\n\treturn (ret == 0);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n{\n\tint ret = 0;  /* An absent tracer adds no restrictions */\n\tconst struct cred *cred;\n\trcu_read_lock();\n\tcred = rcu_dereference(tsk->ptracer_cred);\n\tif (cred)\n\t\tret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);\n\trcu_read_unlock();\n\treturn (ret == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dumpable",
          "args": [
            "mm"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "tsk"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1168-1182",
          "snippet": "struct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nint ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "1119-1162",
    "snippet": "SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n\t\tunsigned long, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(current);\n\t\tgoto out;\n\t}\n\n\tchild = find_get_task_by_vpid(pid);\n\tif (!child) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\t/*\n\t\t * Some architectures need to do book-keeping after\n\t\t * a ptrace attach.\n\t\t */\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (ret < 0)\n\t\tgoto out_put_task_struct;\n\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != PTRACE_DETACH)\n\t\tptrace_unfreeze_traced(child);\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n\t\tunsigned long, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(current);\n\t\tgoto out;\n\t}\n\n\tchild = find_get_task_by_vpid(pid);\n\tif (!child) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\t/*\n\t\t * Some architectures need to do book-keeping after\n\t\t * a ptrace attach.\n\t\t */\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (ret < 0)\n\t\tgoto out_put_task_struct;\n\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != PTRACE_DETACH)\n\t\tptrace_unfreeze_traced(child);\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ptrace.c",
    "lines": "1266-1306",
    "snippet": "SYSCALL_DEFINE4(ptrace, compat_long_t, request, compat_long_t, pid,\n\t\t       compat_long_t, addr, compat_long_t, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = find_get_task_by_vpid(pid);\n\tif (!child) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\t/*\n\t\t * Some architectures need to do book-keeping after\n\t\t * a ptrace attach.\n\t\t */\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret) {\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n\t\tif (ret || request != PTRACE_DETACH)\n\t\t\tptrace_unfreeze_traced(child);\n\t}\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/uio.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE4(ptrace, compat_long_t, request, compat_long_t, pid,\n\t\t       compat_long_t, addr, compat_long_t, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = find_get_task_by_vpid(pid);\n\tif (!child) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\t/*\n\t\t * Some architectures need to do book-keeping after\n\t\t * a ptrace attach.\n\t\t */\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret) {\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n\t\tif (ret || request != PTRACE_DETACH)\n\t\t\tptrace_unfreeze_traced(child);\n\t}\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}"
  }
]