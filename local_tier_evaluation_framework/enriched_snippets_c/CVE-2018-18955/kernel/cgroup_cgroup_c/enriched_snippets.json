[
  {
    "function_name": "cgroup_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "6027-6030",
    "snippet": "static int __init cgroup_sysfs_init(void)\n{\n\treturn sysfs_create_group(kernel_kobj, &cgroup_sysfs_attr_group);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "kernel_kobj",
            "&cgroup_sysfs_attr_group"
          ],
          "line": 6029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int __init cgroup_sysfs_init(void)\n{\n\treturn sysfs_create_group(kernel_kobj, &cgroup_sysfs_attr_group);\n}"
  },
  {
    "function_name": "features_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "6009-6013",
    "snippet": "static ssize_t features_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"nsdelegate\\n\");\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"nsdelegate\\n\""
          ],
          "line": 6012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic ssize_t features_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"nsdelegate\\n\");\n}"
  },
  {
    "function_name": "delegate_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5990-6006",
    "snippet": "static ssize_t delegate_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tssize_t ret = 0;\n\n\tret = show_delegatable_files(cgroup_base_files, buf, PAGE_SIZE - ret,\n\t\t\t\t     NULL);\n\n\tfor_each_subsys(ss, ssid)\n\t\tret += show_delegatable_files(ss->dfl_cftypes, buf + ret,\n\t\t\t\t\t      PAGE_SIZE - ret,\n\t\t\t\t\t      cgroup_subsys_name[ssid]);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};",
      "static struct cftype cgroup_base_files[];",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_delegatable_files",
          "args": [
            "ss->dfl_cftypes",
            "buf + ret",
            "PAGE_SIZE - ret",
            "cgroup_subsys_name[ssid]"
          ],
          "line": 6001
        },
        "resolved": true,
        "details": {
          "function_name": "show_delegatable_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5966-5988",
          "snippet": "static ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (unlikely(ret >= size)) {\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (unlikely(ret >= size)) {\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};\nstatic struct cftype cgroup_base_files[];\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic ssize_t delegate_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tssize_t ret = 0;\n\n\tret = show_delegatable_files(cgroup_base_files, buf, PAGE_SIZE - ret,\n\t\t\t\t     NULL);\n\n\tfor_each_subsys(ss, ssid)\n\t\tret += show_delegatable_files(ss->dfl_cftypes, buf + ret,\n\t\t\t\t\t      PAGE_SIZE - ret,\n\t\t\t\t\t      cgroup_subsys_name[ssid]);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "show_delegatable_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5966-5988",
    "snippet": "static ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (unlikely(ret >= size)) {\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 5982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret >= size"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + ret",
            "size - ret",
            "\"%s\\n\"",
            "cft->name"
          ],
          "line": 5979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + ret",
            "size - ret",
            "\"%s.\"",
            "prefix"
          ],
          "line": 5977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (unlikely(ret >= size)) {\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5953-5962",
    "snippet": "int cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t     union bpf_attr __user *uattr)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_query(cgrp, attr, uattr);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5960
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_query",
          "args": [
            "cgrp",
            "attr",
            "uattr"
          ],
          "line": 5959
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "436-479",
          "snippet": "int __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tu32 flags = cgrp->bpf.flags[type];\n\tint cnt, ret = 0, i;\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(cgrp->bpf.effective[type]);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(cgrp->bpf.effective[type],\n\t\t\t\t\t\t   prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tid = pl->prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tenum bpf_attach_type type = attr->query.attach_type;\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tu32 flags = cgrp->bpf.flags[type];\n\tint cnt, ret = 0, i;\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE)\n\t\tcnt = bpf_prog_array_length(cgrp->bpf.effective[type]);\n\telse\n\t\tcnt = prog_list_length(progs);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt)))\n\t\treturn -EFAULT;\n\tif (attr->query.prog_cnt == 0 || !prog_ids || !cnt)\n\t\t/* return early if user requested only program count + flags */\n\t\treturn 0;\n\tif (attr->query.prog_cnt < cnt) {\n\t\tcnt = attr->query.prog_cnt;\n\t\tret = -ENOSPC;\n\t}\n\n\tif (attr->query.query_flags & BPF_F_QUERY_EFFECTIVE) {\n\t\treturn bpf_prog_array_copy_to_user(cgrp->bpf.effective[type],\n\t\t\t\t\t\t   prog_ids, cnt);\n\t} else {\n\t\tstruct bpf_prog_list *pl;\n\t\tu32 id;\n\n\t\ti = 0;\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tid = pl->prog->aux->id;\n\t\t\tif (copy_to_user(prog_ids + i, &id, sizeof(id)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (++i == cnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5958
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t     union bpf_attr __user *uattr)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_query(cgrp, attr, uattr);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5943-5952",
    "snippet": "int cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t      enum bpf_attach_type type, u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_detach(cgrp, prog, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5950
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_detach",
          "args": [
            "cgrp",
            "prog",
            "type",
            "flags"
          ],
          "line": 5949
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "365-433",
          "snippet": "int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 unused_flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tenum bpf_cgroup_storage_type stype;\n\tu32 flags = cgrp->bpf.flags[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_prog_list *pl;\n\tint err;\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tif (!prog)\n\t\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t\t * of the program to be detached\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\t/* find the prog and detach it */\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog != prog)\n\t\t\t\tcontinue;\n\t\t\told_prog = prog;\n\t\t\t/* mark it deleted, so it's ignored while\n\t\t\t * recomputing effective\n\t\t\t */\n\t\t\tpl->prog = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!old_prog)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL)\n\t\t */\n\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\told_prog = pl->prog;\n\t\tpl->prog = NULL;\n\t}\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t}\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[type] = 0;\n\n\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\treturn 0;\n\ncleanup:\n\t/* and restore back old_prog */\n\tpl->prog = old_prog;\n\treturn err;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 unused_flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tenum bpf_cgroup_storage_type stype;\n\tu32 flags = cgrp->bpf.flags[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_prog_list *pl;\n\tint err;\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tif (!prog)\n\t\t\t/* to detach MULTI prog the user has to specify valid FD\n\t\t\t * of the program to be detached\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (list_empty(progs))\n\t\t\t/* report error when trying to detach and nothing is attached */\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\t/* find the prog and detach it */\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog != prog)\n\t\t\t\tcontinue;\n\t\t\told_prog = prog;\n\t\t\t/* mark it deleted, so it's ignored while\n\t\t\t * recomputing effective\n\t\t\t */\n\t\t\tpl->prog = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!old_prog)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\t/* to maintain backward compatibility NONE and OVERRIDE cgroups\n\t\t * allow detaching with invalid FD (prog==NULL)\n\t\t */\n\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\told_prog = pl->prog;\n\t\tpl->prog = NULL;\n\t}\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* now can actually delete it from this cgroup list */\n\tlist_del(&pl->node);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t}\n\tkfree(pl);\n\tif (list_empty(progs))\n\t\t/* last program was detached, reset flags to zero */\n\t\tcgrp->bpf.flags[type] = 0;\n\n\tbpf_prog_put(old_prog);\n\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\treturn 0;\n\ncleanup:\n\t/* and restore back old_prog */\n\tpl->prog = old_prog;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5948
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t      enum bpf_attach_type type, u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_detach(cgrp, prog, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_bpf_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5933-5942",
    "snippet": "int cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t      enum bpf_attach_type type, u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5940
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cgroup_bpf_attach",
          "args": [
            "cgrp",
            "prog",
            "type",
            "flags"
          ],
          "line": 5939
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_bpf_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "236-354",
          "snippet": "int __cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE],\n\t\t*old_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {NULL};\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_list *pl;\n\tbool pl_was_allocated;\n\tint err;\n\n\tif ((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\n\tif (!hierarchy_allows_attach(cgrp, type, flags))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[type] != flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tstorage[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storage[stype])) {\n\t\t\tstorage[stype] = NULL;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == prog) {\n\t\t\t\t/* disallow attaching the same prog twice */\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpl_was_allocated = true;\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t\tlist_add_tail(&pl->node, progs);\n\t} else {\n\t\tif (list_empty(progs)) {\n\t\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\t\tif (!pl) {\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpl_was_allocated = true;\n\t\t\tlist_add_tail(&pl->node, progs);\n\t\t} else {\n\t\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\t\told_prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\told_storage[stype] = pl->storage[stype];\n\t\t\t\tbpf_cgroup_storage_unlink(old_storage[stype]);\n\t\t\t}\n\t\t\tpl_was_allocated = false;\n\t\t}\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t}\n\n\tcgrp->bpf.flags[type] = flags;\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\tstatic_branch_inc(&cgroup_bpf_enabled_key);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!old_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_free(old_storage[stype]);\n\t}\n\tif (old_prog) {\n\t\tbpf_prog_put(old_prog);\n\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t}\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storage[stype], cgrp, type);\n\treturn 0;\n\ncleanup:\n\t/* and cleanup the prog list */\n\tpl->prog = old_prog;\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\tpl->storage[stype] = old_storage[stype];\n\t\tbpf_cgroup_storage_link(old_storage[stype], cgrp, type);\n\t}\n\tif (pl_was_allocated) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BPF_CGROUP_MAX_PROGS 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define BPF_CGROUP_MAX_PROGS 64\n\nint __cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t\tenum bpf_attach_type type, u32 flags)\n{\n\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\tstruct bpf_prog *old_prog = NULL;\n\tstruct bpf_cgroup_storage *storage[MAX_BPF_CGROUP_STORAGE_TYPE],\n\t\t*old_storage[MAX_BPF_CGROUP_STORAGE_TYPE] = {NULL};\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_prog_list *pl;\n\tbool pl_was_allocated;\n\tint err;\n\n\tif ((flags & BPF_F_ALLOW_OVERRIDE) && (flags & BPF_F_ALLOW_MULTI))\n\t\t/* invalid combination */\n\t\treturn -EINVAL;\n\n\tif (!hierarchy_allows_attach(cgrp, type, flags))\n\t\treturn -EPERM;\n\n\tif (!list_empty(progs) && cgrp->bpf.flags[type] != flags)\n\t\t/* Disallow attaching non-overridable on top\n\t\t * of existing overridable in this cgroup.\n\t\t * Disallow attaching multi-prog if overridable or none\n\t\t */\n\t\treturn -EPERM;\n\n\tif (prog_list_length(progs) >= BPF_CGROUP_MAX_PROGS)\n\t\treturn -E2BIG;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tstorage[stype] = bpf_cgroup_storage_alloc(prog, stype);\n\t\tif (IS_ERR(storage[stype])) {\n\t\t\tstorage[stype] = NULL;\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (flags & BPF_F_ALLOW_MULTI) {\n\t\tlist_for_each_entry(pl, progs, node) {\n\t\t\tif (pl->prog == prog) {\n\t\t\t\t/* disallow attaching the same prog twice */\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\tif (!pl) {\n\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpl_was_allocated = true;\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t\tlist_add_tail(&pl->node, progs);\n\t} else {\n\t\tif (list_empty(progs)) {\n\t\t\tpl = kmalloc(sizeof(*pl), GFP_KERNEL);\n\t\t\tif (!pl) {\n\t\t\t\tfor_each_cgroup_storage_type(stype)\n\t\t\t\t\tbpf_cgroup_storage_free(storage[stype]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpl_was_allocated = true;\n\t\t\tlist_add_tail(&pl->node, progs);\n\t\t} else {\n\t\t\tpl = list_first_entry(progs, typeof(*pl), node);\n\t\t\told_prog = pl->prog;\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\told_storage[stype] = pl->storage[stype];\n\t\t\t\tbpf_cgroup_storage_unlink(old_storage[stype]);\n\t\t\t}\n\t\t\tpl_was_allocated = false;\n\t\t}\n\t\tpl->prog = prog;\n\t\tfor_each_cgroup_storage_type(stype)\n\t\t\tpl->storage[stype] = storage[stype];\n\t}\n\n\tcgrp->bpf.flags[type] = flags;\n\n\terr = update_effective_progs(cgrp, type);\n\tif (err)\n\t\tgoto cleanup;\n\n\tstatic_branch_inc(&cgroup_bpf_enabled_key);\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!old_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_free(old_storage[stype]);\n\t}\n\tif (old_prog) {\n\t\tbpf_prog_put(old_prog);\n\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t}\n\tfor_each_cgroup_storage_type(stype)\n\t\tbpf_cgroup_storage_link(storage[stype], cgrp, type);\n\treturn 0;\n\ncleanup:\n\t/* and cleanup the prog list */\n\tpl->prog = old_prog;\n\tfor_each_cgroup_storage_type(stype) {\n\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\tpl->storage[stype] = old_storage[stype];\n\t\tbpf_cgroup_storage_link(old_storage[stype], cgrp, type);\n\t}\n\tif (pl_was_allocated) {\n\t\tlist_del(&pl->node);\n\t\tkfree(pl);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5938
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t      enum bpf_attach_type type, u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_sk_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5925-5928",
    "snippet": "void cgroup_sk_free(struct sock_cgroup_data *skcd)\n{\n\tcgroup_put(sock_cgroup_ptr(skcd));\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "sock_cgroup_ptr(skcd)"
          ],
          "line": 5927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "skcd"
          ],
          "line": 5927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_sk_free(struct sock_cgroup_data *skcd)\n{\n\tcgroup_put(sock_cgroup_ptr(skcd));\n}"
  },
  {
    "function_name": "cgroup_sk_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5893-5923",
    "snippet": "void cgroup_sk_alloc(struct sock_cgroup_data *skcd)\n{\n\tif (cgroup_sk_alloc_disabled)\n\t\treturn;\n\n\t/* Socket clone path */\n\tif (skcd->val) {\n\t\t/*\n\t\t * We might be cloning a socket which is left in an empty\n\t\t * cgroup and the cgroup might have already been rmdir'd.\n\t\t * Don't use cgroup_get_live().\n\t\t */\n\t\tcgroup_get(sock_cgroup_ptr(skcd));\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\twhile (true) {\n\t\tstruct css_set *cset;\n\n\t\tcset = task_css_set(current);\n\t\tif (likely(cgroup_tryget(cset->dfl_cgrp))) {\n\t\t\tskcd->val = (unsigned long)cset->dfl_cgrp;\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define cgroup_sk_alloc_disabled\tfalse"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5922
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 5919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "cgroup_tryget(cset->dfl_cgrp)"
          ],
          "line": 5915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_tryget",
          "args": [
            "cset->dfl_cgrp"
          ],
          "line": 5915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 5914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5909
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_get",
          "args": [
            "sock_cgroup_ptr(skcd)"
          ],
          "line": 5905
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5843-5865",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "skcd"
          ],
          "line": 5905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\n#define cgroup_sk_alloc_disabled\tfalse\n\nvoid cgroup_sk_alloc(struct sock_cgroup_data *skcd)\n{\n\tif (cgroup_sk_alloc_disabled)\n\t\treturn;\n\n\t/* Socket clone path */\n\tif (skcd->val) {\n\t\t/*\n\t\t * We might be cloning a socket which is left in an empty\n\t\t * cgroup and the cgroup might have already been rmdir'd.\n\t\t * Don't use cgroup_get_live().\n\t\t */\n\t\tcgroup_get(sock_cgroup_ptr(skcd));\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\twhile (true) {\n\t\tstruct css_set *cset;\n\n\t\tcset = task_css_set(current);\n\t\tif (likely(cgroup_tryget(cset->dfl_cgrp))) {\n\t\t\tskcd->val = (unsigned long)cset->dfl_cgrp;\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cgroup_sk_alloc_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5879-5885",
    "snippet": "void cgroup_sk_alloc_disable(void)\n{\n\tif (cgroup_sk_alloc_disabled)\n\t\treturn;\n\tpr_info(\"cgroup: disabling cgroup2 socket matching due to net_prio or net_cls activation\\n\");\n\tcgroup_sk_alloc_disabled = true;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define cgroup_sk_alloc_disabled\tfalse"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"cgroup: disabling cgroup2 socket matching due to net_prio or net_cls activation\\n\""
          ],
          "line": 5883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\n#define cgroup_sk_alloc_disabled\tfalse\n\nvoid cgroup_sk_alloc_disable(void)\n{\n\tif (cgroup_sk_alloc_disabled)\n\t\treturn;\n\tpr_info(\"cgroup: disabling cgroup2 socket matching due to net_prio or net_cls activation\\n\");\n\tcgroup_sk_alloc_disabled = true;\n}"
  },
  {
    "function_name": "cgroup_get_from_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5843-5865",
    "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 5861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 5860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 5859
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "css"
          ],
          "line": 5856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "css"
          ],
          "line": 5855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 5854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online_from_dir",
          "args": [
            "f->f_path.dentry",
            "NULL"
          ],
          "line": 5853
        },
        "resolved": true,
        "details": {
          "function_name": "css_tryget_online_from_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5755-5784",
          "snippet": "struct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type cgroup2_fs_type;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct file_system_type cgroup2_fs_type;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 5851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget_raw",
          "args": [
            "fd"
          ],
          "line": 5849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tfput(f);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}"
  },
  {
    "function_name": "cgroup_get_from_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5809-5831",
    "snippet": "struct cgroup *cgroup_get_from_path(const char *path)\n{\n\tstruct kernfs_node *kn;\n\tstruct cgroup *cgrp;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tkn = kernfs_walk_and_get(cgrp_dfl_root.cgrp.kn, path);\n\tif (kn) {\n\t\tif (kernfs_type(kn) == KERNFS_DIR) {\n\t\t\tcgrp = kn->priv;\n\t\t\tcgroup_get_live(cgrp);\n\t\t} else {\n\t\t\tcgrp = ERR_PTR(-ENOTDIR);\n\t\t}\n\t\tkernfs_put(kn);\n\t} else {\n\t\tcgrp = ERR_PTR(-ENOENT);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn cgrp;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5829
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 5826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 5824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 5822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "cgrp"
          ],
          "line": 5820
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "559-563",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_walk_and_get",
          "args": [
            "cgrp_dfl_root.cgrp.kn",
            "path"
          ],
          "line": 5816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5814
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_path(const char *path)\n{\n\tstruct kernfs_node *kn;\n\tstruct cgroup *cgrp;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tkn = kernfs_walk_and_get(cgrp_dfl_root.cgrp.kn, path);\n\tif (kn) {\n\t\tif (kernfs_type(kn) == KERNFS_DIR) {\n\t\t\tcgrp = kn->priv;\n\t\t\tcgroup_get_live(cgrp);\n\t\t} else {\n\t\t\tcgrp = ERR_PTR(-ENOTDIR);\n\t\t}\n\t\tkernfs_put(kn);\n\t} else {\n\t\tcgrp = ERR_PTR(-ENOENT);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn cgrp;\n}"
  },
  {
    "function_name": "css_from_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5794-5798",
    "snippet": "struct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&ss->css_idr, id);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&ss->css_idr",
            "id"
          ],
          "line": 5797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 5796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 5796
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstruct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&ss->css_idr, id);\n}"
  },
  {
    "function_name": "css_tryget_online_from_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5755-5784",
    "snippet": "struct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type cgroup2_fs_type;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5782
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 5780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "css"
          ],
          "line": 5779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 5777
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "463-471",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*(void __rcu __force **)&kn->priv"
          ],
          "line": 5775
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5768
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 5766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_node_from_dentry",
          "args": [
            "dentry"
          ],
          "line": 5758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct file_system_type cgroup2_fs_type;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}"
  },
  {
    "function_name": "cgroup_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5725-5743",
    "snippet": "static int __init cgroup_disable(char *str)\n{\n\tstruct cgroup_subsys *ss;\n\tchar *token;\n\tint i;\n\n\twhile ((token = strsep(&str, \",\")) != NULL) {\n\t\tif (!*token)\n\t\t\tcontinue;\n\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(token, ss->name) &&\n\t\t\t    strcmp(token, ss->legacy_name))\n\t\t\t\tcontinue;\n\t\t\tcgroup_disable_mask |= 1 << i;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "token",
            "ss->legacy_name"
          ],
          "line": 5737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "token",
            "ss->name"
          ],
          "line": 5736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 5735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\",\""
          ],
          "line": 5731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic int __init cgroup_disable(char *str)\n{\n\tstruct cgroup_subsys *ss;\n\tchar *token;\n\tint i;\n\n\twhile ((token = strsep(&str, \",\")) != NULL) {\n\t\tif (!*token)\n\t\t\tcontinue;\n\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(token, ss->name) &&\n\t\t\t    strcmp(token, ss->legacy_name))\n\t\t\t\tcontinue;\n\t\t\tcgroup_disable_mask |= 1 << i;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "cgroup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5712-5723",
    "snippet": "void cgroup_free(struct task_struct *task)\n{\n\tstruct css_set *cset = task_css_set(task);\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, have_free_callback) {\n\t\tss->free(task);\n\t} while_each_subsys_mask();\n\n\tput_css_set(cset);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 have_free_callback",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "cset"
          ],
          "line": 5722
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "863-898",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 5720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->free",
          "args": [
            "task"
          ],
          "line": 5719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "have_free_callback"
          ],
          "line": 5718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 5714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_free_callback;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_free(struct task_struct *task)\n{\n\tstruct css_set *cset = task_css_set(task);\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, have_free_callback) {\n\t\tss->free(task);\n\t} while_each_subsys_mask();\n\n\tput_css_set(cset);\n}"
  },
  {
    "function_name": "cgroup_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5685-5710",
    "snippet": "void cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\t/*\n\t * Unlink from @tsk from its css_set.  As migration path can't race\n\t * with us, we can check css_set and cg_list without synchronization.\n\t */\n\tcset = task_css_set(tsk);\n\n\tif (!list_empty(&tsk->cg_list)) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcss_set_move_task(tsk, cset, NULL, false);\n\t\tcset->nr_tasks--;\n\t\tspin_unlock_irq(&css_set_lock);\n\t} else {\n\t\tget_css_set(cset);\n\t}\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 have_exit_callback",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 5709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->exit",
          "args": [
            "tsk"
          ],
          "line": 5708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "i",
            "have_exit_callback"
          ],
          "line": 5707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 5703
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "179-182",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5701
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_move_task",
          "args": [
            "tsk",
            "cset",
            "NULL",
            "false"
          ],
          "line": 5699
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_move_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "794-840",
          "snippet": "static void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tstruct css_task_iter *it, *pos;\n\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\t/*\n\t\t * @task is leaving, advance task iterators which are\n\t\t * pointing to it so that they can resume at the next\n\t\t * position.  Advancing an iterator might remove it from\n\t\t * the list, use safe walk.  See css_task_iter_advance*()\n\t\t * for details.\n\t\t */\n\t\tlist_for_each_entry_safe(it, pos, &from_cset->task_iters,\n\t\t\t\t\t iters_node)\n\t\t\tif (it->task_pos == &task->cg_list)\n\t\t\t\tcss_task_iter_advance(it);\n\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit() changing the css_set to\n\t\t * init_css_set and dropping the old one.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct percpu_rw_semaphore cgroup_threadgroup_rwsem;",
            "static void css_task_iter_advance(struct css_task_iter *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct percpu_rw_semaphore cgroup_threadgroup_rwsem;\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tstruct css_task_iter *it, *pos;\n\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\t/*\n\t\t * @task is leaving, advance task iterators which are\n\t\t * pointing to it so that they can resume at the next\n\t\t * position.  Advancing an iterator might remove it from\n\t\t * the list, use safe walk.  See css_task_iter_advance*()\n\t\t * for details.\n\t\t */\n\t\tlist_for_each_entry_safe(it, pos, &from_cset->task_iters,\n\t\t\t\t\t iters_node)\n\t\t\tif (it->task_pos == &task->cg_list)\n\t\t\t\tcss_task_iter_advance(it);\n\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit() changing the css_set to\n\t\t * init_css_set and dropping the old one.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5698
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tsk->cg_list"
          ],
          "line": 5697
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "tsk"
          ],
          "line": 5695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_exit_callback;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\t/*\n\t * Unlink from @tsk from its css_set.  As migration path can't race\n\t * with us, we can check css_set and cg_list without synchronization.\n\t */\n\tcset = task_css_set(tsk);\n\n\tif (!list_empty(&tsk->cg_list)) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcss_set_move_task(tsk, cset, NULL, false);\n\t\tcset->nr_tasks--;\n\t\tspin_unlock_irq(&css_set_lock);\n\t} else {\n\t\tget_css_set(cset);\n\t}\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}"
  },
  {
    "function_name": "cgroup_post_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5617-5664",
    "snippet": "void cgroup_post_fork(struct task_struct *child)\n{\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\t/*\n\t * This may race against cgroup_enable_task_cg_lists().  As that\n\t * function sets use_task_css_set_links before grabbing\n\t * tasklist_lock and we just went through tasklist_lock to add\n\t * @child, it's guaranteed that either we see the set\n\t * use_task_css_set_links or cgroup_enable_task_cg_lists() sees\n\t * @child during its iteration.\n\t *\n\t * If we won the race, @child is associated with %current's\n\t * css_set.  Grabbing css_set_lock guarantees both that the\n\t * association is stable, and, on completion of the parent's\n\t * migration, @child is visible in the source of migration or\n\t * already in the destination cgroup.  This guarantee is necessary\n\t * when implementing operations which need to migrate all tasks of\n\t * a cgroup to another.\n\t *\n\t * Note that if we lose to cgroup_enable_task_cg_lists(), @child\n\t * will remain in init_css_set.  This is safe because all tasks are\n\t * in the init_css_set before cg_links is enabled and there's no\n\t * operation which transfers all tasks out of init_css_set.\n\t */\n\tif (use_task_css_set_links) {\n\t\tstruct css_set *cset;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset = task_css_set(current);\n\t\tif (list_empty(&child->cg_list)) {\n\t\t\tget_css_set(cset);\n\t\t\tcset->nr_tasks++;\n\t\t\tcss_set_move_task(child, NULL, cset, false);\n\t\t}\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\t/*\n\t * Call ss->fork().  This must happen after @child is linked on\n\t * css_set; otherwise, @child might change state between ->fork()\n\t * and addition to css_set.\n\t */\n\tdo_each_subsys_mask(ss, i, have_fork_callback) {\n\t\tss->fork(child);\n\t} while_each_subsys_mask();\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 have_fork_callback",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 5663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->fork",
          "args": [
            "child"
          ],
          "line": 5662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "i",
            "have_fork_callback"
          ],
          "line": 5661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5653
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_move_task",
          "args": [
            "child",
            "NULL",
            "cset",
            "false"
          ],
          "line": 5651
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_move_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "794-840",
          "snippet": "static void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tstruct css_task_iter *it, *pos;\n\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\t/*\n\t\t * @task is leaving, advance task iterators which are\n\t\t * pointing to it so that they can resume at the next\n\t\t * position.  Advancing an iterator might remove it from\n\t\t * the list, use safe walk.  See css_task_iter_advance*()\n\t\t * for details.\n\t\t */\n\t\tlist_for_each_entry_safe(it, pos, &from_cset->task_iters,\n\t\t\t\t\t iters_node)\n\t\t\tif (it->task_pos == &task->cg_list)\n\t\t\t\tcss_task_iter_advance(it);\n\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit() changing the css_set to\n\t\t * init_css_set and dropping the old one.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct percpu_rw_semaphore cgroup_threadgroup_rwsem;",
            "static void css_task_iter_advance(struct css_task_iter *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct percpu_rw_semaphore cgroup_threadgroup_rwsem;\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tstruct css_task_iter *it, *pos;\n\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\t/*\n\t\t * @task is leaving, advance task iterators which are\n\t\t * pointing to it so that they can resume at the next\n\t\t * position.  Advancing an iterator might remove it from\n\t\t * the list, use safe walk.  See css_task_iter_advance*()\n\t\t * for details.\n\t\t */\n\t\tlist_for_each_entry_safe(it, pos, &from_cset->task_iters,\n\t\t\t\t\t iters_node)\n\t\t\tif (it->task_pos == &task->cg_list)\n\t\t\t\tcss_task_iter_advance(it);\n\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit() changing the css_set to\n\t\t * init_css_set and dropping the old one.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 5649
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "179-182",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child->cg_list"
          ],
          "line": 5648
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 5647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5646
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_fork_callback;\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_post_fork(struct task_struct *child)\n{\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\t/*\n\t * This may race against cgroup_enable_task_cg_lists().  As that\n\t * function sets use_task_css_set_links before grabbing\n\t * tasklist_lock and we just went through tasklist_lock to add\n\t * @child, it's guaranteed that either we see the set\n\t * use_task_css_set_links or cgroup_enable_task_cg_lists() sees\n\t * @child during its iteration.\n\t *\n\t * If we won the race, @child is associated with %current's\n\t * css_set.  Grabbing css_set_lock guarantees both that the\n\t * association is stable, and, on completion of the parent's\n\t * migration, @child is visible in the source of migration or\n\t * already in the destination cgroup.  This guarantee is necessary\n\t * when implementing operations which need to migrate all tasks of\n\t * a cgroup to another.\n\t *\n\t * Note that if we lose to cgroup_enable_task_cg_lists(), @child\n\t * will remain in init_css_set.  This is safe because all tasks are\n\t * in the init_css_set before cg_links is enabled and there's no\n\t * operation which transfers all tasks out of init_css_set.\n\t */\n\tif (use_task_css_set_links) {\n\t\tstruct css_set *cset;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset = task_css_set(current);\n\t\tif (list_empty(&child->cg_list)) {\n\t\t\tget_css_set(cset);\n\t\t\tcset->nr_tasks++;\n\t\t\tcss_set_move_task(child, NULL, cset, false);\n\t\t}\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\t/*\n\t * Call ss->fork().  This must happen after @child is linked on\n\t * css_set; otherwise, @child might change state between ->fork()\n\t * and addition to css_set.\n\t */\n\tdo_each_subsys_mask(ss, i, have_fork_callback) {\n\t\tss->fork(child);\n\t} while_each_subsys_mask();\n}"
  },
  {
    "function_name": "cgroup_cancel_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5597-5605",
    "snippet": "void cgroup_cancel_fork(struct task_struct *child)\n{\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ss->cancel_fork",
          "args": [
            "child"
          ],
          "line": 5604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 5602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_cancel_fork(struct task_struct *child)\n{\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child);\n}"
  },
  {
    "function_name": "cgroup_can_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5566-5588",
    "snippet": "int cgroup_can_fork(struct task_struct *child)\n{\n\tstruct cgroup_subsys *ss;\n\tint i, j, ret;\n\n\tdo_each_subsys_mask(ss, i, have_canfork_callback) {\n\t\tret = ss->can_fork(child);\n\t\tif (ret)\n\t\t\tgoto out_revert;\n\t} while_each_subsys_mask();\n\n\treturn 0;\n\nout_revert:\n\tfor_each_subsys(ss, j) {\n\t\tif (j >= i)\n\t\t\tbreak;\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 have_canfork_callback",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ss->cancel_fork",
          "args": [
            "child"
          ],
          "line": 5584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "j"
          ],
          "line": 5580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 5575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->can_fork",
          "args": [
            "child"
          ],
          "line": 5572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "i",
            "have_canfork_callback"
          ],
          "line": 5571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_canfork_callback;\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint cgroup_can_fork(struct task_struct *child)\n{\n\tstruct cgroup_subsys *ss;\n\tint i, j, ret;\n\n\tdo_each_subsys_mask(ss, i, have_canfork_callback) {\n\t\tret = ss->can_fork(child);\n\t\tif (ret)\n\t\t\tgoto out_revert;\n\t} while_each_subsys_mask();\n\n\treturn 0;\n\nout_revert:\n\tfor_each_subsys(ss, j) {\n\t\tif (j >= i)\n\t\t\tbreak;\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5552-5556",
    "snippet": "void cgroup_fork(struct task_struct *child)\n{\n\tRCU_INIT_POINTER(child->cgroups, &init_css_set);\n\tINIT_LIST_HEAD(&child->cg_list);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&child->cg_list"
          ],
          "line": 5555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "child->cgroups",
            "&init_css_set"
          ],
          "line": 5554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_fork(struct task_struct *child)\n{\n\tRCU_INIT_POINTER(child->cgroups, &init_css_set);\n\tINIT_LIST_HEAD(&child->cg_list);\n}"
  },
  {
    "function_name": "proc_cgroup_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5471-5542",
    "snippet": "int proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf;\n\tint retval;\n\tstruct cgroup_root *root;\n\n\tretval = -ENOMEM;\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tfor_each_root(root) {\n\t\tstruct cgroup_subsys *ss;\n\t\tstruct cgroup *cgrp;\n\t\tint ssid, count = 0;\n\n\t\tif (root == &cgrp_dfl_root && !cgrp_dfl_visible)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%d:\", root->hierarchy_id);\n\t\tif (root != &cgrp_dfl_root)\n\t\t\tfor_each_subsys(ss, ssid)\n\t\t\t\tif (root->subsys_mask & (1 << ssid))\n\t\t\t\t\tseq_printf(m, \"%s%s\", count++ ? \",\" : \"\",\n\t\t\t\t\t\t   ss->legacy_name);\n\t\tif (strlen(root->name))\n\t\t\tseq_printf(m, \"%sname=%s\", count ? \",\" : \"\",\n\t\t\t\t   root->name);\n\t\tseq_putc(m, ':');\n\n\t\tcgrp = task_cgroup_from_root(tsk, root);\n\n\t\t/*\n\t\t * On traditional hierarchies, all zombie tasks show up as\n\t\t * belonging to the root cgroup.  On the default hierarchy,\n\t\t * while a zombie doesn't show up in \"cgroup.procs\" and\n\t\t * thus can't be migrated, its /proc/PID/cgroup keeps\n\t\t * reporting the cgroup it belonged to before exiting.  If\n\t\t * the cgroup is removed before the zombie is reaped,\n\t\t * \" (deleted)\" is appended to the cgroup path.\n\t\t */\n\t\tif (cgroup_on_dfl(cgrp) || !(tsk->flags & PF_EXITING)) {\n\t\t\tretval = cgroup_path_ns_locked(cgrp, buf, PATH_MAX,\n\t\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\t\t\tif (retval >= PATH_MAX)\n\t\t\t\tretval = -ENAMETOOLONG;\n\t\t\tif (retval < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tseq_puts(m, buf);\n\t\t} else {\n\t\t\tseq_puts(m, \"/\");\n\t\t}\n\n\t\tif (cgroup_on_dfl(cgrp) && cgroup_is_dead(cgrp))\n\t\t\tseq_puts(m, \" (deleted)\\n\");\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\tretval = 0;\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\tkfree(buf);\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static bool cgrp_dfl_visible;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 5539
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5538
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5537
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 5532
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" (deleted)\\n\""
          ],
          "line": 5530
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "cgrp"
          ],
          "line": 5529
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "147-150",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 5529
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_path_ns_locked",
          "args": [
            "cgrp",
            "buf",
            "PATH_MAX",
            "current->nsproxy->cgroup_ns"
          ],
          "line": 5517
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_ns_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2116-2122",
          "snippet": "int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cgroup_from_root",
          "args": [
            "tsk",
            "root"
          ],
          "line": 5505
        },
        "resolved": true,
        "details": {
          "function_name": "task_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1357-1366",
          "snippet": "struct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold cgroup_mutex the\n\t * task can't change groups, so the only thing that can happen\n\t * is that it exits and its css is set back to init_css_set.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold cgroup_mutex the\n\t * task can't change groups, so the only thing that can happen\n\t * is that it exits and its css is set back to init_css_set.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%sname=%s\"",
            "count ? \",\" : \"\"",
            "root->name"
          ],
          "line": 5501
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "root->name"
          ],
          "line": 5500
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 5496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5484
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5483
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 5479
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic bool cgrp_dfl_visible;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf;\n\tint retval;\n\tstruct cgroup_root *root;\n\n\tretval = -ENOMEM;\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tfor_each_root(root) {\n\t\tstruct cgroup_subsys *ss;\n\t\tstruct cgroup *cgrp;\n\t\tint ssid, count = 0;\n\n\t\tif (root == &cgrp_dfl_root && !cgrp_dfl_visible)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%d:\", root->hierarchy_id);\n\t\tif (root != &cgrp_dfl_root)\n\t\t\tfor_each_subsys(ss, ssid)\n\t\t\t\tif (root->subsys_mask & (1 << ssid))\n\t\t\t\t\tseq_printf(m, \"%s%s\", count++ ? \",\" : \"\",\n\t\t\t\t\t\t   ss->legacy_name);\n\t\tif (strlen(root->name))\n\t\t\tseq_printf(m, \"%sname=%s\", count ? \",\" : \"\",\n\t\t\t\t   root->name);\n\t\tseq_putc(m, ':');\n\n\t\tcgrp = task_cgroup_from_root(tsk, root);\n\n\t\t/*\n\t\t * On traditional hierarchies, all zombie tasks show up as\n\t\t * belonging to the root cgroup.  On the default hierarchy,\n\t\t * while a zombie doesn't show up in \"cgroup.procs\" and\n\t\t * thus can't be migrated, its /proc/PID/cgroup keeps\n\t\t * reporting the cgroup it belonged to before exiting.  If\n\t\t * the cgroup is removed before the zombie is reaped,\n\t\t * \" (deleted)\" is appended to the cgroup path.\n\t\t */\n\t\tif (cgroup_on_dfl(cgrp) || !(tsk->flags & PF_EXITING)) {\n\t\t\tretval = cgroup_path_ns_locked(cgrp, buf, PATH_MAX,\n\t\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\t\t\tif (retval >= PATH_MAX)\n\t\t\t\tretval = -ENAMETOOLONG;\n\t\t\tif (retval < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tseq_puts(m, buf);\n\t\t} else {\n\t\t\tseq_puts(m, \"/\");\n\t\t}\n\n\t\tif (cgroup_on_dfl(cgrp) && cgroup_is_dead(cgrp))\n\t\t\tseq_puts(m, \" (deleted)\\n\");\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\tretval = 0;\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\tkfree(buf);\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "cgroup_path_from_kernfs_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5454-5464",
    "snippet": "void cgroup_path_from_kernfs_id(const union kernfs_node_id *id,\n\t\t\t\t\tchar *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_path",
          "args": [
            "kn",
            "buf",
            "buflen"
          ],
          "line": 5462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_node_by_id",
          "args": [
            "cgrp_dfl_root.kf_root",
            "id"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\n\nvoid cgroup_path_from_kernfs_id(const union kernfs_node_id *id,\n\t\t\t\t\tchar *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}"
  },
  {
    "function_name": "cgroup_wq_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5438-5451",
    "snippet": "static int __init cgroup_wq_init(void)\n{\n\t/*\n\t * There isn't much point in executing destruction path in\n\t * parallel.  Good chunk is serialized with cgroup_mutex anyway.\n\t * Use 1 for @max_active.\n\t *\n\t * We would prefer to do this in cgroup_init() above, but that\n\t * is called before init_workqueues(): so leave this until after.\n\t */\n\tcgroup_destroy_wq = alloc_workqueue(\"cgroup_destroy\", 0, 1);\n\tBUG_ON(!cgroup_destroy_wq);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cgroup_destroy_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cgroup_destroy_wq"
          ],
          "line": 5449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"cgroup_destroy\"",
            "0",
            "1"
          ],
          "line": 5448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_destroy_wq;\n\nstatic int __init cgroup_wq_init(void)\n{\n\t/*\n\t * There isn't much point in executing destruction path in\n\t * parallel.  Good chunk is serialized with cgroup_mutex anyway.\n\t * Use 1 for @max_active.\n\t *\n\t * We would prefer to do this in cgroup_init() above, but that\n\t * is called before init_workqueues(): so leave this until after.\n\t */\n\tcgroup_destroy_wq = alloc_workqueue(\"cgroup_destroy\", 0, 1);\n\tBUG_ON(!cgroup_destroy_wq);\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5333-5436",
    "snippet": "int __init cgroup_init(void)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tBUILD_BUG_ON(CGROUP_SUBSYS_COUNT > 16);\n\tBUG_ON(percpu_init_rwsem(&cgroup_threadgroup_rwsem));\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup_base_files));\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup1_base_files));\n\n\tcgroup_rstat_boot();\n\n\t/*\n\t * The latency of the synchronize_sched() is too high for cgroups,\n\t * avoid it at the cost of forcing all readers into the slow path.\n\t */\n\trcu_sync_enter_start(&cgroup_threadgroup_rwsem.rss);\n\n\tget_user_ns(init_cgroup_ns.user_ns);\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/*\n\t * Add init_css_set to the hash table so that dfl_root can link to\n\t * it during init.\n\t */\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tBUG_ON(cgroup_setup_root(&cgrp_dfl_root, 0, 0));\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (ss->early_init) {\n\t\t\tstruct cgroup_subsys_state *css =\n\t\t\t\tinit_css_set.subsys[ss->id];\n\n\t\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tBUG_ON(css->id < 0);\n\t\t} else {\n\t\t\tcgroup_init_subsys(ss, false);\n\t\t}\n\n\t\tlist_add_tail(&init_css_set.e_cset_node[ssid],\n\t\t\t      &cgrp_dfl_root.cgrp.e_csets[ssid]);\n\n\t\t/*\n\t\t * Setting dfl_root subsys_mask needs to consider the\n\t\t * disabled flag and cftype registration needs kmalloc,\n\t\t * both of which aren't available during early_init.\n\t\t */\n\t\tif (cgroup_disable_mask & (1 << ssid)) {\n\t\t\tstatic_branch_disable(cgroup_subsys_enabled_key[ssid]);\n\t\t\tprintk(KERN_INFO \"Disabling %s control group subsystem\\n\",\n\t\t\t       ss->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cgroup1_ssid_disabled(ssid))\n\t\t\tprintk(KERN_INFO \"Disabling %s control group subsystem in v1 mounts\\n\",\n\t\t\t       ss->name);\n\n\t\tcgrp_dfl_root.subsys_mask |= 1 << ss->id;\n\n\t\t/* implicit controllers must be threaded too */\n\t\tWARN_ON(ss->implicit_on_dfl && !ss->threaded);\n\n\t\tif (ss->implicit_on_dfl)\n\t\t\tcgrp_dfl_implicit_ss_mask |= 1 << ss->id;\n\t\telse if (!ss->dfl_cftypes)\n\t\t\tcgrp_dfl_inhibit_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->threaded)\n\t\t\tcgrp_dfl_threaded_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->dfl_cftypes == ss->legacy_cftypes) {\n\t\t\tWARN_ON(cgroup_add_cftypes(ss, ss->dfl_cftypes));\n\t\t} else {\n\t\t\tWARN_ON(cgroup_add_dfl_cftypes(ss, ss->dfl_cftypes));\n\t\t\tWARN_ON(cgroup_add_legacy_cftypes(ss, ss->legacy_cftypes));\n\t\t}\n\n\t\tif (ss->bind)\n\t\t\tss->bind(init_css_set.subsys[ssid]);\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tcss_populate_dir(init_css_set.subsys[ssid]);\n\t\tmutex_unlock(&cgroup_mutex);\n\t}\n\n\t/* init_css_set.subsys[] has been updated, re-hash */\n\thash_del(&init_css_set.hlist);\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tWARN_ON(sysfs_create_mount_point(fs_kobj, \"cgroup\"));\n\tWARN_ON(register_filesystem(&cgroup_fs_type));\n\tWARN_ON(register_filesystem(&cgroup2_fs_type));\n\tWARN_ON(!proc_create_single(\"cgroups\", 0, NULL, proc_cgroupstats_show));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct percpu_rw_semaphore cgroup_threadgroup_rwsem;",
      "static struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};",
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static u16 cgrp_dfl_inhibit_ss_mask;",
      "static u16 cgrp_dfl_implicit_ss_mask;",
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "struct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
      "static struct file_system_type cgroup2_fs_type;",
      "static struct cftype cgroup_base_files[];",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!proc_create_single(\"cgroups\", 0, NULL, proc_cgroupstats_show)"
          ],
          "line": 5433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single",
          "args": [
            "\"cgroups\"",
            "0",
            "NULL",
            "proc_cgroupstats_show"
          ],
          "line": 5433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "register_filesystem(&cgroup2_fs_type)"
          ],
          "line": 5432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&cgroup2_fs_type"
          ],
          "line": 5432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "register_filesystem(&cgroup_fs_type)"
          ],
          "line": 5431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&cgroup_fs_type"
          ],
          "line": 5431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sysfs_create_mount_point(fs_kobj, \"cgroup\")"
          ],
          "line": 5430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_mount_point",
          "args": [
            "fs_kobj",
            "\"cgroup\""
          ],
          "line": 5430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "css_set_table",
            "&init_css_set.hlist",
            "css_set_hash(init_css_set.subsys)"
          ],
          "line": 5427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_hash",
          "args": [
            "init_css_set.subsys"
          ],
          "line": 5428
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "850-861",
          "snippet": "static unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&init_css_set.hlist"
          ],
          "line": 5426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5422
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_populate_dir",
          "args": [
            "init_css_set.subsys[ssid]"
          ],
          "line": 5421
        },
        "resolved": true,
        "details": {
          "function_name": "css_populate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1604-1642",
          "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5420
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss->bind",
          "args": [
            "init_css_set.subsys[ssid]"
          ],
          "line": 5418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_legacy_cftypes(ss, ss->legacy_cftypes)"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_legacy_cftypes",
          "args": [
            "ss",
            "ss->legacy_cftypes"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_dfl_cftypes(ss, ss->dfl_cftypes)"
          ],
          "line": 5413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_dfl_cftypes",
          "args": [
            "ss",
            "ss->dfl_cftypes"
          ],
          "line": 5413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_cftypes(ss, ss->dfl_cftypes)"
          ],
          "line": 5411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_cftypes",
          "args": [
            "ss",
            "ss->dfl_cftypes"
          ],
          "line": 5411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ss->implicit_on_dfl && !ss->threaded"
          ],
          "line": 5400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Disabling %s control group subsystem in v1 mounts\\n\"",
            "ss->name"
          ],
          "line": 5394
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup1_ssid_disabled",
          "args": [
            "ssid"
          ],
          "line": 5393
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_ssid_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "42-45",
          "snippet": "bool cgroup1_ssid_disabled(int ssid)\n{\n\treturn cgroup_no_v1_mask & (1 << ssid);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgroup_no_v1_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgroup_no_v1_mask;\n\nbool cgroup1_ssid_disabled(int ssid)\n{\n\treturn cgroup_no_v1_mask & (1 << ssid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "cgroup_subsys_enabled_key[ssid]"
          ],
          "line": 5387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&init_css_set.e_cset_node[ssid]",
            "&cgrp_dfl_root.cgrp.e_csets[ssid]"
          ],
          "line": 5378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_subsys",
          "args": [
            "ss",
            "false"
          ],
          "line": 5375
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init_subsys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5236-5287",
          "snippet": "static void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(cgroup_css(&cgrp_dfl_root.cgrp, ss));\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_free_callback |= (bool)ss->free << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static u16 have_fork_callback",
            "static u16 have_exit_callback",
            "static u16 have_free_callback",
            "static u16 have_canfork_callback",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 have_fork_callback;\nstatic u16 have_exit_callback;\nstatic u16 have_free_callback;\nstatic u16 have_canfork_callback;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(cgroup_css(&cgrp_dfl_root.cgrp, ss));\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_free_callback |= (bool)ss->free << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "css->id < 0"
          ],
          "line": 5373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_idr_alloc",
          "args": [
            "&ss->css_idr",
            "css",
            "1",
            "2",
            "GFP_KERNEL"
          ],
          "line": 5371
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "301-312",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 5366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_setup_root(&cgrp_dfl_root, 0, 0)"
          ],
          "line": 5362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_setup_root",
          "args": [
            "&cgrp_dfl_root",
            "0",
            "0"
          ],
          "line": 5362
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_setup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1896-1995",
          "snippet": "int cgroup_setup_root(struct cgroup_root *root, u16 ss_mask, int ref_flags)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = cgroup_idr_alloc(&root->cgroup_idr, root_cgrp, 1, 2, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out;\n\troot_cgrp->id = ret;\n\troot_cgrp->ancestor_ids[0] = ret;\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      ref_flags, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tkernfs_activate(root_cgrp->kn);\n\tret = 0;\n\tgoto out;\n\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_root_count;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_setup_root(struct cgroup_root *root, u16 ss_mask, int ref_flags)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = cgroup_idr_alloc(&root->cgroup_idr, root_cgrp, 1, 2, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out;\n\troot_cgrp->id = ret;\n\troot_cgrp->ancestor_ids[0] = ret;\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      ref_flags, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tkernfs_activate(root_cgrp->kn);\n\tret = 0;\n\tgoto out;\n\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "css_set_table",
            "&init_css_set.hlist",
            "css_set_hash(init_css_set.subsys)"
          ],
          "line": 5359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "init_cgroup_ns.user_ns"
          ],
          "line": 5351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_sync_enter_start",
          "args": [
            "&cgroup_threadgroup_rwsem.rss"
          ],
          "line": 5349
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_enter_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
          "lines": "96-100",
          "snippet": "void rcu_sync_enter_start(struct rcu_sync *rsp)\n{\n\trsp->gp_count++;\n\trsp->gp_state = GP_PASSED;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nvoid rcu_sync_enter_start(struct rcu_sync *rsp)\n{\n\trsp->gp_count++;\n\trsp->gp_state = GP_PASSED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_boot",
          "args": [],
          "line": 5343
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_boot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "290-298",
          "snippet": "void __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n\n\tBUG_ON(cgroup_rstat_init(&cgrp_dfl_root.cgrp));\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n\n\tBUG_ON(cgroup_rstat_init(&cgrp_dfl_root.cgrp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_init_cftypes(NULL, cgroup1_base_files)"
          ],
          "line": 5341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_cftypes",
          "args": [
            "NULL",
            "cgroup1_base_files"
          ],
          "line": 5341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_init_cftypes(NULL, cgroup_base_files)"
          ],
          "line": 5340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_cftypes",
          "args": [
            "NULL",
            "cgroup_base_files"
          ],
          "line": 5340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "percpu_init_rwsem(&cgroup_threadgroup_rwsem)"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_init_rwsem",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "CGROUP_SUBSYS_COUNT > 16"
          ],
          "line": 5338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct percpu_rw_semaphore cgroup_threadgroup_rwsem;\nstatic struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstruct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic struct file_system_type cgroup2_fs_type;\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nint __init cgroup_init(void)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tBUILD_BUG_ON(CGROUP_SUBSYS_COUNT > 16);\n\tBUG_ON(percpu_init_rwsem(&cgroup_threadgroup_rwsem));\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup_base_files));\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup1_base_files));\n\n\tcgroup_rstat_boot();\n\n\t/*\n\t * The latency of the synchronize_sched() is too high for cgroups,\n\t * avoid it at the cost of forcing all readers into the slow path.\n\t */\n\trcu_sync_enter_start(&cgroup_threadgroup_rwsem.rss);\n\n\tget_user_ns(init_cgroup_ns.user_ns);\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/*\n\t * Add init_css_set to the hash table so that dfl_root can link to\n\t * it during init.\n\t */\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tBUG_ON(cgroup_setup_root(&cgrp_dfl_root, 0, 0));\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (ss->early_init) {\n\t\t\tstruct cgroup_subsys_state *css =\n\t\t\t\tinit_css_set.subsys[ss->id];\n\n\t\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tBUG_ON(css->id < 0);\n\t\t} else {\n\t\t\tcgroup_init_subsys(ss, false);\n\t\t}\n\n\t\tlist_add_tail(&init_css_set.e_cset_node[ssid],\n\t\t\t      &cgrp_dfl_root.cgrp.e_csets[ssid]);\n\n\t\t/*\n\t\t * Setting dfl_root subsys_mask needs to consider the\n\t\t * disabled flag and cftype registration needs kmalloc,\n\t\t * both of which aren't available during early_init.\n\t\t */\n\t\tif (cgroup_disable_mask & (1 << ssid)) {\n\t\t\tstatic_branch_disable(cgroup_subsys_enabled_key[ssid]);\n\t\t\tprintk(KERN_INFO \"Disabling %s control group subsystem\\n\",\n\t\t\t       ss->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cgroup1_ssid_disabled(ssid))\n\t\t\tprintk(KERN_INFO \"Disabling %s control group subsystem in v1 mounts\\n\",\n\t\t\t       ss->name);\n\n\t\tcgrp_dfl_root.subsys_mask |= 1 << ss->id;\n\n\t\t/* implicit controllers must be threaded too */\n\t\tWARN_ON(ss->implicit_on_dfl && !ss->threaded);\n\n\t\tif (ss->implicit_on_dfl)\n\t\t\tcgrp_dfl_implicit_ss_mask |= 1 << ss->id;\n\t\telse if (!ss->dfl_cftypes)\n\t\t\tcgrp_dfl_inhibit_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->threaded)\n\t\t\tcgrp_dfl_threaded_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->dfl_cftypes == ss->legacy_cftypes) {\n\t\t\tWARN_ON(cgroup_add_cftypes(ss, ss->dfl_cftypes));\n\t\t} else {\n\t\t\tWARN_ON(cgroup_add_dfl_cftypes(ss, ss->dfl_cftypes));\n\t\t\tWARN_ON(cgroup_add_legacy_cftypes(ss, ss->legacy_cftypes));\n\t\t}\n\n\t\tif (ss->bind)\n\t\t\tss->bind(init_css_set.subsys[ssid]);\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tcss_populate_dir(init_css_set.subsys[ssid]);\n\t\tmutex_unlock(&cgroup_mutex);\n\t}\n\n\t/* init_css_set.subsys[] has been updated, re-hash */\n\thash_del(&init_css_set.hlist);\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tWARN_ON(sysfs_create_mount_point(fs_kobj, \"cgroup\"));\n\tWARN_ON(register_filesystem(&cgroup_fs_type));\n\tWARN_ON(register_filesystem(&cgroup2_fs_type));\n\tWARN_ON(!proc_create_single(\"cgroups\", 0, NULL, proc_cgroupstats_show));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_init_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5295-5323",
    "snippet": "int __init cgroup_init_early(void)\n{\n\tstatic struct cgroup_sb_opts __initdata opts;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tinit_cgroup_root(&cgrp_dfl_root, &opts);\n\tcgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;\n\n\tRCU_INIT_POINTER(init_task.cgroups, &init_css_set);\n\n\tfor_each_subsys(ss, i) {\n\t\tWARN(!ss->css_alloc || !ss->css_free || ss->name || ss->id,\n\t\t     \"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\\n\",\n\t\t     i, cgroup_subsys_name[i], ss->css_alloc, ss->css_free,\n\t\t     ss->id, ss->name);\n\t\tWARN(strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN,\n\t\t     \"cgroup_subsys_name %s too long\\n\", cgroup_subsys_name[i]);\n\n\t\tss->id = i;\n\t\tss->name = cgroup_subsys_name[i];\n\t\tif (!ss->legacy_name)\n\t\t\tss->legacy_name = cgroup_subsys_name[i];\n\n\t\tif (ss->early_init)\n\t\t\tcgroup_init_subsys(ss, true);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};",
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_init_subsys",
          "args": [
            "ss",
            "true"
          ],
          "line": 5320
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init_subsys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5236-5287",
          "snippet": "static void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(cgroup_css(&cgrp_dfl_root.cgrp, ss));\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_free_callback |= (bool)ss->free << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static u16 have_fork_callback",
            "static u16 have_exit_callback",
            "static u16 have_free_callback",
            "static u16 have_canfork_callback",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 have_fork_callback;\nstatic u16 have_exit_callback;\nstatic u16 have_free_callback;\nstatic u16 have_canfork_callback;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(cgroup_css(&cgrp_dfl_root.cgrp, ss));\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_free_callback |= (bool)ss->free << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN",
            "\"cgroup_subsys_name %s too long\\n\"",
            "cgroup_subsys_name[i]"
          ],
          "line": 5311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cgroup_subsys_name[i]"
          ],
          "line": 5311
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!ss->css_alloc || !ss->css_free || ss->name || ss->id",
            "\"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\\n\"",
            "i",
            "cgroup_subsys_name[i]",
            "ss->css_alloc",
            "ss->css_free",
            "ss->id",
            "ss->name"
          ],
          "line": 5307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "init_task.cgroups",
            "&init_css_set"
          ],
          "line": 5304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cgroup_root",
          "args": [
            "&cgrp_dfl_root",
            "&opts"
          ],
          "line": 5301
        },
        "resolved": true,
        "details": {
          "function_name": "init_cgroup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1877-1894",
          "snippet": "void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\tidr_init(&root->cgroup_idr);\n\n\troot->flags = opts->flags;\n\tif (opts->release_agent)\n\t\tstrscpy(root->release_agent_path, opts->release_agent, PATH_MAX);\n\tif (opts->name)\n\t\tstrscpy(root->name, opts->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (opts->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\tidr_init(&root->cgroup_idr);\n\n\troot->flags = opts->flags;\n\tif (opts->release_agent)\n\t\tstrscpy(root->release_agent_path, opts->release_agent, PATH_MAX);\n\tif (opts->name)\n\t\tstrscpy(root->name, opts->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (opts->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint __init cgroup_init_early(void)\n{\n\tstatic struct cgroup_sb_opts __initdata opts;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tinit_cgroup_root(&cgrp_dfl_root, &opts);\n\tcgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;\n\n\tRCU_INIT_POINTER(init_task.cgroups, &init_css_set);\n\n\tfor_each_subsys(ss, i) {\n\t\tWARN(!ss->css_alloc || !ss->css_free || ss->name || ss->id,\n\t\t     \"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\\n\",\n\t\t     i, cgroup_subsys_name[i], ss->css_alloc, ss->css_free,\n\t\t     ss->id, ss->name);\n\t\tWARN(strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN,\n\t\t     \"cgroup_subsys_name %s too long\\n\", cgroup_subsys_name[i]);\n\n\t\tss->id = i;\n\t\tss->name = cgroup_subsys_name[i];\n\t\tif (!ss->legacy_name)\n\t\t\tss->legacy_name = cgroup_subsys_name[i];\n\n\t\tif (ss->early_init)\n\t\t\tcgroup_init_subsys(ss, true);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_init_subsys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5236-5287",
    "snippet": "static void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(cgroup_css(&cgrp_dfl_root.cgrp, ss));\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_free_callback |= (bool)ss->free << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static u16 have_fork_callback",
      "static u16 have_exit_callback",
      "static u16 have_free_callback",
      "static u16 have_canfork_callback",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5286
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "online_css(css)"
          ],
          "line": 5284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "online_css",
          "args": [
            "css"
          ],
          "line": 5284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&init_task.tasks)"
          ],
          "line": 5282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&init_task.tasks"
          ],
          "line": 5282
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "css->id < 0"
          ],
          "line": 5265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_idr_alloc",
          "args": [
            "&ss->css_idr",
            "css",
            "1",
            "2",
            "GFP_KERNEL"
          ],
          "line": 5264
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "301-312",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_and_link_css",
          "args": [
            "css",
            "ss",
            "&cgrp_dfl_root.cgrp"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(css)"
          ],
          "line": 5251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "css"
          ],
          "line": 5251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_alloc",
          "args": [
            "cgroup_css(&cgrp_dfl_root.cgrp, ss)"
          ],
          "line": 5249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "&cgrp_dfl_root.cgrp",
            "ss"
          ],
          "line": 5249
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "463-471",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ss->cfts"
          ],
          "line": 5245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&ss->css_idr"
          ],
          "line": 5244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5242
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Initializing cgroup subsys %s\\n\"",
            "ss->name"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 have_fork_callback;\nstatic u16 have_exit_callback;\nstatic u16 have_free_callback;\nstatic u16 have_canfork_callback;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(cgroup_css(&cgrp_dfl_root.cgrp, ss));\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_free_callback |= (bool)ss->free << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}"
  },
  {
    "function_name": "cgroup_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5211-5226",
    "snippet": "int cgroup_rmdir(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\tint ret = 0;\n\n\tcgrp = cgroup_kn_lock_live(kn, false);\n\tif (!cgrp)\n\t\treturn 0;\n\n\tret = cgroup_destroy_locked(cgrp);\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(rmdir, cgrp);\n\n\tcgroup_kn_unlock(kn);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "kn"
          ],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1488-1501",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "rmdir",
            "cgrp"
          ],
          "line": 5222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_destroy_locked",
          "args": [
            "cgrp"
          ],
          "line": 5220
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_destroy_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5149-5209",
          "snippet": "static int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t}\n\n\tcgroup1_check_for_release(parent);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void css_release(struct percpu_ref *ref);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t}\n\n\tcgroup1_check_for_release(parent);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "kn",
            "false"
          ],
          "line": 5216
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1520-1549",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_rmdir(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\tint ret = 0;\n\n\tcgrp = cgroup_kn_lock_live(kn, false);\n\tif (!cgrp)\n\t\treturn 0;\n\n\tret = cgroup_destroy_locked(cgrp);\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(rmdir, cgrp);\n\n\tcgroup_kn_unlock(kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_destroy_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5149-5209",
    "snippet": "static int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t}\n\n\tcgroup1_check_for_release(parent);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&cgrp->self.refcnt"
          ],
          "line": 5206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup1_check_for_release",
          "args": [
            "parent"
          ],
          "line": 5203
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_check_for_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "772-777",
          "snippet": "void cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "tcgrp"
          ],
          "line": 5198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 5195
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "cgrp->kn"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_clear_dir",
          "args": [
            "&cgrp->self"
          ],
          "line": 5192
        },
        "resolved": true,
        "details": {
          "function_name": "css_clear_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1575-1596",
          "snippet": "static void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_css",
          "args": [
            "css"
          ],
          "line": 5189
        },
        "resolved": true,
        "details": {
          "function_name": "kill_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5091-5123",
          "snippet": "static void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static void css_release(struct percpu_ref *ref);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_css",
          "args": [
            "css",
            "ssid",
            "cgrp"
          ],
          "line": 5188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5185
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cgrp->cset_links",
            "cset_link"
          ],
          "line": 5183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5182
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_has_online_children",
          "args": [
            "&cgrp->self"
          ],
          "line": 5171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t}\n\n\tcgroup1_check_for_release(parent);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kill_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5091-5123",
    "snippet": "static void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_kill_and_confirm",
          "args": [
            "&css->refcnt",
            "css_killed_ref_fn"
          ],
          "line": 5122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css"
          ],
          "line": 5110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_clear_dir",
          "args": [
            "css"
          ],
          "line": 5104
        },
        "resolved": true,
        "details": {
          "function_name": "css_clear_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1575-1596",
          "snippet": "static void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}"
  },
  {
    "function_name": "css_killed_ref_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "5071-5080",
    "snippet": "static void css_killed_ref_fn(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tif (atomic_dec_and_test(&css->online_cnt)) {\n\t\tINIT_WORK(&css->destroy_work, css_killed_work_fn);\n\t\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cgroup_destroy_wq;",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cgroup_destroy_wq",
            "&css->destroy_work"
          ],
          "line": 5078
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "77-97",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&css->destroy_work",
            "css_killed_work_fn"
          ],
          "line": 5077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&css->online_cnt"
          ],
          "line": 5076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structcgroup_subsys_state",
            "refcnt"
          ],
          "line": 5074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_destroy_wq;\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void css_killed_ref_fn(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tif (atomic_dec_and_test(&css->online_cnt)) {\n\t\tINIT_WORK(&css->destroy_work, css_killed_work_fn);\n\t\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n\t}\n}"
  },
  {
    "function_name": "cgroup_attach_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2614-5068",
    "snippet": "int cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct task_struct *task;\n\tint ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/* look up all src csets */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_src(task_css_set(task), dst_cgrp, &mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* prepare dst csets and commit */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (!ret)\n\t\tret = cgroup_migrate(leader, threadgroup, &mgctx);\n\n\tcgroup_migrate_finish(&mgctx);\n\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(attach_task, dst_cgrp, leader, threadgroup);\n\n\treturn ret;\n}\n\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup)\n\t__acquires(&cgroup_threadgroup_rwsem)\n{\n\tstruct task_struct *tsk;\n\tpid_t pid;\n\n\tif (kstrtoint(strstrip(buf), 0, &pid) || pid < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\trcu_read_lock();\n\tif (pid) {\n\t\ttsk = find_task_by_vpid(pid);\n\t\tif (!tsk) {\n\t\t\ttsk = ERR_PTR(-ESRCH);\n\t\t\tgoto out_unlock_threadgroup;\n\t\t}\n\t} else {\n\t\ttsk = current;\n\t}\n\n\tif (threadgroup)\n\t\ttsk = tsk->group_leader;\n\n\t/*\n\t * kthreads may acquire PF_NO_SETAFFINITY during initialization.\n\t * If userland migrates such a kthread to a non-root cgroup, it can\n\t * become trapped in a cpuset, or RT kthread may be born in a\n\t * cgroup with no rt_runtime allocated.  Just say no.\n\t */\n\tif (tsk->no_cgroup_migration || (tsk->flags & PF_NO_SETAFFINITY)) {\n\t\ttsk = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock_threadgroup;\n\t}\n\n\tget_task_struct(tsk);\n\tgoto out_unlock_rcu;\n\nout_unlock_threadgroup:\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\nout_unlock_rcu:\n\trcu_read_unlock();\n\treturn tsk;\n}\n\nvoid cgroup_procs_write_finish(struct task_struct *task)\n\t__releases(&cgroup_threadgroup_rwsem)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\t/* release reference from cgroup_procs_write_start() */\n\tput_task_struct(task);\n\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tfor_each_subsys(ss, ssid)\n\t\tif (ss->post_attach)\n\t\t\tss->post_attach();\n}\n\nstatic void cgroup_print_ss_mask(struct seq_file *seq, u16 ss_mask)\n{\n\tstruct cgroup_subsys *ss;\n\tbool printed = false;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tif (printed)\n\t\t\tseq_putc(seq, ' ');\n\t\tseq_printf(seq, \"%s\", ss->name);\n\t\tprinted = true;\n\t} while_each_subsys_mask();\n\tif (printed)\n\t\tseq_putc(seq, '\\n');\n}\n\n/* show controllers which are enabled from the parent */\nstatic int cgroup_controllers_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgroup_control(cgrp));\n\treturn 0;\n}\n\n/* show controllers which are enabled for a given cgroup's children */\nstatic int cgroup_subtree_control_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgrp->subtree_control);\n\treturn 0;\n}\n\n/**\n * cgroup_update_dfl_csses - update css assoc of a subtree in default hierarchy\n * @cgrp: root of the subtree to update csses for\n *\n * @cgrp's control masks have changed and its subtree's css associations\n * need to be updated accordingly.  This function looks up all css_sets\n * which are attached to the subtree, creates the matching updated css_sets\n * and migrates the tasks to the new ones.\n */\nstatic int cgroup_update_dfl_csses(struct cgroup *cgrp)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup *dsct;\n\tstruct css_set *src_cset;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* look up all csses currently attached to @cgrp's subtree */\n\tspin_lock_irq(&css_set_lock);\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &dsct->cset_links, cset_link)\n\t\t\tcgroup_migrate_add_src(link->cset, dsct, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* NULL dst indicates self on default hierarchy */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(src_cset, &mgctx.preloaded_src_csets, mg_preload_node) {\n\t\tstruct task_struct *task, *ntask;\n\n\t\t/* all tasks in src_csets need to be migrated */\n\t\tlist_for_each_entry_safe(task, ntask, &src_cset->tasks, cg_list)\n\t\t\tcgroup_migrate_add_task(task, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_execute(&mgctx);\nout_finish:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\treturn ret;\n}\n\n/**\n * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses\n * @cgrp: root of the target subtree\n *\n * Because css offlining is asynchronous, userland may try to re-enable a\n * controller while the previous css is still around.  This function grabs\n * cgroup_mutex and drains the previous css instances of @cgrp's subtree.\n */\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp)\n\t__acquires(&cgroup_mutex)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\nrestart:\n\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tif (!css || !percpu_ref_is_dying(&css->refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get_live(dsct);\n\t\t\tprepare_to_wait(&dsct->offline_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tschedule();\n\t\t\tfinish_wait(&dsct->offline_waitq, &wait);\n\n\t\t\tcgroup_put(dsct);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_save_control - save control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Save ->subtree_control, ->subtree_ss_mask and ->dom_cgrp to the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_save_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->old_subtree_control = dsct->subtree_control;\n\t\tdsct->old_subtree_ss_mask = dsct->subtree_ss_mask;\n\t\tdsct->old_dom_cgrp = dsct->dom_cgrp;\n\t}\n}\n\n/**\n * cgroup_propagate_control - refresh control masks of a subtree\n * @cgrp: root of the target subtree\n *\n * For @cgrp and its subtree, ensure ->subtree_ss_mask matches\n * ->subtree_control and propagate controller availability through the\n * subtree so that descendants don't have unavailable controllers enabled.\n */\nstatic void cgroup_propagate_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control &= cgroup_control(dsct);\n\t\tdsct->subtree_ss_mask =\n\t\t\tcgroup_calc_subtree_ss_mask(dsct->subtree_control,\n\t\t\t\t\t\t    cgroup_ss_mask(dsct));\n\t}\n}\n\n/**\n * cgroup_restore_control - restore control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Restore ->subtree_control, ->subtree_ss_mask and ->dom_cgrp from the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_restore_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control = dsct->old_subtree_control;\n\t\tdsct->subtree_ss_mask = dsct->old_subtree_ss_mask;\n\t\tdsct->dom_cgrp = dsct->old_dom_cgrp;\n\t}\n}\n\nstatic bool css_visible(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tif (cgroup_control(cgrp) & (1 << ss->id))\n\t\treturn true;\n\tif (!(cgroup_ss_mask(cgrp) & (1 << ss->id)))\n\t\treturn false;\n\treturn cgroup_on_dfl(cgrp) && ss->implicit_on_dfl;\n}\n\n/**\n * cgroup_apply_control_enable - enable or show csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and create new csses or make the existing ones\n * visible.  A css is created invisible if it's being implicitly enabled\n * through dependency.  An invisible css is made visible when the userland\n * explicitly enables it.\n *\n * Returns 0 on success, -errno on failure.  On failure, csses which have\n * been processed already aren't cleaned up.  The caller is responsible for\n * cleaning up with cgroup_apply_control_disable().\n */\nstatic int cgroup_apply_control_enable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid, ret;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tWARN_ON_ONCE(css && percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (!(cgroup_ss_mask(dsct) & (1 << ss->id)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!css) {\n\t\t\t\tcss = css_create(dsct, ss);\n\t\t\t\tif (IS_ERR(css))\n\t\t\t\t\treturn PTR_ERR(css);\n\t\t\t}\n\n\t\t\tif (css_visible(css)) {\n\t\t\t\tret = css_populate_dir(css);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_apply_control_disable - kill or hide csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and kill and hide csses so that they match\n * cgroup_ss_mask() and cgroup_visible_mask().\n *\n * A css is hidden when the userland requests it to be disabled while other\n * subsystems are still depending on it.  The css must not actively control\n * resources and be in the vanilla state if it's made visible again later.\n * Controllers which may be depended upon should provide ->css_reset() for\n * this purpose.\n */\nstatic void cgroup_apply_control_disable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tWARN_ON_ONCE(css && percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tif (css->parent &&\n\t\t\t    !(cgroup_ss_mask(dsct) & (1 << ss->id))) {\n\t\t\t\tkill_css(css);\n\t\t\t} else if (!css_visible(css)) {\n\t\t\t\tcss_clear_dir(css);\n\t\t\t\tif (ss->css_reset)\n\t\t\t\t\tss->css_reset(css);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * cgroup_apply_control - apply control mask updates to the subtree\n * @cgrp: root of the target subtree\n *\n * subsystems can be enabled and disabled in a subtree using the following\n * steps.\n *\n * 1. Call cgroup_save_control() to stash the current state.\n * 2. Update ->subtree_control masks in the subtree as desired.\n * 3. Call cgroup_apply_control() to apply the changes.\n * 4. Optionally perform other related operations.\n * 5. Call cgroup_finalize_control() to finish up.\n *\n * This function implements step 3 and propagates the mask changes\n * throughout @cgrp's subtree, updates csses accordingly and perform\n * process migrations.\n */\nstatic int cgroup_apply_control(struct cgroup *cgrp)\n{\n\tint ret;\n\n\tcgroup_propagate_control(cgrp);\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * At this point, cgroup_e_css() results reflect the new csses\n\t * making the following cgroup_update_dfl_csses() properly update\n\t * css associations of all tasks in the subtree.\n\t */\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * cgroup_finalize_control - finalize control mask update\n * @cgrp: root of the target subtree\n * @ret: the result of the update\n *\n * Finalize control mask update.  See cgroup_apply_control() for more info.\n */\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret)\n{\n\tif (ret) {\n\t\tcgroup_restore_control(cgrp);\n\t\tcgroup_propagate_control(cgrp);\n\t}\n\n\tcgroup_apply_control_disable(cgrp);\n}\n\nstatic int cgroup_vet_subtree_control_enable(struct cgroup *cgrp, u16 enable)\n{\n\tu16 domain_enable = enable & ~cgrp_dfl_threaded_ss_mask;\n\n\t/* if nothing is getting enabled, nothing to worry about */\n\tif (!enable)\n\t\treturn 0;\n\n\t/* can @cgrp host any resources? */\n\tif (!cgroup_is_valid_domain(cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn 0;\n\n\tif (domain_enable) {\n\t\t/* can't enable domain controllers inside a thread subtree */\n\t\tif (cgroup_is_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\t/*\n\t\t * Threaded controllers can handle internal competitions\n\t\t * and are always allowed inside a (prospective) thread\n\t\t * subtree.\n\t\t */\n\t\tif (cgroup_can_be_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Controllers can't be enabled for a cgroup with tasks to avoid\n\t * child cgroups competing against tasks.\n\t */\n\tif (cgroup_has_tasks(cgrp))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/* change the enabled child controllers for a cgroup in the default hierarchy */\nstatic ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tu16 enable = 0, disable = 0;\n\tstruct cgroup *cgrp, *child;\n\tstruct cgroup_subsys *ss;\n\tchar *tok;\n\tint ssid, ret;\n\n\t/*\n\t * Parse input - space separated list of subsystem names prefixed\n\t * with either + or -.\n\t */\n\tbuf = strstrip(buf);\n\twhile ((tok = strsep(&buf, \" \"))) {\n\t\tif (tok[0] == '\\0')\n\t\t\tcontinue;\n\t\tdo_each_subsys_mask(ss, ssid, ~cgrp_dfl_inhibit_ss_mask) {\n\t\t\tif (!cgroup_ssid_enabled(ssid) ||\n\t\t\t    strcmp(tok + 1, ss->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (*tok == '+') {\n\t\t\t\tenable |= 1 << ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while_each_subsys_mask();\n\t\tif (ssid == CGROUP_SUBSYS_COUNT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (enable & (1 << ssid)) {\n\t\t\tif (cgrp->subtree_control & (1 << ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(cgroup_control(cgrp) & (1 << ssid))) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->subtree_control & (1 << ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* a child has it enabled? */\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->subtree_control & (1 << ssid)) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tret = cgroup_vet_subtree_control_enable(cgrp, enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* save and update control masks and prepare csses */\n\tcgroup_save_control(cgrp);\n\n\tcgrp->subtree_control |= enable;\n\tcgrp->subtree_control &= ~disable;\n\n\tret = cgroup_apply_control(cgrp);\n\tcgroup_finalize_control(cgrp, ret);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tkernfs_activate(cgrp->kn);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\n/**\n * cgroup_enable_threaded - make @cgrp threaded\n * @cgrp: the target cgroup\n *\n * Called when \"threaded\" is written to the cgroup.type interface file and\n * tries to make @cgrp threaded and join the parent's resource domain.\n * This function is never called on the root cgroup as cgroup.type doesn't\n * exist on it.\n */\nstatic int cgroup_enable_threaded(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup *dom_cgrp = parent->dom_cgrp;\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* noop if already threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @cgroup is populated or has domain controllers enabled, it\n\t * can't be switched.  While the below cgroup_can_be_thread_root()\n\t * test can catch the same conditions, that's only when @parent is\n\t * not mixable, so let's check it explicitly.\n\t */\n\tif (cgroup_is_populated(cgrp) ||\n\t    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn -EOPNOTSUPP;\n\n\t/* we're joining the parent's domain, ensure its validity */\n\tif (!cgroup_is_valid_domain(dom_cgrp) ||\n\t    !cgroup_can_be_thread_root(dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * The following shouldn't cause actual migrations and should\n\t * always succeed.\n\t */\n\tcgroup_save_control(cgrp);\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\n\t\tif (dsct == cgrp || cgroup_is_threaded(dsct))\n\t\t\tdsct->dom_cgrp = dom_cgrp;\n\n\tret = cgroup_apply_control(cgrp);\n\tif (!ret)\n\t\tparent->nr_threaded_children++;\n\n\tcgroup_finalize_control(cgrp, ret);\n\treturn ret;\n}\n\nstatic int cgroup_type_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tif (cgroup_is_threaded(cgrp))\n\t\tseq_puts(seq, \"threaded\\n\");\n\telse if (!cgroup_is_valid_domain(cgrp))\n\t\tseq_puts(seq, \"domain invalid\\n\");\n\telse if (cgroup_is_thread_root(cgrp))\n\t\tseq_puts(seq, \"domain threaded\\n\");\n\telse\n\t\tseq_puts(seq, \"domain\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* only switching to threaded mode is supported */\n\tif (strcmp(strstrip(buf), \"threaded\"))\n\t\treturn -EINVAL;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/* threaded can only be enabled */\n\tret = cgroup_enable_threaded(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_max_descendants_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint descendants = READ_ONCE(cgrp->max_descendants);\n\n\tif (descendants == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", descendants);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,\n\t\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint descendants;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdescendants = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &descendants);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (descendants < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_descendants = descendants;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_max_depth_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint depth = READ_ONCE(cgrp->max_depth);\n\n\tif (depth == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", depth);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint depth;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdepth = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &depth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (depth < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_depth = depth;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_events_show(struct seq_file *seq, void *v)\n{\n\tseq_printf(seq, \"populated %d\\n\",\n\t\t   cgroup_is_populated(seq_css(seq)->cgroup));\n\treturn 0;\n}\n\nstatic int cgroup_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgroup = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"nr_descendants %d\\n\",\n\t\t   cgroup->nr_descendants);\n\tseq_printf(seq, \"nr_dying_descendants %d\\n\",\n\t\t   cgroup->nr_dying_descendants);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cgroup_extra_stat_show(struct seq_file *seq,\n\t\t\t\t\t\t struct cgroup *cgrp, int ssid)\n{\n\tstruct cgroup_subsys *ss = cgroup_subsys[ssid];\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!ss->css_extra_stat_show)\n\t\treturn 0;\n\n\tcss = cgroup_tryget_css(cgrp, ss);\n\tif (!css)\n\t\treturn 0;\n\n\tret = ss->css_extra_stat_show(seq, css);\n\tcss_put(css);\n\treturn ret;\n}\n\nstatic int cpu_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup __maybe_unused *cgrp = seq_css(seq)->cgroup;\n\tint ret = 0;\n\n\tcgroup_base_stat_cputime_show(seq);\n#ifdef CONFIG_CGROUP_SCHED\n\tret = cgroup_extra_stat_show(seq, cgrp, cpu_cgrp_id);\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_PSI\nstatic int cgroup_io_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_IO);\n}\nstatic int cgroup_memory_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_MEM);\n}\nstatic int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_CPU);\n}\n#endif\n\nstatic int cgroup_file_open(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->open)\n\t\treturn cft->open(of);\n\treturn 0;\n}\n\nstatic void cgroup_file_release(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->release)\n\t\tcft->release(of);\n}\n\nstatic ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of->kn->priv;\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, disallow writes to\n\t * files in an non-init namespace root from inside the namespace\n\t * except for the files explicitly marked delegatable -\n\t * cgroup.procs and cgroup.subtree_control.\n\t */\n\tif ((cgrp->root->flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    !(cft->flags & CFTYPE_NS_DELEGATABLE) &&\n\t    ns != &init_cgroup_ns && ns->root_cset->dfl_cgrp == cgrp)\n\t\treturn -EPERM;\n\n\tif (cft->write)\n\t\treturn cft->write(of, buf, nbytes, off);\n\n\t/*\n\t * kernfs guarantees that a file isn't deleted with operations in\n\t * flight, which means that the matching css is and stays alive and\n\t * doesn't need to be pinned.  The RCU locking is not necessary\n\t * either.  It's just for the convenience of using cgroup_css().\n\t */\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, cft->ss);\n\trcu_read_unlock();\n\n\tif (cft->write_u64) {\n\t\tunsigned long long v;\n\t\tret = kstrtoull(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_u64(css, cft, v);\n\t} else if (cft->write_s64) {\n\t\tlong long v;\n\t\tret = kstrtoll(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_s64(css, cft, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ?: nbytes;\n}\n\nstatic void *cgroup_seqfile_start(struct seq_file *seq, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_start(seq, ppos);\n}\n\nstatic void *cgroup_seqfile_next(struct seq_file *seq, void *v, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_next(seq, v, ppos);\n}\n\nstatic void cgroup_seqfile_stop(struct seq_file *seq, void *v)\n{\n\tif (seq_cft(seq)->seq_stop)\n\t\tseq_cft(seq)->seq_stop(seq, v);\n}\n\nstatic int cgroup_seqfile_show(struct seq_file *m, void *arg)\n{\n\tstruct cftype *cft = seq_cft(m);\n\tstruct cgroup_subsys_state *css = seq_css(m);\n\n\tif (cft->seq_show)\n\t\treturn cft->seq_show(m, arg);\n\n\tif (cft->read_u64)\n\t\tseq_printf(m, \"%llu\\n\", cft->read_u64(css, cft));\n\telse if (cft->read_s64)\n\t\tseq_printf(m, \"%lld\\n\", cft->read_s64(css, cft));\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct kernfs_ops cgroup_kf_single_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\nstatic struct kernfs_ops cgroup_kf_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.seq_start\t\t= cgroup_seqfile_start,\n\t.seq_next\t\t= cgroup_seqfile_next,\n\t.seq_stop\t\t= cgroup_seqfile_stop,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\n/* set uid and gid of cgroup dirs and files to that of the creator */\nstatic int cgroup_kn_set_ugid(struct kernfs_node *kn)\n{\n\tstruct iattr iattr = { .ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t       .ia_uid = current_fsuid(),\n\t\t\t       .ia_gid = current_fsgid(), };\n\n\tif (uid_eq(iattr.ia_uid, GLOBAL_ROOT_UID) &&\n\t    gid_eq(iattr.ia_gid, GLOBAL_ROOT_GID))\n\t\treturn 0;\n\n\treturn kernfs_setattr(kn, &iattr);\n}\n\nstatic void cgroup_file_notify_timer(struct timer_list *timer)\n{\n\tcgroup_file_notify(container_of(timer, struct cgroup_file,\n\t\t\t\t\tnotify_timer));\n}\n\nstatic int cgroup_add_file(struct cgroup_subsys_state *css, struct cgroup *cgrp,\n\t\t\t   struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\tstruct kernfs_node *kn;\n\tstruct lock_class_key *key = NULL;\n\tint ret;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tkey = &cft->lockdep_key;\n#endif\n\tkn = __kernfs_create_file(cgrp->kn, cgroup_file_name(cgrp, cft, name),\n\t\t\t\t  cgroup_file_mode(cft),\n\t\t\t\t  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\t  0, cft->kf_ops, cft,\n\t\t\t\t  NULL, key);\n\tif (IS_ERR(kn))\n\t\treturn PTR_ERR(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret) {\n\t\tkernfs_remove(kn);\n\t\treturn ret;\n\t}\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\ttimer_setup(&cfile->notify_timer, cgroup_file_notify_timer, 0);\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = kn;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_addrm_files - add or remove files to a cgroup directory\n * @css: the target css\n * @cgrp: the target cgroup (usually css->cgroup)\n * @cfts: array of cftypes to be added\n * @is_add: whether to add or remove\n *\n * Depending on @is_add, add or remove files defined by @cfts on @cgrp.\n * For removals, this function never fails.\n */\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add)\n{\n\tstruct cftype *cft, *cft_end = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\nrestart:\n\tfor (cft = cfts; cft != cft_end && cft->name[0] != '\\0'; cft++) {\n\t\t/* does cft->flags tell us to skip this file on @cgrp? */\n\t\tif ((cft->flags & __CFTYPE_ONLY_ON_DFL) && !cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_NOT_ON_DFL) && cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_NOT_ON_ROOT) && !cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_ONLY_ON_ROOT) && cgroup_parent(cgrp))\n\t\t\tcontinue;\n\n\t\tif (is_add) {\n\t\t\tret = cgroup_add_file(css, cgrp, cft);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s: failed to add %s, err=%d\\n\",\n\t\t\t\t\t__func__, cft->name, ret);\n\t\t\t\tcft_end = cft;\n\t\t\t\tis_add = false;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t} else {\n\t\t\tcgroup_rm_file(cgrp, cft);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cgroup_apply_cftypes(struct cftype *cfts, bool is_add)\n{\n\tstruct cgroup_subsys *ss = cfts[0].ss;\n\tstruct cgroup *root = &ss->root->cgrp;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* add/rm files for all cgroups created before */\n\tcss_for_each_descendant_pre(css, cgroup_css(root, ss)) {\n\t\tstruct cgroup *cgrp = css->cgroup;\n\n\t\tif (!(css->flags & CSS_VISIBLE))\n\t\t\tcontinue;\n\n\t\tret = cgroup_addrm_files(css, cgrp, cfts, is_add);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_add && !ret)\n\t\tkernfs_activate(root->kn);\n\treturn ret;\n}\n\nstatic void cgroup_exit_cftypes(struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\t/* free copy for custom atomic_write_len, see init_cftypes() */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE)\n\t\t\tkfree(cft->kf_ops);\n\t\tcft->kf_ops = NULL;\n\t\tcft->ss = NULL;\n\n\t\t/* revert flags set by cgroup core while adding @cfts */\n\t\tcft->flags &= ~(__CFTYPE_ONLY_ON_DFL | __CFTYPE_NOT_ON_DFL);\n\t}\n}\n\nstatic int cgroup_init_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\tstruct kernfs_ops *kf_ops;\n\n\t\tWARN_ON(cft->ss || cft->kf_ops);\n\n\t\tif (cft->seq_start)\n\t\t\tkf_ops = &cgroup_kf_ops;\n\t\telse\n\t\t\tkf_ops = &cgroup_kf_single_ops;\n\n\t\t/*\n\t\t * Ugh... if @cft wants a custom max_write_len, we need to\n\t\t * make a copy of kf_ops to set its atomic_write_len.\n\t\t */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE) {\n\t\t\tkf_ops = kmemdup(kf_ops, sizeof(*kf_ops), GFP_KERNEL);\n\t\t\tif (!kf_ops) {\n\t\t\t\tcgroup_exit_cftypes(cfts);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tkf_ops->atomic_write_len = cft->max_write_len;\n\t\t}\n\n\t\tcft->kf_ops = kf_ops;\n\t\tcft->ss = ss;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_rm_cftypes_locked(struct cftype *cfts)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!cfts || !cfts[0].ss)\n\t\treturn -ENOENT;\n\n\tlist_del(&cfts->node);\n\tcgroup_apply_cftypes(cfts, false);\n\tcgroup_exit_cftypes(cfts);\n\treturn 0;\n}\n\n/**\n * cgroup_rm_cftypes - remove an array of cftypes from a subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Unregister @cfts.  Files described by @cfts are removed from all\n * existing cgroups and all future cgroups won't have them either.  This\n * function can be called anytime whether @cfts' subsys is attached or not.\n *\n * Returns 0 on successful unregistration, -ENOENT if @cfts is not\n * registered.\n */\nint cgroup_rm_cftypes(struct cftype *cfts)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = cgroup_rm_cftypes_locked(cfts);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_cftypes - add an array of cftypes to a subsystem\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Register @cfts to @ss.  Files described by @cfts are created for all\n * existing cgroups to which @ss is attached and all future cgroups will\n * have them too.  This function can be called anytime whether @ss is\n * attached or not.\n *\n * Returns 0 on successful registration, -errno on failure.  Note that this\n * function currently returns 0 as long as @cfts registration is successful\n * even if some file creation attempts on existing cgroups fail.\n */\nstatic int cgroup_add_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tint ret;\n\n\tif (!cgroup_ssid_enabled(ss->id))\n\t\treturn 0;\n\n\tif (!cfts || cfts[0].name[0] == '\\0')\n\t\treturn 0;\n\n\tret = cgroup_init_cftypes(ss, cfts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_add_tail(&cfts->node, &ss->cfts);\n\tret = cgroup_apply_cftypes(cfts, true);\n\tif (ret)\n\t\tcgroup_rm_cftypes_locked(cfts);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_dfl_cftypes - add an array of cftypes for default hierarchy\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the default hierarchy.\n */\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_ONLY_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the legacy hierarchies.\n */\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_NOT_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_file_notify - generate a file modified event for a cgroup_file\n * @cfile: target cgroup_file\n *\n * @cfile must have been obtained by setting cftype->file_offset.\n */\nvoid cgroup_file_notify(struct cgroup_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_file_kn_lock, flags);\n\tif (cfile->kn) {\n\t\tunsigned long last = cfile->notified_at;\n\t\tunsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;\n\n\t\tif (time_in_range(jiffies, last, next)) {\n\t\t\ttimer_reduce(&cfile->notify_timer, next);\n\t\t} else {\n\t\t\tkernfs_notify(cfile->kn);\n\t\t\tcfile->notified_at = jiffies;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cgroup_file_kn_lock, flags);\n}\n\n/**\n * css_next_child - find the next child of a given css\n * @pos: the current position (%NULL to initiate traversal)\n * @parent: css whose children to walk\n *\n * This function returns the next child of @parent and should be called\n * under either cgroup_mutex or RCU read lock.  The only requirement is\n * that @parent and @pos are accessible.  The next sibling is guaranteed to\n * be returned regardless of their states.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/*\n\t * @pos could already have been unlinked from the sibling list.\n\t * Once a cgroup is removed, its ->sibling.next is no longer\n\t * updated when its next sibling changes.  CSS_RELEASED is set when\n\t * @pos is taken off list, at which time its next pointer is valid,\n\t * and, as releases are serialized, the one pointed to by the next\n\t * pointer is guaranteed to not have started release yet.  This\n\t * implies that if we observe !CSS_RELEASED on @pos in this RCU\n\t * critical section, the one pointed to by its next pointer is\n\t * guaranteed to not have finished its RCU grace period even if we\n\t * have dropped rcu_read_lock() inbetween iterations.\n\t *\n\t * If @pos has CSS_RELEASED set, its next pointer can't be\n\t * dereferenced; however, as each css is given a monotonically\n\t * increasing unique serial number and always appended to the\n\t * sibling list, the next one can be found by walking the parent's\n\t * children until the first css with higher serial number than\n\t * @pos's.  While this path can be slower, it happens iff iteration\n\t * races against release and the race window is very small.\n\t */\n\tif (!pos) {\n\t\tnext = list_entry_rcu(parent->children.next, struct cgroup_subsys_state, sibling);\n\t} else if (likely(!(pos->flags & CSS_RELEASED))) {\n\t\tnext = list_entry_rcu(pos->sibling.next, struct cgroup_subsys_state, sibling);\n\t} else {\n\t\tlist_for_each_entry_rcu(next, &parent->children, sibling)\n\t\t\tif (next->serial_nr > pos->serial_nr)\n\t\t\t\tbreak;\n\t}\n\n\t/*\n\t * @next, if not pointing to the head, can be dereferenced and is\n\t * the next sibling.\n\t */\n\tif (&next->sibling != &parent->children)\n\t\treturn next;\n\treturn NULL;\n}\n\n/**\n * css_next_descendant_pre - find the next descendant for pre-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_pre().  Find the next descendant\n * to visit for pre-order traversal of @root's descendants.  @root is\n * included in the iteration and the first node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @root are accessible and @pos is a descendant of @root.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\tstruct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit @root */\n\tif (!pos)\n\t\treturn root;\n\n\t/* visit the first child if exists */\n\tnext = css_next_child(NULL, pos);\n\tif (next)\n\t\treturn next;\n\n\t/* no child, visit my or the closest ancestor's next sibling */\n\twhile (pos != root) {\n\t\tnext = css_next_child(pos, pos->parent);\n\t\tif (next)\n\t\t\treturn next;\n\t\tpos = pos->parent;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * css_rightmost_descendant - return the rightmost descendant of a css\n * @pos: css of interest\n *\n * Return the rightmost descendant of @pos.  If there's no descendant, @pos\n * is returned.  This can be used during pre-order traversal to skip\n * subtree of @pos.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct rightmost descendant as\n * long as @pos is accessible.\n */\nstruct cgroup_subsys_state *\ncss_rightmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last, *tmp;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\tdo {\n\t\tlast = pos;\n\t\t/* ->prev isn't RCU safe, walk ->next till the end */\n\t\tpos = NULL;\n\t\tcss_for_each_child(tmp, last)\n\t\t\tpos = tmp;\n\t} while (pos);\n\n\treturn last;\n}\n\nstatic struct cgroup_subsys_state *\ncss_leftmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last;\n\n\tdo {\n\t\tlast = pos;\n\t\tpos = css_next_child(NULL, pos);\n\t} while (pos);\n\n\treturn last;\n}\n\n/**\n * css_next_descendant_post - find the next descendant for post-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_post().  Find the next descendant\n * to visit for post-order traversal of @root's descendants.  @root is\n * included in the iteration and the last node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @cgroup are accessible and @pos is a descendant of\n * @cgroup.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t struct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit leftmost descendant which may be @root */\n\tif (!pos)\n\t\treturn css_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\tnext = css_next_child(pos, pos->parent);\n\tif (next)\n\t\treturn css_leftmost_descendant(next);\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}\n\n/**\n * css_has_online_children - does a css have online children\n * @css: the target css\n *\n * Returns %true if @css has any online children; otherwise, %false.  This\n * function can be called from any context but the caller is responsible\n * for synchronizing against on/offlining as necessary.\n */\nbool css_has_online_children(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *child;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tcss_for_each_child(child, css) {\n\t\tif (child->flags & CSS_ONLINE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct css_set *css_task_iter_next_css_set(struct css_task_iter *it)\n{\n\tstruct list_head *l;\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* find the next threaded cset */\n\tif (it->tcset_pos) {\n\t\tl = it->tcset_pos->next;\n\n\t\tif (l != it->tcset_head) {\n\t\t\tit->tcset_pos = l;\n\t\t\treturn container_of(l, struct css_set,\n\t\t\t\t\t    threaded_csets_node);\n\t\t}\n\n\t\tit->tcset_pos = NULL;\n\t}\n\n\t/* find the next cset */\n\tl = it->cset_pos;\n\tl = l->next;\n\tif (l == it->cset_head) {\n\t\tit->cset_pos = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (it->ss) {\n\t\tcset = container_of(l, struct css_set, e_cset_node[it->ss->id]);\n\t} else {\n\t\tlink = list_entry(l, struct cgrp_cset_link, cset_link);\n\t\tcset = link->cset;\n\t}\n\n\tit->cset_pos = l;\n\n\t/* initialize threaded css_set walking */\n\tif (it->flags & CSS_TASK_ITER_THREADED) {\n\t\tif (it->cur_dcset)\n\t\t\tput_css_set_locked(it->cur_dcset);\n\t\tit->cur_dcset = cset;\n\t\tget_css_set(cset);\n\n\t\tit->tcset_head = &cset->threaded_csets;\n\t\tit->tcset_pos = &cset->threaded_csets;\n\t}\n\n\treturn cset;\n}\n\n/**\n * css_task_iter_advance_css_set - advance a task itererator to the next css_set\n * @it: the iterator to advance\n *\n * Advance @it to the next css_set to walk.\n */\nstatic void css_task_iter_advance_css_set(struct css_task_iter *it)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* Advance to the next non-empty css_set */\n\tdo {\n\t\tcset = css_task_iter_next_css_set(it);\n\t\tif (!cset) {\n\t\t\tit->task_pos = NULL;\n\t\t\treturn;\n\t\t}\n\t} while (!css_set_populated(cset));\n\n\tif (!list_empty(&cset->tasks))\n\t\tit->task_pos = cset->tasks.next;\n\telse\n\t\tit->task_pos = cset->mg_tasks.next;\n\n\tit->tasks_head = &cset->tasks;\n\tit->mg_tasks_head = &cset->mg_tasks;\n\n\t/*\n\t * We don't keep css_sets locked across iteration steps and thus\n\t * need to take steps to ensure that iteration can be resumed after\n\t * the lock is re-acquired.  Iteration is performed at two levels -\n\t * css_sets and tasks in them.\n\t *\n\t * Once created, a css_set never leaves its cgroup lists, so a\n\t * pinned css_set is guaranteed to stay put and we can resume\n\t * iteration afterwards.\n\t *\n\t * Tasks may leave @cset across iteration steps.  This is resolved\n\t * by registering each iterator with the css_set currently being\n\t * walked and making css_set_move_task() advance iterators whose\n\t * next task is leaving.\n\t */\n\tif (it->cur_cset) {\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t}\n\tget_css_set(cset);\n\tit->cur_cset = cset;\n\tlist_add(&it->iters_node, &cset->task_iters);\n}\n\nstatic void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct list_head *next;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\t/*\n\t * Advance iterator to find next entry.  cset->tasks is consumed\n\t * first and then ->mg_tasks.  After ->mg_tasks, we move onto the\n\t * next cset.\n\t */\n\tnext = it->task_pos->next;\n\n\tif (next == it->tasks_head)\n\t\tnext = it->mg_tasks_head->next;\n\n\tif (next == it->mg_tasks_head)\n\t\tcss_task_iter_advance_css_set(it);\n\telse\n\t\tit->task_pos = next;\n\n\t/* if PROCS, skip over tasks which aren't group leaders */\n\tif ((it->flags & CSS_TASK_ITER_PROCS) && it->task_pos &&\n\t    !thread_group_leader(list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t    cg_list)))\n\t\tgoto repeat;\n}\n\n/**\n * css_task_iter_start - initiate task iteration\n * @css: the css to walk tasks of\n * @flags: CSS_TASK_ITER_* flags\n * @it: the task iterator to use\n *\n * Initiate iteration through the tasks of @css.  The caller can call\n * css_task_iter_next() to walk through the tasks until the function\n * returns NULL.  On completion of iteration, css_task_iter_end() must be\n * called.\n */\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\t/* no one should try to iterate before mounting cgroups */\n\tWARN_ON_ONCE(!use_task_css_set_links);\n\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance_css_set(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}\n\n/**\n * css_task_iter_next - return the next task for the iterator\n * @it: the task iterator being iterated\n *\n * The \"next\" function for task iteration.  @it should have been\n * initialized via css_task_iter_start().  Returns NULL when the iteration\n * reaches the end.\n */\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}\n\n/**\n * css_task_iter_end - finish task iteration\n * @it: the task iterator to finish\n *\n * Finish task iteration started by css_task_iter_start().\n */\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}\n\nstatic void cgroup_procs_release(struct kernfs_open_file *of)\n{\n\tif (of->priv) {\n\t\tcss_task_iter_end(of->priv);\n\t\tkfree(of->priv);\n\t}\n}\n\nstatic void *cgroup_procs_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct css_task_iter *it = of->priv;\n\n\treturn css_task_iter_next(it);\n}\n\nstatic void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct css_task_iter *it = of->priv;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!it) {\n\t\tif (WARN_ON_ONCE((*pos)++))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tit = kzalloc(sizeof(*it), GFP_KERNEL);\n\t\tif (!it)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tof->priv = it;\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else if (!(*pos)++) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t}\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}\n\nstatic void *cgroup_procs_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\n\t/*\n\t * All processes of a threaded subtree belong to the domain cgroup\n\t * of the subtree.  Only threads can be distributed across the\n\t * subtree.  Reject reads on cgroup.procs in the subtree proper.\n\t * They're always empty anyway.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn __cgroup_procs_start(s, pos, CSS_TASK_ITER_PROCS |\n\t\t\t\t\t    CSS_TASK_ITER_THREADED);\n}\n\nstatic int cgroup_procs_show(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", task_pid_vnr(v));\n\treturn 0;\n}\n\nstatic int cgroup_procs_write_permission(struct cgroup *src_cgrp,\n\t\t\t\t\t struct cgroup *dst_cgrp,\n\t\t\t\t\t struct super_block *sb)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct cgroup *com_cgrp = src_cgrp;\n\tstruct inode *inode;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* find the common ancestor */\n\twhile (!cgroup_is_descendant(dst_cgrp, com_cgrp))\n\t\tcom_cgrp = cgroup_parent(com_cgrp);\n\n\t/* %current should be authorized to migrate to the common ancestor */\n\tinode = kernfs_get_inode(sb, com_cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(inode, MAY_WRITE);\n\tiput(inode);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, %current must be able\n\t * to see both source and destination cgroups from its namespace.\n\t */\n\tif ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||\n\t     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_procs_write(struct kernfs_open_file *of,\n\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tssize_t ret;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, true);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp,\n\t\t\t\t\t    of->file->f_path.dentry->d_sb);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, true);\n\nout_finish:\n\tcgroup_procs_write_finish(task);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic void *cgroup_threads_start(struct seq_file *s, loff_t *pos)\n{\n\treturn __cgroup_procs_start(s, pos, 0);\n}\n\nstatic ssize_t cgroup_threads_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, false);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* thread migrations follow the cgroup.procs delegation rule */\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp,\n\t\t\t\t\t    of->file->f_path.dentry->d_sb);\n\tif (ret)\n\t\tgoto out_finish;\n\n\t/* and must be contained in the same domain */\n\tret = -EOPNOTSUPP;\n\tif (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, false);\n\nout_finish:\n\tcgroup_procs_write_finish(task);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\n/* cgroup core interface files for the default hierarchy */\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t},\n#endif\n\t{ }\t/* terminate */\n};\n\n/*\n * css destruction is four-stage process.\n *\n * 1. Destruction starts.  Killing of the percpu_ref is initiated.\n *    Implemented in kill_css().\n *\n * 2. When the percpu_ref is confirmed to be visible as killed on all CPUs\n *    and thus css_tryget_online() is guaranteed to fail, the css can be\n *    offlined by invoking offline_css().  After offlining, the base ref is\n *    put.  Implemented in css_killed_work_fn().\n *\n * 3. When the percpu_ref reaches zero, the only possible remaining\n *    accessors are inside RCU read sections.  css_release() schedules the\n *    RCU callback.\n *\n * 4. After the grace period, the css can be freed.  Implemented in\n *    css_free_work_fn().\n *\n * It is actually hairier because both step 2 and 4 require process context\n * and thus involve punting to css->destroy_work adding two additional\n * steps to the already complex sequence.\n */\nstatic void css_free_rwork_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css = container_of(to_rcu_work(work),\n\t\t\t\tstruct cgroup_subsys_state, destroy_rwork);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tpercpu_ref_exit(&css->refcnt);\n\n\tif (ss) {\n\t\t/* css free path */\n\t\tstruct cgroup_subsys_state *parent = css->parent;\n\t\tint id = css->id;\n\n\t\tss->css_free(css);\n\t\tcgroup_idr_remove(&ss->css_idr, id);\n\t\tcgroup_put(cgrp);\n\n\t\tif (parent)\n\t\t\tcss_put(parent);\n\t} else {\n\t\t/* cgroup free path */\n\t\tatomic_dec(&cgrp->root->nr_cgrps);\n\t\tcgroup1_pidlist_destroy_all(cgrp);\n\t\tcancel_work_sync(&cgrp->release_agent_work);\n\n\t\tif (cgroup_parent(cgrp)) {\n\t\t\t/*\n\t\t\t * We get a ref to the parent, and put the ref when\n\t\t\t * this cgroup is being freed, so it's guaranteed\n\t\t\t * that the parent won't be destroyed before its\n\t\t\t * children.\n\t\t\t */\n\t\t\tcgroup_put(cgroup_parent(cgrp));\n\t\t\tkernfs_put(cgrp->kn);\n\t\t\tpsi_cgroup_free(cgrp);\n\t\t\tif (cgroup_on_dfl(cgrp))\n\t\t\t\tcgroup_rstat_exit(cgrp);\n\t\t\tkfree(cgrp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is root cgroup's refcnt reaching zero,\n\t\t\t * which indicates that the root should be\n\t\t\t * released.\n\t\t\t */\n\t\t\tcgroup_destroy_root(cgrp->root);\n\t\t}\n\t}\n}\n\nstatic void css_release_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tcss->flags |= CSS_RELEASED;\n\tlist_del_rcu(&css->sibling);\n\n\tif (ss) {\n\t\t/* css release path */\n\t\tif (!list_empty(&css->rstat_css_node)) {\n\t\t\tcgroup_rstat_flush(cgrp);\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t}\n\n\t\tcgroup_idr_replace(&ss->css_idr, NULL, css->id);\n\t\tif (ss->css_released)\n\t\t\tss->css_released(css);\n\t} else {\n\t\tstruct cgroup *tcgrp;\n\n\t\t/* cgroup release path */\n\t\tTRACE_CGROUP_PATH(release, cgrp);\n\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcgroup_rstat_flush(cgrp);\n\n\t\tfor (tcgrp = cgroup_parent(cgrp); tcgrp;\n\t\t     tcgrp = cgroup_parent(tcgrp))\n\t\t\ttcgrp->nr_dying_descendants--;\n\n\t\tcgroup_idr_remove(&cgrp->root->cgroup_idr, cgrp->id);\n\t\tcgrp->id = -1;\n\n\t\t/*\n\t\t * There are two control paths which try to determine\n\t\t * cgroup from dentry without going through kernfs -\n\t\t * cgroupstats_build() and css_tryget_online_from_dir().\n\t\t * Those are supported by RCU protecting clearing of\n\t\t * cgrp->kn->priv backpointer.\n\t\t */\n\t\tif (cgrp->kn)\n\t\t\tRCU_INIT_POINTER(*(void __rcu __force **)&cgrp->kn->priv,\n\t\t\t\t\t NULL);\n\n\t\tcgroup_bpf_put(cgrp);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n}\n\nstatic void css_release(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tINIT_WORK(&css->destroy_work, css_release_work_fn);\n\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n}\n\nstatic void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (cgroup_on_dfl(cgrp) && ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}\n\n/* invoke ->css_online() on a new CSS and mark it online if successful */\nstatic int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}\n\n/* if the CSS is online, invoke ->css_offline() on it and mark it offline */\nstatic void offline_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!(css->flags & CSS_ONLINE))\n\t\treturn;\n\n\tif (ss->css_offline)\n\t\tss->css_offline(css);\n\n\tcss->flags &= ~CSS_ONLINE;\n\tRCU_INIT_POINTER(css->cgroup->subsys[ss->id], NULL);\n\n\twake_up_all(&css->cgroup->offline_waitq);\n}\n\n/**\n * css_create - create a cgroup_subsys_state\n * @cgrp: the cgroup new css will be associated with\n * @ss: the subsys of new css\n *\n * Create a new css associated with @cgrp - @ss pair.  On success, the new\n * css is online and installed in @cgrp.  This function doesn't create the\n * interface files.  Returns 0 on success, -errno on failure.\n */\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *parent_css = cgroup_css(parent, ss);\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcss = ss->css_alloc(parent_css);\n\tif (!css)\n\t\tcss = ERR_PTR(-ENOMEM);\n\tif (IS_ERR(css))\n\t\treturn css;\n\n\tinit_and_link_css(css, ss, cgrp);\n\n\terr = percpu_ref_init(&css->refcnt, css_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_css;\n\n\terr = cgroup_idr_alloc(&ss->css_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_free_css;\n\tcss->id = err;\n\n\t/* @css is ready to be brought online now, make it visible */\n\tlist_add_tail_rcu(&css->sibling, &parent_css->children);\n\tcgroup_idr_replace(&ss->css_idr, css, css->id);\n\n\terr = online_css(css);\n\tif (err)\n\t\tgoto err_list_del;\n\n\tif (ss->broken_hierarchy && !ss->warned_broken_hierarchy &&\n\t    cgroup_parent(parent)) {\n\t\tpr_warn(\"%s (%d) created nested cgroup for controller \\\"%s\\\" which has incomplete hierarchy support. Nested cgroups may change behavior in the future.\\n\",\n\t\t\tcurrent->comm, current->pid, ss->name);\n\t\tif (!strcmp(ss->name, \"memory\"))\n\t\t\tpr_warn(\"\\\"memory\\\" requires setting use_hierarchy to 1 on the root\\n\");\n\t\tss->warned_broken_hierarchy = true;\n\t}\n\n\treturn css;\n\nerr_list_del:\n\tlist_del_rcu(&css->sibling);\nerr_free_css:\n\tlist_del_rcu(&css->rstat_css_node);\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n\treturn ERR_PTR(err);\n}\n\n/*\n * The returned cgroup is fully initialized including its control mask, but\n * it isn't associated with its kernfs_node and doesn't have the control\n * mask applied.\n */\nstatic struct cgroup *cgroup_create(struct cgroup *parent)\n{\n\tstruct cgroup_root *root = parent->root;\n\tstruct cgroup *cgrp, *tcgrp;\n\tint level = parent->level + 1;\n\tint ret;\n\n\t/* allocate the cgroup and its ID, 0 is reserved for the root */\n\tcgrp = kzalloc(struct_size(cgrp, ancestor_ids, (level + 1)),\n\t\t       GFP_KERNEL);\n\tif (!cgrp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_ref_init(&cgrp->self.refcnt, css_release, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_free_cgrp;\n\n\tif (cgroup_on_dfl(parent)) {\n\t\tret = cgroup_rstat_init(cgrp);\n\t\tif (ret)\n\t\t\tgoto out_cancel_ref;\n\t}\n\n\t/*\n\t * Temporarily set the pointer to NULL, so idr_find() won't return\n\t * a half-baked cgroup.\n\t */\n\tcgrp->id = cgroup_idr_alloc(&root->cgroup_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (cgrp->id < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto out_stat_exit;\n\t}\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->self.parent = &parent->self;\n\tcgrp->root = root;\n\tcgrp->level = level;\n\n\tret = psi_cgroup_alloc(cgrp);\n\tif (ret)\n\t\tgoto out_idr_free;\n\n\tret = cgroup_bpf_inherit(cgrp);\n\tif (ret)\n\t\tgoto out_psi_free;\n\n\tfor (tcgrp = cgrp; tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\tcgrp->ancestor_ids[tcgrp->level] = tcgrp->id;\n\n\t\tif (tcgrp != cgrp)\n\t\t\ttcgrp->nr_descendants++;\n\t}\n\n\tif (notify_on_release(parent))\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &parent->flags))\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &cgrp->flags);\n\n\tcgrp->self.serial_nr = css_serial_nr_next++;\n\n\t/* allocation complete, commit to creation */\n\tlist_add_tail_rcu(&cgrp->self.sibling, &cgroup_parent(cgrp)->self.children);\n\tatomic_inc(&root->nr_cgrps);\n\tcgroup_get_live(parent);\n\n\t/*\n\t * @cgrp is now fully operational.  If something fails after this\n\t * point, it'll be released via the normal destruction path.\n\t */\n\tcgroup_idr_replace(&root->cgroup_idr, cgrp, cgrp->id);\n\n\t/*\n\t * On the default hierarchy, a child doesn't automatically inherit\n\t * subtree_control from the parent.  Each is configured manually.\n\t */\n\tif (!cgroup_on_dfl(cgrp))\n\t\tcgrp->subtree_control = cgroup_control(cgrp);\n\n\tcgroup_propagate_control(cgrp);\n\n\treturn cgrp;\n\nout_psi_free:\n\tpsi_cgroup_free(cgrp);\nout_idr_free:\n\tcgroup_idr_remove(&root->cgroup_idr, cgrp->id);\nout_stat_exit:\n\tif (cgroup_on_dfl(parent))\n\t\tcgroup_rstat_exit(cgrp);\nout_cancel_ref:\n\tpercpu_ref_exit(&cgrp->self.refcnt);\nout_free_cgrp:\n\tkfree(cgrp);\n\treturn ERR_PTR(ret);\n}\n\nstatic bool cgroup_check_hierarchy_limits(struct cgroup *parent)\n{\n\tstruct cgroup *cgroup;\n\tint ret = false;\n\tint level = 1;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tfor (cgroup = parent; cgroup; cgroup = cgroup_parent(cgroup)) {\n\t\tif (cgroup->nr_descendants >= cgroup->max_descendants)\n\t\t\tgoto fail;\n\n\t\tif (level > cgroup->max_depth)\n\t\t\tgoto fail;\n\n\t\tlevel++;\n\t}\n\n\tret = true;\nfail:\n\treturn ret;\n}\n\nint cgroup_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)\n{\n\tstruct cgroup *parent, *cgrp;\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\t/* do not accept '\\n' to prevent making /proc/<pid>/cgroup unparsable */\n\tif (strchr(name, '\\n'))\n\t\treturn -EINVAL;\n\n\tparent = cgroup_kn_lock_live(parent_kn, false);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tif (!cgroup_check_hierarchy_limits(parent)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tcgrp = cgroup_create(parent);\n\tif (IS_ERR(cgrp)) {\n\t\tret = PTR_ERR(cgrp);\n\t\tgoto out_unlock;\n\t}\n\n\t/* create the directory */\n\tkn = kernfs_create_dir(parent->kn, name, mode, cgrp);\n\tif (IS_ERR(kn)) {\n\t\tret = PTR_ERR(kn);\n\t\tgoto out_destroy;\n\t}\n\tcgrp->kn = kn;\n\n\t/*\n\t * This extra ref will be put in cgroup_free_fn() and guarantees\n\t * that @cgrp->kn is always accessible.\n\t */\n\tkernfs_get(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = css_populate_dir(&cgrp->self);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tTRACE_CGROUP_PATH(mkdir, cgrp);\n\n\t/* let's create and online css's */\n\tkernfs_activate(kn);\n\n\tret = 0;\n\tgoto out_unlock;\n\nout_destroy:\n\tcgroup_destroy_locked(cgrp);\nout_unlock:\n\tcgroup_kn_unlock(parent_kn);\n\treturn ret;\n}\n\n/*\n * This is called when the refcnt of a css is confirmed to be killed.\n * css_tryget_online() is now guaranteed to fail.  Tell the subsystem to\n * initate destruction and put the css ref from kill_css().\n */\nstatic void css_killed_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tdo {\n\t\toffline_css(css);\n\t\tcss_put(css);\n\t\t/* @css can't go away while we're holding cgroup_mutex */\n\t\tcss = css->parent;\n\t} while (css && atomic_dec_and_test(&css->online_cnt));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_FILE_NOTIFY_MIN_INTV\tDIV_ROUND_UP(HZ, 100)",
      "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_file_kn_lock);",
      "struct percpu_rw_semaphore cgroup_threadgroup_rwsem;",
      "static struct workqueue_struct *cgroup_destroy_wq;",
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static u16 cgrp_dfl_inhibit_ss_mask;",
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static u64 css_serial_nr_next = 1;",
      "struct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
      "static struct cftype cgroup_base_files[];",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5067
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&css->online_cnt"
          ],
          "line": 5065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "parent_kn"
          ],
          "line": 5044
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1488-1501",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_destroy_locked",
          "args": [
            "cgrp"
          ],
          "line": 5042
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_destroy_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5149-5209",
          "snippet": "static int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t}\n\n\tcgroup1_check_for_release(parent);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void css_release(struct percpu_ref *ref);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t}\n\n\tcgroup1_check_for_release(parent);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "kn"
          ],
          "line": 5036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "mkdir",
            "cgrp"
          ],
          "line": 5033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control_enable",
          "args": [
            "cgrp"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_populate_dir",
          "args": [
            "&cgrp->self"
          ],
          "line": 5025
        },
        "resolved": true,
        "details": {
          "function_name": "css_populate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1604-1642",
          "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kn_set_ugid",
          "args": [
            "kn"
          ],
          "line": 5021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "kn"
          ],
          "line": 5019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 5010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kn"
          ],
          "line": 5009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_create_dir",
          "args": [
            "parent->kn",
            "name",
            "mode",
            "cgrp"
          ],
          "line": 5008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 5003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_create",
          "args": [
            "parent"
          ],
          "line": 5001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_check_hierarchy_limits",
          "args": [
            "parent"
          ],
          "line": 4996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "parent_kn",
            "false"
          ],
          "line": 4992
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1520-1549",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'\\n'"
          ],
          "line": 4989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgroup"
          ],
          "line": 4967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cgrp"
          ],
          "line": 4955
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&cgrp->self.refcnt"
          ],
          "line": 4953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_exit",
          "args": [
            "cgrp"
          ],
          "line": 4951
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "271-288",
          "snippet": "void cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "parent"
          ],
          "line": 4950
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_idr_remove",
          "args": [
            "&root->cgroup_idr",
            "cgrp->id"
          ],
          "line": 4948
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "324-329",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_cgroup_free",
          "args": [
            "cgrp"
          ],
          "line": 4946
        },
        "resolved": true,
        "details": {
          "function_name": "psi_cgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "613-620",
          "snippet": "void psi_cgroup_free(struct cgroup *cgroup)\n{\n\tif (psi_disabled)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&cgroup->psi.clock_work);\n\tfree_percpu(cgroup->psi.pcpu);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool psi_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nvoid psi_cgroup_free(struct cgroup *cgroup)\n{\n\tif (psi_disabled)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&cgroup->psi.clock_work);\n\tfree_percpu(cgroup->psi.pcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_propagate_control",
          "args": [
            "cgrp"
          ],
          "line": 4941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_control",
          "args": [
            "cgrp"
          ],
          "line": 4939
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "415-433",
          "snippet": "static u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_inhibit_ss_mask;",
            "static u16 cgrp_dfl_implicit_ss_mask;",
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_idr_replace",
          "args": [
            "&root->cgroup_idr",
            "cgrp",
            "cgrp->id"
          ],
          "line": 4932
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "314-322",
          "snippet": "static void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "parent"
          ],
          "line": 4926
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "559-563",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->nr_cgrps"
          ],
          "line": 4925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&cgrp->self.sibling",
            "&cgroup_parent(cgrp)->self.children"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_CPUSET_CLONE_CHILDREN",
            "&cgrp->flags"
          ],
          "line": 4919
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_CPUSET_CLONE_CHILDREN",
            "&parent->flags"
          ],
          "line": 4918
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_on_release",
          "args": [
            "parent"
          ],
          "line": 4915
        },
        "resolved": true,
        "details": {
          "function_name": "notify_on_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "152-155",
          "snippet": "static inline bool notify_on_release(const struct cgroup *cgrp)\n{\n\treturn test_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool notify_on_release(const struct cgroup *cgrp)\n{\n\treturn test_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "tcgrp"
          ],
          "line": 4908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_inherit",
          "args": [
            "cgrp"
          ],
          "line": 4904
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_inherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "160-184",
          "snippet": "int cgroup_bpf_inherit(struct cgroup *cgrp)\n{\n/* has to use marco instead of const int, since compiler thinks\n * that array below is variable length\n */\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\tstruct bpf_prog_array __rcu *arrays[NR] = {};\n\tint i;\n\n\tfor (i = 0; i < NR; i++)\n\t\tINIT_LIST_HEAD(&cgrp->bpf.progs[i]);\n\n\tfor (i = 0; i < NR; i++)\n\t\tif (compute_effective_progs(cgrp, i, &arrays[i]))\n\t\t\tgoto cleanup;\n\n\tfor (i = 0; i < NR; i++)\n\t\tactivate_effective_progs(cgrp, i, arrays[i]);\n\n\treturn 0;\ncleanup:\n\tfor (i = 0; i < NR; i++)\n\t\tbpf_prog_array_free(arrays[i]);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define\tNR ARRAY_SIZE(cgrp->bpf.effective)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\nint cgroup_bpf_inherit(struct cgroup *cgrp)\n{\n/* has to use marco instead of const int, since compiler thinks\n * that array below is variable length\n */\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\tstruct bpf_prog_array __rcu *arrays[NR] = {};\n\tint i;\n\n\tfor (i = 0; i < NR; i++)\n\t\tINIT_LIST_HEAD(&cgrp->bpf.progs[i]);\n\n\tfor (i = 0; i < NR; i++)\n\t\tif (compute_effective_progs(cgrp, i, &arrays[i]))\n\t\t\tgoto cleanup;\n\n\tfor (i = 0; i < NR; i++)\n\t\tactivate_effective_progs(cgrp, i, arrays[i]);\n\n\treturn 0;\ncleanup:\n\tfor (i = 0; i < NR; i++)\n\t\tbpf_prog_array_free(arrays[i]);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_cgroup_alloc",
          "args": [
            "cgrp"
          ],
          "line": 4900
        },
        "resolved": true,
        "details": {
          "function_name": "psi_cgroup_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "601-611",
          "snippet": "int psi_cgroup_alloc(struct cgroup *cgroup)\n{\n\tif (psi_disabled)\n\t\treturn 0;\n\n\tcgroup->psi.pcpu = alloc_percpu(struct psi_group_cpu);\n\tif (!cgroup->psi.pcpu)\n\t\treturn -ENOMEM;\n\tgroup_init(&cgroup->psi);\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool psi_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nint psi_cgroup_alloc(struct cgroup *cgroup)\n{\n\tif (psi_disabled)\n\t\treturn 0;\n\n\tcgroup->psi.pcpu = alloc_percpu(struct psi_group_cpu);\n\tif (!cgroup->psi.pcpu)\n\t\treturn -ENOMEM;\n\tgroup_init(&cgroup->psi);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_cgroup_housekeeping",
          "args": [
            "cgrp"
          ],
          "line": 4894
        },
        "resolved": true,
        "details": {
          "function_name": "init_cgroup_housekeeping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1852-1875",
          "snippet": "static void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_idr_alloc",
          "args": [
            "&root->cgroup_idr",
            "NULL",
            "2",
            "0",
            "GFP_KERNEL"
          ],
          "line": 4888
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "301-312",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_init",
          "args": [
            "cgrp"
          ],
          "line": 4879
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "249-269",
          "snippet": "int cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nint cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&cgrp->self.refcnt",
            "css_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(cgrp, ancestor_ids, (level + 1))",
            "GFP_KERNEL"
          ],
          "line": 4869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "cgrp",
            "ancestor_ids",
            "(level + 1)"
          ],
          "line": 4869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_rcu_work",
          "args": [
            "cgroup_destroy_wq",
            "&css->destroy_rwork"
          ],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "queue_rcu_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1625-1636",
          "snippet": "bool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)\n{\n\tstruct work_struct *work = &rwork->work;\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\trwork->wq = wq;\n\t\tcall_rcu(&rwork->rcu, rcu_work_rcufn);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)\n{\n\tstruct work_struct *work = &rwork->work;\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\trwork->wq = wq;\n\t\tcall_rcu(&rwork->rcu, rcu_work_rcufn);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_RCU_WORK",
          "args": [
            "&css->destroy_rwork",
            "css_free_rwork_fn"
          ],
          "line": 4851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&css->sibling"
          ],
          "line": 4848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\\"memory\\\" requires setting use_hierarchy to 1 on the root\\n\""
          ],
          "line": 4841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ss->name",
            "\"memory\""
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s (%d) created nested cgroup for controller \\\"%s\\\" which has incomplete hierarchy support. Nested cgroups may change behavior in the future.\\n\"",
            "current->comm",
            "current->pid",
            "ss->name"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "parent"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "online_css",
          "args": [
            "css"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&css->sibling",
            "&parent_css->children"
          ],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&css->refcnt",
            "css_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 4819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_and_link_css",
          "args": [
            "css",
            "ss",
            "cgrp"
          ],
          "line": 4817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "css"
          ],
          "line": 4814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_alloc",
          "args": [
            "parent_css"
          ],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "parent",
            "ss"
          ],
          "line": 4805
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "463-471",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&css->cgroup->offline_waitq"
          ],
          "line": 4789
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "49-69",
          "snippet": "void swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "css->cgroup->subsys[ss->id]",
            "NULL"
          ],
          "line": 4787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_offline",
          "args": [
            "css"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&css->parent->online_cnt"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&css->online_cnt"
          ],
          "line": 4766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "css->cgroup->subsys[ss->id]",
            "css"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_online",
          "args": [
            "css"
          ],
          "line": 4761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_css(cgrp, ss)"
          ],
          "line": 4749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&css->rstat_css_node",
            "&cgrp->rstat_css_list"
          ],
          "line": 4747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css->parent"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&css->online_cnt",
            "0"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&css->children"
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&css->sibling"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "css",
            "0",
            "sizeof(*css)"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_put",
          "args": [
            "cgrp"
          ],
          "line": 4706
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "26-47",
          "snippet": "void cgroup_bpf_put(struct cgroup *cgrp)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tunsigned int type;\n\n\tfor (type = 0; type < ARRAY_SIZE(cgrp->bpf.progs); type++) {\n\t\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\t\tstruct bpf_prog_list *pl, *tmp;\n\n\t\tlist_for_each_entry_safe(pl, tmp, progs, node) {\n\t\t\tlist_del(&pl->node);\n\t\t\tbpf_prog_put(pl->prog);\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\t\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\t\t}\n\t\t\tkfree(pl);\n\t\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t\t}\n\t\tbpf_prog_array_free(cgrp->bpf.effective[type]);\n\t}\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nvoid cgroup_bpf_put(struct cgroup *cgrp)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tunsigned int type;\n\n\tfor (type = 0; type < ARRAY_SIZE(cgrp->bpf.progs); type++) {\n\t\tstruct list_head *progs = &cgrp->bpf.progs[type];\n\t\tstruct bpf_prog_list *pl, *tmp;\n\n\t\tlist_for_each_entry_safe(pl, tmp, progs, node) {\n\t\t\tlist_del(&pl->node);\n\t\t\tbpf_prog_put(pl->prog);\n\t\t\tfor_each_cgroup_storage_type(stype) {\n\t\t\t\tbpf_cgroup_storage_unlink(pl->storage[stype]);\n\t\t\t\tbpf_cgroup_storage_free(pl->storage[stype]);\n\t\t\t}\n\t\t\tkfree(pl);\n\t\t\tstatic_branch_dec(&cgroup_bpf_enabled_key);\n\t\t}\n\t\tbpf_prog_array_free(cgrp->bpf.effective[type]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "*(void __rcu __force **)&cgrp->kn->priv",
            "NULL"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "tcgrp"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush",
          "args": [
            "cgrp"
          ],
          "line": 4686
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "232-238",
          "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "release",
            "cgrp"
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_released",
          "args": [
            "css"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 4673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 4671
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_destroy_root",
          "args": [
            "cgrp->root"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_destroy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1246-1286",
          "snippet": "static void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_root_count;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "cgrp->kn"
          ],
          "line": 4641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgroup_parent(cgrp)"
          ],
          "line": 4640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&cgrp->release_agent_work"
          ],
          "line": 4631
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3038-3041",
          "snippet": "bool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup1_pidlist_destroy_all",
          "args": [
            "cgrp"
          ],
          "line": 4630
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_pidlist_destroy_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "212-223",
          "snippet": "void cgroup1_pidlist_destroy_all(struct cgroup *cgrp)\n{\n\tstruct cgroup_pidlist *l, *tmp_l;\n\n\tmutex_lock(&cgrp->pidlist_mutex);\n\tlist_for_each_entry_safe(l, tmp_l, &cgrp->pidlists, links)\n\t\tmod_delayed_work(cgroup_pidlist_destroy_wq, &l->destroy_dwork, 0);\n\tmutex_unlock(&cgrp->pidlist_mutex);\n\n\tflush_workqueue(cgroup_pidlist_destroy_wq);\n\tBUG_ON(!list_empty(&cgrp->pidlists));\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *cgroup_pidlist_destroy_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_pidlist_destroy_wq;\n\nvoid cgroup1_pidlist_destroy_all(struct cgroup *cgrp)\n{\n\tstruct cgroup_pidlist *l, *tmp_l;\n\n\tmutex_lock(&cgrp->pidlist_mutex);\n\tlist_for_each_entry_safe(l, tmp_l, &cgrp->pidlists, links)\n\t\tmod_delayed_work(cgroup_pidlist_destroy_wq, &l->destroy_dwork, 0);\n\tmutex_unlock(&cgrp->pidlist_mutex);\n\n\tflush_workqueue(cgroup_pidlist_destroy_wq);\n\tBUG_ON(!list_empty(&cgrp->pidlists));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cgrp->root->nr_cgrps"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "parent"
          ],
          "line": 4626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_free",
          "args": [
            "css"
          ],
          "line": 4621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_finish",
          "args": [
            "task"
          ],
          "line": 4496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_attach_task",
          "args": [
            "dst_cgrp",
            "task",
            "false"
          ],
          "line": 4493
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_attach_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2614-5068",
          "snippet": "int cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct task_struct *task;\n\tint ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/* look up all src csets */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_src(task_css_set(task), dst_cgrp, &mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* prepare dst csets and commit */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (!ret)\n\t\tret = cgroup_migrate(leader, threadgroup, &mgctx);\n\n\tcgroup_migrate_finish(&mgctx);\n\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(attach_task, dst_cgrp, leader, threadgroup);\n\n\treturn ret;\n}\n\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup)\n\t__acquires(&cgroup_threadgroup_rwsem)\n{\n\tstruct task_struct *tsk;\n\tpid_t pid;\n\n\tif (kstrtoint(strstrip(buf), 0, &pid) || pid < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\trcu_read_lock();\n\tif (pid) {\n\t\ttsk = find_task_by_vpid(pid);\n\t\tif (!tsk) {\n\t\t\ttsk = ERR_PTR(-ESRCH);\n\t\t\tgoto out_unlock_threadgroup;\n\t\t}\n\t} else {\n\t\ttsk = current;\n\t}\n\n\tif (threadgroup)\n\t\ttsk = tsk->group_leader;\n\n\t/*\n\t * kthreads may acquire PF_NO_SETAFFINITY during initialization.\n\t * If userland migrates such a kthread to a non-root cgroup, it can\n\t * become trapped in a cpuset, or RT kthread may be born in a\n\t * cgroup with no rt_runtime allocated.  Just say no.\n\t */\n\tif (tsk->no_cgroup_migration || (tsk->flags & PF_NO_SETAFFINITY)) {\n\t\ttsk = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock_threadgroup;\n\t}\n\n\tget_task_struct(tsk);\n\tgoto out_unlock_rcu;\n\nout_unlock_threadgroup:\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\nout_unlock_rcu:\n\trcu_read_unlock();\n\treturn tsk;\n}\n\nvoid cgroup_procs_write_finish(struct task_struct *task)\n\t__releases(&cgroup_threadgroup_rwsem)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\t/* release reference from cgroup_procs_write_start() */\n\tput_task_struct(task);\n\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tfor_each_subsys(ss, ssid)\n\t\tif (ss->post_attach)\n\t\t\tss->post_attach();\n}\n\nstatic void cgroup_print_ss_mask(struct seq_file *seq, u16 ss_mask)\n{\n\tstruct cgroup_subsys *ss;\n\tbool printed = false;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tif (printed)\n\t\t\tseq_putc(seq, ' ');\n\t\tseq_printf(seq, \"%s\", ss->name);\n\t\tprinted = true;\n\t} while_each_subsys_mask();\n\tif (printed)\n\t\tseq_putc(seq, '\\n');\n}\n\n/* show controllers which are enabled from the parent */\nstatic int cgroup_controllers_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgroup_control(cgrp));\n\treturn 0;\n}\n\n/* show controllers which are enabled for a given cgroup's children */\nstatic int cgroup_subtree_control_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgrp->subtree_control);\n\treturn 0;\n}\n\n/**\n * cgroup_update_dfl_csses - update css assoc of a subtree in default hierarchy\n * @cgrp: root of the subtree to update csses for\n *\n * @cgrp's control masks have changed and its subtree's css associations\n * need to be updated accordingly.  This function looks up all css_sets\n * which are attached to the subtree, creates the matching updated css_sets\n * and migrates the tasks to the new ones.\n */\nstatic int cgroup_update_dfl_csses(struct cgroup *cgrp)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup *dsct;\n\tstruct css_set *src_cset;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* look up all csses currently attached to @cgrp's subtree */\n\tspin_lock_irq(&css_set_lock);\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &dsct->cset_links, cset_link)\n\t\t\tcgroup_migrate_add_src(link->cset, dsct, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* NULL dst indicates self on default hierarchy */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(src_cset, &mgctx.preloaded_src_csets, mg_preload_node) {\n\t\tstruct task_struct *task, *ntask;\n\n\t\t/* all tasks in src_csets need to be migrated */\n\t\tlist_for_each_entry_safe(task, ntask, &src_cset->tasks, cg_list)\n\t\t\tcgroup_migrate_add_task(task, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_execute(&mgctx);\nout_finish:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\treturn ret;\n}\n\n/**\n * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses\n * @cgrp: root of the target subtree\n *\n * Because css offlining is asynchronous, userland may try to re-enable a\n * controller while the previous css is still around.  This function grabs\n * cgroup_mutex and drains the previous css instances of @cgrp's subtree.\n */\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp)\n\t__acquires(&cgroup_mutex)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\nrestart:\n\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tif (!css || !percpu_ref_is_dying(&css->refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get_live(dsct);\n\t\t\tprepare_to_wait(&dsct->offline_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tschedule();\n\t\t\tfinish_wait(&dsct->offline_waitq, &wait);\n\n\t\t\tcgroup_put(dsct);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_save_control - save control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Save ->subtree_control, ->subtree_ss_mask and ->dom_cgrp to the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_save_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->old_subtree_control = dsct->subtree_control;\n\t\tdsct->old_subtree_ss_mask = dsct->subtree_ss_mask;\n\t\tdsct->old_dom_cgrp = dsct->dom_cgrp;\n\t}\n}\n\n/**\n * cgroup_propagate_control - refresh control masks of a subtree\n * @cgrp: root of the target subtree\n *\n * For @cgrp and its subtree, ensure ->subtree_ss_mask matches\n * ->subtree_control and propagate controller availability through the\n * subtree so that descendants don't have unavailable controllers enabled.\n */\nstatic void cgroup_propagate_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control &= cgroup_control(dsct);\n\t\tdsct->subtree_ss_mask =\n\t\t\tcgroup_calc_subtree_ss_mask(dsct->subtree_control,\n\t\t\t\t\t\t    cgroup_ss_mask(dsct));\n\t}\n}\n\n/**\n * cgroup_restore_control - restore control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Restore ->subtree_control, ->subtree_ss_mask and ->dom_cgrp from the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_restore_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control = dsct->old_subtree_control;\n\t\tdsct->subtree_ss_mask = dsct->old_subtree_ss_mask;\n\t\tdsct->dom_cgrp = dsct->old_dom_cgrp;\n\t}\n}\n\nstatic bool css_visible(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tif (cgroup_control(cgrp) & (1 << ss->id))\n\t\treturn true;\n\tif (!(cgroup_ss_mask(cgrp) & (1 << ss->id)))\n\t\treturn false;\n\treturn cgroup_on_dfl(cgrp) && ss->implicit_on_dfl;\n}\n\n/**\n * cgroup_apply_control_enable - enable or show csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and create new csses or make the existing ones\n * visible.  A css is created invisible if it's being implicitly enabled\n * through dependency.  An invisible css is made visible when the userland\n * explicitly enables it.\n *\n * Returns 0 on success, -errno on failure.  On failure, csses which have\n * been processed already aren't cleaned up.  The caller is responsible for\n * cleaning up with cgroup_apply_control_disable().\n */\nstatic int cgroup_apply_control_enable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid, ret;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tWARN_ON_ONCE(css && percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (!(cgroup_ss_mask(dsct) & (1 << ss->id)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!css) {\n\t\t\t\tcss = css_create(dsct, ss);\n\t\t\t\tif (IS_ERR(css))\n\t\t\t\t\treturn PTR_ERR(css);\n\t\t\t}\n\n\t\t\tif (css_visible(css)) {\n\t\t\t\tret = css_populate_dir(css);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_apply_control_disable - kill or hide csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and kill and hide csses so that they match\n * cgroup_ss_mask() and cgroup_visible_mask().\n *\n * A css is hidden when the userland requests it to be disabled while other\n * subsystems are still depending on it.  The css must not actively control\n * resources and be in the vanilla state if it's made visible again later.\n * Controllers which may be depended upon should provide ->css_reset() for\n * this purpose.\n */\nstatic void cgroup_apply_control_disable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tWARN_ON_ONCE(css && percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tif (css->parent &&\n\t\t\t    !(cgroup_ss_mask(dsct) & (1 << ss->id))) {\n\t\t\t\tkill_css(css);\n\t\t\t} else if (!css_visible(css)) {\n\t\t\t\tcss_clear_dir(css);\n\t\t\t\tif (ss->css_reset)\n\t\t\t\t\tss->css_reset(css);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * cgroup_apply_control - apply control mask updates to the subtree\n * @cgrp: root of the target subtree\n *\n * subsystems can be enabled and disabled in a subtree using the following\n * steps.\n *\n * 1. Call cgroup_save_control() to stash the current state.\n * 2. Update ->subtree_control masks in the subtree as desired.\n * 3. Call cgroup_apply_control() to apply the changes.\n * 4. Optionally perform other related operations.\n * 5. Call cgroup_finalize_control() to finish up.\n *\n * This function implements step 3 and propagates the mask changes\n * throughout @cgrp's subtree, updates csses accordingly and perform\n * process migrations.\n */\nstatic int cgroup_apply_control(struct cgroup *cgrp)\n{\n\tint ret;\n\n\tcgroup_propagate_control(cgrp);\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * At this point, cgroup_e_css() results reflect the new csses\n\t * making the following cgroup_update_dfl_csses() properly update\n\t * css associations of all tasks in the subtree.\n\t */\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * cgroup_finalize_control - finalize control mask update\n * @cgrp: root of the target subtree\n * @ret: the result of the update\n *\n * Finalize control mask update.  See cgroup_apply_control() for more info.\n */\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret)\n{\n\tif (ret) {\n\t\tcgroup_restore_control(cgrp);\n\t\tcgroup_propagate_control(cgrp);\n\t}\n\n\tcgroup_apply_control_disable(cgrp);\n}\n\nstatic int cgroup_vet_subtree_control_enable(struct cgroup *cgrp, u16 enable)\n{\n\tu16 domain_enable = enable & ~cgrp_dfl_threaded_ss_mask;\n\n\t/* if nothing is getting enabled, nothing to worry about */\n\tif (!enable)\n\t\treturn 0;\n\n\t/* can @cgrp host any resources? */\n\tif (!cgroup_is_valid_domain(cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn 0;\n\n\tif (domain_enable) {\n\t\t/* can't enable domain controllers inside a thread subtree */\n\t\tif (cgroup_is_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\t/*\n\t\t * Threaded controllers can handle internal competitions\n\t\t * and are always allowed inside a (prospective) thread\n\t\t * subtree.\n\t\t */\n\t\tif (cgroup_can_be_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Controllers can't be enabled for a cgroup with tasks to avoid\n\t * child cgroups competing against tasks.\n\t */\n\tif (cgroup_has_tasks(cgrp))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/* change the enabled child controllers for a cgroup in the default hierarchy */\nstatic ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tu16 enable = 0, disable = 0;\n\tstruct cgroup *cgrp, *child;\n\tstruct cgroup_subsys *ss;\n\tchar *tok;\n\tint ssid, ret;\n\n\t/*\n\t * Parse input - space separated list of subsystem names prefixed\n\t * with either + or -.\n\t */\n\tbuf = strstrip(buf);\n\twhile ((tok = strsep(&buf, \" \"))) {\n\t\tif (tok[0] == '\\0')\n\t\t\tcontinue;\n\t\tdo_each_subsys_mask(ss, ssid, ~cgrp_dfl_inhibit_ss_mask) {\n\t\t\tif (!cgroup_ssid_enabled(ssid) ||\n\t\t\t    strcmp(tok + 1, ss->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (*tok == '+') {\n\t\t\t\tenable |= 1 << ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while_each_subsys_mask();\n\t\tif (ssid == CGROUP_SUBSYS_COUNT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (enable & (1 << ssid)) {\n\t\t\tif (cgrp->subtree_control & (1 << ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(cgroup_control(cgrp) & (1 << ssid))) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->subtree_control & (1 << ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* a child has it enabled? */\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->subtree_control & (1 << ssid)) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tret = cgroup_vet_subtree_control_enable(cgrp, enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* save and update control masks and prepare csses */\n\tcgroup_save_control(cgrp);\n\n\tcgrp->subtree_control |= enable;\n\tcgrp->subtree_control &= ~disable;\n\n\tret = cgroup_apply_control(cgrp);\n\tcgroup_finalize_control(cgrp, ret);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tkernfs_activate(cgrp->kn);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\n/**\n * cgroup_enable_threaded - make @cgrp threaded\n * @cgrp: the target cgroup\n *\n * Called when \"threaded\" is written to the cgroup.type interface file and\n * tries to make @cgrp threaded and join the parent's resource domain.\n * This function is never called on the root cgroup as cgroup.type doesn't\n * exist on it.\n */\nstatic int cgroup_enable_threaded(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup *dom_cgrp = parent->dom_cgrp;\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* noop if already threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @cgroup is populated or has domain controllers enabled, it\n\t * can't be switched.  While the below cgroup_can_be_thread_root()\n\t * test can catch the same conditions, that's only when @parent is\n\t * not mixable, so let's check it explicitly.\n\t */\n\tif (cgroup_is_populated(cgrp) ||\n\t    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn -EOPNOTSUPP;\n\n\t/* we're joining the parent's domain, ensure its validity */\n\tif (!cgroup_is_valid_domain(dom_cgrp) ||\n\t    !cgroup_can_be_thread_root(dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * The following shouldn't cause actual migrations and should\n\t * always succeed.\n\t */\n\tcgroup_save_control(cgrp);\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\n\t\tif (dsct == cgrp || cgroup_is_threaded(dsct))\n\t\t\tdsct->dom_cgrp = dom_cgrp;\n\n\tret = cgroup_apply_control(cgrp);\n\tif (!ret)\n\t\tparent->nr_threaded_children++;\n\n\tcgroup_finalize_control(cgrp, ret);\n\treturn ret;\n}\n\nstatic int cgroup_type_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tif (cgroup_is_threaded(cgrp))\n\t\tseq_puts(seq, \"threaded\\n\");\n\telse if (!cgroup_is_valid_domain(cgrp))\n\t\tseq_puts(seq, \"domain invalid\\n\");\n\telse if (cgroup_is_thread_root(cgrp))\n\t\tseq_puts(seq, \"domain threaded\\n\");\n\telse\n\t\tseq_puts(seq, \"domain\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* only switching to threaded mode is supported */\n\tif (strcmp(strstrip(buf), \"threaded\"))\n\t\treturn -EINVAL;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/* threaded can only be enabled */\n\tret = cgroup_enable_threaded(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_max_descendants_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint descendants = READ_ONCE(cgrp->max_descendants);\n\n\tif (descendants == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", descendants);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,\n\t\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint descendants;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdescendants = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &descendants);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (descendants < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_descendants = descendants;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_max_depth_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint depth = READ_ONCE(cgrp->max_depth);\n\n\tif (depth == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", depth);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint depth;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdepth = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &depth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (depth < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_depth = depth;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_events_show(struct seq_file *seq, void *v)\n{\n\tseq_printf(seq, \"populated %d\\n\",\n\t\t   cgroup_is_populated(seq_css(seq)->cgroup));\n\treturn 0;\n}\n\nstatic int cgroup_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgroup = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"nr_descendants %d\\n\",\n\t\t   cgroup->nr_descendants);\n\tseq_printf(seq, \"nr_dying_descendants %d\\n\",\n\t\t   cgroup->nr_dying_descendants);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cgroup_extra_stat_show(struct seq_file *seq,\n\t\t\t\t\t\t struct cgroup *cgrp, int ssid)\n{\n\tstruct cgroup_subsys *ss = cgroup_subsys[ssid];\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!ss->css_extra_stat_show)\n\t\treturn 0;\n\n\tcss = cgroup_tryget_css(cgrp, ss);\n\tif (!css)\n\t\treturn 0;\n\n\tret = ss->css_extra_stat_show(seq, css);\n\tcss_put(css);\n\treturn ret;\n}\n\nstatic int cpu_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup __maybe_unused *cgrp = seq_css(seq)->cgroup;\n\tint ret = 0;\n\n\tcgroup_base_stat_cputime_show(seq);\n#ifdef CONFIG_CGROUP_SCHED\n\tret = cgroup_extra_stat_show(seq, cgrp, cpu_cgrp_id);\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_PSI\nstatic int cgroup_io_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_IO);\n}\nstatic int cgroup_memory_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_MEM);\n}\nstatic int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_CPU);\n}\n#endif\n\nstatic int cgroup_file_open(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->open)\n\t\treturn cft->open(of);\n\treturn 0;\n}\n\nstatic void cgroup_file_release(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->release)\n\t\tcft->release(of);\n}\n\nstatic ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of->kn->priv;\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, disallow writes to\n\t * files in an non-init namespace root from inside the namespace\n\t * except for the files explicitly marked delegatable -\n\t * cgroup.procs and cgroup.subtree_control.\n\t */\n\tif ((cgrp->root->flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    !(cft->flags & CFTYPE_NS_DELEGATABLE) &&\n\t    ns != &init_cgroup_ns && ns->root_cset->dfl_cgrp == cgrp)\n\t\treturn -EPERM;\n\n\tif (cft->write)\n\t\treturn cft->write(of, buf, nbytes, off);\n\n\t/*\n\t * kernfs guarantees that a file isn't deleted with operations in\n\t * flight, which means that the matching css is and stays alive and\n\t * doesn't need to be pinned.  The RCU locking is not necessary\n\t * either.  It's just for the convenience of using cgroup_css().\n\t */\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, cft->ss);\n\trcu_read_unlock();\n\n\tif (cft->write_u64) {\n\t\tunsigned long long v;\n\t\tret = kstrtoull(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_u64(css, cft, v);\n\t} else if (cft->write_s64) {\n\t\tlong long v;\n\t\tret = kstrtoll(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_s64(css, cft, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ?: nbytes;\n}\n\nstatic void *cgroup_seqfile_start(struct seq_file *seq, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_start(seq, ppos);\n}\n\nstatic void *cgroup_seqfile_next(struct seq_file *seq, void *v, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_next(seq, v, ppos);\n}\n\nstatic void cgroup_seqfile_stop(struct seq_file *seq, void *v)\n{\n\tif (seq_cft(seq)->seq_stop)\n\t\tseq_cft(seq)->seq_stop(seq, v);\n}\n\nstatic int cgroup_seqfile_show(struct seq_file *m, void *arg)\n{\n\tstruct cftype *cft = seq_cft(m);\n\tstruct cgroup_subsys_state *css = seq_css(m);\n\n\tif (cft->seq_show)\n\t\treturn cft->seq_show(m, arg);\n\n\tif (cft->read_u64)\n\t\tseq_printf(m, \"%llu\\n\", cft->read_u64(css, cft));\n\telse if (cft->read_s64)\n\t\tseq_printf(m, \"%lld\\n\", cft->read_s64(css, cft));\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct kernfs_ops cgroup_kf_single_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\nstatic struct kernfs_ops cgroup_kf_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.seq_start\t\t= cgroup_seqfile_start,\n\t.seq_next\t\t= cgroup_seqfile_next,\n\t.seq_stop\t\t= cgroup_seqfile_stop,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\n/* set uid and gid of cgroup dirs and files to that of the creator */\nstatic int cgroup_kn_set_ugid(struct kernfs_node *kn)\n{\n\tstruct iattr iattr = { .ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t       .ia_uid = current_fsuid(),\n\t\t\t       .ia_gid = current_fsgid(), };\n\n\tif (uid_eq(iattr.ia_uid, GLOBAL_ROOT_UID) &&\n\t    gid_eq(iattr.ia_gid, GLOBAL_ROOT_GID))\n\t\treturn 0;\n\n\treturn kernfs_setattr(kn, &iattr);\n}\n\nstatic void cgroup_file_notify_timer(struct timer_list *timer)\n{\n\tcgroup_file_notify(container_of(timer, struct cgroup_file,\n\t\t\t\t\tnotify_timer));\n}\n\nstatic int cgroup_add_file(struct cgroup_subsys_state *css, struct cgroup *cgrp,\n\t\t\t   struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\tstruct kernfs_node *kn;\n\tstruct lock_class_key *key = NULL;\n\tint ret;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tkey = &cft->lockdep_key;\n#endif\n\tkn = __kernfs_create_file(cgrp->kn, cgroup_file_name(cgrp, cft, name),\n\t\t\t\t  cgroup_file_mode(cft),\n\t\t\t\t  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\t  0, cft->kf_ops, cft,\n\t\t\t\t  NULL, key);\n\tif (IS_ERR(kn))\n\t\treturn PTR_ERR(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret) {\n\t\tkernfs_remove(kn);\n\t\treturn ret;\n\t}\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\ttimer_setup(&cfile->notify_timer, cgroup_file_notify_timer, 0);\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = kn;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_addrm_files - add or remove files to a cgroup directory\n * @css: the target css\n * @cgrp: the target cgroup (usually css->cgroup)\n * @cfts: array of cftypes to be added\n * @is_add: whether to add or remove\n *\n * Depending on @is_add, add or remove files defined by @cfts on @cgrp.\n * For removals, this function never fails.\n */\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add)\n{\n\tstruct cftype *cft, *cft_end = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\nrestart:\n\tfor (cft = cfts; cft != cft_end && cft->name[0] != '\\0'; cft++) {\n\t\t/* does cft->flags tell us to skip this file on @cgrp? */\n\t\tif ((cft->flags & __CFTYPE_ONLY_ON_DFL) && !cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_NOT_ON_DFL) && cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_NOT_ON_ROOT) && !cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_ONLY_ON_ROOT) && cgroup_parent(cgrp))\n\t\t\tcontinue;\n\n\t\tif (is_add) {\n\t\t\tret = cgroup_add_file(css, cgrp, cft);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s: failed to add %s, err=%d\\n\",\n\t\t\t\t\t__func__, cft->name, ret);\n\t\t\t\tcft_end = cft;\n\t\t\t\tis_add = false;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t} else {\n\t\t\tcgroup_rm_file(cgrp, cft);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cgroup_apply_cftypes(struct cftype *cfts, bool is_add)\n{\n\tstruct cgroup_subsys *ss = cfts[0].ss;\n\tstruct cgroup *root = &ss->root->cgrp;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* add/rm files for all cgroups created before */\n\tcss_for_each_descendant_pre(css, cgroup_css(root, ss)) {\n\t\tstruct cgroup *cgrp = css->cgroup;\n\n\t\tif (!(css->flags & CSS_VISIBLE))\n\t\t\tcontinue;\n\n\t\tret = cgroup_addrm_files(css, cgrp, cfts, is_add);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_add && !ret)\n\t\tkernfs_activate(root->kn);\n\treturn ret;\n}\n\nstatic void cgroup_exit_cftypes(struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\t/* free copy for custom atomic_write_len, see init_cftypes() */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE)\n\t\t\tkfree(cft->kf_ops);\n\t\tcft->kf_ops = NULL;\n\t\tcft->ss = NULL;\n\n\t\t/* revert flags set by cgroup core while adding @cfts */\n\t\tcft->flags &= ~(__CFTYPE_ONLY_ON_DFL | __CFTYPE_NOT_ON_DFL);\n\t}\n}\n\nstatic int cgroup_init_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\tstruct kernfs_ops *kf_ops;\n\n\t\tWARN_ON(cft->ss || cft->kf_ops);\n\n\t\tif (cft->seq_start)\n\t\t\tkf_ops = &cgroup_kf_ops;\n\t\telse\n\t\t\tkf_ops = &cgroup_kf_single_ops;\n\n\t\t/*\n\t\t * Ugh... if @cft wants a custom max_write_len, we need to\n\t\t * make a copy of kf_ops to set its atomic_write_len.\n\t\t */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE) {\n\t\t\tkf_ops = kmemdup(kf_ops, sizeof(*kf_ops), GFP_KERNEL);\n\t\t\tif (!kf_ops) {\n\t\t\t\tcgroup_exit_cftypes(cfts);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tkf_ops->atomic_write_len = cft->max_write_len;\n\t\t}\n\n\t\tcft->kf_ops = kf_ops;\n\t\tcft->ss = ss;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_rm_cftypes_locked(struct cftype *cfts)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!cfts || !cfts[0].ss)\n\t\treturn -ENOENT;\n\n\tlist_del(&cfts->node);\n\tcgroup_apply_cftypes(cfts, false);\n\tcgroup_exit_cftypes(cfts);\n\treturn 0;\n}\n\n/**\n * cgroup_rm_cftypes - remove an array of cftypes from a subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Unregister @cfts.  Files described by @cfts are removed from all\n * existing cgroups and all future cgroups won't have them either.  This\n * function can be called anytime whether @cfts' subsys is attached or not.\n *\n * Returns 0 on successful unregistration, -ENOENT if @cfts is not\n * registered.\n */\nint cgroup_rm_cftypes(struct cftype *cfts)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = cgroup_rm_cftypes_locked(cfts);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_cftypes - add an array of cftypes to a subsystem\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Register @cfts to @ss.  Files described by @cfts are created for all\n * existing cgroups to which @ss is attached and all future cgroups will\n * have them too.  This function can be called anytime whether @ss is\n * attached or not.\n *\n * Returns 0 on successful registration, -errno on failure.  Note that this\n * function currently returns 0 as long as @cfts registration is successful\n * even if some file creation attempts on existing cgroups fail.\n */\nstatic int cgroup_add_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tint ret;\n\n\tif (!cgroup_ssid_enabled(ss->id))\n\t\treturn 0;\n\n\tif (!cfts || cfts[0].name[0] == '\\0')\n\t\treturn 0;\n\n\tret = cgroup_init_cftypes(ss, cfts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_add_tail(&cfts->node, &ss->cfts);\n\tret = cgroup_apply_cftypes(cfts, true);\n\tif (ret)\n\t\tcgroup_rm_cftypes_locked(cfts);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_dfl_cftypes - add an array of cftypes for default hierarchy\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the default hierarchy.\n */\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_ONLY_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the legacy hierarchies.\n */\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_NOT_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_file_notify - generate a file modified event for a cgroup_file\n * @cfile: target cgroup_file\n *\n * @cfile must have been obtained by setting cftype->file_offset.\n */\nvoid cgroup_file_notify(struct cgroup_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_file_kn_lock, flags);\n\tif (cfile->kn) {\n\t\tunsigned long last = cfile->notified_at;\n\t\tunsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;\n\n\t\tif (time_in_range(jiffies, last, next)) {\n\t\t\ttimer_reduce(&cfile->notify_timer, next);\n\t\t} else {\n\t\t\tkernfs_notify(cfile->kn);\n\t\t\tcfile->notified_at = jiffies;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cgroup_file_kn_lock, flags);\n}\n\n/**\n * css_next_child - find the next child of a given css\n * @pos: the current position (%NULL to initiate traversal)\n * @parent: css whose children to walk\n *\n * This function returns the next child of @parent and should be called\n * under either cgroup_mutex or RCU read lock.  The only requirement is\n * that @parent and @pos are accessible.  The next sibling is guaranteed to\n * be returned regardless of their states.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/*\n\t * @pos could already have been unlinked from the sibling list.\n\t * Once a cgroup is removed, its ->sibling.next is no longer\n\t * updated when its next sibling changes.  CSS_RELEASED is set when\n\t * @pos is taken off list, at which time its next pointer is valid,\n\t * and, as releases are serialized, the one pointed to by the next\n\t * pointer is guaranteed to not have started release yet.  This\n\t * implies that if we observe !CSS_RELEASED on @pos in this RCU\n\t * critical section, the one pointed to by its next pointer is\n\t * guaranteed to not have finished its RCU grace period even if we\n\t * have dropped rcu_read_lock() inbetween iterations.\n\t *\n\t * If @pos has CSS_RELEASED set, its next pointer can't be\n\t * dereferenced; however, as each css is given a monotonically\n\t * increasing unique serial number and always appended to the\n\t * sibling list, the next one can be found by walking the parent's\n\t * children until the first css with higher serial number than\n\t * @pos's.  While this path can be slower, it happens iff iteration\n\t * races against release and the race window is very small.\n\t */\n\tif (!pos) {\n\t\tnext = list_entry_rcu(parent->children.next, struct cgroup_subsys_state, sibling);\n\t} else if (likely(!(pos->flags & CSS_RELEASED))) {\n\t\tnext = list_entry_rcu(pos->sibling.next, struct cgroup_subsys_state, sibling);\n\t} else {\n\t\tlist_for_each_entry_rcu(next, &parent->children, sibling)\n\t\t\tif (next->serial_nr > pos->serial_nr)\n\t\t\t\tbreak;\n\t}\n\n\t/*\n\t * @next, if not pointing to the head, can be dereferenced and is\n\t * the next sibling.\n\t */\n\tif (&next->sibling != &parent->children)\n\t\treturn next;\n\treturn NULL;\n}\n\n/**\n * css_next_descendant_pre - find the next descendant for pre-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_pre().  Find the next descendant\n * to visit for pre-order traversal of @root's descendants.  @root is\n * included in the iteration and the first node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @root are accessible and @pos is a descendant of @root.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\tstruct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit @root */\n\tif (!pos)\n\t\treturn root;\n\n\t/* visit the first child if exists */\n\tnext = css_next_child(NULL, pos);\n\tif (next)\n\t\treturn next;\n\n\t/* no child, visit my or the closest ancestor's next sibling */\n\twhile (pos != root) {\n\t\tnext = css_next_child(pos, pos->parent);\n\t\tif (next)\n\t\t\treturn next;\n\t\tpos = pos->parent;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * css_rightmost_descendant - return the rightmost descendant of a css\n * @pos: css of interest\n *\n * Return the rightmost descendant of @pos.  If there's no descendant, @pos\n * is returned.  This can be used during pre-order traversal to skip\n * subtree of @pos.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct rightmost descendant as\n * long as @pos is accessible.\n */\nstruct cgroup_subsys_state *\ncss_rightmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last, *tmp;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\tdo {\n\t\tlast = pos;\n\t\t/* ->prev isn't RCU safe, walk ->next till the end */\n\t\tpos = NULL;\n\t\tcss_for_each_child(tmp, last)\n\t\t\tpos = tmp;\n\t} while (pos);\n\n\treturn last;\n}\n\nstatic struct cgroup_subsys_state *\ncss_leftmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last;\n\n\tdo {\n\t\tlast = pos;\n\t\tpos = css_next_child(NULL, pos);\n\t} while (pos);\n\n\treturn last;\n}\n\n/**\n * css_next_descendant_post - find the next descendant for post-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_post().  Find the next descendant\n * to visit for post-order traversal of @root's descendants.  @root is\n * included in the iteration and the last node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @cgroup are accessible and @pos is a descendant of\n * @cgroup.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t struct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit leftmost descendant which may be @root */\n\tif (!pos)\n\t\treturn css_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\tnext = css_next_child(pos, pos->parent);\n\tif (next)\n\t\treturn css_leftmost_descendant(next);\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}\n\n/**\n * css_has_online_children - does a css have online children\n * @css: the target css\n *\n * Returns %true if @css has any online children; otherwise, %false.  This\n * function can be called from any context but the caller is responsible\n * for synchronizing against on/offlining as necessary.\n */\nbool css_has_online_children(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *child;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tcss_for_each_child(child, css) {\n\t\tif (child->flags & CSS_ONLINE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct css_set *css_task_iter_next_css_set(struct css_task_iter *it)\n{\n\tstruct list_head *l;\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* find the next threaded cset */\n\tif (it->tcset_pos) {\n\t\tl = it->tcset_pos->next;\n\n\t\tif (l != it->tcset_head) {\n\t\t\tit->tcset_pos = l;\n\t\t\treturn container_of(l, struct css_set,\n\t\t\t\t\t    threaded_csets_node);\n\t\t}\n\n\t\tit->tcset_pos = NULL;\n\t}\n\n\t/* find the next cset */\n\tl = it->cset_pos;\n\tl = l->next;\n\tif (l == it->cset_head) {\n\t\tit->cset_pos = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (it->ss) {\n\t\tcset = container_of(l, struct css_set, e_cset_node[it->ss->id]);\n\t} else {\n\t\tlink = list_entry(l, struct cgrp_cset_link, cset_link);\n\t\tcset = link->cset;\n\t}\n\n\tit->cset_pos = l;\n\n\t/* initialize threaded css_set walking */\n\tif (it->flags & CSS_TASK_ITER_THREADED) {\n\t\tif (it->cur_dcset)\n\t\t\tput_css_set_locked(it->cur_dcset);\n\t\tit->cur_dcset = cset;\n\t\tget_css_set(cset);\n\n\t\tit->tcset_head = &cset->threaded_csets;\n\t\tit->tcset_pos = &cset->threaded_csets;\n\t}\n\n\treturn cset;\n}\n\n/**\n * css_task_iter_advance_css_set - advance a task itererator to the next css_set\n * @it: the iterator to advance\n *\n * Advance @it to the next css_set to walk.\n */\nstatic void css_task_iter_advance_css_set(struct css_task_iter *it)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* Advance to the next non-empty css_set */\n\tdo {\n\t\tcset = css_task_iter_next_css_set(it);\n\t\tif (!cset) {\n\t\t\tit->task_pos = NULL;\n\t\t\treturn;\n\t\t}\n\t} while (!css_set_populated(cset));\n\n\tif (!list_empty(&cset->tasks))\n\t\tit->task_pos = cset->tasks.next;\n\telse\n\t\tit->task_pos = cset->mg_tasks.next;\n\n\tit->tasks_head = &cset->tasks;\n\tit->mg_tasks_head = &cset->mg_tasks;\n\n\t/*\n\t * We don't keep css_sets locked across iteration steps and thus\n\t * need to take steps to ensure that iteration can be resumed after\n\t * the lock is re-acquired.  Iteration is performed at two levels -\n\t * css_sets and tasks in them.\n\t *\n\t * Once created, a css_set never leaves its cgroup lists, so a\n\t * pinned css_set is guaranteed to stay put and we can resume\n\t * iteration afterwards.\n\t *\n\t * Tasks may leave @cset across iteration steps.  This is resolved\n\t * by registering each iterator with the css_set currently being\n\t * walked and making css_set_move_task() advance iterators whose\n\t * next task is leaving.\n\t */\n\tif (it->cur_cset) {\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t}\n\tget_css_set(cset);\n\tit->cur_cset = cset;\n\tlist_add(&it->iters_node, &cset->task_iters);\n}\n\nstatic void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct list_head *next;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\t/*\n\t * Advance iterator to find next entry.  cset->tasks is consumed\n\t * first and then ->mg_tasks.  After ->mg_tasks, we move onto the\n\t * next cset.\n\t */\n\tnext = it->task_pos->next;\n\n\tif (next == it->tasks_head)\n\t\tnext = it->mg_tasks_head->next;\n\n\tif (next == it->mg_tasks_head)\n\t\tcss_task_iter_advance_css_set(it);\n\telse\n\t\tit->task_pos = next;\n\n\t/* if PROCS, skip over tasks which aren't group leaders */\n\tif ((it->flags & CSS_TASK_ITER_PROCS) && it->task_pos &&\n\t    !thread_group_leader(list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t    cg_list)))\n\t\tgoto repeat;\n}\n\n/**\n * css_task_iter_start - initiate task iteration\n * @css: the css to walk tasks of\n * @flags: CSS_TASK_ITER_* flags\n * @it: the task iterator to use\n *\n * Initiate iteration through the tasks of @css.  The caller can call\n * css_task_iter_next() to walk through the tasks until the function\n * returns NULL.  On completion of iteration, css_task_iter_end() must be\n * called.\n */\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\t/* no one should try to iterate before mounting cgroups */\n\tWARN_ON_ONCE(!use_task_css_set_links);\n\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance_css_set(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}\n\n/**\n * css_task_iter_next - return the next task for the iterator\n * @it: the task iterator being iterated\n *\n * The \"next\" function for task iteration.  @it should have been\n * initialized via css_task_iter_start().  Returns NULL when the iteration\n * reaches the end.\n */\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}\n\n/**\n * css_task_iter_end - finish task iteration\n * @it: the task iterator to finish\n *\n * Finish task iteration started by css_task_iter_start().\n */\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}\n\nstatic void cgroup_procs_release(struct kernfs_open_file *of)\n{\n\tif (of->priv) {\n\t\tcss_task_iter_end(of->priv);\n\t\tkfree(of->priv);\n\t}\n}\n\nstatic void *cgroup_procs_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct css_task_iter *it = of->priv;\n\n\treturn css_task_iter_next(it);\n}\n\nstatic void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct css_task_iter *it = of->priv;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!it) {\n\t\tif (WARN_ON_ONCE((*pos)++))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tit = kzalloc(sizeof(*it), GFP_KERNEL);\n\t\tif (!it)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tof->priv = it;\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else if (!(*pos)++) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t}\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}\n\nstatic void *cgroup_procs_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\n\t/*\n\t * All processes of a threaded subtree belong to the domain cgroup\n\t * of the subtree.  Only threads can be distributed across the\n\t * subtree.  Reject reads on cgroup.procs in the subtree proper.\n\t * They're always empty anyway.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn __cgroup_procs_start(s, pos, CSS_TASK_ITER_PROCS |\n\t\t\t\t\t    CSS_TASK_ITER_THREADED);\n}\n\nstatic int cgroup_procs_show(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", task_pid_vnr(v));\n\treturn 0;\n}\n\nstatic int cgroup_procs_write_permission(struct cgroup *src_cgrp,\n\t\t\t\t\t struct cgroup *dst_cgrp,\n\t\t\t\t\t struct super_block *sb)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct cgroup *com_cgrp = src_cgrp;\n\tstruct inode *inode;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* find the common ancestor */\n\twhile (!cgroup_is_descendant(dst_cgrp, com_cgrp))\n\t\tcom_cgrp = cgroup_parent(com_cgrp);\n\n\t/* %current should be authorized to migrate to the common ancestor */\n\tinode = kernfs_get_inode(sb, com_cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(inode, MAY_WRITE);\n\tiput(inode);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, %current must be able\n\t * to see both source and destination cgroups from its namespace.\n\t */\n\tif ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||\n\t     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_procs_write(struct kernfs_open_file *of,\n\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tssize_t ret;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, true);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp,\n\t\t\t\t\t    of->file->f_path.dentry->d_sb);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, true);\n\nout_finish:\n\tcgroup_procs_write_finish(task);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic void *cgroup_threads_start(struct seq_file *s, loff_t *pos)\n{\n\treturn __cgroup_procs_start(s, pos, 0);\n}\n\nstatic ssize_t cgroup_threads_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, false);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* thread migrations follow the cgroup.procs delegation rule */\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp,\n\t\t\t\t\t    of->file->f_path.dentry->d_sb);\n\tif (ret)\n\t\tgoto out_finish;\n\n\t/* and must be contained in the same domain */\n\tret = -EOPNOTSUPP;\n\tif (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, false);\n\nout_finish:\n\tcgroup_procs_write_finish(task);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\n/* cgroup core interface files for the default hierarchy */\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t},\n#endif\n\t{ }\t/* terminate */\n};\n\n/*\n * css destruction is four-stage process.\n *\n * 1. Destruction starts.  Killing of the percpu_ref is initiated.\n *    Implemented in kill_css().\n *\n * 2. When the percpu_ref is confirmed to be visible as killed on all CPUs\n *    and thus css_tryget_online() is guaranteed to fail, the css can be\n *    offlined by invoking offline_css().  After offlining, the base ref is\n *    put.  Implemented in css_killed_work_fn().\n *\n * 3. When the percpu_ref reaches zero, the only possible remaining\n *    accessors are inside RCU read sections.  css_release() schedules the\n *    RCU callback.\n *\n * 4. After the grace period, the css can be freed.  Implemented in\n *    css_free_work_fn().\n *\n * It is actually hairier because both step 2 and 4 require process context\n * and thus involve punting to css->destroy_work adding two additional\n * steps to the already complex sequence.\n */\nstatic void css_free_rwork_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css = container_of(to_rcu_work(work),\n\t\t\t\tstruct cgroup_subsys_state, destroy_rwork);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tpercpu_ref_exit(&css->refcnt);\n\n\tif (ss) {\n\t\t/* css free path */\n\t\tstruct cgroup_subsys_state *parent = css->parent;\n\t\tint id = css->id;\n\n\t\tss->css_free(css);\n\t\tcgroup_idr_remove(&ss->css_idr, id);\n\t\tcgroup_put(cgrp);\n\n\t\tif (parent)\n\t\t\tcss_put(parent);\n\t} else {\n\t\t/* cgroup free path */\n\t\tatomic_dec(&cgrp->root->nr_cgrps);\n\t\tcgroup1_pidlist_destroy_all(cgrp);\n\t\tcancel_work_sync(&cgrp->release_agent_work);\n\n\t\tif (cgroup_parent(cgrp)) {\n\t\t\t/*\n\t\t\t * We get a ref to the parent, and put the ref when\n\t\t\t * this cgroup is being freed, so it's guaranteed\n\t\t\t * that the parent won't be destroyed before its\n\t\t\t * children.\n\t\t\t */\n\t\t\tcgroup_put(cgroup_parent(cgrp));\n\t\t\tkernfs_put(cgrp->kn);\n\t\t\tpsi_cgroup_free(cgrp);\n\t\t\tif (cgroup_on_dfl(cgrp))\n\t\t\t\tcgroup_rstat_exit(cgrp);\n\t\t\tkfree(cgrp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is root cgroup's refcnt reaching zero,\n\t\t\t * which indicates that the root should be\n\t\t\t * released.\n\t\t\t */\n\t\t\tcgroup_destroy_root(cgrp->root);\n\t\t}\n\t}\n}\n\nstatic void css_release_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tcss->flags |= CSS_RELEASED;\n\tlist_del_rcu(&css->sibling);\n\n\tif (ss) {\n\t\t/* css release path */\n\t\tif (!list_empty(&css->rstat_css_node)) {\n\t\t\tcgroup_rstat_flush(cgrp);\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t}\n\n\t\tcgroup_idr_replace(&ss->css_idr, NULL, css->id);\n\t\tif (ss->css_released)\n\t\t\tss->css_released(css);\n\t} else {\n\t\tstruct cgroup *tcgrp;\n\n\t\t/* cgroup release path */\n\t\tTRACE_CGROUP_PATH(release, cgrp);\n\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcgroup_rstat_flush(cgrp);\n\n\t\tfor (tcgrp = cgroup_parent(cgrp); tcgrp;\n\t\t     tcgrp = cgroup_parent(tcgrp))\n\t\t\ttcgrp->nr_dying_descendants--;\n\n\t\tcgroup_idr_remove(&cgrp->root->cgroup_idr, cgrp->id);\n\t\tcgrp->id = -1;\n\n\t\t/*\n\t\t * There are two control paths which try to determine\n\t\t * cgroup from dentry without going through kernfs -\n\t\t * cgroupstats_build() and css_tryget_online_from_dir().\n\t\t * Those are supported by RCU protecting clearing of\n\t\t * cgrp->kn->priv backpointer.\n\t\t */\n\t\tif (cgrp->kn)\n\t\t\tRCU_INIT_POINTER(*(void __rcu __force **)&cgrp->kn->priv,\n\t\t\t\t\t NULL);\n\n\t\tcgroup_bpf_put(cgrp);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n}\n\nstatic void css_release(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tINIT_WORK(&css->destroy_work, css_release_work_fn);\n\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n}\n\nstatic void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (cgroup_on_dfl(cgrp) && ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}\n\n/* invoke ->css_online() on a new CSS and mark it online if successful */\nstatic int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}\n\n/* if the CSS is online, invoke ->css_offline() on it and mark it offline */\nstatic void offline_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!(css->flags & CSS_ONLINE))\n\t\treturn;\n\n\tif (ss->css_offline)\n\t\tss->css_offline(css);\n\n\tcss->flags &= ~CSS_ONLINE;\n\tRCU_INIT_POINTER(css->cgroup->subsys[ss->id], NULL);\n\n\twake_up_all(&css->cgroup->offline_waitq);\n}\n\n/**\n * css_create - create a cgroup_subsys_state\n * @cgrp: the cgroup new css will be associated with\n * @ss: the subsys of new css\n *\n * Create a new css associated with @cgrp - @ss pair.  On success, the new\n * css is online and installed in @cgrp.  This function doesn't create the\n * interface files.  Returns 0 on success, -errno on failure.\n */\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *parent_css = cgroup_css(parent, ss);\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcss = ss->css_alloc(parent_css);\n\tif (!css)\n\t\tcss = ERR_PTR(-ENOMEM);\n\tif (IS_ERR(css))\n\t\treturn css;\n\n\tinit_and_link_css(css, ss, cgrp);\n\n\terr = percpu_ref_init(&css->refcnt, css_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_css;\n\n\terr = cgroup_idr_alloc(&ss->css_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_free_css;\n\tcss->id = err;\n\n\t/* @css is ready to be brought online now, make it visible */\n\tlist_add_tail_rcu(&css->sibling, &parent_css->children);\n\tcgroup_idr_replace(&ss->css_idr, css, css->id);\n\n\terr = online_css(css);\n\tif (err)\n\t\tgoto err_list_del;\n\n\tif (ss->broken_hierarchy && !ss->warned_broken_hierarchy &&\n\t    cgroup_parent(parent)) {\n\t\tpr_warn(\"%s (%d) created nested cgroup for controller \\\"%s\\\" which has incomplete hierarchy support. Nested cgroups may change behavior in the future.\\n\",\n\t\t\tcurrent->comm, current->pid, ss->name);\n\t\tif (!strcmp(ss->name, \"memory\"))\n\t\t\tpr_warn(\"\\\"memory\\\" requires setting use_hierarchy to 1 on the root\\n\");\n\t\tss->warned_broken_hierarchy = true;\n\t}\n\n\treturn css;\n\nerr_list_del:\n\tlist_del_rcu(&css->sibling);\nerr_free_css:\n\tlist_del_rcu(&css->rstat_css_node);\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n\treturn ERR_PTR(err);\n}\n\n/*\n * The returned cgroup is fully initialized including its control mask, but\n * it isn't associated with its kernfs_node and doesn't have the control\n * mask applied.\n */\nstatic struct cgroup *cgroup_create(struct cgroup *parent)\n{\n\tstruct cgroup_root *root = parent->root;\n\tstruct cgroup *cgrp, *tcgrp;\n\tint level = parent->level + 1;\n\tint ret;\n\n\t/* allocate the cgroup and its ID, 0 is reserved for the root */\n\tcgrp = kzalloc(struct_size(cgrp, ancestor_ids, (level + 1)),\n\t\t       GFP_KERNEL);\n\tif (!cgrp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_ref_init(&cgrp->self.refcnt, css_release, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_free_cgrp;\n\n\tif (cgroup_on_dfl(parent)) {\n\t\tret = cgroup_rstat_init(cgrp);\n\t\tif (ret)\n\t\t\tgoto out_cancel_ref;\n\t}\n\n\t/*\n\t * Temporarily set the pointer to NULL, so idr_find() won't return\n\t * a half-baked cgroup.\n\t */\n\tcgrp->id = cgroup_idr_alloc(&root->cgroup_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (cgrp->id < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto out_stat_exit;\n\t}\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->self.parent = &parent->self;\n\tcgrp->root = root;\n\tcgrp->level = level;\n\n\tret = psi_cgroup_alloc(cgrp);\n\tif (ret)\n\t\tgoto out_idr_free;\n\n\tret = cgroup_bpf_inherit(cgrp);\n\tif (ret)\n\t\tgoto out_psi_free;\n\n\tfor (tcgrp = cgrp; tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\tcgrp->ancestor_ids[tcgrp->level] = tcgrp->id;\n\n\t\tif (tcgrp != cgrp)\n\t\t\ttcgrp->nr_descendants++;\n\t}\n\n\tif (notify_on_release(parent))\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &parent->flags))\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &cgrp->flags);\n\n\tcgrp->self.serial_nr = css_serial_nr_next++;\n\n\t/* allocation complete, commit to creation */\n\tlist_add_tail_rcu(&cgrp->self.sibling, &cgroup_parent(cgrp)->self.children);\n\tatomic_inc(&root->nr_cgrps);\n\tcgroup_get_live(parent);\n\n\t/*\n\t * @cgrp is now fully operational.  If something fails after this\n\t * point, it'll be released via the normal destruction path.\n\t */\n\tcgroup_idr_replace(&root->cgroup_idr, cgrp, cgrp->id);\n\n\t/*\n\t * On the default hierarchy, a child doesn't automatically inherit\n\t * subtree_control from the parent.  Each is configured manually.\n\t */\n\tif (!cgroup_on_dfl(cgrp))\n\t\tcgrp->subtree_control = cgroup_control(cgrp);\n\n\tcgroup_propagate_control(cgrp);\n\n\treturn cgrp;\n\nout_psi_free:\n\tpsi_cgroup_free(cgrp);\nout_idr_free:\n\tcgroup_idr_remove(&root->cgroup_idr, cgrp->id);\nout_stat_exit:\n\tif (cgroup_on_dfl(parent))\n\t\tcgroup_rstat_exit(cgrp);\nout_cancel_ref:\n\tpercpu_ref_exit(&cgrp->self.refcnt);\nout_free_cgrp:\n\tkfree(cgrp);\n\treturn ERR_PTR(ret);\n}\n\nstatic bool cgroup_check_hierarchy_limits(struct cgroup *parent)\n{\n\tstruct cgroup *cgroup;\n\tint ret = false;\n\tint level = 1;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tfor (cgroup = parent; cgroup; cgroup = cgroup_parent(cgroup)) {\n\t\tif (cgroup->nr_descendants >= cgroup->max_descendants)\n\t\t\tgoto fail;\n\n\t\tif (level > cgroup->max_depth)\n\t\t\tgoto fail;\n\n\t\tlevel++;\n\t}\n\n\tret = true;\nfail:\n\treturn ret;\n}\n\nint cgroup_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)\n{\n\tstruct cgroup *parent, *cgrp;\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\t/* do not accept '\\n' to prevent making /proc/<pid>/cgroup unparsable */\n\tif (strchr(name, '\\n'))\n\t\treturn -EINVAL;\n\n\tparent = cgroup_kn_lock_live(parent_kn, false);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tif (!cgroup_check_hierarchy_limits(parent)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tcgrp = cgroup_create(parent);\n\tif (IS_ERR(cgrp)) {\n\t\tret = PTR_ERR(cgrp);\n\t\tgoto out_unlock;\n\t}\n\n\t/* create the directory */\n\tkn = kernfs_create_dir(parent->kn, name, mode, cgrp);\n\tif (IS_ERR(kn)) {\n\t\tret = PTR_ERR(kn);\n\t\tgoto out_destroy;\n\t}\n\tcgrp->kn = kn;\n\n\t/*\n\t * This extra ref will be put in cgroup_free_fn() and guarantees\n\t * that @cgrp->kn is always accessible.\n\t */\n\tkernfs_get(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = css_populate_dir(&cgrp->self);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tTRACE_CGROUP_PATH(mkdir, cgrp);\n\n\t/* let's create and online css's */\n\tkernfs_activate(kn);\n\n\tret = 0;\n\tgoto out_unlock;\n\nout_destroy:\n\tcgroup_destroy_locked(cgrp);\nout_unlock:\n\tcgroup_kn_unlock(parent_kn);\n\treturn ret;\n}\n\n/*\n * This is called when the refcnt of a css is confirmed to be killed.\n * css_tryget_online() is now guaranteed to fail.  Tell the subsystem to\n * initate destruction and put the css ref from kill_css().\n */\nstatic void css_killed_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tdo {\n\t\toffline_css(css);\n\t\tcss_put(css);\n\t\t/* @css can't go away while we're holding cgroup_mutex */\n\t\tcss = css->parent;\n\t} while (css && atomic_dec_and_test(&css->online_cnt));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_permission",
          "args": [
            "src_cgrp",
            "dst_cgrp",
            "of->file->f_path.dentry->d_sb"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cgroup_from_root",
          "args": [
            "task",
            "&cgrp_dfl_root"
          ],
          "line": 4479
        },
        "resolved": true,
        "details": {
          "function_name": "task_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1357-1366",
          "snippet": "struct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold cgroup_mutex the\n\t * task can't change groups, so the only thing that can happen\n\t * is that it exits and its css is set back to init_css_set.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold cgroup_mutex the\n\t * task can't change groups, so the only thing that can happen\n\t * is that it exits and its css is set back to init_css_set.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4478
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "task"
          ],
          "line": 4473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_start",
          "args": [
            "buf",
            "false"
          ],
          "line": 4472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 4466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_finish",
          "args": [
            "task"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_permission",
          "args": [
            "src_cgrp",
            "dst_cgrp",
            "of->file->f_path.dentry->d_sb"
          ],
          "line": 4439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "task"
          ],
          "line": 4430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_start",
          "args": [
            "buf",
            "true"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_descendant",
          "args": [
            "dst_cgrp",
            "ns->root_cset->dfl_cgrp"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_descendant",
          "args": [
            "src_cgrp",
            "ns->root_cset->dfl_cgrp"
          ],
          "line": 4411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_WRITE"
          ],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_inode",
          "args": [
            "sb",
            "com_cgrp->procs_file.kn"
          ],
          "line": 4397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "com_cgrp"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_descendant",
          "args": [
            "dst_cgrp",
            "com_cgrp"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_permission",
          "args": [
            "structcgroup *src_cgrp",
            "structcgroup *dst_cgrp",
            "structsuper_block *sb"
          ],
          "line": 4381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%d\\n\"",
            "task_pid_vnr(v)"
          ],
          "line": 4377
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "v"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cgroup_procs_start",
          "args": [
            "s",
            "pos",
            "CSS_TASK_ITER_PROCS |\n\t\t\t\t\t    CSS_TASK_ITER_THREADED"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 4369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "s"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_next",
          "args": [
            "s",
            "NULL",
            "NULL"
          ],
          "line": 4355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cgrp->self",
            "iter_flags",
            "it"
          ],
          "line": 4352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "it"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cgrp->self",
            "iter_flags",
            "it"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*it)",
            "GFP_KERNEL"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(*pos)++"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "s"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cgroup_procs_start",
          "args": [
            "structseq_file *s",
            "loff_t *pos",
            "unsigned intiter_flags"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "it"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_next",
          "args": [
            "structseq_file *s",
            "void *v",
            "loff_t *pos"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "of->priv"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "it->cur_task"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "it->cur_dcset"
          ],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "863-898",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&it->iters_node"
          ],
          "line": 4302
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_advance",
          "args": [
            "it"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "it->cur_task"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "it->task_pos",
            "structtask_struct",
            "cg_list"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_advance_css_set",
          "args": [
            "it"
          ],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "it",
            "0",
            "sizeof(*it)"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!use_task_css_set_links"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t    cg_list)"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "it->task_pos",
            "structtask_struct",
            "cg_list"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_advance_css_set",
          "args": [
            "it"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&it->iters_node",
            "&cset->task_iters"
          ],
          "line": 4196
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 4194
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "179-182",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_populated",
          "args": [
            "cset"
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "707-712",
          "snippet": "static bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next_css_set",
          "args": [
            "it"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l",
            "structcgrp_cset_link",
            "cset_link"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "l",
            "structcss_set",
            "e_cset_node[it->ss->id]"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "l",
            "structcss_set",
            "threaded_csets_node"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_next_css_set",
          "args": [
            "structcss_task_iter *it"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4090
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_for_each_child",
          "args": [
            "child",
            "css"
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4083
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_leftmost_descendant",
          "args": [
            "next"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "pos",
            "pos->parent"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_leftmost_descendant",
          "args": [
            "root"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_assert_mutex_or_rcu_locked",
          "args": [],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "NULL",
            "pos"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_leftmost_descendant",
          "args": [
            "structcgroup_subsys_state *pos"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_child",
          "args": [
            "tmp",
            "last"
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_assert_mutex_or_rcu_locked",
          "args": [],
          "line": 3997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "pos",
            "pos->parent"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "NULL",
            "pos"
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_assert_mutex_or_rcu_locked",
          "args": [],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "next",
            "&parent->children",
            "sibling"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "pos->sibling.next",
            "structcgroup_subsys_state",
            "sibling"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(pos->flags & CSS_RELEASED)"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "parent->children.next",
            "structcgroup_subsys_state",
            "sibling"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_assert_mutex_or_rcu_locked",
          "args": [],
          "line": 3889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&cgroup_file_kn_lock",
            "flags"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_notify",
          "args": [
            "cfile->kn"
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_reduce",
          "args": [
            "&cfile->notify_timer",
            "next"
          ],
          "line": 3858
        },
        "resolved": true,
        "details": {
          "function_name": "timer_reduce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1115-1118",
          "snippet": "int timer_reduce(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, MOD_TIMER_REDUCE);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define MOD_TIMER_REDUCE\t\t0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_REDUCE\t\t0x02\n\nint timer_reduce(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, MOD_TIMER_REDUCE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_in_range",
          "args": [
            "jiffies",
            "last",
            "next"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&cgroup_file_kn_lock",
            "flags"
          ],
          "line": 3852
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_add_cftypes",
          "args": [
            "ss",
            "cfts"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_cftypes",
          "args": [
            "ss",
            "cfts"
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rm_cftypes_locked",
          "args": [
            "cfts"
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_cftypes",
          "args": [
            "cfts",
            "true"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cfts->node",
            "&ss->cfts"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3797
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_init_cftypes",
          "args": [
            "ss",
            "cfts"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ssid_enabled",
          "args": [
            "ss->id"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_ssid_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "234-240",
          "snippet": "bool cgroup_ssid_enabled(int ssid)\n{\n\tif (CGROUP_SUBSYS_COUNT == 0)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};\n\nbool cgroup_ssid_enabled(int ssid)\n{\n\tif (CGROUP_SUBSYS_COUNT == 0)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rm_cftypes_locked",
          "args": [
            "cfts"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit_cftypes",
          "args": [
            "cfts"
          ],
          "line": 3744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_cftypes",
          "args": [
            "cfts",
            "false"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit_cftypes",
          "args": [
            "cfts"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "kf_ops",
            "sizeof(*kf_ops)",
            "GFP_KERNEL"
          ],
          "line": 3720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cft->ss || cft->kf_ops"
          ],
          "line": 3708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "root->kn"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "is_add"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "cgroup_css(root, ss)"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rm_file",
          "args": [
            "cgrp",
            "cft"
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rm_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1551-1569",
          "snippet": "static void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_file_kn_lock);",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic DEFINE_SPINLOCK(cgroup_file_kn_lock);\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: failed to add %s, err=%d\\n\"",
            "__func__",
            "cft->name",
            "ret"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_file",
          "args": [
            "css",
            "cgrp",
            "cft"
          ],
          "line": 3644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 3640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&cfile->notify_timer",
            "cgroup_file_notify_timer",
            "0"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "kn"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kn_set_ugid",
          "args": [
            "kn"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kn"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernfs_create_file",
          "args": [
            "cgrp->kn",
            "cgroup_file_name(cgrp, cft, name)",
            "cgroup_file_mode(cft)",
            "GLOBAL_ROOT_UID",
            "GLOBAL_ROOT_GID",
            "0",
            "cft->kf_ops",
            "cft",
            "NULL",
            "key"
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_mode",
          "args": [
            "cft"
          ],
          "line": 3586
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_file_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1417-1432",
          "snippet": "static umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_file_name",
          "args": [
            "cgrp",
            "cft",
            "name"
          ],
          "line": 3585
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_file_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1396-1409",
          "snippet": "static char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX))\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s.%s\",\n\t\t\t cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\telse\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\treturn buf;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX))\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s.%s\",\n\t\t\t cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\telse\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_add_file",
          "args": [
            "structcgroup_subsys_state *css",
            "structcgroup *cgrp",
            "structcftype *cft"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify_timer",
          "args": [
            "structtimer_list *timer"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_setattr",
          "args": [
            "kn",
            "&iattr"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "iattr.ia_gid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "iattr.ia_uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->read_s64",
          "args": [
            "css",
            "cft"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->read_u64",
          "args": [
            "css",
            "cft"
          ],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->seq_show",
          "args": [
            "m",
            "arg"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "m"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_seqfile_show",
          "args": [
            "structseq_file *m",
            "void *arg"
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq",
            "v"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->write_s64",
          "args": [
            "css",
            "cft",
            "v"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoll",
          "args": [
            "buf",
            "0",
            "&v"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->write_u64",
          "args": [
            "css",
            "cft",
            "v"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "buf",
            "0",
            "&v"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->write",
          "args": [
            "of",
            "buf",
            "nbytes",
            "off"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->release",
          "args": [
            "of"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_release",
          "args": [
            "structkernfs_open_file *of"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->open",
          "args": [
            "of"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_open",
          "args": [
            "structkernfs_open_file *of"
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "seq",
            "&seq_css(seq)->cgroup->psi",
            "PSI_CPU"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "psi_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "671-698",
          "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool psi_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\n\tif (psi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\tupdate_stats(group);\n\n\tfor (full = 0; full < 2 - (res == PSI_CPU); full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[res * 2 + full], NSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_cpu_pressure_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_memory_pressure_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_io_pressure_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_extra_stat_show",
          "args": [
            "seq",
            "cgrp",
            "cpu_cgrp_id"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_show",
          "args": [
            "seq"
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "395-416",
          "snippet": "void cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\n\tif (!cgroup_parent(cgrp))\n\t\treturn;\n\n\tcgroup_rstat_flush_hold(cgrp);\n\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime, &utime, &stime);\n\tcgroup_rstat_flush_release();\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\n\tif (!cgroup_parent(cgrp))\n\t\treturn;\n\n\tcgroup_rstat_flush_hold(cgrp);\n\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime, &utime, &stime);\n\tcgroup_rstat_flush_release();\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "css"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_extra_stat_show",
          "args": [
            "seq",
            "css"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_tryget_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_tryget_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "481-493",
          "snippet": "static struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (!css || !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (!css || !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_extra_stat_show",
          "args": [
            "structseq_file *seq",
            "structcgroup *cgrp",
            "intssid"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_stat_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "seq_css(seq)->cgroup"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&depth"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"max\""
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_max_depth_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"max\\n\""
          ],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cgrp->max_depth"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&descendants"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"max\""
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_max_descendants_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cgrp->max_descendants"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_enable_threaded",
          "args": [
            "cgrp"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strstrip(buf)",
            "\"threaded\""
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_thread_root",
          "args": [
            "cgrp"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_thread_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "375-394",
          "snippet": "bool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_valid_domain",
          "args": [
            "cgrp"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_valid_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "397-412",
          "snippet": "static bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_finalize_control",
          "args": [
            "cgrp",
            "ret"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "cgrp"
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_save_control",
          "args": [
            "cgrp"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_can_be_thread_root",
          "args": [
            "dom_cgrp"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_can_be_thread_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "353-372",
          "snippet": "static bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "cgrp->kn"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_finalize_control",
          "args": [
            "cgrp",
            "ret"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "cgrp"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_save_control",
          "args": [
            "cgrp"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_vet_subtree_control_enable",
          "args": [
            "cgrp",
            "enable"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_child",
          "args": [
            "child",
            "cgrp"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tok + 1",
            "ss->name"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "~cgrp_dfl_inhibit_ss_mask"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\" \""
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_has_tasks",
          "args": [
            "cgrp"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_has_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "331-334",
          "snippet": "static bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_mixable",
          "args": [
            "cgrp"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_mixable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "342-350",
          "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_vet_subtree_control_enable",
          "args": [
            "structcgroup *cgrp",
            "u16enable"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control_disable",
          "args": [
            "cgrp"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_propagate_control",
          "args": [
            "cgrp"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_restore_control",
          "args": [
            "cgrp"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_dfl_csses",
          "args": [
            "cgrp"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control_enable",
          "args": [
            "cgrp"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_propagate_control",
          "args": [
            "cgrp"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_reset",
          "args": [
            "css"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_clear_dir",
          "args": [
            "css"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "css_clear_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1575-1596",
          "snippet": "static void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_visible",
          "args": [
            "css"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_css",
          "args": [
            "css"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "kill_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5091-5123",
          "snippet": "static void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static void css_release(struct percpu_ref *ref);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_ss_mask",
          "args": [
            "dsct"
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_ss_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "436-450",
          "snippet": "static u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "css && percpu_ref_is_dying(&css->refcnt)"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_dying",
          "args": [
            "&css->refcnt"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_post",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_visible",
          "args": [
            "css"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "css"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "css"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_create",
          "args": [
            "dsct",
            "ss"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "css && percpu_ref_is_dying(&css->refcnt)"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_dying",
          "args": [
            "&css->refcnt"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_visible",
          "args": [
            "structcgroup_subsys_state *css"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_post",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_calc_subtree_ss_mask",
          "args": [
            "dsct->subtree_control",
            "cgroup_ss_mask(dsct)"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_calc_subtree_ss_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1446-1476",
          "snippet": "static u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_implicit_ss_mask;",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "dsct"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&dsct->offline_waitq",
            "&wait"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "347-370",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&dsct->offline_waitq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "261-294",
          "snippet": "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_dying",
          "args": [
            "&css->refcnt"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_post",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_finish",
          "args": [
            "&mgctx"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2426-2447",
          "snippet": "void cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_execute",
          "args": [
            "&mgctx"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2291-2380",
          "snippet": "static int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tput_css_set_locked(from_cset);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tput_css_set_locked(from_cset);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_add_task",
          "args": [
            "task",
            "&mgctx"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_add_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2190-2218",
          "snippet": "static void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* leave @task alone if post_fork() hasn't linked it yet */\n\tif (list_empty(&task->cg_list))\n\t\treturn;\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* leave @task alone if post_fork() hasn't linked it yet */\n\tif (list_empty(&task->cg_list))\n\t\treturn;\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "task",
            "ntask",
            "&src_cset->tasks",
            "cg_list"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "src_cset",
            "&mgctx.preloaded_src_csets",
            "mg_preload_node"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_prepare_dst",
          "args": [
            "&mgctx"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_prepare_dst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2512-2562",
          "snippet": "int cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\tgoto err;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\nerr:\n\tcgroup_migrate_finish(mgctx);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\tgoto err;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\nerr:\n\tcgroup_migrate_finish(mgctx);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_add_src",
          "args": [
            "link->cset",
            "dsct",
            "&mgctx"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_add_src",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2465-2496",
          "snippet": "void cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nvoid cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&dsct->cset_links",
            "cset_link"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_CGROUP_MGCTX",
          "args": [
            "mgctx"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_print_ss_mask",
          "args": [
            "seq",
            "cgrp->subtree_control"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subtree_control_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_print_ss_mask",
          "args": [
            "seq",
            "cgroup_control(cgrp)"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "seq",
            "'\\n'"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "ss_mask"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_print_ss_mask",
          "args": [
            "structseq_file *seq",
            "u16ss_mask"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->post_attach",
          "args": [],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "tsk"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESRCH"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "348-351",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "strstrip(buf)",
            "0",
            "&pid"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_start",
          "args": [
            "char *buf",
            "boolthreadgroup"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "attach_task",
            "dst_cgrp",
            "leader",
            "threadgroup"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate",
          "args": [
            "leader",
            "threadgroup",
            "&mgctx"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2582-2604",
          "snippet": "int cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nint cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "leader",
            "task"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_vet_dst",
          "args": [
            "dst_cgrp"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_vet_dst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2391-2417",
          "snippet": "int cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nint cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_CGROUP_MGCTX",
          "args": [
            "mgctx"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NOTIFY_MIN_INTV\tDIV_ROUND_UP(HZ, 100)\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic DEFINE_SPINLOCK(cgroup_file_kn_lock);\nstruct percpu_rw_semaphore cgroup_threadgroup_rwsem;\nstatic struct workqueue_struct *cgroup_destroy_wq;\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic u64 css_serial_nr_next = 1;\nstruct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nint cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct task_struct *task;\n\tint ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/* look up all src csets */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_src(task_css_set(task), dst_cgrp, &mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* prepare dst csets and commit */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (!ret)\n\t\tret = cgroup_migrate(leader, threadgroup, &mgctx);\n\n\tcgroup_migrate_finish(&mgctx);\n\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(attach_task, dst_cgrp, leader, threadgroup);\n\n\treturn ret;\n}\n\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup)\n\t__acquires(&cgroup_threadgroup_rwsem)\n{\n\tstruct task_struct *tsk;\n\tpid_t pid;\n\n\tif (kstrtoint(strstrip(buf), 0, &pid) || pid < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\trcu_read_lock();\n\tif (pid) {\n\t\ttsk = find_task_by_vpid(pid);\n\t\tif (!tsk) {\n\t\t\ttsk = ERR_PTR(-ESRCH);\n\t\t\tgoto out_unlock_threadgroup;\n\t\t}\n\t} else {\n\t\ttsk = current;\n\t}\n\n\tif (threadgroup)\n\t\ttsk = tsk->group_leader;\n\n\t/*\n\t * kthreads may acquire PF_NO_SETAFFINITY during initialization.\n\t * If userland migrates such a kthread to a non-root cgroup, it can\n\t * become trapped in a cpuset, or RT kthread may be born in a\n\t * cgroup with no rt_runtime allocated.  Just say no.\n\t */\n\tif (tsk->no_cgroup_migration || (tsk->flags & PF_NO_SETAFFINITY)) {\n\t\ttsk = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock_threadgroup;\n\t}\n\n\tget_task_struct(tsk);\n\tgoto out_unlock_rcu;\n\nout_unlock_threadgroup:\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\nout_unlock_rcu:\n\trcu_read_unlock();\n\treturn tsk;\n}\n\nvoid cgroup_procs_write_finish(struct task_struct *task)\n\t__releases(&cgroup_threadgroup_rwsem)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\t/* release reference from cgroup_procs_write_start() */\n\tput_task_struct(task);\n\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tfor_each_subsys(ss, ssid)\n\t\tif (ss->post_attach)\n\t\t\tss->post_attach();\n}\n\nstatic void cgroup_print_ss_mask(struct seq_file *seq, u16 ss_mask)\n{\n\tstruct cgroup_subsys *ss;\n\tbool printed = false;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tif (printed)\n\t\t\tseq_putc(seq, ' ');\n\t\tseq_printf(seq, \"%s\", ss->name);\n\t\tprinted = true;\n\t} while_each_subsys_mask();\n\tif (printed)\n\t\tseq_putc(seq, '\\n');\n}\n\n/* show controllers which are enabled from the parent */\nstatic int cgroup_controllers_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgroup_control(cgrp));\n\treturn 0;\n}\n\n/* show controllers which are enabled for a given cgroup's children */\nstatic int cgroup_subtree_control_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgrp->subtree_control);\n\treturn 0;\n}\n\n/**\n * cgroup_update_dfl_csses - update css assoc of a subtree in default hierarchy\n * @cgrp: root of the subtree to update csses for\n *\n * @cgrp's control masks have changed and its subtree's css associations\n * need to be updated accordingly.  This function looks up all css_sets\n * which are attached to the subtree, creates the matching updated css_sets\n * and migrates the tasks to the new ones.\n */\nstatic int cgroup_update_dfl_csses(struct cgroup *cgrp)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup *dsct;\n\tstruct css_set *src_cset;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* look up all csses currently attached to @cgrp's subtree */\n\tspin_lock_irq(&css_set_lock);\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &dsct->cset_links, cset_link)\n\t\t\tcgroup_migrate_add_src(link->cset, dsct, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* NULL dst indicates self on default hierarchy */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(src_cset, &mgctx.preloaded_src_csets, mg_preload_node) {\n\t\tstruct task_struct *task, *ntask;\n\n\t\t/* all tasks in src_csets need to be migrated */\n\t\tlist_for_each_entry_safe(task, ntask, &src_cset->tasks, cg_list)\n\t\t\tcgroup_migrate_add_task(task, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_execute(&mgctx);\nout_finish:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\treturn ret;\n}\n\n/**\n * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses\n * @cgrp: root of the target subtree\n *\n * Because css offlining is asynchronous, userland may try to re-enable a\n * controller while the previous css is still around.  This function grabs\n * cgroup_mutex and drains the previous css instances of @cgrp's subtree.\n */\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp)\n\t__acquires(&cgroup_mutex)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\nrestart:\n\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tif (!css || !percpu_ref_is_dying(&css->refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get_live(dsct);\n\t\t\tprepare_to_wait(&dsct->offline_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tschedule();\n\t\t\tfinish_wait(&dsct->offline_waitq, &wait);\n\n\t\t\tcgroup_put(dsct);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_save_control - save control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Save ->subtree_control, ->subtree_ss_mask and ->dom_cgrp to the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_save_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->old_subtree_control = dsct->subtree_control;\n\t\tdsct->old_subtree_ss_mask = dsct->subtree_ss_mask;\n\t\tdsct->old_dom_cgrp = dsct->dom_cgrp;\n\t}\n}\n\n/**\n * cgroup_propagate_control - refresh control masks of a subtree\n * @cgrp: root of the target subtree\n *\n * For @cgrp and its subtree, ensure ->subtree_ss_mask matches\n * ->subtree_control and propagate controller availability through the\n * subtree so that descendants don't have unavailable controllers enabled.\n */\nstatic void cgroup_propagate_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control &= cgroup_control(dsct);\n\t\tdsct->subtree_ss_mask =\n\t\t\tcgroup_calc_subtree_ss_mask(dsct->subtree_control,\n\t\t\t\t\t\t    cgroup_ss_mask(dsct));\n\t}\n}\n\n/**\n * cgroup_restore_control - restore control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Restore ->subtree_control, ->subtree_ss_mask and ->dom_cgrp from the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_restore_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control = dsct->old_subtree_control;\n\t\tdsct->subtree_ss_mask = dsct->old_subtree_ss_mask;\n\t\tdsct->dom_cgrp = dsct->old_dom_cgrp;\n\t}\n}\n\nstatic bool css_visible(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tif (cgroup_control(cgrp) & (1 << ss->id))\n\t\treturn true;\n\tif (!(cgroup_ss_mask(cgrp) & (1 << ss->id)))\n\t\treturn false;\n\treturn cgroup_on_dfl(cgrp) && ss->implicit_on_dfl;\n}\n\n/**\n * cgroup_apply_control_enable - enable or show csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and create new csses or make the existing ones\n * visible.  A css is created invisible if it's being implicitly enabled\n * through dependency.  An invisible css is made visible when the userland\n * explicitly enables it.\n *\n * Returns 0 on success, -errno on failure.  On failure, csses which have\n * been processed already aren't cleaned up.  The caller is responsible for\n * cleaning up with cgroup_apply_control_disable().\n */\nstatic int cgroup_apply_control_enable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid, ret;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tWARN_ON_ONCE(css && percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (!(cgroup_ss_mask(dsct) & (1 << ss->id)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!css) {\n\t\t\t\tcss = css_create(dsct, ss);\n\t\t\t\tif (IS_ERR(css))\n\t\t\t\t\treturn PTR_ERR(css);\n\t\t\t}\n\n\t\t\tif (css_visible(css)) {\n\t\t\t\tret = css_populate_dir(css);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_apply_control_disable - kill or hide csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and kill and hide csses so that they match\n * cgroup_ss_mask() and cgroup_visible_mask().\n *\n * A css is hidden when the userland requests it to be disabled while other\n * subsystems are still depending on it.  The css must not actively control\n * resources and be in the vanilla state if it's made visible again later.\n * Controllers which may be depended upon should provide ->css_reset() for\n * this purpose.\n */\nstatic void cgroup_apply_control_disable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tWARN_ON_ONCE(css && percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tif (css->parent &&\n\t\t\t    !(cgroup_ss_mask(dsct) & (1 << ss->id))) {\n\t\t\t\tkill_css(css);\n\t\t\t} else if (!css_visible(css)) {\n\t\t\t\tcss_clear_dir(css);\n\t\t\t\tif (ss->css_reset)\n\t\t\t\t\tss->css_reset(css);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * cgroup_apply_control - apply control mask updates to the subtree\n * @cgrp: root of the target subtree\n *\n * subsystems can be enabled and disabled in a subtree using the following\n * steps.\n *\n * 1. Call cgroup_save_control() to stash the current state.\n * 2. Update ->subtree_control masks in the subtree as desired.\n * 3. Call cgroup_apply_control() to apply the changes.\n * 4. Optionally perform other related operations.\n * 5. Call cgroup_finalize_control() to finish up.\n *\n * This function implements step 3 and propagates the mask changes\n * throughout @cgrp's subtree, updates csses accordingly and perform\n * process migrations.\n */\nstatic int cgroup_apply_control(struct cgroup *cgrp)\n{\n\tint ret;\n\n\tcgroup_propagate_control(cgrp);\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * At this point, cgroup_e_css() results reflect the new csses\n\t * making the following cgroup_update_dfl_csses() properly update\n\t * css associations of all tasks in the subtree.\n\t */\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * cgroup_finalize_control - finalize control mask update\n * @cgrp: root of the target subtree\n * @ret: the result of the update\n *\n * Finalize control mask update.  See cgroup_apply_control() for more info.\n */\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret)\n{\n\tif (ret) {\n\t\tcgroup_restore_control(cgrp);\n\t\tcgroup_propagate_control(cgrp);\n\t}\n\n\tcgroup_apply_control_disable(cgrp);\n}\n\nstatic int cgroup_vet_subtree_control_enable(struct cgroup *cgrp, u16 enable)\n{\n\tu16 domain_enable = enable & ~cgrp_dfl_threaded_ss_mask;\n\n\t/* if nothing is getting enabled, nothing to worry about */\n\tif (!enable)\n\t\treturn 0;\n\n\t/* can @cgrp host any resources? */\n\tif (!cgroup_is_valid_domain(cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn 0;\n\n\tif (domain_enable) {\n\t\t/* can't enable domain controllers inside a thread subtree */\n\t\tif (cgroup_is_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\t/*\n\t\t * Threaded controllers can handle internal competitions\n\t\t * and are always allowed inside a (prospective) thread\n\t\t * subtree.\n\t\t */\n\t\tif (cgroup_can_be_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Controllers can't be enabled for a cgroup with tasks to avoid\n\t * child cgroups competing against tasks.\n\t */\n\tif (cgroup_has_tasks(cgrp))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/* change the enabled child controllers for a cgroup in the default hierarchy */\nstatic ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tu16 enable = 0, disable = 0;\n\tstruct cgroup *cgrp, *child;\n\tstruct cgroup_subsys *ss;\n\tchar *tok;\n\tint ssid, ret;\n\n\t/*\n\t * Parse input - space separated list of subsystem names prefixed\n\t * with either + or -.\n\t */\n\tbuf = strstrip(buf);\n\twhile ((tok = strsep(&buf, \" \"))) {\n\t\tif (tok[0] == '\\0')\n\t\t\tcontinue;\n\t\tdo_each_subsys_mask(ss, ssid, ~cgrp_dfl_inhibit_ss_mask) {\n\t\t\tif (!cgroup_ssid_enabled(ssid) ||\n\t\t\t    strcmp(tok + 1, ss->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (*tok == '+') {\n\t\t\t\tenable |= 1 << ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while_each_subsys_mask();\n\t\tif (ssid == CGROUP_SUBSYS_COUNT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (enable & (1 << ssid)) {\n\t\t\tif (cgrp->subtree_control & (1 << ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(cgroup_control(cgrp) & (1 << ssid))) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->subtree_control & (1 << ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* a child has it enabled? */\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->subtree_control & (1 << ssid)) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tret = cgroup_vet_subtree_control_enable(cgrp, enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* save and update control masks and prepare csses */\n\tcgroup_save_control(cgrp);\n\n\tcgrp->subtree_control |= enable;\n\tcgrp->subtree_control &= ~disable;\n\n\tret = cgroup_apply_control(cgrp);\n\tcgroup_finalize_control(cgrp, ret);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tkernfs_activate(cgrp->kn);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\n/**\n * cgroup_enable_threaded - make @cgrp threaded\n * @cgrp: the target cgroup\n *\n * Called when \"threaded\" is written to the cgroup.type interface file and\n * tries to make @cgrp threaded and join the parent's resource domain.\n * This function is never called on the root cgroup as cgroup.type doesn't\n * exist on it.\n */\nstatic int cgroup_enable_threaded(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup *dom_cgrp = parent->dom_cgrp;\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* noop if already threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @cgroup is populated or has domain controllers enabled, it\n\t * can't be switched.  While the below cgroup_can_be_thread_root()\n\t * test can catch the same conditions, that's only when @parent is\n\t * not mixable, so let's check it explicitly.\n\t */\n\tif (cgroup_is_populated(cgrp) ||\n\t    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn -EOPNOTSUPP;\n\n\t/* we're joining the parent's domain, ensure its validity */\n\tif (!cgroup_is_valid_domain(dom_cgrp) ||\n\t    !cgroup_can_be_thread_root(dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * The following shouldn't cause actual migrations and should\n\t * always succeed.\n\t */\n\tcgroup_save_control(cgrp);\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\n\t\tif (dsct == cgrp || cgroup_is_threaded(dsct))\n\t\t\tdsct->dom_cgrp = dom_cgrp;\n\n\tret = cgroup_apply_control(cgrp);\n\tif (!ret)\n\t\tparent->nr_threaded_children++;\n\n\tcgroup_finalize_control(cgrp, ret);\n\treturn ret;\n}\n\nstatic int cgroup_type_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tif (cgroup_is_threaded(cgrp))\n\t\tseq_puts(seq, \"threaded\\n\");\n\telse if (!cgroup_is_valid_domain(cgrp))\n\t\tseq_puts(seq, \"domain invalid\\n\");\n\telse if (cgroup_is_thread_root(cgrp))\n\t\tseq_puts(seq, \"domain threaded\\n\");\n\telse\n\t\tseq_puts(seq, \"domain\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* only switching to threaded mode is supported */\n\tif (strcmp(strstrip(buf), \"threaded\"))\n\t\treturn -EINVAL;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/* threaded can only be enabled */\n\tret = cgroup_enable_threaded(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_max_descendants_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint descendants = READ_ONCE(cgrp->max_descendants);\n\n\tif (descendants == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", descendants);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,\n\t\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint descendants;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdescendants = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &descendants);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (descendants < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_descendants = descendants;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_max_depth_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint depth = READ_ONCE(cgrp->max_depth);\n\n\tif (depth == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", depth);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint depth;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdepth = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &depth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (depth < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_depth = depth;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_events_show(struct seq_file *seq, void *v)\n{\n\tseq_printf(seq, \"populated %d\\n\",\n\t\t   cgroup_is_populated(seq_css(seq)->cgroup));\n\treturn 0;\n}\n\nstatic int cgroup_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgroup = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"nr_descendants %d\\n\",\n\t\t   cgroup->nr_descendants);\n\tseq_printf(seq, \"nr_dying_descendants %d\\n\",\n\t\t   cgroup->nr_dying_descendants);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cgroup_extra_stat_show(struct seq_file *seq,\n\t\t\t\t\t\t struct cgroup *cgrp, int ssid)\n{\n\tstruct cgroup_subsys *ss = cgroup_subsys[ssid];\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!ss->css_extra_stat_show)\n\t\treturn 0;\n\n\tcss = cgroup_tryget_css(cgrp, ss);\n\tif (!css)\n\t\treturn 0;\n\n\tret = ss->css_extra_stat_show(seq, css);\n\tcss_put(css);\n\treturn ret;\n}\n\nstatic int cpu_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup __maybe_unused *cgrp = seq_css(seq)->cgroup;\n\tint ret = 0;\n\n\tcgroup_base_stat_cputime_show(seq);\n#ifdef CONFIG_CGROUP_SCHED\n\tret = cgroup_extra_stat_show(seq, cgrp, cpu_cgrp_id);\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_PSI\nstatic int cgroup_io_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_IO);\n}\nstatic int cgroup_memory_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_MEM);\n}\nstatic int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)\n{\n\treturn psi_show(seq, &seq_css(seq)->cgroup->psi, PSI_CPU);\n}\n#endif\n\nstatic int cgroup_file_open(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->open)\n\t\treturn cft->open(of);\n\treturn 0;\n}\n\nstatic void cgroup_file_release(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->release)\n\t\tcft->release(of);\n}\n\nstatic ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of->kn->priv;\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, disallow writes to\n\t * files in an non-init namespace root from inside the namespace\n\t * except for the files explicitly marked delegatable -\n\t * cgroup.procs and cgroup.subtree_control.\n\t */\n\tif ((cgrp->root->flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    !(cft->flags & CFTYPE_NS_DELEGATABLE) &&\n\t    ns != &init_cgroup_ns && ns->root_cset->dfl_cgrp == cgrp)\n\t\treturn -EPERM;\n\n\tif (cft->write)\n\t\treturn cft->write(of, buf, nbytes, off);\n\n\t/*\n\t * kernfs guarantees that a file isn't deleted with operations in\n\t * flight, which means that the matching css is and stays alive and\n\t * doesn't need to be pinned.  The RCU locking is not necessary\n\t * either.  It's just for the convenience of using cgroup_css().\n\t */\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, cft->ss);\n\trcu_read_unlock();\n\n\tif (cft->write_u64) {\n\t\tunsigned long long v;\n\t\tret = kstrtoull(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_u64(css, cft, v);\n\t} else if (cft->write_s64) {\n\t\tlong long v;\n\t\tret = kstrtoll(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_s64(css, cft, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ?: nbytes;\n}\n\nstatic void *cgroup_seqfile_start(struct seq_file *seq, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_start(seq, ppos);\n}\n\nstatic void *cgroup_seqfile_next(struct seq_file *seq, void *v, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_next(seq, v, ppos);\n}\n\nstatic void cgroup_seqfile_stop(struct seq_file *seq, void *v)\n{\n\tif (seq_cft(seq)->seq_stop)\n\t\tseq_cft(seq)->seq_stop(seq, v);\n}\n\nstatic int cgroup_seqfile_show(struct seq_file *m, void *arg)\n{\n\tstruct cftype *cft = seq_cft(m);\n\tstruct cgroup_subsys_state *css = seq_css(m);\n\n\tif (cft->seq_show)\n\t\treturn cft->seq_show(m, arg);\n\n\tif (cft->read_u64)\n\t\tseq_printf(m, \"%llu\\n\", cft->read_u64(css, cft));\n\telse if (cft->read_s64)\n\t\tseq_printf(m, \"%lld\\n\", cft->read_s64(css, cft));\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct kernfs_ops cgroup_kf_single_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\nstatic struct kernfs_ops cgroup_kf_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.seq_start\t\t= cgroup_seqfile_start,\n\t.seq_next\t\t= cgroup_seqfile_next,\n\t.seq_stop\t\t= cgroup_seqfile_stop,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\n/* set uid and gid of cgroup dirs and files to that of the creator */\nstatic int cgroup_kn_set_ugid(struct kernfs_node *kn)\n{\n\tstruct iattr iattr = { .ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t       .ia_uid = current_fsuid(),\n\t\t\t       .ia_gid = current_fsgid(), };\n\n\tif (uid_eq(iattr.ia_uid, GLOBAL_ROOT_UID) &&\n\t    gid_eq(iattr.ia_gid, GLOBAL_ROOT_GID))\n\t\treturn 0;\n\n\treturn kernfs_setattr(kn, &iattr);\n}\n\nstatic void cgroup_file_notify_timer(struct timer_list *timer)\n{\n\tcgroup_file_notify(container_of(timer, struct cgroup_file,\n\t\t\t\t\tnotify_timer));\n}\n\nstatic int cgroup_add_file(struct cgroup_subsys_state *css, struct cgroup *cgrp,\n\t\t\t   struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\tstruct kernfs_node *kn;\n\tstruct lock_class_key *key = NULL;\n\tint ret;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tkey = &cft->lockdep_key;\n#endif\n\tkn = __kernfs_create_file(cgrp->kn, cgroup_file_name(cgrp, cft, name),\n\t\t\t\t  cgroup_file_mode(cft),\n\t\t\t\t  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\t  0, cft->kf_ops, cft,\n\t\t\t\t  NULL, key);\n\tif (IS_ERR(kn))\n\t\treturn PTR_ERR(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret) {\n\t\tkernfs_remove(kn);\n\t\treturn ret;\n\t}\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\ttimer_setup(&cfile->notify_timer, cgroup_file_notify_timer, 0);\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = kn;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_addrm_files - add or remove files to a cgroup directory\n * @css: the target css\n * @cgrp: the target cgroup (usually css->cgroup)\n * @cfts: array of cftypes to be added\n * @is_add: whether to add or remove\n *\n * Depending on @is_add, add or remove files defined by @cfts on @cgrp.\n * For removals, this function never fails.\n */\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add)\n{\n\tstruct cftype *cft, *cft_end = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\nrestart:\n\tfor (cft = cfts; cft != cft_end && cft->name[0] != '\\0'; cft++) {\n\t\t/* does cft->flags tell us to skip this file on @cgrp? */\n\t\tif ((cft->flags & __CFTYPE_ONLY_ON_DFL) && !cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_NOT_ON_DFL) && cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_NOT_ON_ROOT) && !cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_ONLY_ON_ROOT) && cgroup_parent(cgrp))\n\t\t\tcontinue;\n\n\t\tif (is_add) {\n\t\t\tret = cgroup_add_file(css, cgrp, cft);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s: failed to add %s, err=%d\\n\",\n\t\t\t\t\t__func__, cft->name, ret);\n\t\t\t\tcft_end = cft;\n\t\t\t\tis_add = false;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t} else {\n\t\t\tcgroup_rm_file(cgrp, cft);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cgroup_apply_cftypes(struct cftype *cfts, bool is_add)\n{\n\tstruct cgroup_subsys *ss = cfts[0].ss;\n\tstruct cgroup *root = &ss->root->cgrp;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* add/rm files for all cgroups created before */\n\tcss_for_each_descendant_pre(css, cgroup_css(root, ss)) {\n\t\tstruct cgroup *cgrp = css->cgroup;\n\n\t\tif (!(css->flags & CSS_VISIBLE))\n\t\t\tcontinue;\n\n\t\tret = cgroup_addrm_files(css, cgrp, cfts, is_add);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_add && !ret)\n\t\tkernfs_activate(root->kn);\n\treturn ret;\n}\n\nstatic void cgroup_exit_cftypes(struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\t/* free copy for custom atomic_write_len, see init_cftypes() */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE)\n\t\t\tkfree(cft->kf_ops);\n\t\tcft->kf_ops = NULL;\n\t\tcft->ss = NULL;\n\n\t\t/* revert flags set by cgroup core while adding @cfts */\n\t\tcft->flags &= ~(__CFTYPE_ONLY_ON_DFL | __CFTYPE_NOT_ON_DFL);\n\t}\n}\n\nstatic int cgroup_init_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\tstruct kernfs_ops *kf_ops;\n\n\t\tWARN_ON(cft->ss || cft->kf_ops);\n\n\t\tif (cft->seq_start)\n\t\t\tkf_ops = &cgroup_kf_ops;\n\t\telse\n\t\t\tkf_ops = &cgroup_kf_single_ops;\n\n\t\t/*\n\t\t * Ugh... if @cft wants a custom max_write_len, we need to\n\t\t * make a copy of kf_ops to set its atomic_write_len.\n\t\t */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE) {\n\t\t\tkf_ops = kmemdup(kf_ops, sizeof(*kf_ops), GFP_KERNEL);\n\t\t\tif (!kf_ops) {\n\t\t\t\tcgroup_exit_cftypes(cfts);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tkf_ops->atomic_write_len = cft->max_write_len;\n\t\t}\n\n\t\tcft->kf_ops = kf_ops;\n\t\tcft->ss = ss;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_rm_cftypes_locked(struct cftype *cfts)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!cfts || !cfts[0].ss)\n\t\treturn -ENOENT;\n\n\tlist_del(&cfts->node);\n\tcgroup_apply_cftypes(cfts, false);\n\tcgroup_exit_cftypes(cfts);\n\treturn 0;\n}\n\n/**\n * cgroup_rm_cftypes - remove an array of cftypes from a subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Unregister @cfts.  Files described by @cfts are removed from all\n * existing cgroups and all future cgroups won't have them either.  This\n * function can be called anytime whether @cfts' subsys is attached or not.\n *\n * Returns 0 on successful unregistration, -ENOENT if @cfts is not\n * registered.\n */\nint cgroup_rm_cftypes(struct cftype *cfts)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = cgroup_rm_cftypes_locked(cfts);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_cftypes - add an array of cftypes to a subsystem\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Register @cfts to @ss.  Files described by @cfts are created for all\n * existing cgroups to which @ss is attached and all future cgroups will\n * have them too.  This function can be called anytime whether @ss is\n * attached or not.\n *\n * Returns 0 on successful registration, -errno on failure.  Note that this\n * function currently returns 0 as long as @cfts registration is successful\n * even if some file creation attempts on existing cgroups fail.\n */\nstatic int cgroup_add_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tint ret;\n\n\tif (!cgroup_ssid_enabled(ss->id))\n\t\treturn 0;\n\n\tif (!cfts || cfts[0].name[0] == '\\0')\n\t\treturn 0;\n\n\tret = cgroup_init_cftypes(ss, cfts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_add_tail(&cfts->node, &ss->cfts);\n\tret = cgroup_apply_cftypes(cfts, true);\n\tif (ret)\n\t\tcgroup_rm_cftypes_locked(cfts);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_dfl_cftypes - add an array of cftypes for default hierarchy\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the default hierarchy.\n */\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_ONLY_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the legacy hierarchies.\n */\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_NOT_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_file_notify - generate a file modified event for a cgroup_file\n * @cfile: target cgroup_file\n *\n * @cfile must have been obtained by setting cftype->file_offset.\n */\nvoid cgroup_file_notify(struct cgroup_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_file_kn_lock, flags);\n\tif (cfile->kn) {\n\t\tunsigned long last = cfile->notified_at;\n\t\tunsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;\n\n\t\tif (time_in_range(jiffies, last, next)) {\n\t\t\ttimer_reduce(&cfile->notify_timer, next);\n\t\t} else {\n\t\t\tkernfs_notify(cfile->kn);\n\t\t\tcfile->notified_at = jiffies;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cgroup_file_kn_lock, flags);\n}\n\n/**\n * css_next_child - find the next child of a given css\n * @pos: the current position (%NULL to initiate traversal)\n * @parent: css whose children to walk\n *\n * This function returns the next child of @parent and should be called\n * under either cgroup_mutex or RCU read lock.  The only requirement is\n * that @parent and @pos are accessible.  The next sibling is guaranteed to\n * be returned regardless of their states.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/*\n\t * @pos could already have been unlinked from the sibling list.\n\t * Once a cgroup is removed, its ->sibling.next is no longer\n\t * updated when its next sibling changes.  CSS_RELEASED is set when\n\t * @pos is taken off list, at which time its next pointer is valid,\n\t * and, as releases are serialized, the one pointed to by the next\n\t * pointer is guaranteed to not have started release yet.  This\n\t * implies that if we observe !CSS_RELEASED on @pos in this RCU\n\t * critical section, the one pointed to by its next pointer is\n\t * guaranteed to not have finished its RCU grace period even if we\n\t * have dropped rcu_read_lock() inbetween iterations.\n\t *\n\t * If @pos has CSS_RELEASED set, its next pointer can't be\n\t * dereferenced; however, as each css is given a monotonically\n\t * increasing unique serial number and always appended to the\n\t * sibling list, the next one can be found by walking the parent's\n\t * children until the first css with higher serial number than\n\t * @pos's.  While this path can be slower, it happens iff iteration\n\t * races against release and the race window is very small.\n\t */\n\tif (!pos) {\n\t\tnext = list_entry_rcu(parent->children.next, struct cgroup_subsys_state, sibling);\n\t} else if (likely(!(pos->flags & CSS_RELEASED))) {\n\t\tnext = list_entry_rcu(pos->sibling.next, struct cgroup_subsys_state, sibling);\n\t} else {\n\t\tlist_for_each_entry_rcu(next, &parent->children, sibling)\n\t\t\tif (next->serial_nr > pos->serial_nr)\n\t\t\t\tbreak;\n\t}\n\n\t/*\n\t * @next, if not pointing to the head, can be dereferenced and is\n\t * the next sibling.\n\t */\n\tif (&next->sibling != &parent->children)\n\t\treturn next;\n\treturn NULL;\n}\n\n/**\n * css_next_descendant_pre - find the next descendant for pre-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_pre().  Find the next descendant\n * to visit for pre-order traversal of @root's descendants.  @root is\n * included in the iteration and the first node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @root are accessible and @pos is a descendant of @root.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\tstruct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit @root */\n\tif (!pos)\n\t\treturn root;\n\n\t/* visit the first child if exists */\n\tnext = css_next_child(NULL, pos);\n\tif (next)\n\t\treturn next;\n\n\t/* no child, visit my or the closest ancestor's next sibling */\n\twhile (pos != root) {\n\t\tnext = css_next_child(pos, pos->parent);\n\t\tif (next)\n\t\t\treturn next;\n\t\tpos = pos->parent;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * css_rightmost_descendant - return the rightmost descendant of a css\n * @pos: css of interest\n *\n * Return the rightmost descendant of @pos.  If there's no descendant, @pos\n * is returned.  This can be used during pre-order traversal to skip\n * subtree of @pos.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct rightmost descendant as\n * long as @pos is accessible.\n */\nstruct cgroup_subsys_state *\ncss_rightmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last, *tmp;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\tdo {\n\t\tlast = pos;\n\t\t/* ->prev isn't RCU safe, walk ->next till the end */\n\t\tpos = NULL;\n\t\tcss_for_each_child(tmp, last)\n\t\t\tpos = tmp;\n\t} while (pos);\n\n\treturn last;\n}\n\nstatic struct cgroup_subsys_state *\ncss_leftmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last;\n\n\tdo {\n\t\tlast = pos;\n\t\tpos = css_next_child(NULL, pos);\n\t} while (pos);\n\n\treturn last;\n}\n\n/**\n * css_next_descendant_post - find the next descendant for post-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_post().  Find the next descendant\n * to visit for post-order traversal of @root's descendants.  @root is\n * included in the iteration and the last node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @cgroup are accessible and @pos is a descendant of\n * @cgroup.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t struct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit leftmost descendant which may be @root */\n\tif (!pos)\n\t\treturn css_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\tnext = css_next_child(pos, pos->parent);\n\tif (next)\n\t\treturn css_leftmost_descendant(next);\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}\n\n/**\n * css_has_online_children - does a css have online children\n * @css: the target css\n *\n * Returns %true if @css has any online children; otherwise, %false.  This\n * function can be called from any context but the caller is responsible\n * for synchronizing against on/offlining as necessary.\n */\nbool css_has_online_children(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *child;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tcss_for_each_child(child, css) {\n\t\tif (child->flags & CSS_ONLINE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct css_set *css_task_iter_next_css_set(struct css_task_iter *it)\n{\n\tstruct list_head *l;\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* find the next threaded cset */\n\tif (it->tcset_pos) {\n\t\tl = it->tcset_pos->next;\n\n\t\tif (l != it->tcset_head) {\n\t\t\tit->tcset_pos = l;\n\t\t\treturn container_of(l, struct css_set,\n\t\t\t\t\t    threaded_csets_node);\n\t\t}\n\n\t\tit->tcset_pos = NULL;\n\t}\n\n\t/* find the next cset */\n\tl = it->cset_pos;\n\tl = l->next;\n\tif (l == it->cset_head) {\n\t\tit->cset_pos = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (it->ss) {\n\t\tcset = container_of(l, struct css_set, e_cset_node[it->ss->id]);\n\t} else {\n\t\tlink = list_entry(l, struct cgrp_cset_link, cset_link);\n\t\tcset = link->cset;\n\t}\n\n\tit->cset_pos = l;\n\n\t/* initialize threaded css_set walking */\n\tif (it->flags & CSS_TASK_ITER_THREADED) {\n\t\tif (it->cur_dcset)\n\t\t\tput_css_set_locked(it->cur_dcset);\n\t\tit->cur_dcset = cset;\n\t\tget_css_set(cset);\n\n\t\tit->tcset_head = &cset->threaded_csets;\n\t\tit->tcset_pos = &cset->threaded_csets;\n\t}\n\n\treturn cset;\n}\n\n/**\n * css_task_iter_advance_css_set - advance a task itererator to the next css_set\n * @it: the iterator to advance\n *\n * Advance @it to the next css_set to walk.\n */\nstatic void css_task_iter_advance_css_set(struct css_task_iter *it)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* Advance to the next non-empty css_set */\n\tdo {\n\t\tcset = css_task_iter_next_css_set(it);\n\t\tif (!cset) {\n\t\t\tit->task_pos = NULL;\n\t\t\treturn;\n\t\t}\n\t} while (!css_set_populated(cset));\n\n\tif (!list_empty(&cset->tasks))\n\t\tit->task_pos = cset->tasks.next;\n\telse\n\t\tit->task_pos = cset->mg_tasks.next;\n\n\tit->tasks_head = &cset->tasks;\n\tit->mg_tasks_head = &cset->mg_tasks;\n\n\t/*\n\t * We don't keep css_sets locked across iteration steps and thus\n\t * need to take steps to ensure that iteration can be resumed after\n\t * the lock is re-acquired.  Iteration is performed at two levels -\n\t * css_sets and tasks in them.\n\t *\n\t * Once created, a css_set never leaves its cgroup lists, so a\n\t * pinned css_set is guaranteed to stay put and we can resume\n\t * iteration afterwards.\n\t *\n\t * Tasks may leave @cset across iteration steps.  This is resolved\n\t * by registering each iterator with the css_set currently being\n\t * walked and making css_set_move_task() advance iterators whose\n\t * next task is leaving.\n\t */\n\tif (it->cur_cset) {\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t}\n\tget_css_set(cset);\n\tit->cur_cset = cset;\n\tlist_add(&it->iters_node, &cset->task_iters);\n}\n\nstatic void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct list_head *next;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\t/*\n\t * Advance iterator to find next entry.  cset->tasks is consumed\n\t * first and then ->mg_tasks.  After ->mg_tasks, we move onto the\n\t * next cset.\n\t */\n\tnext = it->task_pos->next;\n\n\tif (next == it->tasks_head)\n\t\tnext = it->mg_tasks_head->next;\n\n\tif (next == it->mg_tasks_head)\n\t\tcss_task_iter_advance_css_set(it);\n\telse\n\t\tit->task_pos = next;\n\n\t/* if PROCS, skip over tasks which aren't group leaders */\n\tif ((it->flags & CSS_TASK_ITER_PROCS) && it->task_pos &&\n\t    !thread_group_leader(list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t    cg_list)))\n\t\tgoto repeat;\n}\n\n/**\n * css_task_iter_start - initiate task iteration\n * @css: the css to walk tasks of\n * @flags: CSS_TASK_ITER_* flags\n * @it: the task iterator to use\n *\n * Initiate iteration through the tasks of @css.  The caller can call\n * css_task_iter_next() to walk through the tasks until the function\n * returns NULL.  On completion of iteration, css_task_iter_end() must be\n * called.\n */\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\t/* no one should try to iterate before mounting cgroups */\n\tWARN_ON_ONCE(!use_task_css_set_links);\n\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance_css_set(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}\n\n/**\n * css_task_iter_next - return the next task for the iterator\n * @it: the task iterator being iterated\n *\n * The \"next\" function for task iteration.  @it should have been\n * initialized via css_task_iter_start().  Returns NULL when the iteration\n * reaches the end.\n */\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}\n\n/**\n * css_task_iter_end - finish task iteration\n * @it: the task iterator to finish\n *\n * Finish task iteration started by css_task_iter_start().\n */\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}\n\nstatic void cgroup_procs_release(struct kernfs_open_file *of)\n{\n\tif (of->priv) {\n\t\tcss_task_iter_end(of->priv);\n\t\tkfree(of->priv);\n\t}\n}\n\nstatic void *cgroup_procs_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct css_task_iter *it = of->priv;\n\n\treturn css_task_iter_next(it);\n}\n\nstatic void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct css_task_iter *it = of->priv;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!it) {\n\t\tif (WARN_ON_ONCE((*pos)++))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tit = kzalloc(sizeof(*it), GFP_KERNEL);\n\t\tif (!it)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tof->priv = it;\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else if (!(*pos)++) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t}\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}\n\nstatic void *cgroup_procs_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\n\t/*\n\t * All processes of a threaded subtree belong to the domain cgroup\n\t * of the subtree.  Only threads can be distributed across the\n\t * subtree.  Reject reads on cgroup.procs in the subtree proper.\n\t * They're always empty anyway.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn __cgroup_procs_start(s, pos, CSS_TASK_ITER_PROCS |\n\t\t\t\t\t    CSS_TASK_ITER_THREADED);\n}\n\nstatic int cgroup_procs_show(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", task_pid_vnr(v));\n\treturn 0;\n}\n\nstatic int cgroup_procs_write_permission(struct cgroup *src_cgrp,\n\t\t\t\t\t struct cgroup *dst_cgrp,\n\t\t\t\t\t struct super_block *sb)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct cgroup *com_cgrp = src_cgrp;\n\tstruct inode *inode;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* find the common ancestor */\n\twhile (!cgroup_is_descendant(dst_cgrp, com_cgrp))\n\t\tcom_cgrp = cgroup_parent(com_cgrp);\n\n\t/* %current should be authorized to migrate to the common ancestor */\n\tinode = kernfs_get_inode(sb, com_cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(inode, MAY_WRITE);\n\tiput(inode);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, %current must be able\n\t * to see both source and destination cgroups from its namespace.\n\t */\n\tif ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||\n\t     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_procs_write(struct kernfs_open_file *of,\n\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tssize_t ret;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, true);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp,\n\t\t\t\t\t    of->file->f_path.dentry->d_sb);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, true);\n\nout_finish:\n\tcgroup_procs_write_finish(task);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic void *cgroup_threads_start(struct seq_file *s, loff_t *pos)\n{\n\treturn __cgroup_procs_start(s, pos, 0);\n}\n\nstatic ssize_t cgroup_threads_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, false);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* thread migrations follow the cgroup.procs delegation rule */\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp,\n\t\t\t\t\t    of->file->f_path.dentry->d_sb);\n\tif (ret)\n\t\tgoto out_finish;\n\n\t/* and must be contained in the same domain */\n\tret = -EOPNOTSUPP;\n\tif (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, false);\n\nout_finish:\n\tcgroup_procs_write_finish(task);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\n/* cgroup core interface files for the default hierarchy */\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t},\n#endif\n\t{ }\t/* terminate */\n};\n\n/*\n * css destruction is four-stage process.\n *\n * 1. Destruction starts.  Killing of the percpu_ref is initiated.\n *    Implemented in kill_css().\n *\n * 2. When the percpu_ref is confirmed to be visible as killed on all CPUs\n *    and thus css_tryget_online() is guaranteed to fail, the css can be\n *    offlined by invoking offline_css().  After offlining, the base ref is\n *    put.  Implemented in css_killed_work_fn().\n *\n * 3. When the percpu_ref reaches zero, the only possible remaining\n *    accessors are inside RCU read sections.  css_release() schedules the\n *    RCU callback.\n *\n * 4. After the grace period, the css can be freed.  Implemented in\n *    css_free_work_fn().\n *\n * It is actually hairier because both step 2 and 4 require process context\n * and thus involve punting to css->destroy_work adding two additional\n * steps to the already complex sequence.\n */\nstatic void css_free_rwork_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css = container_of(to_rcu_work(work),\n\t\t\t\tstruct cgroup_subsys_state, destroy_rwork);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tpercpu_ref_exit(&css->refcnt);\n\n\tif (ss) {\n\t\t/* css free path */\n\t\tstruct cgroup_subsys_state *parent = css->parent;\n\t\tint id = css->id;\n\n\t\tss->css_free(css);\n\t\tcgroup_idr_remove(&ss->css_idr, id);\n\t\tcgroup_put(cgrp);\n\n\t\tif (parent)\n\t\t\tcss_put(parent);\n\t} else {\n\t\t/* cgroup free path */\n\t\tatomic_dec(&cgrp->root->nr_cgrps);\n\t\tcgroup1_pidlist_destroy_all(cgrp);\n\t\tcancel_work_sync(&cgrp->release_agent_work);\n\n\t\tif (cgroup_parent(cgrp)) {\n\t\t\t/*\n\t\t\t * We get a ref to the parent, and put the ref when\n\t\t\t * this cgroup is being freed, so it's guaranteed\n\t\t\t * that the parent won't be destroyed before its\n\t\t\t * children.\n\t\t\t */\n\t\t\tcgroup_put(cgroup_parent(cgrp));\n\t\t\tkernfs_put(cgrp->kn);\n\t\t\tpsi_cgroup_free(cgrp);\n\t\t\tif (cgroup_on_dfl(cgrp))\n\t\t\t\tcgroup_rstat_exit(cgrp);\n\t\t\tkfree(cgrp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is root cgroup's refcnt reaching zero,\n\t\t\t * which indicates that the root should be\n\t\t\t * released.\n\t\t\t */\n\t\t\tcgroup_destroy_root(cgrp->root);\n\t\t}\n\t}\n}\n\nstatic void css_release_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tcss->flags |= CSS_RELEASED;\n\tlist_del_rcu(&css->sibling);\n\n\tif (ss) {\n\t\t/* css release path */\n\t\tif (!list_empty(&css->rstat_css_node)) {\n\t\t\tcgroup_rstat_flush(cgrp);\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t}\n\n\t\tcgroup_idr_replace(&ss->css_idr, NULL, css->id);\n\t\tif (ss->css_released)\n\t\t\tss->css_released(css);\n\t} else {\n\t\tstruct cgroup *tcgrp;\n\n\t\t/* cgroup release path */\n\t\tTRACE_CGROUP_PATH(release, cgrp);\n\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcgroup_rstat_flush(cgrp);\n\n\t\tfor (tcgrp = cgroup_parent(cgrp); tcgrp;\n\t\t     tcgrp = cgroup_parent(tcgrp))\n\t\t\ttcgrp->nr_dying_descendants--;\n\n\t\tcgroup_idr_remove(&cgrp->root->cgroup_idr, cgrp->id);\n\t\tcgrp->id = -1;\n\n\t\t/*\n\t\t * There are two control paths which try to determine\n\t\t * cgroup from dentry without going through kernfs -\n\t\t * cgroupstats_build() and css_tryget_online_from_dir().\n\t\t * Those are supported by RCU protecting clearing of\n\t\t * cgrp->kn->priv backpointer.\n\t\t */\n\t\tif (cgrp->kn)\n\t\t\tRCU_INIT_POINTER(*(void __rcu __force **)&cgrp->kn->priv,\n\t\t\t\t\t NULL);\n\n\t\tcgroup_bpf_put(cgrp);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n}\n\nstatic void css_release(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tINIT_WORK(&css->destroy_work, css_release_work_fn);\n\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n}\n\nstatic void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (cgroup_on_dfl(cgrp) && ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}\n\n/* invoke ->css_online() on a new CSS and mark it online if successful */\nstatic int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}\n\n/* if the CSS is online, invoke ->css_offline() on it and mark it offline */\nstatic void offline_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!(css->flags & CSS_ONLINE))\n\t\treturn;\n\n\tif (ss->css_offline)\n\t\tss->css_offline(css);\n\n\tcss->flags &= ~CSS_ONLINE;\n\tRCU_INIT_POINTER(css->cgroup->subsys[ss->id], NULL);\n\n\twake_up_all(&css->cgroup->offline_waitq);\n}\n\n/**\n * css_create - create a cgroup_subsys_state\n * @cgrp: the cgroup new css will be associated with\n * @ss: the subsys of new css\n *\n * Create a new css associated with @cgrp - @ss pair.  On success, the new\n * css is online and installed in @cgrp.  This function doesn't create the\n * interface files.  Returns 0 on success, -errno on failure.\n */\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *parent_css = cgroup_css(parent, ss);\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcss = ss->css_alloc(parent_css);\n\tif (!css)\n\t\tcss = ERR_PTR(-ENOMEM);\n\tif (IS_ERR(css))\n\t\treturn css;\n\n\tinit_and_link_css(css, ss, cgrp);\n\n\terr = percpu_ref_init(&css->refcnt, css_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_css;\n\n\terr = cgroup_idr_alloc(&ss->css_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_free_css;\n\tcss->id = err;\n\n\t/* @css is ready to be brought online now, make it visible */\n\tlist_add_tail_rcu(&css->sibling, &parent_css->children);\n\tcgroup_idr_replace(&ss->css_idr, css, css->id);\n\n\terr = online_css(css);\n\tif (err)\n\t\tgoto err_list_del;\n\n\tif (ss->broken_hierarchy && !ss->warned_broken_hierarchy &&\n\t    cgroup_parent(parent)) {\n\t\tpr_warn(\"%s (%d) created nested cgroup for controller \\\"%s\\\" which has incomplete hierarchy support. Nested cgroups may change behavior in the future.\\n\",\n\t\t\tcurrent->comm, current->pid, ss->name);\n\t\tif (!strcmp(ss->name, \"memory\"))\n\t\t\tpr_warn(\"\\\"memory\\\" requires setting use_hierarchy to 1 on the root\\n\");\n\t\tss->warned_broken_hierarchy = true;\n\t}\n\n\treturn css;\n\nerr_list_del:\n\tlist_del_rcu(&css->sibling);\nerr_free_css:\n\tlist_del_rcu(&css->rstat_css_node);\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n\treturn ERR_PTR(err);\n}\n\n/*\n * The returned cgroup is fully initialized including its control mask, but\n * it isn't associated with its kernfs_node and doesn't have the control\n * mask applied.\n */\nstatic struct cgroup *cgroup_create(struct cgroup *parent)\n{\n\tstruct cgroup_root *root = parent->root;\n\tstruct cgroup *cgrp, *tcgrp;\n\tint level = parent->level + 1;\n\tint ret;\n\n\t/* allocate the cgroup and its ID, 0 is reserved for the root */\n\tcgrp = kzalloc(struct_size(cgrp, ancestor_ids, (level + 1)),\n\t\t       GFP_KERNEL);\n\tif (!cgrp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_ref_init(&cgrp->self.refcnt, css_release, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_free_cgrp;\n\n\tif (cgroup_on_dfl(parent)) {\n\t\tret = cgroup_rstat_init(cgrp);\n\t\tif (ret)\n\t\t\tgoto out_cancel_ref;\n\t}\n\n\t/*\n\t * Temporarily set the pointer to NULL, so idr_find() won't return\n\t * a half-baked cgroup.\n\t */\n\tcgrp->id = cgroup_idr_alloc(&root->cgroup_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (cgrp->id < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto out_stat_exit;\n\t}\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->self.parent = &parent->self;\n\tcgrp->root = root;\n\tcgrp->level = level;\n\n\tret = psi_cgroup_alloc(cgrp);\n\tif (ret)\n\t\tgoto out_idr_free;\n\n\tret = cgroup_bpf_inherit(cgrp);\n\tif (ret)\n\t\tgoto out_psi_free;\n\n\tfor (tcgrp = cgrp; tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\tcgrp->ancestor_ids[tcgrp->level] = tcgrp->id;\n\n\t\tif (tcgrp != cgrp)\n\t\t\ttcgrp->nr_descendants++;\n\t}\n\n\tif (notify_on_release(parent))\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &parent->flags))\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &cgrp->flags);\n\n\tcgrp->self.serial_nr = css_serial_nr_next++;\n\n\t/* allocation complete, commit to creation */\n\tlist_add_tail_rcu(&cgrp->self.sibling, &cgroup_parent(cgrp)->self.children);\n\tatomic_inc(&root->nr_cgrps);\n\tcgroup_get_live(parent);\n\n\t/*\n\t * @cgrp is now fully operational.  If something fails after this\n\t * point, it'll be released via the normal destruction path.\n\t */\n\tcgroup_idr_replace(&root->cgroup_idr, cgrp, cgrp->id);\n\n\t/*\n\t * On the default hierarchy, a child doesn't automatically inherit\n\t * subtree_control from the parent.  Each is configured manually.\n\t */\n\tif (!cgroup_on_dfl(cgrp))\n\t\tcgrp->subtree_control = cgroup_control(cgrp);\n\n\tcgroup_propagate_control(cgrp);\n\n\treturn cgrp;\n\nout_psi_free:\n\tpsi_cgroup_free(cgrp);\nout_idr_free:\n\tcgroup_idr_remove(&root->cgroup_idr, cgrp->id);\nout_stat_exit:\n\tif (cgroup_on_dfl(parent))\n\t\tcgroup_rstat_exit(cgrp);\nout_cancel_ref:\n\tpercpu_ref_exit(&cgrp->self.refcnt);\nout_free_cgrp:\n\tkfree(cgrp);\n\treturn ERR_PTR(ret);\n}\n\nstatic bool cgroup_check_hierarchy_limits(struct cgroup *parent)\n{\n\tstruct cgroup *cgroup;\n\tint ret = false;\n\tint level = 1;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tfor (cgroup = parent; cgroup; cgroup = cgroup_parent(cgroup)) {\n\t\tif (cgroup->nr_descendants >= cgroup->max_descendants)\n\t\t\tgoto fail;\n\n\t\tif (level > cgroup->max_depth)\n\t\t\tgoto fail;\n\n\t\tlevel++;\n\t}\n\n\tret = true;\nfail:\n\treturn ret;\n}\n\nint cgroup_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)\n{\n\tstruct cgroup *parent, *cgrp;\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\t/* do not accept '\\n' to prevent making /proc/<pid>/cgroup unparsable */\n\tif (strchr(name, '\\n'))\n\t\treturn -EINVAL;\n\n\tparent = cgroup_kn_lock_live(parent_kn, false);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tif (!cgroup_check_hierarchy_limits(parent)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tcgrp = cgroup_create(parent);\n\tif (IS_ERR(cgrp)) {\n\t\tret = PTR_ERR(cgrp);\n\t\tgoto out_unlock;\n\t}\n\n\t/* create the directory */\n\tkn = kernfs_create_dir(parent->kn, name, mode, cgrp);\n\tif (IS_ERR(kn)) {\n\t\tret = PTR_ERR(kn);\n\t\tgoto out_destroy;\n\t}\n\tcgrp->kn = kn;\n\n\t/*\n\t * This extra ref will be put in cgroup_free_fn() and guarantees\n\t * that @cgrp->kn is always accessible.\n\t */\n\tkernfs_get(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = css_populate_dir(&cgrp->self);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tTRACE_CGROUP_PATH(mkdir, cgrp);\n\n\t/* let's create and online css's */\n\tkernfs_activate(kn);\n\n\tret = 0;\n\tgoto out_unlock;\n\nout_destroy:\n\tcgroup_destroy_locked(cgrp);\nout_unlock:\n\tcgroup_kn_unlock(parent_kn);\n\treturn ret;\n}\n\n/*\n * This is called when the refcnt of a css is confirmed to be killed.\n * css_tryget_online() is now guaranteed to fail.  Tell the subsystem to\n * initate destruction and put the css ref from kill_css().\n */\nstatic void css_killed_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tdo {\n\t\toffline_css(css);\n\t\tcss_put(css);\n\t\t/* @css can't go away while we're holding cgroup_mutex */\n\t\tcss = css->parent;\n\t} while (css && atomic_dec_and_test(&css->online_cnt));\n\n\tmutex_unlock(&cgroup_mutex);\n}"
  },
  {
    "function_name": "cgroup_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2582-2604",
    "snippet": "int cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_migrate_execute",
          "args": [
            "mgctx"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2291-2380",
          "snippet": "static int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tput_css_set_locked(from_cset);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tput_css_set_locked(from_cset);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "leader",
            "task"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_add_task",
          "args": [
            "task",
            "mgctx"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_add_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2190-2218",
          "snippet": "static void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* leave @task alone if post_fork() hasn't linked it yet */\n\tif (list_empty(&task->cg_list))\n\t\treturn;\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* leave @task alone if post_fork() hasn't linked it yet */\n\tif (list_empty(&task->cg_list))\n\t\treturn;\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nint cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}"
  },
  {
    "function_name": "cgroup_migrate_prepare_dst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2512-2562",
    "snippet": "int cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\tgoto err;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\nerr:\n\tcgroup_migrate_finish(mgctx);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_migrate_finish",
          "args": [
            "mgctx"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2426-2447",
          "snippet": "void cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "dst_cset"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "863-898",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&dst_cset->mg_preload_node",
            "&mgctx->preloaded_dst_csets"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dst_cset->mg_preload_node"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&src_cset->mg_preload_node"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "src_cset->mg_dst_cset || dst_cset->mg_dst_cset"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_css_set",
          "args": [
            "src_cset",
            "src_cset->mg_dst_cgrp"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "find_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1108-1208",
          "snippet": "static struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_root_count;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "src_cset",
            "tmp_cset",
            "&mgctx->preloaded_src_csets",
            "mg_preload_node"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\tgoto err;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\nerr:\n\tcgroup_migrate_finish(mgctx);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "cgroup_migrate_add_src",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2465-2496",
    "snippet": "void cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_advance(struct css_task_iter *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&src_cset->mg_preload_node",
            "&mgctx->preloaded_src_csets"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "src_cset"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "179-182",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&src_cset->mg_node)"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&src_cset->mg_node"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&src_cset->mg_tasks)"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "src_cset->mg_dst_cgrp"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "src_cset->mg_src_cgrp"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cset_cgroup_from_root",
          "args": [
            "src_cset",
            "dst_cgrp->root"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "cset_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1324-1351",
          "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nvoid cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}"
  },
  {
    "function_name": "cgroup_migrate_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2426-2447",
    "snippet": "void cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_css_set_locked",
          "args": [
            "cset"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "863-898",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cset->mg_preload_node"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "cset",
            "tmp_cset",
            "&preloaded",
            "mg_preload_node"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&mgctx->preloaded_dst_csets",
            "&preloaded"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&mgctx->preloaded_src_csets",
            "&preloaded"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "preloaded"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_migrate_vet_dst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2391-2417",
    "snippet": "int cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_advance(struct css_task_iter *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "dst_cgrp"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_can_be_thread_root",
          "args": [
            "dst_cgrp"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_can_be_thread_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "353-372",
          "snippet": "static bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_mixable",
          "args": [
            "dst_cgrp"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_mixable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "342-350",
          "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_valid_domain",
          "args": [
            "dst_cgrp->dom_cgrp"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_valid_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "397-412",
          "snippet": "static bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "dst_cgrp"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nint cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_migrate_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2291-2380",
    "snippet": "static int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tput_css_set_locked(from_cset);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cset->mg_node"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&cset->mg_tasks",
            "&cset->tasks"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "cset",
            "tmp_cset",
            "&tset->src_csets",
            "mg_node"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&tset->dst_csets",
            "&tset->src_csets"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->cancel_attach",
          "args": [
            "tset"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "mgctx->ss_mask"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->attach",
          "args": [
            "tset"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "mgctx->ss_mask"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set_locked",
          "args": [
            "from_cset"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "863-898",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_move_task",
          "args": [
            "task",
            "from_cset",
            "to_cset",
            "true"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_move_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "794-840",
          "snippet": "static void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tstruct css_task_iter *it, *pos;\n\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\t/*\n\t\t * @task is leaving, advance task iterators which are\n\t\t * pointing to it so that they can resume at the next\n\t\t * position.  Advancing an iterator might remove it from\n\t\t * the list, use safe walk.  See css_task_iter_advance*()\n\t\t * for details.\n\t\t */\n\t\tlist_for_each_entry_safe(it, pos, &from_cset->task_iters,\n\t\t\t\t\t iters_node)\n\t\t\tif (it->task_pos == &task->cg_list)\n\t\t\t\tcss_task_iter_advance(it);\n\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit() changing the css_set to\n\t\t * init_css_set and dropping the old one.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct percpu_rw_semaphore cgroup_threadgroup_rwsem;",
            "static void css_task_iter_advance(struct css_task_iter *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct percpu_rw_semaphore cgroup_threadgroup_rwsem;\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tstruct css_task_iter *it, *pos;\n\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\t/*\n\t\t * @task is leaving, advance task iterators which are\n\t\t * pointing to it so that they can resume at the next\n\t\t * position.  Advancing an iterator might remove it from\n\t\t * the list, use safe walk.  See css_task_iter_advance*()\n\t\t * for details.\n\t\t */\n\t\tlist_for_each_entry_safe(it, pos, &from_cset->task_iters,\n\t\t\t\t\t iters_node)\n\t\t\tif (it->task_pos == &task->cg_list)\n\t\t\t\tcss_task_iter_advance(it);\n\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit() changing the css_set to\n\t\t * init_css_set and dropping the old one.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "to_cset"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "179-182",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "task",
            "tmp_task",
            "&cset->mg_tasks",
            "cg_list"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cset",
            "&tset->src_csets",
            "mg_node"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->can_attach",
          "args": [
            "tset"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "mgctx->ss_mask"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tput_css_set_locked(from_cset);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_taskset_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2244-2280",
    "snippet": "struct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (&cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "cset",
            "mg_node"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "task",
            "cg_list"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&cset->mg_tasks",
            "structtask_struct",
            "cg_list"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (&cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgroup_taskset_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2227-2234",
    "snippet": "struct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_taskset_next",
          "args": [
            "tset",
            "dst_cssp"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_taskset_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2244-2280",
          "snippet": "struct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (&cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (&cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "tset->csets",
            "structcss_set",
            "mg_node"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}"
  },
  {
    "function_name": "cgroup_migrate_add_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2190-2218",
    "snippet": "static void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* leave @task alone if post_fork() hasn't linked it yet */\n\tif (list_empty(&task->cg_list))\n\t\treturn;\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_advance(struct css_task_iter *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cset->mg_dst_cset->mg_node",
            "&mgctx->tset.dst_csets"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->mg_dst_cset->mg_node"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cset->mg_node",
            "&mgctx->tset.src_csets"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&task->cg_list",
            "&cset->mg_tasks"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* leave @task alone if post_fork() hasn't linked it yet */\n\tif (list_empty(&task->cg_list))\n\t\treturn;\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}"
  },
  {
    "function_name": "task_cgroup_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2154-2177",
    "snippet": "int task_cgroup_path(struct task_struct *task, char *buf, size_t buflen)\n{\n\tstruct cgroup_root *root;\n\tstruct cgroup *cgrp;\n\tint hierarchy_id = 1;\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\troot = idr_get_next(&cgroup_hierarchy_idr, &hierarchy_id);\n\n\tif (root) {\n\t\tcgrp = task_cgroup_from_root(task, root);\n\t\tret = cgroup_path_ns_locked(cgrp, buf, buflen, &init_cgroup_ns);\n\t} else {\n\t\t/* if no hierarchy exists, everyone is in \"/\" */\n\t\tret = strlcpy(buf, \"/\", buflen);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(cgroup_hierarchy_idr);",
      "struct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "\"/\"",
            "buflen"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_path_ns_locked",
          "args": [
            "cgrp",
            "buf",
            "buflen",
            "&init_cgroup_ns"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_ns_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2116-2122",
          "snippet": "int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cgroup_from_root",
          "args": [
            "task",
            "root"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "task_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1357-1366",
          "snippet": "struct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold cgroup_mutex the\n\t * task can't change groups, so the only thing that can happen\n\t * is that it exits and its css is set back to init_css_set.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold cgroup_mutex the\n\t * task can't change groups, so the only thing that can happen\n\t * is that it exits and its css is set back to init_css_set.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_get_next",
          "args": [
            "&cgroup_hierarchy_idr",
            "&hierarchy_id"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\nstruct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint task_cgroup_path(struct task_struct *task, char *buf, size_t buflen)\n{\n\tstruct cgroup_root *root;\n\tstruct cgroup *cgrp;\n\tint hierarchy_id = 1;\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\troot = idr_get_next(&cgroup_hierarchy_idr, &hierarchy_id);\n\n\tif (root) {\n\t\tcgrp = task_cgroup_from_root(task, root);\n\t\tret = cgroup_path_ns_locked(cgrp, buf, buflen, &init_cgroup_ns);\n\t} else {\n\t\t/* if no hierarchy exists, everyone is in \"/\" */\n\t\tret = strlcpy(buf, \"/\", buflen);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_path_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2124-2138",
    "snippet": "int cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t   struct cgroup_namespace *ns)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tret = cgroup_path_ns_locked(cgrp, buf, buflen, ns);\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_path_ns_locked",
          "args": [
            "cgrp",
            "buf",
            "buflen",
            "ns"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_ns_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "2116-2122",
          "snippet": "int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t   struct cgroup_namespace *ns)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tret = cgroup_path_ns_locked(cgrp, buf, buflen, ns);\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_path_ns_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2116-2122",
    "snippet": "int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_path_from_node",
          "args": [
            "cgrp->kn",
            "root->kn",
            "buf",
            "buflen"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cset_cgroup_from_root",
          "args": [
            "ns->root_cset",
            "cgrp->root"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "cset_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1324-1351",
          "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}"
  },
  {
    "function_name": "cgroup_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2081-2100",
    "snippet": "static void cgroup_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_root *kf_root = kernfs_root_from_sb(sb);\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\n\t/*\n\t * If @root doesn't have any mounts or children, start killing it.\n\t * This prevents new mounts by disabling percpu_ref_tryget_live().\n\t * cgroup_mount() may wait for @root's release.\n\t *\n\t * And don't kill the default root.\n\t */\n\tif (!list_empty(&root->cgrp.self.children) ||\n\t    root == &cgrp_dfl_root)\n\t\tcgroup_put(&root->cgrp);\n\telse\n\t\tpercpu_ref_kill(&root->cgrp.self.refcnt);\n\n\tkernfs_kill_sb(sb);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_kill_sb",
          "args": [
            "sb"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&root->cgrp.self.refcnt"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "&root->cgrp"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root->cgrp.self.children"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_root_from_kf",
          "args": [
            "kf_root"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_root_from_kf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1210-1215",
          "snippet": "struct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_root_from_sb",
          "args": [
            "sb"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_root *kf_root = kernfs_root_from_sb(sb);\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\n\t/*\n\t * If @root doesn't have any mounts or children, start killing it.\n\t * This prevents new mounts by disabling percpu_ref_tryget_live().\n\t * cgroup_mount() may wait for @root's release.\n\t *\n\t * And don't kill the default root.\n\t */\n\tif (!list_empty(&root->cgrp.self.children) ||\n\t    root == &cgrp_dfl_root)\n\t\tcgroup_put(&root->cgrp);\n\telse\n\t\tpercpu_ref_kill(&root->cgrp.self.refcnt);\n\n\tkernfs_kill_sb(sb);\n}"
  },
  {
    "function_name": "cgroup_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "2033-2079",
    "snippet": "static struct dentry *cgroup_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *unused_dev_name,\n\t\t\t void *data)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tget_cgroup_ns(ns);\n\n\t/* Check if the caller has permission to mount. */\n\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN)) {\n\t\tput_cgroup_ns(ns);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\t/*\n\t * The first time anyone tries to mount a cgroup, enable the list\n\t * linking each css_set to its tasks and fix up all existing tasks.\n\t */\n\tif (!use_task_css_set_links)\n\t\tcgroup_enable_task_cg_lists();\n\n\tif (fs_type == &cgroup2_fs_type) {\n\t\tunsigned int root_flags;\n\n\t\tret = parse_cgroup_root_flags(data, &root_flags);\n\t\tif (ret) {\n\t\t\tput_cgroup_ns(ns);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tcgrp_dfl_visible = true;\n\t\tcgroup_get_live(&cgrp_dfl_root.cgrp);\n\n\t\tdentry = cgroup_do_mount(&cgroup2_fs_type, flags, &cgrp_dfl_root,\n\t\t\t\t\t CGROUP2_SUPER_MAGIC, ns);\n\t\tif (!IS_ERR(dentry))\n\t\t\tapply_cgroup_root_flags(root_flags);\n\t} else {\n\t\tdentry = cgroup1_mount(&cgroup_fs_type, flags, data,\n\t\t\t\t       CGROUP_SUPER_MAGIC, ns);\n\t}\n\n\tput_cgroup_ns(ns);\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static bool cgrp_dfl_visible;",
      "static struct file_system_type cgroup2_fs_type;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "ns"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup1_mount",
          "args": [
            "&cgroup_fs_type",
            "flags",
            "data",
            "CGROUP_SUPER_MAGIC",
            "ns"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "1108-1268",
          "snippet": "struct dentry *cgroup1_mount(struct file_system_type *fs_type, int flags,\n\t\t\t     void *data, unsigned long magic,\n\t\t\t     struct cgroup_namespace *ns)\n{\n\tstruct super_block *pinned_sb = NULL;\n\tstruct cgroup_sb_opts opts;\n\tstruct cgroup_root *root;\n\tstruct cgroup_subsys *ss;\n\tstruct dentry *dentry;\n\tint i, ret;\n\tbool new_root = false;\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\t/* First find the desired set of subsystems */\n\tret = parse_cgroupfs_options(data, &opts);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Destruction of cgroup root is asynchronous, so subsystems may\n\t * still be dying after the previous unmount.  Let's drain the\n\t * dying subsystems.  We just need to ensure that the ones\n\t * unmounted previously finish dying and don't care about new ones\n\t * starting.  Testing ref liveliness is good enough.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (!(opts.subsys_mask & (1 << i)) ||\n\t\t    ss->root == &cgrp_dfl_root)\n\t\t\tcontinue;\n\n\t\tif (!percpu_ref_tryget_live(&ss->root->cgrp.self.refcnt)) {\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tmsleep(10);\n\t\t\tret = restart_syscall();\n\t\t\tgoto out_free;\n\t\t}\n\t\tcgroup_put(&ss->root->cgrp);\n\t}\n\n\tfor_each_root(root) {\n\t\tbool name_match = false;\n\n\t\tif (root == &cgrp_dfl_root)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we asked for a name then it must match.  Also, if\n\t\t * name matches but sybsys_mask doesn't, we should fail.\n\t\t * Remember whether name matched.\n\t\t */\n\t\tif (opts.name) {\n\t\t\tif (strcmp(opts.name, root->name))\n\t\t\t\tcontinue;\n\t\t\tname_match = true;\n\t\t}\n\n\t\t/*\n\t\t * If we asked for subsystems (or explicitly for no\n\t\t * subsystems) then they must match.\n\t\t */\n\t\tif ((opts.subsys_mask || opts.none) &&\n\t\t    (opts.subsys_mask != root->subsys_mask)) {\n\t\t\tif (!name_match)\n\t\t\t\tcontinue;\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (root->flags ^ opts.flags)\n\t\t\tpr_warn(\"new mount options do not match the existing superblock, will be ignored\\n\");\n\n\t\t/*\n\t\t * We want to reuse @root whose lifetime is governed by its\n\t\t * ->cgrp.  Let's check whether @root is alive and keep it\n\t\t * that way.  As cgroup_kill_sb() can happen anytime, we\n\t\t * want to block it by pinning the sb so that @root doesn't\n\t\t * get killed before mount is complete.\n\t\t *\n\t\t * With the sb pinned, tryget_live can reliably indicate\n\t\t * whether @root can be reused.  If it's being killed,\n\t\t * drain it.  We can use wait_queue for the wait but this\n\t\t * path is super cold.  Let's just sleep a bit and retry.\n\t\t */\n\t\tpinned_sb = kernfs_pin_sb(root->kf_root, NULL);\n\t\tif (IS_ERR(pinned_sb) ||\n\t\t    !percpu_ref_tryget_live(&root->cgrp.self.refcnt)) {\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tif (!IS_ERR_OR_NULL(pinned_sb))\n\t\t\t\tdeactivate_super(pinned_sb);\n\t\t\tmsleep(10);\n\t\t\tret = restart_syscall();\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * No such thing, create a new one.  name= matching without subsys\n\t * specification is allowed for already existing hierarchies but we\n\t * can't create new one without subsys specification.\n\t */\n\tif (!opts.subsys_mask && !opts.none) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Hierarchies may only be created in the initial cgroup namespace. */\n\tif (ns != &init_cgroup_ns) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tnew_root = true;\n\n\tinit_cgroup_root(root, &opts);\n\n\tret = cgroup_setup_root(root, opts.subsys_mask, PERCPU_REF_INIT_DEAD);\n\tif (ret)\n\t\tcgroup_free_root(root);\n\nout_unlock:\n\tmutex_unlock(&cgroup_mutex);\nout_free:\n\tkfree(opts.release_agent);\n\tkfree(opts.name);\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdentry = cgroup_do_mount(&cgroup_fs_type, flags, root,\n\t\t\t\t CGROUP_SUPER_MAGIC, ns);\n\n\t/*\n\t * There's a race window after we release cgroup_mutex and before\n\t * allocating a superblock. Make sure a concurrent process won't\n\t * be able to re-use the root during this window by delaying the\n\t * initialization of root refcnt.\n\t */\n\tif (new_root) {\n\t\tmutex_lock(&cgroup_mutex);\n\t\tpercpu_ref_reinit(&root->cgrp.self.refcnt);\n\t\tmutex_unlock(&cgroup_mutex);\n\t}\n\n\t/*\n\t * If @pinned_sb, we're reusing an existing root and holding an\n\t * extra ref on its sb.  Mount is complete.  Put the extra ref.\n\t */\n\tif (pinned_sb)\n\t\tdeactivate_super(pinned_sb);\n\n\treturn dentry;\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nstruct dentry *cgroup1_mount(struct file_system_type *fs_type, int flags,\n\t\t\t     void *data, unsigned long magic,\n\t\t\t     struct cgroup_namespace *ns)\n{\n\tstruct super_block *pinned_sb = NULL;\n\tstruct cgroup_sb_opts opts;\n\tstruct cgroup_root *root;\n\tstruct cgroup_subsys *ss;\n\tstruct dentry *dentry;\n\tint i, ret;\n\tbool new_root = false;\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\t/* First find the desired set of subsystems */\n\tret = parse_cgroupfs_options(data, &opts);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Destruction of cgroup root is asynchronous, so subsystems may\n\t * still be dying after the previous unmount.  Let's drain the\n\t * dying subsystems.  We just need to ensure that the ones\n\t * unmounted previously finish dying and don't care about new ones\n\t * starting.  Testing ref liveliness is good enough.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (!(opts.subsys_mask & (1 << i)) ||\n\t\t    ss->root == &cgrp_dfl_root)\n\t\t\tcontinue;\n\n\t\tif (!percpu_ref_tryget_live(&ss->root->cgrp.self.refcnt)) {\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tmsleep(10);\n\t\t\tret = restart_syscall();\n\t\t\tgoto out_free;\n\t\t}\n\t\tcgroup_put(&ss->root->cgrp);\n\t}\n\n\tfor_each_root(root) {\n\t\tbool name_match = false;\n\n\t\tif (root == &cgrp_dfl_root)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we asked for a name then it must match.  Also, if\n\t\t * name matches but sybsys_mask doesn't, we should fail.\n\t\t * Remember whether name matched.\n\t\t */\n\t\tif (opts.name) {\n\t\t\tif (strcmp(opts.name, root->name))\n\t\t\t\tcontinue;\n\t\t\tname_match = true;\n\t\t}\n\n\t\t/*\n\t\t * If we asked for subsystems (or explicitly for no\n\t\t * subsystems) then they must match.\n\t\t */\n\t\tif ((opts.subsys_mask || opts.none) &&\n\t\t    (opts.subsys_mask != root->subsys_mask)) {\n\t\t\tif (!name_match)\n\t\t\t\tcontinue;\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (root->flags ^ opts.flags)\n\t\t\tpr_warn(\"new mount options do not match the existing superblock, will be ignored\\n\");\n\n\t\t/*\n\t\t * We want to reuse @root whose lifetime is governed by its\n\t\t * ->cgrp.  Let's check whether @root is alive and keep it\n\t\t * that way.  As cgroup_kill_sb() can happen anytime, we\n\t\t * want to block it by pinning the sb so that @root doesn't\n\t\t * get killed before mount is complete.\n\t\t *\n\t\t * With the sb pinned, tryget_live can reliably indicate\n\t\t * whether @root can be reused.  If it's being killed,\n\t\t * drain it.  We can use wait_queue for the wait but this\n\t\t * path is super cold.  Let's just sleep a bit and retry.\n\t\t */\n\t\tpinned_sb = kernfs_pin_sb(root->kf_root, NULL);\n\t\tif (IS_ERR(pinned_sb) ||\n\t\t    !percpu_ref_tryget_live(&root->cgrp.self.refcnt)) {\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tif (!IS_ERR_OR_NULL(pinned_sb))\n\t\t\t\tdeactivate_super(pinned_sb);\n\t\t\tmsleep(10);\n\t\t\tret = restart_syscall();\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * No such thing, create a new one.  name= matching without subsys\n\t * specification is allowed for already existing hierarchies but we\n\t * can't create new one without subsys specification.\n\t */\n\tif (!opts.subsys_mask && !opts.none) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Hierarchies may only be created in the initial cgroup namespace. */\n\tif (ns != &init_cgroup_ns) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tnew_root = true;\n\n\tinit_cgroup_root(root, &opts);\n\n\tret = cgroup_setup_root(root, opts.subsys_mask, PERCPU_REF_INIT_DEAD);\n\tif (ret)\n\t\tcgroup_free_root(root);\n\nout_unlock:\n\tmutex_unlock(&cgroup_mutex);\nout_free:\n\tkfree(opts.release_agent);\n\tkfree(opts.name);\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdentry = cgroup_do_mount(&cgroup_fs_type, flags, root,\n\t\t\t\t CGROUP_SUPER_MAGIC, ns);\n\n\t/*\n\t * There's a race window after we release cgroup_mutex and before\n\t * allocating a superblock. Make sure a concurrent process won't\n\t * be able to re-use the root during this window by delaying the\n\t * initialization of root refcnt.\n\t */\n\tif (new_root) {\n\t\tmutex_lock(&cgroup_mutex);\n\t\tpercpu_ref_reinit(&root->cgrp.self.refcnt);\n\t\tmutex_unlock(&cgroup_mutex);\n\t}\n\n\t/*\n\t * If @pinned_sb, we're reusing an existing root and holding an\n\t * extra ref on its sb.  Mount is complete.  Put the extra ref.\n\t */\n\tif (pinned_sb)\n\t\tdeactivate_super(pinned_sb);\n\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_cgroup_root_flags",
          "args": [
            "root_flags"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "apply_cgroup_root_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1763-1771",
          "snippet": "static void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "struct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstruct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\n\nstatic void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_do_mount",
          "args": [
            "&cgroup2_fs_type",
            "flags",
            "&cgrp_dfl_root",
            "CGROUP2_SUPER_MAGIC",
            "ns"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_do_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1997-2031",
          "snippet": "struct dentry *cgroup_do_mount(struct file_system_type *fs_type, int flags,\n\t\t\t       struct cgroup_root *root, unsigned long magic,\n\t\t\t       struct cgroup_namespace *ns)\n{\n\tstruct dentry *dentry;\n\tbool new_sb;\n\n\tdentry = kernfs_mount(fs_type, flags, root->kf_root, magic, &new_sb);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!IS_ERR(dentry) && ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ns->root_cset, root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, dentry->d_sb);\n\t\tdput(dentry);\n\t\tdentry = nsdentry;\n\t}\n\n\tif (IS_ERR(dentry) || !new_sb)\n\t\tcgroup_put(&root->cgrp);\n\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct dentry *cgroup_do_mount(struct file_system_type *fs_type, int flags,\n\t\t\t       struct cgroup_root *root, unsigned long magic,\n\t\t\t       struct cgroup_namespace *ns)\n{\n\tstruct dentry *dentry;\n\tbool new_sb;\n\n\tdentry = kernfs_mount(fs_type, flags, root->kf_root, magic, &new_sb);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!IS_ERR(dentry) && ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ns->root_cset, root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, dentry->d_sb);\n\t\tdput(dentry);\n\t\tdentry = nsdentry;\n\t}\n\n\tif (IS_ERR(dentry) || !new_sb)\n\t\tcgroup_put(&root->cgrp);\n\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "&cgrp_dfl_root.cgrp"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "559-563",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "ns"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_cgroup_root_flags",
          "args": [
            "data",
            "&root_flags"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cgroup_root_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1741-1761",
          "snippet": "static int parse_cgroup_root_flags(char *data, unsigned int *root_flags)\n{\n\tchar *token;\n\n\t*root_flags = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\twhile ((token = strsep(&data, \",\")) != NULL) {\n\t\tif (!strcmp(token, \"nsdelegate\")) {\n\t\t\t*root_flags |= CGRP_ROOT_NS_DELEGATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_err(\"cgroup2: unknown option \\\"%s\\\"\\n\", token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int parse_cgroup_root_flags(char *data, unsigned int *root_flags)\n{\n\tchar *token;\n\n\t*root_flags = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\twhile ((token = strsep(&data, \",\")) != NULL) {\n\t\tif (!strcmp(token, \"nsdelegate\")) {\n\t\t\t*root_flags |= CGRP_ROOT_NS_DELEGATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_err(\"cgroup2: unknown option \\\"%s\\\"\\n\", token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_enable_task_cg_lists",
          "args": [],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_enable_task_cg_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1801-1850",
          "snippet": "static void cgroup_enable_task_cg_lists(void)\n{\n\tstruct task_struct *p, *g;\n\n\t/*\n\t * We need tasklist_lock because RCU is not safe against\n\t * while_each_thread(). Besides, a forking task that has passed\n\t * cgroup_post_fork() without seeing use_task_css_set_links = 1\n\t * is not guaranteed to have its child immediately visible in the\n\t * tasklist if we walk through it with RCU.\n\t */\n\tread_lock(&tasklist_lock);\n\tspin_lock_irq(&css_set_lock);\n\n\tif (use_task_css_set_links)\n\t\tgoto out_unlock;\n\n\tuse_task_css_set_links = true;\n\n\tdo_each_thread(g, p) {\n\t\tWARN_ON_ONCE(!list_empty(&p->cg_list) ||\n\t\t\t     task_css_set(p) != &init_css_set);\n\n\t\t/*\n\t\t * We should check if the process is exiting, otherwise\n\t\t * it will race with cgroup_exit() in that the list\n\t\t * entry won't be deleted though the process has exited.\n\t\t * Do it while holding siglock so that we don't end up\n\t\t * racing against cgroup_exit().\n\t\t *\n\t\t * Interrupts were already disabled while acquiring\n\t\t * the css_set_lock, so we do not need to disable it\n\t\t * again when acquiring the sighand->siglock here.\n\t\t */\n\t\tspin_lock(&p->sighand->siglock);\n\t\tif (!(p->flags & PF_EXITING)) {\n\t\t\tstruct css_set *cset = task_css_set(p);\n\n\t\t\tif (!css_set_populated(cset))\n\t\t\t\tcss_set_update_populated(cset, true);\n\t\t\tlist_add_tail(&p->cg_list, &cset->tasks);\n\t\t\tget_css_set(cset);\n\t\t\tcset->nr_tasks++;\n\t\t}\n\t\tspin_unlock(&p->sighand->siglock);\n\t} while_each_thread(g, p);\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tread_unlock(&tasklist_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_advance(struct css_task_iter *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void cgroup_enable_task_cg_lists(void)\n{\n\tstruct task_struct *p, *g;\n\n\t/*\n\t * We need tasklist_lock because RCU is not safe against\n\t * while_each_thread(). Besides, a forking task that has passed\n\t * cgroup_post_fork() without seeing use_task_css_set_links = 1\n\t * is not guaranteed to have its child immediately visible in the\n\t * tasklist if we walk through it with RCU.\n\t */\n\tread_lock(&tasklist_lock);\n\tspin_lock_irq(&css_set_lock);\n\n\tif (use_task_css_set_links)\n\t\tgoto out_unlock;\n\n\tuse_task_css_set_links = true;\n\n\tdo_each_thread(g, p) {\n\t\tWARN_ON_ONCE(!list_empty(&p->cg_list) ||\n\t\t\t     task_css_set(p) != &init_css_set);\n\n\t\t/*\n\t\t * We should check if the process is exiting, otherwise\n\t\t * it will race with cgroup_exit() in that the list\n\t\t * entry won't be deleted though the process has exited.\n\t\t * Do it while holding siglock so that we don't end up\n\t\t * racing against cgroup_exit().\n\t\t *\n\t\t * Interrupts were already disabled while acquiring\n\t\t * the css_set_lock, so we do not need to disable it\n\t\t * again when acquiring the sighand->siglock here.\n\t\t */\n\t\tspin_lock(&p->sighand->siglock);\n\t\tif (!(p->flags & PF_EXITING)) {\n\t\t\tstruct css_set *cset = task_css_set(p);\n\n\t\t\tif (!css_set_populated(cset))\n\t\t\t\tcss_set_update_populated(cset, true);\n\t\t\tlist_add_tail(&p->cg_list, &cset->tasks);\n\t\t\tget_css_set(cset);\n\t\t\tcset->nr_tasks++;\n\t\t}\n\t\tspin_unlock(&p->sighand->siglock);\n\t} while_each_thread(g, p);\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tread_unlock(&tasklist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "ns"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "ns"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic bool cgrp_dfl_visible;\nstatic struct file_system_type cgroup2_fs_type;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct dentry *cgroup_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *unused_dev_name,\n\t\t\t void *data)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tget_cgroup_ns(ns);\n\n\t/* Check if the caller has permission to mount. */\n\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN)) {\n\t\tput_cgroup_ns(ns);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\t/*\n\t * The first time anyone tries to mount a cgroup, enable the list\n\t * linking each css_set to its tasks and fix up all existing tasks.\n\t */\n\tif (!use_task_css_set_links)\n\t\tcgroup_enable_task_cg_lists();\n\n\tif (fs_type == &cgroup2_fs_type) {\n\t\tunsigned int root_flags;\n\n\t\tret = parse_cgroup_root_flags(data, &root_flags);\n\t\tif (ret) {\n\t\t\tput_cgroup_ns(ns);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tcgrp_dfl_visible = true;\n\t\tcgroup_get_live(&cgrp_dfl_root.cgrp);\n\n\t\tdentry = cgroup_do_mount(&cgroup2_fs_type, flags, &cgrp_dfl_root,\n\t\t\t\t\t CGROUP2_SUPER_MAGIC, ns);\n\t\tif (!IS_ERR(dentry))\n\t\t\tapply_cgroup_root_flags(root_flags);\n\t} else {\n\t\tdentry = cgroup1_mount(&cgroup_fs_type, flags, data,\n\t\t\t\t       CGROUP_SUPER_MAGIC, ns);\n\t}\n\n\tput_cgroup_ns(ns);\n\treturn dentry;\n}"
  },
  {
    "function_name": "cgroup_do_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1997-2031",
    "snippet": "struct dentry *cgroup_do_mount(struct file_system_type *fs_type, int flags,\n\t\t\t       struct cgroup_root *root, unsigned long magic,\n\t\t\t       struct cgroup_namespace *ns)\n{\n\tstruct dentry *dentry;\n\tbool new_sb;\n\n\tdentry = kernfs_mount(fs_type, flags, root->kf_root, magic, &new_sb);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!IS_ERR(dentry) && ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ns->root_cset, root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, dentry->d_sb);\n\t\tdput(dentry);\n\t\tdentry = nsdentry;\n\t}\n\n\tif (IS_ERR(dentry) || !new_sb)\n\t\tcgroup_put(&root->cgrp);\n\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "&root->cgrp"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_node_dentry",
          "args": [
            "cgrp->kn",
            "dentry->d_sb"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cset_cgroup_from_root",
          "args": [
            "ns->root_cset",
            "root"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "cset_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1324-1351",
          "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_mount",
          "args": [
            "fs_type",
            "flags",
            "root->kf_root",
            "magic",
            "&new_sb"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct dentry *cgroup_do_mount(struct file_system_type *fs_type, int flags,\n\t\t\t       struct cgroup_root *root, unsigned long magic,\n\t\t\t       struct cgroup_namespace *ns)\n{\n\tstruct dentry *dentry;\n\tbool new_sb;\n\n\tdentry = kernfs_mount(fs_type, flags, root->kf_root, magic, &new_sb);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!IS_ERR(dentry) && ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ns->root_cset, root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, dentry->d_sb);\n\t\tdput(dentry);\n\t\tdentry = nsdentry;\n\t}\n\n\tif (IS_ERR(dentry) || !new_sb)\n\t\tcgroup_put(&root->cgrp);\n\n\treturn dentry;\n}"
  },
  {
    "function_name": "cgroup_setup_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1896-1995",
    "snippet": "int cgroup_setup_root(struct cgroup_root *root, u16 ss_mask, int ref_flags)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = cgroup_idr_alloc(&root->cgroup_idr, root_cgrp, 1, 2, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out;\n\troot_cgrp->id = ret;\n\troot_cgrp->ancestor_ids[0] = ret;\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      ref_flags, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tkernfs_activate(root_cgrp->kn);\n\tret = 0;\n\tgoto out;\n\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_root_count;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cgrp_cset_links",
          "args": [
            "&tmp_links"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgrp_cset_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1033-1041",
          "snippet": "static void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&root_cgrp->self.refcnt"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit_root_id",
          "args": [
            "root"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_exit_root_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1231-1236",
          "snippet": "static void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(cgroup_hierarchy_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_destroy_root",
          "args": [
            "root->kf_root"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "root_cgrp->kn"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&root->nr_cgrps) != 1"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->nr_cgrps"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&root_cgrp->self.children)"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root_cgrp->self.children"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_update_populated",
          "args": [
            "root_cgrp",
            "true"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "731-759",
          "snippet": "static void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_populated",
          "args": [
            "cset"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "707-712",
          "snippet": "static bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_css_set",
          "args": [
            "&tmp_links",
            "cset",
            "root_cgrp"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "link_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1075-1098",
          "snippet": "static void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in choronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in choronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "css_set_table",
            "i",
            "cset",
            "hlist"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&root->root_list",
            "&cgroup_roots"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_cgroup_setup_root",
          "args": [
            "root"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_inherit",
          "args": [
            "root_cgrp"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_inherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "160-184",
          "snippet": "int cgroup_bpf_inherit(struct cgroup *cgrp)\n{\n/* has to use marco instead of const int, since compiler thinks\n * that array below is variable length\n */\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\tstruct bpf_prog_array __rcu *arrays[NR] = {};\n\tint i;\n\n\tfor (i = 0; i < NR; i++)\n\t\tINIT_LIST_HEAD(&cgrp->bpf.progs[i]);\n\n\tfor (i = 0; i < NR; i++)\n\t\tif (compute_effective_progs(cgrp, i, &arrays[i]))\n\t\t\tgoto cleanup;\n\n\tfor (i = 0; i < NR; i++)\n\t\tactivate_effective_progs(cgrp, i, arrays[i]);\n\n\treturn 0;\ncleanup:\n\tfor (i = 0; i < NR; i++)\n\t\tbpf_prog_array_free(arrays[i]);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define\tNR ARRAY_SIZE(cgrp->bpf.effective)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\nint cgroup_bpf_inherit(struct cgroup *cgrp)\n{\n/* has to use marco instead of const int, since compiler thinks\n * that array below is variable length\n */\n#define\tNR ARRAY_SIZE(cgrp->bpf.effective)\n\tstruct bpf_prog_array __rcu *arrays[NR] = {};\n\tint i;\n\n\tfor (i = 0; i < NR; i++)\n\t\tINIT_LIST_HEAD(&cgrp->bpf.progs[i]);\n\n\tfor (i = 0; i < NR; i++)\n\t\tif (compute_effective_progs(cgrp, i, &arrays[i]))\n\t\t\tgoto cleanup;\n\n\tfor (i = 0; i < NR; i++)\n\t\tactivate_effective_progs(cgrp, i, arrays[i]);\n\n\treturn 0;\ncleanup:\n\tfor (i = 0; i < NR; i++)\n\t\tbpf_prog_array_free(arrays[i]);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebind_subsystems",
          "args": [
            "root",
            "ss_mask"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "rebind_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1644-1712",
          "snippet": "int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\t} while_each_subsys_mask();\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\t/* disable from the source */\n\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};",
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nint rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\t} while_each_subsys_mask();\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\t/* disable from the source */\n\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_populate_dir",
          "args": [
            "&root_cgrp->self"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "css_populate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1604-1642",
          "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root->kf_root"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root->kf_root"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_create_root",
          "args": [
            "kf_sops",
            "KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP",
            "root_cgrp"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_root_id",
          "args": [
            "root"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init_root_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1217-1229",
          "snippet": "static int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(cgroup_hierarchy_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_cgrp_cset_links",
          "args": [
            "2 * css_set_count",
            "&tmp_links"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_cgrp_cset_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1051-1067",
          "snippet": "static int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&root_cgrp->self.refcnt",
            "css_release",
            "ref_flags",
            "GFP_KERNEL"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_idr_alloc",
          "args": [
            "&root->cgroup_idr",
            "root_cgrp",
            "1",
            "2",
            "GFP_KERNEL"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "301-312",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_links"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_setup_root(struct cgroup_root *root, u16 ss_mask, int ref_flags)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = cgroup_idr_alloc(&root->cgroup_idr, root_cgrp, 1, 2, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out;\n\troot_cgrp->id = ret;\n\troot_cgrp->ancestor_ids[0] = ret;\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      ref_flags, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tkernfs_activate(root_cgrp->kn);\n\tret = 0;\n\tgoto out;\n\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}"
  },
  {
    "function_name": "init_cgroup_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1877-1894",
    "snippet": "void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\tidr_init(&root->cgroup_idr);\n\n\troot->flags = opts->flags;\n\tif (opts->release_agent)\n\t\tstrscpy(root->release_agent_path, opts->release_agent, PATH_MAX);\n\tif (opts->name)\n\t\tstrscpy(root->name, opts->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (opts->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_CPUSET_CLONE_CHILDREN",
            "&root->cgrp.flags"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "root->name",
            "opts->name",
            "MAX_CGROUP_ROOT_NAMELEN"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "root->release_agent_path",
            "opts->release_agent",
            "PATH_MAX"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&root->cgroup_idr"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cgroup_housekeeping",
          "args": [
            "cgrp"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "init_cgroup_housekeeping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1852-1875",
          "snippet": "static void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->nr_cgrps",
            "1"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->root_list"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\tidr_init(&root->cgroup_idr);\n\n\troot->flags = opts->flags;\n\tif (opts->release_agent)\n\t\tstrscpy(root->release_agent_path, opts->release_agent, PATH_MAX);\n\tif (opts->name)\n\t\tstrscpy(root->name, opts->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (opts->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}"
  },
  {
    "function_name": "init_cgroup_housekeeping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1852-1875",
    "snippet": "static void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cgrp->release_agent_work",
            "cgroup1_release_agent"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cgrp->offline_waitq"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->e_csets[ssid]"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev_cputime_init",
          "args": [
            "&cgrp->prev_cputime"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->rstat_css_list"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&cgrp->pidlist_mutex"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->pidlists"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->cset_links"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->self.children"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->self.sibling"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}"
  },
  {
    "function_name": "cgroup_enable_task_cg_lists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1801-1850",
    "snippet": "static void cgroup_enable_task_cg_lists(void)\n{\n\tstruct task_struct *p, *g;\n\n\t/*\n\t * We need tasklist_lock because RCU is not safe against\n\t * while_each_thread(). Besides, a forking task that has passed\n\t * cgroup_post_fork() without seeing use_task_css_set_links = 1\n\t * is not guaranteed to have its child immediately visible in the\n\t * tasklist if we walk through it with RCU.\n\t */\n\tread_lock(&tasklist_lock);\n\tspin_lock_irq(&css_set_lock);\n\n\tif (use_task_css_set_links)\n\t\tgoto out_unlock;\n\n\tuse_task_css_set_links = true;\n\n\tdo_each_thread(g, p) {\n\t\tWARN_ON_ONCE(!list_empty(&p->cg_list) ||\n\t\t\t     task_css_set(p) != &init_css_set);\n\n\t\t/*\n\t\t * We should check if the process is exiting, otherwise\n\t\t * it will race with cgroup_exit() in that the list\n\t\t * entry won't be deleted though the process has exited.\n\t\t * Do it while holding siglock so that we don't end up\n\t\t * racing against cgroup_exit().\n\t\t *\n\t\t * Interrupts were already disabled while acquiring\n\t\t * the css_set_lock, so we do not need to disable it\n\t\t * again when acquiring the sighand->siglock here.\n\t\t */\n\t\tspin_lock(&p->sighand->siglock);\n\t\tif (!(p->flags & PF_EXITING)) {\n\t\t\tstruct css_set *cset = task_css_set(p);\n\n\t\t\tif (!css_set_populated(cset))\n\t\t\t\tcss_set_update_populated(cset, true);\n\t\t\tlist_add_tail(&p->cg_list, &cset->tasks);\n\t\t\tget_css_set(cset);\n\t\t\tcset->nr_tasks++;\n\t\t}\n\t\tspin_unlock(&p->sighand->siglock);\n\t} while_each_thread(g, p);\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tread_unlock(&tasklist_lock);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_advance(struct css_task_iter *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "179-182",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&p->cg_list",
            "&cset->tasks"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_update_populated",
          "args": [
            "cset",
            "true"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_update_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "769-777",
          "snippet": "static void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_populated",
          "args": [
            "cset"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "707-712",
          "snippet": "static bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "p"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&p->cg_list) ||\n\t\t\t     task_css_set(p) != &init_css_set"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "p"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&p->cg_list"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void cgroup_enable_task_cg_lists(void)\n{\n\tstruct task_struct *p, *g;\n\n\t/*\n\t * We need tasklist_lock because RCU is not safe against\n\t * while_each_thread(). Besides, a forking task that has passed\n\t * cgroup_post_fork() without seeing use_task_css_set_links = 1\n\t * is not guaranteed to have its child immediately visible in the\n\t * tasklist if we walk through it with RCU.\n\t */\n\tread_lock(&tasklist_lock);\n\tspin_lock_irq(&css_set_lock);\n\n\tif (use_task_css_set_links)\n\t\tgoto out_unlock;\n\n\tuse_task_css_set_links = true;\n\n\tdo_each_thread(g, p) {\n\t\tWARN_ON_ONCE(!list_empty(&p->cg_list) ||\n\t\t\t     task_css_set(p) != &init_css_set);\n\n\t\t/*\n\t\t * We should check if the process is exiting, otherwise\n\t\t * it will race with cgroup_exit() in that the list\n\t\t * entry won't be deleted though the process has exited.\n\t\t * Do it while holding siglock so that we don't end up\n\t\t * racing against cgroup_exit().\n\t\t *\n\t\t * Interrupts were already disabled while acquiring\n\t\t * the css_set_lock, so we do not need to disable it\n\t\t * again when acquiring the sighand->siglock here.\n\t\t */\n\t\tspin_lock(&p->sighand->siglock);\n\t\tif (!(p->flags & PF_EXITING)) {\n\t\t\tstruct css_set *cset = task_css_set(p);\n\n\t\t\tif (!css_set_populated(cset))\n\t\t\t\tcss_set_update_populated(cset, true);\n\t\t\tlist_add_tail(&p->cg_list, &cset->tasks);\n\t\t\tget_css_set(cset);\n\t\t\tcset->nr_tasks++;\n\t\t}\n\t\tspin_unlock(&p->sighand->siglock);\n\t} while_each_thread(g, p);\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tread_unlock(&tasklist_lock);\n}"
  },
  {
    "function_name": "cgroup_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1780-1791",
    "snippet": "static int cgroup_remount(struct kernfs_root *kf_root, int *flags, char *data)\n{\n\tunsigned int root_flags;\n\tint ret;\n\n\tret = parse_cgroup_root_flags(data, &root_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tapply_cgroup_root_flags(root_flags);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_cgroup_root_flags",
          "args": [
            "root_flags"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "apply_cgroup_root_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1763-1771",
          "snippet": "static void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "struct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstruct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\n\nstatic void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_cgroup_root_flags",
          "args": [
            "data",
            "&root_flags"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cgroup_root_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1741-1761",
          "snippet": "static int parse_cgroup_root_flags(char *data, unsigned int *root_flags)\n{\n\tchar *token;\n\n\t*root_flags = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\twhile ((token = strsep(&data, \",\")) != NULL) {\n\t\tif (!strcmp(token, \"nsdelegate\")) {\n\t\t\t*root_flags |= CGRP_ROOT_NS_DELEGATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_err(\"cgroup2: unknown option \\\"%s\\\"\\n\", token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int parse_cgroup_root_flags(char *data, unsigned int *root_flags)\n{\n\tchar *token;\n\n\t*root_flags = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\twhile ((token = strsep(&data, \",\")) != NULL) {\n\t\tif (!strcmp(token, \"nsdelegate\")) {\n\t\t\t*root_flags |= CGRP_ROOT_NS_DELEGATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_err(\"cgroup2: unknown option \\\"%s\\\"\\n\", token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_remount(struct kernfs_root *kf_root, int *flags, char *data)\n{\n\tunsigned int root_flags;\n\tint ret;\n\n\tret = parse_cgroup_root_flags(data, &root_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tapply_cgroup_root_flags(root_flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1773-1778",
    "snippet": "static int cgroup_show_options(struct seq_file *seq, struct kernfs_root *kf_root)\n{\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE)\n\t\tseq_puts(seq, \",nsdelegate\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",nsdelegate\""
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\n\nstatic int cgroup_show_options(struct seq_file *seq, struct kernfs_root *kf_root)\n{\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE)\n\t\tseq_puts(seq, \",nsdelegate\");\n\treturn 0;\n}"
  },
  {
    "function_name": "apply_cgroup_root_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1763-1771",
    "snippet": "static void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "struct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstruct cgroup_namespace init_cgroup_ns = {\n\t.count\t\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\n\nstatic void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\t}\n}"
  },
  {
    "function_name": "parse_cgroup_root_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1741-1761",
    "snippet": "static int parse_cgroup_root_flags(char *data, unsigned int *root_flags)\n{\n\tchar *token;\n\n\t*root_flags = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\twhile ((token = strsep(&data, \",\")) != NULL) {\n\t\tif (!strcmp(token, \"nsdelegate\")) {\n\t\t\t*root_flags |= CGRP_ROOT_NS_DELEGATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_err(\"cgroup2: unknown option \\\"%s\\\"\\n\", token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cgroup2: unknown option \\\"%s\\\"\\n\"",
            "token"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "token",
            "\"nsdelegate\""
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&data",
            "\",\""
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int parse_cgroup_root_flags(char *data, unsigned int *root_flags)\n{\n\tchar *token;\n\n\t*root_flags = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\twhile ((token = strsep(&data, \",\")) != NULL) {\n\t\tif (!strcmp(token, \"nsdelegate\")) {\n\t\t\t*root_flags |= CGRP_ROOT_NS_DELEGATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_err(\"cgroup2: unknown option \\\"%s\\\"\\n\", token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_show_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1714-1739",
    "snippet": "int cgroup_show_path(struct seq_file *sf, struct kernfs_node *kf_node,\n\t\t     struct kernfs_root *kf_root)\n{\n\tint len = 0;\n\tchar *buf = NULL;\n\tstruct cgroup_root *kf_cgroot = cgroup_root_from_kf(kf_root);\n\tstruct cgroup *ns_cgroup;\n\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&css_set_lock);\n\tns_cgroup = current_cgns_cgroup_from_root(kf_cgroot);\n\tlen = kernfs_path_from_node(kf_node, ns_cgroup->kn, buf, PATH_MAX);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (len >= PATH_MAX)\n\t\tlen = -ERANGE;\n\telse if (len > 0) {\n\t\tseq_escape(sf, buf, \" \\t\\n\\\\\");\n\t\tlen = 0;\n\t}\n\tkfree(buf);\n\treturn len;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "sf",
            "buf",
            "\" \\t\\n\\\\\""
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_path_from_node",
          "args": [
            "kf_node",
            "ns_cgroup->kn",
            "buf",
            "PATH_MAX"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cgns_cgroup_from_root",
          "args": [
            "kf_cgroot"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "current_cgns_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1292-1321",
          "snippet": "static struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_root_from_kf",
          "args": [
            "kf_root"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_root_from_kf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1210-1215",
          "snippet": "struct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nint cgroup_show_path(struct seq_file *sf, struct kernfs_node *kf_node,\n\t\t     struct kernfs_root *kf_root)\n{\n\tint len = 0;\n\tchar *buf = NULL;\n\tstruct cgroup_root *kf_cgroot = cgroup_root_from_kf(kf_root);\n\tstruct cgroup *ns_cgroup;\n\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&css_set_lock);\n\tns_cgroup = current_cgns_cgroup_from_root(kf_cgroot);\n\tlen = kernfs_path_from_node(kf_node, ns_cgroup->kn, buf, PATH_MAX);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (len >= PATH_MAX)\n\t\tlen = -ERANGE;\n\telse if (len > 0) {\n\t\tseq_escape(sf, buf, \" \\t\\n\\\\\");\n\t\tlen = 0;\n\t}\n\tkfree(buf);\n\treturn len;\n}"
  },
  {
    "function_name": "rebind_subsystems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1644-1712",
    "snippet": "int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\t} while_each_subsys_mask();\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\t/* disable from the source */\n\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};",
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "dcgrp->kn"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->bind",
          "args": [
            "css"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"partial failure to rebind %s controller (err=%d)\\n\"",
            "ss->name",
            "ret"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "dcgrp"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "cgroup_subsys_on_dfl_key[ssid]"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "cgroup_subsys_on_dfl_key[ssid]"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&cset->e_cset_node[ss->id]",
            "&dcgrp->e_csets[ss->id]"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "css_set_table",
            "i",
            "cset",
            "hlist"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "dcgrp->subsys[ssid]",
            "css"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "scgrp->subsys[ssid]",
            "NULL"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_finalize_control",
          "args": [
            "scgrp",
            "0"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_apply_control(scgrp)"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "scgrp"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!css || cgroup_css(dcgrp, ss)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "dcgrp",
            "ss"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "463-471",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "ss_mask"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "NULL",
            "cgroup_css(&ss->root->cgrp, ss)"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "ss_mask"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nint rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\t} while_each_subsys_mask();\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\t/* disable from the source */\n\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}"
  },
  {
    "function_name": "css_populate_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1604-1642",
    "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cftype cgroup_base_files[];",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "false"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cfts",
            "&css->ss->cfts",
            "node"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "true"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cfts",
            "&css->ss->cfts",
            "node"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "&cgrp->self",
            "cgrp",
            "cfts",
            "true"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "css_clear_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1575-1596",
    "snippet": "static void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cftype cgroup_base_files[];",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "false"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cfts",
            "&css->ss->cfts",
            "node"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "false"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}"
  },
  {
    "function_name": "cgroup_rm_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1551-1569",
    "snippet": "static void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_file_kn_lock);",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "cgrp->kn",
            "cgroup_file_name(cgrp, cft, name)"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_name",
          "args": [
            "cgrp",
            "cft",
            "name"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_file_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1396-1409",
          "snippet": "static char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX))\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s.%s\",\n\t\t\t cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\telse\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\treturn buf;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX))\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s.%s\",\n\t\t\t cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\telse\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&cfile->notify_timer"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_file_kn_lock"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_file_kn_lock"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "cft->ss"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "463-471",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic DEFINE_SPINLOCK(cgroup_file_kn_lock);\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}"
  },
  {
    "function_name": "cgroup_kn_lock_live",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1520-1549",
    "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "kn"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1488-1501",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "cgrp"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "147-150",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_lock_and_drain_offline",
          "args": [
            "cgrp"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_break_active_protection",
          "args": [
            "kn"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_tryget",
          "args": [
            "cgrp"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgroup_kn_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1488-1501",
    "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_unbreak_active_protection",
          "args": [
            "kn"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
  },
  {
    "function_name": "cgroup_calc_subtree_ss_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1446-1476",
    "snippet": "static u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_implicit_ss_mask;",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "cur_ss_mask"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}"
  },
  {
    "function_name": "cgroup_file_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1417-1432",
    "snippet": "static umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}"
  },
  {
    "function_name": "cgroup_file_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1396-1409",
    "snippet": "static char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX))\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s.%s\",\n\t\t\t cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\telse\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\treturn buf;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
    ],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "buf",
            "cft->name",
            "CGROUP_FILE_NAME_MAX"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "CGROUP_FILE_NAME_MAX",
            "\"%s.%s\"",
            "cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name",
            "cft->name"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX))\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s.%s\",\n\t\t\t cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\telse\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\treturn buf;\n}"
  },
  {
    "function_name": "task_cgroup_from_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1357-1366",
    "snippet": "struct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold cgroup_mutex the\n\t * task can't change groups, so the only thing that can happen\n\t * is that it exits and its css is set back to init_css_set.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cset_cgroup_from_root",
          "args": [
            "task_css_set(task)",
            "root"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "cset_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1324-1351",
          "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold cgroup_mutex the\n\t * task can't change groups, so the only thing that can happen\n\t * is that it exits and its css is set back to init_css_set.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}"
  },
  {
    "function_name": "cset_cgroup_from_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1324-1351",
    "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!res"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
  },
  {
    "function_name": "current_cgns_cgroup_from_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1292-1321",
    "snippet": "static struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!res"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}"
  },
  {
    "function_name": "cgroup_destroy_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1246-1286",
    "snippet": "static void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_root_count;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_free_root",
          "args": [
            "root"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_free_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1238-1244",
          "snippet": "void cgroup_free_root(struct cgroup_root *root)\n{\n\tif (root) {\n\t\tidr_destroy(&root->cgroup_idr);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_free_root(struct cgroup_root *root)\n{\n\tif (root) {\n\t\tidr_destroy(&root->cgroup_idr);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_destroy_root",
          "args": [
            "root->kf_root"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_exit_root_id",
          "args": [
            "root"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_exit_root_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1231-1236",
          "snippet": "static void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(cgroup_hierarchy_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&root->root_list"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root->root_list"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "link",
            "tmp_link",
            "&cgrp->cset_links",
            "cset_link"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rebind_subsystems(&cgrp_dfl_root, root->subsys_mask)"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rebind_subsystems",
          "args": [
            "&cgrp_dfl_root",
            "root->subsys_mask"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "rebind_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1644-1712",
          "snippet": "int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\t} while_each_subsys_mask();\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\t/* disable from the source */\n\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};",
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nint rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\t} while_each_subsys_mask();\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\t/* disable from the source */\n\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&cgrp->self.children)"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&root->nr_cgrps)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->nr_cgrps"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_lock_and_drain_offline",
          "args": [
            "&cgrp_dfl_root.cgrp"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cgroup_destroy_root",
          "args": [
            "root"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}"
  },
  {
    "function_name": "cgroup_free_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1238-1244",
    "snippet": "void cgroup_free_root(struct cgroup_root *root)\n{\n\tif (root) {\n\t\tidr_destroy(&root->cgroup_idr);\n\t\tkfree(root);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&root->cgroup_idr"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_free_root(struct cgroup_root *root)\n{\n\tif (root) {\n\t\tidr_destroy(&root->cgroup_idr);\n\t\tkfree(root);\n\t}\n}"
  },
  {
    "function_name": "cgroup_exit_root_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1231-1236",
    "snippet": "static void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(cgroup_hierarchy_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&cgroup_hierarchy_idr",
            "root->hierarchy_id"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "324-329",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}"
  },
  {
    "function_name": "cgroup_init_root_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1217-1229",
    "snippet": "static int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(cgroup_hierarchy_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&cgroup_hierarchy_idr",
            "root",
            "0",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_root_from_kf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1210-1215",
    "snippet": "struct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}"
  },
  {
    "function_name": "find_css_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1108-1208",
    "snippet": "static struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_root_count;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cset->threaded_csets_node",
            "&dcset->threaded_csets"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "cset"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "863-898",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_css_set",
          "args": [
            "cset",
            "cset->dfl_cgrp->dom_cgrp"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "find_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1108-1208",
          "snippet": "static struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cset->dfl_cgrp"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cset->e_cset_node[ssid]",
            "&css->cgroup->e_csets[ssid]"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "css_set_table",
            "&cset->hlist",
            "key"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_hash",
          "args": [
            "cset->subsys"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "850-861",
          "snippet": "static unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&tmp_links)"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp_links"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_css_set",
          "args": [
            "&tmp_links",
            "cset",
            "c"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "link_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1075-1098",
          "snippet": "static void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in choronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in choronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&old_cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cset->subsys",
            "template",
            "sizeof(cset->subsys)"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->mg_node"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->mg_preload_node"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->cgrp_links"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&cset->hlist"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->threaded_csets"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->task_iters"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->mg_tasks"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->tasks"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&cset->refcount",
            "1"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cset"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_cgrp_cset_links",
          "args": [
            "cgroup_root_count",
            "&tmp_links"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_cgrp_cset_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1051-1067",
          "snippet": "static int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cset)",
            "GFP_KERNEL"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "179-182",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_existing_css_set",
          "args": [
            "old_cset",
            "cgrp",
            "template"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "find_existing_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "989-1031",
          "snippet": "static struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. while subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. while subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}"
  },
  {
    "function_name": "link_css_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1075-1098",
    "snippet": "static void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in choronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "cgrp"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "559-563",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&link->cgrp_link",
            "&cset->cgrp_links"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&link->cset_link",
            "&cgrp->cset_links"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "tmp_links",
            "structcgrp_cset_link",
            "cset_link"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(tmp_links)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "tmp_links"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in choronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}"
  },
  {
    "function_name": "allocate_cgrp_cset_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1051-1067",
    "snippet": "static int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&link->cset_link",
            "tmp_links"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cgrp_cset_links",
          "args": [
            "tmp_links"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgrp_cset_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "1033-1041",
          "snippet": "static void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*link)",
            "GFP_KERNEL"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "tmp_links"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_cgrp_cset_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "1033-1041",
    "snippet": "static void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&link->cset_link"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "link",
            "tmp_link",
            "links_to_free",
            "cset_link"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}"
  },
  {
    "function_name": "find_existing_css_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "989-1031",
    "snippet": "static struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. while subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "compare_css_sets",
          "args": [
            "cset",
            "old_cset",
            "cgrp",
            "template"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "compare_css_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "910-981",
          "snippet": "static bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "css_set_table",
            "cset",
            "hlist",
            "key"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_hash",
          "args": [
            "template"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "850-861",
          "snippet": "static unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_e_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_e_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "505-524",
          "snippet": "static struct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgrp,\n\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgrp,\n\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. while subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}"
  },
  {
    "function_name": "compare_css_sets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "910-981",
    "snippet": "static bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgrp1->root != cgrp2->root"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l2",
            "structcgrp_cset_link",
            "cgrp_link"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l1",
            "structcgrp_cset_link",
            "cgrp_link"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "l2 == &old_cset->cgrp_links"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "l2 != &old_cset->cgrp_links"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "new_cgrp"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "template",
            "cset->subsys",
            "sizeof(cset->subsys)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "put_css_set_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "863-898",
    "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "cset",
            "rcu_head"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set_locked",
          "args": [
            "cset->dom_cset"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "863-898",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cset->threaded_csets_node"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_threaded",
          "args": [
            "cset"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "693-696",
          "snippet": "static bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "link->cgrp"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "link->cgrp"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "link",
            "tmp_link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&cset->hlist"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "cset->subsys[ssid]"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&cset->threaded_csets)"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->threaded_csets"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&cset->refcount"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
  },
  {
    "function_name": "css_set_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "850-861",
    "snippet": "static unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}"
  },
  {
    "function_name": "css_set_move_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "794-840",
    "snippet": "static void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tstruct css_task_iter *it, *pos;\n\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\t/*\n\t\t * @task is leaving, advance task iterators which are\n\t\t * pointing to it so that they can resume at the next\n\t\t * position.  Advancing an iterator might remove it from\n\t\t * the list, use safe walk.  See css_task_iter_advance*()\n\t\t * for details.\n\t\t */\n\t\tlist_for_each_entry_safe(it, pos, &from_cset->task_iters,\n\t\t\t\t\t iters_node)\n\t\t\tif (it->task_pos == &task->cg_list)\n\t\t\t\tcss_task_iter_advance(it);\n\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit() changing the css_set to\n\t\t * init_css_set and dropping the old one.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct percpu_rw_semaphore cgroup_threadgroup_rwsem;",
      "static void css_task_iter_advance(struct css_task_iter *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&task->cg_list",
            "use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_move_task",
          "args": [
            "task",
            "to_cset"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_move_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "634-668",
          "snippet": "void cgroup_move_task(struct task_struct *task, struct css_set *to)\n{\n\tbool move_psi = !psi_disabled;\n\tunsigned int task_flags = 0;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (move_psi) {\n\t\trq = task_rq_lock(task, &rf);\n\n\t\tif (task_on_rq_queued(task))\n\t\t\ttask_flags = TSK_RUNNING;\n\t\telse if (task->in_iowait)\n\t\t\ttask_flags = TSK_IOWAIT;\n\n\t\tif (task->flags & PF_MEMSTALL)\n\t\t\ttask_flags |= TSK_MEMSTALL;\n\n\t\tif (task_flags)\n\t\t\tpsi_task_change(task, task_flags, 0);\n\t}\n\n\t/*\n\t * Lame to do this here, but the scheduler cannot be locked\n\t * from the outside, so we move cgroups from inside sched/.\n\t */\n\trcu_assign_pointer(task->cgroups, to);\n\n\tif (move_psi) {\n\t\tif (task_flags)\n\t\t\tpsi_task_change(task, 0, task_flags);\n\n\t\ttask_rq_unlock(rq, task, &rf);\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool psi_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\nbool psi_disabled;\n\nvoid cgroup_move_task(struct task_struct *task, struct css_set *to)\n{\n\tbool move_psi = !psi_disabled;\n\tunsigned int task_flags = 0;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (move_psi) {\n\t\trq = task_rq_lock(task, &rf);\n\n\t\tif (task_on_rq_queued(task))\n\t\t\ttask_flags = TSK_RUNNING;\n\t\telse if (task->in_iowait)\n\t\t\ttask_flags = TSK_IOWAIT;\n\n\t\tif (task->flags & PF_MEMSTALL)\n\t\t\ttask_flags |= TSK_MEMSTALL;\n\n\t\tif (task_flags)\n\t\t\tpsi_task_change(task, task_flags, 0);\n\t}\n\n\t/*\n\t * Lame to do this here, but the scheduler cannot be locked\n\t * from the outside, so we move cgroups from inside sched/.\n\t */\n\trcu_assign_pointer(task->cgroups, to);\n\n\tif (move_psi) {\n\t\tif (task_flags)\n\t\t\tpsi_task_change(task, 0, task_flags);\n\n\t\ttask_rq_unlock(rq, task, &rf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "task->flags & PF_EXITING"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&task->cg_list)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&task->cg_list"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_update_populated",
          "args": [
            "from_cset",
            "false"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_update_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "769-777",
          "snippet": "static void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_populated",
          "args": [
            "from_cset"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "707-712",
          "snippet": "static bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&task->cg_list"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_advance",
          "args": [
            "it"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "it",
            "pos",
            "&from_cset->task_iters",
            "iters_node"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "list_empty(&task->cg_list)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct percpu_rw_semaphore cgroup_threadgroup_rwsem;\nstatic void css_task_iter_advance(struct css_task_iter *it);\n\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tstruct css_task_iter *it, *pos;\n\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\t/*\n\t\t * @task is leaving, advance task iterators which are\n\t\t * pointing to it so that they can resume at the next\n\t\t * position.  Advancing an iterator might remove it from\n\t\t * the list, use safe walk.  See css_task_iter_advance*()\n\t\t * for details.\n\t\t */\n\t\tlist_for_each_entry_safe(it, pos, &from_cset->task_iters,\n\t\t\t\t\t iters_node)\n\t\t\tif (it->task_pos == &task->cg_list)\n\t\t\t\tcss_task_iter_advance(it);\n\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit() changing the css_set to\n\t\t * init_css_set and dropping the old one.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}"
  },
  {
    "function_name": "css_set_update_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "769-777",
    "snippet": "static void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_update_populated",
          "args": [
            "link->cgrp",
            "populated"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "731-759",
          "snippet": "static void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}"
  },
  {
    "function_name": "cgroup_update_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "731-759",
    "snippet": "static void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup1_check_for_release",
          "args": [
            "cgrp"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_check_for_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "772-777",
          "snippet": "void cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "child"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}"
  },
  {
    "function_name": "css_set_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "707-712",
    "snippet": "static bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->mg_tasks"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}"
  },
  {
    "function_name": "css_set_threaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "693-696",
    "snippet": "static bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}"
  },
  {
    "function_name": "of_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "565-582",
    "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "cgrp->subsys[cft->ss->id]"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
  },
  {
    "function_name": "cgroup_get_live",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "559-563",
    "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&cgrp->self"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cgroup_is_dead(cgrp)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "cgrp"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "147-150",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
  },
  {
    "function_name": "cgroup_get_e_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "537-557",
    "snippet": "struct cgroup_subsys_state *cgroup_get_e_css(struct cgroup *cgrp,\n\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcss = cgroup_css(cgrp, ss);\n\n\t\tif (css && css_tryget_online(css))\n\t\t\tgoto out_unlock;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n\n\tcss = init_css_set.subsys[ss->id];\n\tcss_get(css);\nout_unlock:\n\trcu_read_unlock();\n\treturn css;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "css"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "463-471",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *cgroup_get_e_css(struct cgroup *cgrp,\n\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcss = cgroup_css(cgrp, ss);\n\n\t\tif (css && css_tryget_online(css))\n\t\t\tgoto out_unlock;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n\n\tcss = init_css_set.subsys[ss->id];\n\tcss_get(css);\nout_unlock:\n\trcu_read_unlock();\n\treturn css;\n}"
  },
  {
    "function_name": "cgroup_e_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "505-524",
    "snippet": "static struct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgrp,\n\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "463-471",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ss_mask",
          "args": [
            "cgrp"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_ss_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "436-450",
          "snippet": "static u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgrp,\n\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}"
  },
  {
    "function_name": "cgroup_tryget_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "481-493",
    "snippet": "static struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (!css || !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "css"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "463-471",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (!css || !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}"
  },
  {
    "function_name": "cgroup_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "463-471",
    "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "cgrp->subsys[ss->id]",
            "lockdep_is_held(&cgroup_mutex)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
  },
  {
    "function_name": "cgroup_ss_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "436-450",
    "snippet": "static u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}"
  },
  {
    "function_name": "cgroup_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "415-433",
    "snippet": "static u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_inhibit_ss_mask;",
      "static u16 cgrp_dfl_implicit_ss_mask;",
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "295-298",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}"
  },
  {
    "function_name": "cgroup_is_valid_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "397-412",
    "snippet": "static bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_thread_root",
          "args": [
            "cgrp"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_thread_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "375-394",
          "snippet": "bool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_mixable",
          "args": [
            "cgrp"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_mixable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "342-350",
          "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgroup_is_thread_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "375-394",
    "snippet": "bool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_has_tasks",
          "args": [
            "cgrp"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_has_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "331-334",
          "snippet": "static bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "cgroup_can_be_thread_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "353-372",
    "snippet": "static bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "336-339",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_mixable",
          "args": [
            "cgrp"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_mixable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "342-350",
          "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_advance(struct css_task_iter *it);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgroup_is_mixable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "342-350",
    "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_advance(struct css_task_iter *it);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_advance(struct css_task_iter *it);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
  },
  {
    "function_name": "cgroup_is_threaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "336-339",
    "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
  },
  {
    "function_name": "cgroup_has_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "331-334",
    "snippet": "static bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}"
  },
  {
    "function_name": "cgroup_idr_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "324-329",
    "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "idr",
            "id"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "324-329",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
  },
  {
    "function_name": "cgroup_idr_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "314-322",
    "snippet": "static void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_idr_lock);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_replace",
          "args": [
            "idr",
            "ptr",
            "id"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "314-322",
          "snippet": "static void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_idr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "301-312",
    "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_idr_lock);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "idr",
            "ptr",
            "start",
            "end",
            "gfp_mask & ~__GFP_DIRECT_RECLAIM"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "301-312",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "gfp_mask"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_on_dfl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "295-298",
    "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
  },
  {
    "function_name": "cgroup_ssid_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
    "lines": "234-240",
    "snippet": "bool cgroup_ssid_enabled(int ssid)\n{\n\tif (CGROUP_SUBSYS_COUNT == 0)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "cgroup_subsys_enabled_key[ssid]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};\n\nbool cgroup_ssid_enabled(int ssid)\n{\n\tif (CGROUP_SUBSYS_COUNT == 0)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}"
  }
]