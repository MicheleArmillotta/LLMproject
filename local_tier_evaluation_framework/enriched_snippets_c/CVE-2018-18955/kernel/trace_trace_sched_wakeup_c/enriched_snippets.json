[
  {
    "function_name": "init_wakeup_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "810-827",
    "snippet": "__init static int init_wakeup_tracer(void)\n{\n\tint ret;\n\n\tret = register_tracer(&wakeup_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_tracer(&wakeup_rt_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_tracer(&wakeup_dl_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&wakeup_dl_tracer"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1591-1672",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n__init static int init_wakeup_tracer(void)\n{\n\tint ret;\n\n\tret = register_tracer(&wakeup_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_tracer(&wakeup_rt_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_tracer(&wakeup_dl_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wakeup_tracer_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "745-748",
    "snippet": "static void wakeup_tracer_stop(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_tracer_stop(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n}"
  },
  {
    "function_name": "wakeup_tracer_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "739-743",
    "snippet": "static void wakeup_tracer_start(struct trace_array *tr)\n{\n\twakeup_reset(tr);\n\ttracer_enabled = 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_reset",
          "args": [
            "tr"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "520-531",
          "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_tracer_start(struct trace_array *tr)\n{\n\twakeup_reset(tr);\n\ttracer_enabled = 1;\n}"
  },
  {
    "function_name": "wakeup_tracer_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "724-737",
    "snippet": "static void wakeup_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\n\tstop_wakeup_tracer(tr);\n\t/* make sure we put back any tasks we are tracing */\n\twakeup_reset(tr);\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tftrace_reset_array_ops(tr);\n\twakeup_busy = false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int save_flags;",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_reset_array_ops",
          "args": [
            "tr"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_reset_array_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6247-6250",
          "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tracer_flag",
          "args": [
            "tr",
            "TRACE_ITER_OVERWRITE",
            "overwrite_flag"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "set_tracer_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "4352-4403",
          "snippet": "int set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map)\n\t\t\ttgid_map = kcalloc(PID_MAX_DEFAULT + 1,\n\t\t\t\t\t   sizeof(*tgid_map),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->trace_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int *tgid_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int *tgid_map;\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map)\n\t\t\ttgid_map = kcalloc(PID_MAX_DEFAULT + 1,\n\t\t\t\t\t   sizeof(*tgid_map),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->trace_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_reset",
          "args": [
            "tr"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "520-531",
          "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_wakeup_tracer",
          "args": [
            "tr"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "stop_wakeup_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "665-673",
          "snippet": "static void stop_wakeup_tracer(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n\tstop_func_tracer(tr, is_graph(tr));\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void stop_wakeup_tracer(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n\tstop_func_tracer(tr, is_graph(tr));\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic void wakeup_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\n\tstop_wakeup_tracer(tr);\n\t/* make sure we put back any tasks we are tracing */\n\twakeup_reset(tr);\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tftrace_reset_array_ops(tr);\n\twakeup_busy = false;\n}"
  },
  {
    "function_name": "wakeup_dl_tracer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "714-722",
    "snippet": "static int wakeup_dl_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = 1;\n\twakeup_rt = 0;\n\treturn __wakeup_tracer_init(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\twakeup_rt;",
      "static int\t\t\twakeup_dl;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wakeup_tracer_init",
          "args": [
            "tr"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "677-692",
          "snippet": "static int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*wakeup_trace;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int save_flags;",
            "static bool wakeup_busy;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int\t\t\twakeup_rt;\nstatic int\t\t\twakeup_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic bool wakeup_busy;\n\nstatic int wakeup_dl_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = 1;\n\twakeup_rt = 0;\n\treturn __wakeup_tracer_init(tr);\n}"
  },
  {
    "function_name": "wakeup_rt_tracer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "704-712",
    "snippet": "static int wakeup_rt_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = 0;\n\twakeup_rt = 1;\n\treturn __wakeup_tracer_init(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\twakeup_rt;",
      "static int\t\t\twakeup_dl;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wakeup_tracer_init",
          "args": [
            "tr"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "677-692",
          "snippet": "static int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*wakeup_trace;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int save_flags;",
            "static bool wakeup_busy;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int\t\t\twakeup_rt;\nstatic int\t\t\twakeup_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic bool wakeup_busy;\n\nstatic int wakeup_rt_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = 0;\n\twakeup_rt = 1;\n\treturn __wakeup_tracer_init(tr);\n}"
  },
  {
    "function_name": "wakeup_tracer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "694-702",
    "snippet": "static int wakeup_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = 0;\n\twakeup_rt = 0;\n\treturn __wakeup_tracer_init(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\twakeup_rt;",
      "static int\t\t\twakeup_dl;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wakeup_tracer_init",
          "args": [
            "tr"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "677-692",
          "snippet": "static int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*wakeup_trace;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int save_flags;",
            "static bool wakeup_busy;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int\t\t\twakeup_rt;\nstatic int\t\t\twakeup_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic bool wakeup_busy;\n\nstatic int wakeup_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = 0;\n\twakeup_rt = 0;\n\treturn __wakeup_tracer_init(tr);\n}"
  },
  {
    "function_name": "__wakeup_tracer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "677-692",
    "snippet": "static int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int save_flags;",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_wakeup_tracer",
          "args": [
            "tr"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "start_wakeup_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "612-663",
          "snippet": "static void start_wakeup_tracer(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\");\n\t\treturn;\n\t}\n\n\twakeup_reset(tr);\n\n\t/*\n\t * Don't let the tracer_enabled = 1 show up before\n\t * the wakeup_task is reset. This may be overkill since\n\t * wakeup_reset does a spin_unlock after setting the\n\t * wakeup_task to NULL, but I want to be safe.\n\t * This is a slow path anyway.\n\t */\n\tsmp_wmb();\n\n\tif (start_func_tracer(tr, is_graph(tr)))\n\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");\n\n\treturn;\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void start_wakeup_tracer(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\");\n\t\treturn;\n\t}\n\n\twakeup_reset(tr);\n\n\t/*\n\t * Don't let the tracer_enabled = 1 show up before\n\t * the wakeup_task is reset. This may be overkill since\n\t * wakeup_reset does a spin_unlock after setting the\n\t * wakeup_task to NULL, but I want to be safe.\n\t * This is a slow path anyway.\n\t */\n\tsmp_wmb();\n\n\tif (start_func_tracer(tr, is_graph(tr)))\n\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");\n\n\treturn;\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_init_array_ops",
          "args": [
            "tr",
            "wakeup_tracer_call"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_array_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6235-6245",
          "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tracer_flag",
          "args": [
            "tr",
            "TRACE_ITER_LATENCY_FMT",
            "1"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "set_tracer_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "4352-4403",
          "snippet": "int set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map)\n\t\t\ttgid_map = kcalloc(PID_MAX_DEFAULT + 1,\n\t\t\t\t\t   sizeof(*tgid_map),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->trace_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int *tgid_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int *tgid_map;\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map)\n\t\t\ttgid_map = kcalloc(PID_MAX_DEFAULT + 1,\n\t\t\t\t\t   sizeof(*tgid_map),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->trace_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "stop_wakeup_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "665-673",
    "snippet": "static void stop_wakeup_tracer(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n\tstop_func_tracer(tr, is_graph(tr));\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_migrate_task",
          "args": [
            "probe_wakeup_migrate_task",
            "NULL"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "probe_wakeup_sched_switch",
            "NULL"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_func_tracer",
          "args": [
            "tr",
            "is_graph(tr)"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "stop_func_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "215-220",
          "snippet": "static void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void stop_wakeup_tracer(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n\tstop_func_tracer(tr, is_graph(tr));\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n}"
  },
  {
    "function_name": "start_wakeup_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "612-663",
    "snippet": "static void start_wakeup_tracer(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\");\n\t\treturn;\n\t}\n\n\twakeup_reset(tr);\n\n\t/*\n\t * Don't let the tracer_enabled = 1 show up before\n\t * the wakeup_task is reset. This may be overkill since\n\t * wakeup_reset does a spin_unlock after setting the\n\t * wakeup_task to NULL, but I want to be safe.\n\t * This is a slow path anyway.\n\t */\n\tsmp_wmb();\n\n\tif (start_func_tracer(tr, is_graph(tr)))\n\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");\n\n\treturn;\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct\t*wakeup_task;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"failed to start wakeup tracer\\n\""
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_func_tracer",
          "args": [
            "tr",
            "is_graph(tr)"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "start_func_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "201-213",
          "snippet": "static int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_reset",
          "args": [
            "tr"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "520-531",
          "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_migrate_task",
          "args": [
            "probe_wakeup_migrate_task",
            "NULL"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_switch",
          "args": [
            "probe_wakeup_sched_switch",
            "NULL"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_wakeup_new",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\""
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_wakeup",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void start_wakeup_tracer(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\");\n\t\treturn;\n\t}\n\n\twakeup_reset(tr);\n\n\t/*\n\t * Don't let the tracer_enabled = 1 show up before\n\t * the wakeup_task is reset. This may be overkill since\n\t * wakeup_reset does a spin_unlock after setting the\n\t * wakeup_task to NULL, but I want to be safe.\n\t * This is a slow path anyway.\n\t */\n\tsmp_wmb();\n\n\tif (start_func_tracer(tr, is_graph(tr)))\n\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");\n\n\treturn;\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n}"
  },
  {
    "function_name": "probe_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "533-610",
    "snippet": "static void\nprobe_wakeup(void *ignore, struct task_struct *p)\n{\n\tstruct trace_array_cpu *data;\n\tint cpu = smp_processor_id();\n\tunsigned long flags;\n\tlong disabled;\n\tint pc;\n\n\tif (likely(!tracer_enabled))\n\t\treturn;\n\n\ttracing_record_cmdline(p);\n\ttracing_record_cmdline(current);\n\n\t/*\n\t * Semantic is like this:\n\t *  - wakeup tracer handles all tasks in the system, independently\n\t *    from their scheduling class;\n\t *  - wakeup_rt tracer handles tasks belonging to sched_dl and\n\t *    sched_rt class;\n\t *  - wakeup_dl handles tasks belonging to sched_dl class only.\n\t */\n\tif (tracing_dl || (wakeup_dl && !dl_task(p)) ||\n\t    (wakeup_rt && !dl_task(p) && !rt_task(p)) ||\n\t    (!dl_task(p) && (p->prio >= wakeup_prio || p->prio >= current->prio)))\n\t\treturn;\n\n\tpc = preempt_count();\n\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\t/* interrupts should be off from try_to_wake_up */\n\tarch_spin_lock(&wakeup_lock);\n\n\t/* check for races. */\n\tif (!tracer_enabled || tracing_dl ||\n\t    (!dl_task(p) && p->prio >= wakeup_prio))\n\t\tgoto out_locked;\n\n\t/* reset the trace */\n\t__wakeup_reset(wakeup_trace);\n\n\twakeup_cpu = task_cpu(p);\n\twakeup_current_cpu = wakeup_cpu;\n\twakeup_prio = p->prio;\n\n\t/*\n\t * Once you start tracing a -deadline task, don't bother tracing\n\t * another task until the first one wakes up.\n\t */\n\tif (dl_task(p))\n\t\ttracing_dl = 1;\n\telse\n\t\ttracing_dl = 0;\n\n\twakeup_task = p;\n\tget_task_struct(wakeup_task);\n\n\tlocal_save_flags(flags);\n\n\tdata = per_cpu_ptr(wakeup_trace->trace_buffer.data, wakeup_cpu);\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\ttracing_sched_wakeup_trace(wakeup_trace, p, current, flags, pc);\n\n\t/*\n\t * We must be careful in using CALLER_ADDR2. But since wake_up\n\t * is not called by an assembly function  (where as schedule is)\n\t * it should be safe to use it here.\n\t */\n\t__trace_function(wakeup_trace, CALLER_ADDR1, CALLER_ADDR2, flags, pc);\n\nout_locked:\n\tarch_spin_unlock(&wakeup_lock);\nout:\n\tatomic_dec(&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define __trace_function trace_function"
    ],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_cpu;",
      "static int\t\t\twakeup_current_cpu;",
      "static unsigned\t\t\twakeup_prio = -1;",
      "static int\t\t\twakeup_rt;",
      "static int\t\t\twakeup_dl;",
      "static int\t\t\ttracing_dl = 0;",
      "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->trace_buffer.data",
            "cpu"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_function",
          "args": [
            "wakeup_trace",
            "CALLER_ADDR1",
            "CALLER_ADDR2",
            "flags",
            "pc"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "320-329",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define __trace_function trace_function\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_sched_wakeup_trace",
          "args": [
            "wakeup_trace",
            "p",
            "current",
            "flags",
            "pc"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_sched_wakeup_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "411-437",
          "snippet": "static void\ntracing_sched_wakeup_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *wakee,\n\t\t\t   struct task_struct *curr,\n\t\t\t   unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_wakeup;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= curr->pid;\n\tentry->prev_prio\t\t= curr->prio;\n\tentry->prev_state\t\t= task_state_index(curr);\n\tentry->next_pid\t\t\t= wakee->pid;\n\tentry->next_prio\t\t= wakee->prio;\n\tentry->next_state\t\t= task_state_index(wakee);\n\tentry->next_cpu\t\t\t= task_cpu(wakee);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, flags, pc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\ntracing_sched_wakeup_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *wakee,\n\t\t\t   struct task_struct *curr,\n\t\t\t   unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_wakeup;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= curr->pid;\n\tentry->prev_prio\t\t= curr->prio;\n\tentry->prev_state\t\t= task_state_index(curr);\n\tentry->next_pid\t\t\t= wakee->pid;\n\tentry->next_prio\t\t= wakee->prio;\n\tentry->next_state\t\t= task_state_index(wakee);\n\tentry->next_cpu\t\t\t= task_cpu(wakee);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_now",
          "args": [
            "cpu"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "582-585",
          "snippet": "u64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.trace_buffer, cpu);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.trace_buffer, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->trace_buffer.data",
            "wakeup_cpu"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "wakeup_task"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wakeup_reset",
          "args": [
            "wakeup_trace"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "508-518",
          "snippet": "static void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = 0;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_cpu;",
            "static unsigned\t\t\twakeup_prio = -1;",
            "static int\t\t\ttracing_dl = 0;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic int\t\t\ttracing_dl = 0;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = 0;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "disabled != 1"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->trace_buffer.data",
            "cpu"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "p"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "tg_has_rt_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2416-2432",
          "snippet": "static inline int tg_has_rt_tasks(struct task_group *tg)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * Autogroups do not have RT tasks; see autogroup_create().\n\t */\n\tif (task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\tfor_each_process_thread(g, p) {\n\t\tif (rt_task(p) && task_group(p) == tg)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int tg_has_rt_tasks(struct task_group *tg)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * Autogroups do not have RT tasks; see autogroup_create().\n\t */\n\tif (task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\tfor_each_process_thread(g, p) {\n\t\tif (rt_task(p) && task_group(p) == tg)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_record_cmdline",
          "args": [
            "current"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_record_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2108-2111",
          "snippet": "void tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!tracer_enabled"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define __trace_function trace_function\n\nstatic struct trace_array\t*wakeup_trace;\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic int\t\t\twakeup_current_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic int\t\t\twakeup_rt;\nstatic int\t\t\twakeup_dl;\nstatic int\t\t\ttracing_dl = 0;\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void\nprobe_wakeup(void *ignore, struct task_struct *p)\n{\n\tstruct trace_array_cpu *data;\n\tint cpu = smp_processor_id();\n\tunsigned long flags;\n\tlong disabled;\n\tint pc;\n\n\tif (likely(!tracer_enabled))\n\t\treturn;\n\n\ttracing_record_cmdline(p);\n\ttracing_record_cmdline(current);\n\n\t/*\n\t * Semantic is like this:\n\t *  - wakeup tracer handles all tasks in the system, independently\n\t *    from their scheduling class;\n\t *  - wakeup_rt tracer handles tasks belonging to sched_dl and\n\t *    sched_rt class;\n\t *  - wakeup_dl handles tasks belonging to sched_dl class only.\n\t */\n\tif (tracing_dl || (wakeup_dl && !dl_task(p)) ||\n\t    (wakeup_rt && !dl_task(p) && !rt_task(p)) ||\n\t    (!dl_task(p) && (p->prio >= wakeup_prio || p->prio >= current->prio)))\n\t\treturn;\n\n\tpc = preempt_count();\n\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\t/* interrupts should be off from try_to_wake_up */\n\tarch_spin_lock(&wakeup_lock);\n\n\t/* check for races. */\n\tif (!tracer_enabled || tracing_dl ||\n\t    (!dl_task(p) && p->prio >= wakeup_prio))\n\t\tgoto out_locked;\n\n\t/* reset the trace */\n\t__wakeup_reset(wakeup_trace);\n\n\twakeup_cpu = task_cpu(p);\n\twakeup_current_cpu = wakeup_cpu;\n\twakeup_prio = p->prio;\n\n\t/*\n\t * Once you start tracing a -deadline task, don't bother tracing\n\t * another task until the first one wakes up.\n\t */\n\tif (dl_task(p))\n\t\ttracing_dl = 1;\n\telse\n\t\ttracing_dl = 0;\n\n\twakeup_task = p;\n\tget_task_struct(wakeup_task);\n\n\tlocal_save_flags(flags);\n\n\tdata = per_cpu_ptr(wakeup_trace->trace_buffer.data, wakeup_cpu);\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\ttracing_sched_wakeup_trace(wakeup_trace, p, current, flags, pc);\n\n\t/*\n\t * We must be careful in using CALLER_ADDR2. But since wake_up\n\t * is not called by an assembly function  (where as schedule is)\n\t * it should be safe to use it here.\n\t */\n\t__trace_function(wakeup_trace, CALLER_ADDR1, CALLER_ADDR2, flags, pc);\n\nout_locked:\n\tarch_spin_unlock(&wakeup_lock);\nout:\n\tatomic_dec(&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled);\n}"
  },
  {
    "function_name": "wakeup_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "520-531",
    "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wakeup_reset",
          "args": [
            "tr"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "508-518",
          "snippet": "static void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = 0;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_cpu;",
            "static unsigned\t\t\twakeup_prio = -1;",
            "static int\t\t\ttracing_dl = 0;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic int\t\t\ttracing_dl = 0;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = 0;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&tr->trace_buffer"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1690-1709",
          "snippet": "void tracing_reset_online_cpus(struct trace_buffer *buf)\n{\n\tstruct ring_buffer *buffer = buf->buffer;\n\tint cpu;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_sched();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tfor_each_online_cpu(cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct trace_buffer *buf)\n{\n\tstruct ring_buffer *buffer = buf->buffer;\n\tint cpu;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_sched();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tfor_each_online_cpu(cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__wakeup_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "508-518",
    "snippet": "static void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = 0;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_cpu;",
      "static unsigned\t\t\twakeup_prio = -1;",
      "static int\t\t\ttracing_dl = 0;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "wakeup_task"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic int\t\t\ttracing_dl = 0;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = 0;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}"
  },
  {
    "function_name": "probe_wakeup_sched_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "439-506",
    "snippet": "static void notrace\nprobe_wakeup_sched_switch(void *ignore, bool preempt,\n\t\t\t  struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array_cpu *data;\n\tu64 T0, T1, delta;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\ttracing_record_cmdline(prev);\n\n\tif (unlikely(!tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * When we start a new trace, we set wakeup_task to NULL\n\t * and then set tracer_enabled = 1. We want to make sure\n\t * that another CPU does not see the tracer_enabled = 1\n\t * and the wakeup_task with an older task, that might\n\t * actually be the same as next.\n\t */\n\tsmp_rmb();\n\n\tif (next != wakeup_task)\n\t\treturn;\n\n\tpc = preempt_count();\n\n\t/* disable local data, not wakeup_cpu data */\n\tcpu = raw_smp_processor_id();\n\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled);\n\tif (likely(disabled != 1))\n\t\tgoto out;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\n\t/* We could race with grabbing wakeup_lock */\n\tif (unlikely(!tracer_enabled || next != wakeup_task))\n\t\tgoto out_unlock;\n\n\t/* The task we are waiting for is waking up */\n\tdata = per_cpu_ptr(wakeup_trace->trace_buffer.data, wakeup_cpu);\n\n\t__trace_function(wakeup_trace, CALLER_ADDR0, CALLER_ADDR1, flags, pc);\n\ttracing_sched_switch_trace(wakeup_trace, prev, next, flags, pc);\n\n\tT0 = data->preempt_timestamp;\n\tT1 = ftrace_now(cpu);\n\tdelta = T1-T0;\n\n\tif (!report_latency(wakeup_trace, delta))\n\t\tgoto out_unlock;\n\n\tif (likely(!is_tracing_stopped())) {\n\t\twakeup_trace->max_latency = delta;\n\t\tupdate_max_tr(wakeup_trace, wakeup_task, wakeup_cpu);\n\t}\n\nout_unlock:\n\t__wakeup_reset(wakeup_trace);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\nout:\n\tatomic_dec(&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define __trace_function trace_function"
    ],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_cpu;",
      "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->trace_buffer.data",
            "cpu"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wakeup_reset",
          "args": [
            "wakeup_trace"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "508-518",
          "snippet": "static void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = 0;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_cpu;",
            "static unsigned\t\t\twakeup_prio = -1;",
            "static int\t\t\ttracing_dl = 0;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic int\t\t\ttracing_dl = 0;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = 0;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_max_tr",
          "args": [
            "wakeup_trace",
            "wakeup_task",
            "wakeup_cpu"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1397-1431",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_tracing_stopped()"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_tracing_stopped",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "is_tracing_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1797-1800",
          "snippet": "int is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_latency",
          "args": [
            "wakeup_trace",
            "delta"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "report_latency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "362-372",
          "snippet": "static bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_now",
          "args": [
            "cpu"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "582-585",
          "snippet": "u64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.trace_buffer, cpu);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.trace_buffer, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_sched_switch_trace",
          "args": [
            "wakeup_trace",
            "prev",
            "next",
            "flags",
            "pc"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_sched_switch_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "383-409",
          "snippet": "static void\ntracing_sched_switch_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *prev,\n\t\t\t   struct task_struct *next,\n\t\t\t   unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_context_switch;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= prev->pid;\n\tentry->prev_prio\t\t= prev->prio;\n\tentry->prev_state\t\t= task_state_index(prev);\n\tentry->next_pid\t\t\t= next->pid;\n\tentry->next_prio\t\t= next->prio;\n\tentry->next_state\t\t= task_state_index(next);\n\tentry->next_cpu\t= task_cpu(next);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, flags, pc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\ntracing_sched_switch_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *prev,\n\t\t\t   struct task_struct *next,\n\t\t\t   unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_context_switch;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= prev->pid;\n\tentry->prev_prio\t\t= prev->prio;\n\tentry->prev_state\t\t= task_state_index(prev);\n\tentry->next_pid\t\t\t= next->pid;\n\tentry->next_prio\t\t= next->prio;\n\tentry->next_state\t\t= task_state_index(next);\n\tentry->next_cpu\t= task_cpu(next);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_function",
          "args": [
            "wakeup_trace",
            "CALLER_ADDR0",
            "CALLER_ADDR1",
            "flags",
            "pc"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "320-329",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define __trace_function trace_function\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->trace_buffer.data",
            "wakeup_cpu"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tracer_enabled || next != wakeup_task"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled != 1"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->trace_buffer.data",
            "cpu"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tracer_enabled"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_record_cmdline",
          "args": [
            "prev"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_record_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2108-2111",
          "snippet": "void tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define __trace_function trace_function\n\nstatic struct trace_array\t*wakeup_trace;\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void notrace\nprobe_wakeup_sched_switch(void *ignore, bool preempt,\n\t\t\t  struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array_cpu *data;\n\tu64 T0, T1, delta;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\ttracing_record_cmdline(prev);\n\n\tif (unlikely(!tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * When we start a new trace, we set wakeup_task to NULL\n\t * and then set tracer_enabled = 1. We want to make sure\n\t * that another CPU does not see the tracer_enabled = 1\n\t * and the wakeup_task with an older task, that might\n\t * actually be the same as next.\n\t */\n\tsmp_rmb();\n\n\tif (next != wakeup_task)\n\t\treturn;\n\n\tpc = preempt_count();\n\n\t/* disable local data, not wakeup_cpu data */\n\tcpu = raw_smp_processor_id();\n\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled);\n\tif (likely(disabled != 1))\n\t\tgoto out;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\n\t/* We could race with grabbing wakeup_lock */\n\tif (unlikely(!tracer_enabled || next != wakeup_task))\n\t\tgoto out_unlock;\n\n\t/* The task we are waiting for is waking up */\n\tdata = per_cpu_ptr(wakeup_trace->trace_buffer.data, wakeup_cpu);\n\n\t__trace_function(wakeup_trace, CALLER_ADDR0, CALLER_ADDR1, flags, pc);\n\ttracing_sched_switch_trace(wakeup_trace, prev, next, flags, pc);\n\n\tT0 = data->preempt_timestamp;\n\tT1 = ftrace_now(cpu);\n\tdelta = T1-T0;\n\n\tif (!report_latency(wakeup_trace, delta))\n\t\tgoto out_unlock;\n\n\tif (likely(!is_tracing_stopped())) {\n\t\twakeup_trace->max_latency = delta;\n\t\tupdate_max_tr(wakeup_trace, wakeup_task, wakeup_cpu);\n\t}\n\nout_unlock:\n\t__wakeup_reset(wakeup_trace);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\nout:\n\tatomic_dec(&per_cpu_ptr(wakeup_trace->trace_buffer.data, cpu)->disabled);\n}"
  },
  {
    "function_name": "tracing_sched_wakeup_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "411-437",
    "snippet": "static void\ntracing_sched_wakeup_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *wakee,\n\t\t\t   struct task_struct *curr,\n\t\t\t   unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_wakeup;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= curr->pid;\n\tentry->prev_prio\t\t= curr->prio;\n\tentry->prev_state\t\t= task_state_index(curr);\n\tentry->next_pid\t\t\t= wakee->pid;\n\tentry->next_prio\t\t= wakee->prio;\n\tentry->next_state\t\t= task_state_index(wakee);\n\tentry->next_cpu\t\t\t= task_cpu(wakee);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, flags, pc);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "tr",
            "buffer",
            "event",
            "flags",
            "pc"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1250-1256",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "305-316",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "wakee"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_state_index",
          "args": [
            "wakee"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_state_index",
          "args": [
            "curr"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_WAKE",
            "sizeof(*entry)",
            "flags",
            "pc"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\ntracing_sched_wakeup_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *wakee,\n\t\t\t   struct task_struct *curr,\n\t\t\t   unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_wakeup;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= curr->pid;\n\tentry->prev_prio\t\t= curr->prio;\n\tentry->prev_state\t\t= task_state_index(curr);\n\tentry->next_pid\t\t\t= wakee->pid;\n\tentry->next_prio\t\t= wakee->prio;\n\tentry->next_state\t\t= task_state_index(wakee);\n\tentry->next_cpu\t\t\t= task_cpu(wakee);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, flags, pc);\n}"
  },
  {
    "function_name": "tracing_sched_switch_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "383-409",
    "snippet": "static void\ntracing_sched_switch_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *prev,\n\t\t\t   struct task_struct *next,\n\t\t\t   unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_context_switch;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= prev->pid;\n\tentry->prev_prio\t\t= prev->prio;\n\tentry->prev_state\t\t= task_state_index(prev);\n\tentry->next_pid\t\t\t= next->pid;\n\tentry->next_prio\t\t= next->prio;\n\tentry->next_state\t\t= task_state_index(next);\n\tentry->next_cpu\t= task_cpu(next);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, flags, pc);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "tr",
            "buffer",
            "event",
            "flags",
            "pc"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1250-1256",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "305-316",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "next"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_state_index",
          "args": [
            "next"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_state_index",
          "args": [
            "prev"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_CTX",
            "sizeof(*entry)",
            "flags",
            "pc"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\ntracing_sched_switch_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *prev,\n\t\t\t   struct task_struct *next,\n\t\t\t   unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_context_switch;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= prev->pid;\n\tentry->prev_prio\t\t= prev->prio;\n\tentry->prev_state\t\t= task_state_index(prev);\n\tentry->next_pid\t\t\t= next->pid;\n\tentry->next_prio\t\t= next->prio;\n\tentry->next_state\t\t= task_state_index(next);\n\tentry->next_cpu\t= task_cpu(next);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, flags, pc);\n}"
  },
  {
    "function_name": "probe_wakeup_migrate_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "374-381",
    "snippet": "static void\nprobe_wakeup_migrate_task(void *ignore, struct task_struct *task, int cpu)\n{\n\tif (task != wakeup_task)\n\t\treturn;\n\n\twakeup_current_cpu = cpu;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_current_cpu;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\n\nstatic void\nprobe_wakeup_migrate_task(void *ignore, struct task_struct *task, int cpu)\n{\n\tif (task != wakeup_task)\n\t\treturn;\n\n\twakeup_current_cpu = cpu;\n}"
  },
  {
    "function_name": "report_latency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "362-372",
    "snippet": "static bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "wakeup_print_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "352-355",
    "snippet": "static void wakeup_print_header(struct seq_file *s)\n{\n\ttrace_latency_header(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_latency_header",
          "args": [
            "s"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "trace_latency_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3681-3695",
          "snippet": "void trace_latency_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t/* print nothing if the buffers are empty */\n\tif (trace_empty(iter))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT)\n\t\tprint_trace_header(m, iter);\n\n\tif (!(tr->trace_flags & TRACE_ITER_VERBOSE))\n\t\tprint_lat_help_header(m);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_latency_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t/* print nothing if the buffers are empty */\n\tif (trace_empty(iter))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT)\n\t\tprint_trace_header(m, iter);\n\n\tif (!(tr->trace_flags & TRACE_ITER_VERBOSE))\n\t\tprint_lat_help_header(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_print_header(struct seq_file *s)\n{\n\ttrace_latency_header(s);\n}"
  },
  {
    "function_name": "wakeup_print_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "347-350",
    "snippet": "static void wakeup_print_header(struct seq_file *s)\n{\n\ttrace_default_header(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_default_header",
          "args": [
            "s"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "trace_default_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3697-3723",
          "snippet": "void trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->trace_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->trace_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->trace_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->trace_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_print_header(struct seq_file *s)\n{\n\ttrace_default_header(s);\n}"
  },
  {
    "function_name": "wakeup_graph_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "346-346",
    "snippet": "static void wakeup_graph_return(struct ftrace_graph_ret *trace) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_graph_return(struct ftrace_graph_ret *trace) { }"
  },
  {
    "function_name": "wakeup_graph_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "342-345",
    "snippet": "static int wakeup_graph_entry(struct ftrace_graph_ent *trace)\n{\n\treturn -1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int wakeup_graph_entry(struct ftrace_graph_ent *trace)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "wakeup_trace_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "339-339",
    "snippet": "static void wakeup_trace_close(struct trace_iterator *iter) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_trace_close(struct trace_iterator *iter) { }"
  },
  {
    "function_name": "wakeup_trace_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "338-338",
    "snippet": "static void wakeup_trace_open(struct trace_iterator *iter) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_trace_open(struct trace_iterator *iter) { }"
  },
  {
    "function_name": "wakeup_print_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "333-336",
    "snippet": "static enum print_line_t wakeup_print_line(struct trace_iterator *iter)\n{\n\treturn TRACE_TYPE_UNHANDLED;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic enum print_line_t wakeup_print_line(struct trace_iterator *iter)\n{\n\treturn TRACE_TYPE_UNHANDLED;\n}"
  },
  {
    "function_name": "__trace_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "320-329",
    "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define __trace_function trace_function"
    ],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "flags",
            "pc"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "320-329",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "trace_graph_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "flags",
            "pc"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "trace_graph_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "448-454",
          "snippet": "void\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned long flags, int pc)\n{\n\t__trace_graph_function(tr, ip, flags, pc);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned long flags, int pc)\n{\n\t__trace_graph_function(tr, ip, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define __trace_function trace_function\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}"
  },
  {
    "function_name": "wakeup_print_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "312-318",
    "snippet": "static void wakeup_print_header(struct seq_file *s)\n{\n\tif (is_graph(wakeup_trace))\n\t\tprint_graph_headers_flags(s, GRAPH_TRACER_FLAGS);\n\telse\n\t\ttrace_default_header(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_ABS_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION)"
    ],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_default_header",
          "args": [
            "s"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "trace_default_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3697-3723",
          "snippet": "void trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->trace_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->trace_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->trace_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->trace_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_headers_flags",
          "args": [
            "s",
            "GRAPH_TRACER_FLAGS"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_headers_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1377-1394",
          "snippet": "void print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "wakeup_trace"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_ABS_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION)\n\nstatic struct trace_array\t*wakeup_trace;\n\nstatic void wakeup_print_header(struct seq_file *s)\n{\n\tif (is_graph(wakeup_trace))\n\t\tprint_graph_headers_flags(s, GRAPH_TRACER_FLAGS);\n\telse\n\t\ttrace_default_header(s);\n}"
  },
  {
    "function_name": "wakeup_print_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "300-310",
    "snippet": "static enum print_line_t wakeup_print_line(struct trace_iterator *iter)\n{\n\t/*\n\t * In graph mode call the graph tracer output function,\n\t * otherwise go with the TRACE_FN event handler\n\t */\n\tif (is_graph(iter->tr))\n\t\treturn print_graph_function_flags(iter, GRAPH_TRACER_FLAGS);\n\n\treturn TRACE_TYPE_UNHANDLED;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_ABS_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION)"
    ],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_function_flags",
          "args": [
            "iter",
            "GRAPH_TRACER_FLAGS"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_function_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1240-1299",
          "snippet": "enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nenum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "iter->tr"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_ABS_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION)\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic enum print_line_t wakeup_print_line(struct trace_iterator *iter)\n{\n\t/*\n\t * In graph mode call the graph tracer output function,\n\t * otherwise go with the TRACE_FN event handler\n\t */\n\tif (is_graph(iter->tr))\n\t\treturn print_graph_function_flags(iter, GRAPH_TRACER_FLAGS);\n\n\treturn TRACE_TYPE_UNHANDLED;\n}"
  },
  {
    "function_name": "wakeup_trace_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "290-294",
    "snippet": "static void wakeup_trace_close(struct trace_iterator *iter)\n{\n\tif (iter->private)\n\t\tgraph_trace_close(iter);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_trace_close",
          "args": [
            "iter"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1438-1446",
          "snippet": "void graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_trace_close(struct trace_iterator *iter)\n{\n\tif (iter->private)\n\t\tgraph_trace_close(iter);\n}"
  },
  {
    "function_name": "wakeup_trace_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "284-288",
    "snippet": "static void wakeup_trace_open(struct trace_iterator *iter)\n{\n\tif (is_graph(iter->tr))\n\t\tgraph_trace_open(iter);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_trace_open",
          "args": [
            "iter"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1396-1436",
          "snippet": "void graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "iter->tr"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_trace_open(struct trace_iterator *iter)\n{\n\tif (is_graph(iter->tr))\n\t\tgraph_trace_open(iter);\n}"
  },
  {
    "function_name": "wakeup_graph_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "266-282",
    "snippet": "static void wakeup_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tint pc;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &pc))\n\t\treturn;\n\n\tlocal_save_flags(flags);\n\t__trace_graph_return(tr, trace, flags, pc);\n\tatomic_dec(&data->disabled);\n\n\tpreempt_enable_notrace();\n\treturn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_return",
          "args": [
            "tr",
            "trace",
            "flags",
            "pc"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "456-474",
          "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_prolog_preempt_disable",
          "args": [
            "tr",
            "&data",
            "&pc"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_preempt_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "74-105",
          "snippet": "static int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    int *pc)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*pc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_current_cpu;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    int *pc)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*pc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tint pc;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &pc))\n\t\treturn;\n\n\tlocal_save_flags(flags);\n\t__trace_graph_return(tr, trace, flags, pc);\n\tatomic_dec(&data->disabled);\n\n\tpreempt_enable_notrace();\n\treturn;\n}"
  },
  {
    "function_name": "wakeup_graph_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "236-264",
    "snippet": "static int wakeup_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tint pc, ret = 0;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func))\n\t\treturn 1;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &pc))\n\t\treturn 0;\n\n\tlocal_save_flags(flags);\n\tret = __trace_graph_entry(tr, trace, flags, pc);\n\tatomic_dec(&data->disabled);\n\tpreempt_enable_notrace();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_entry",
          "args": [
            "tr",
            "trace",
            "flags",
            "pc"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "345-365",
          "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_prolog_preempt_disable",
          "args": [
            "tr",
            "&data",
            "&pc"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_preempt_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "74-105",
          "snippet": "static int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    int *pc)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*pc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_current_cpu;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    int *pc)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*pc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_notrace_addr",
          "args": [
            "trace->func"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_notrace_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "893-896",
          "snippet": "static inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_ignore_func",
          "args": [
            "trace"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_ignore_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "901-907",
          "snippet": "static inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace->depth || ftrace_graph_addr(trace->func)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace->depth || ftrace_graph_addr(trace->func)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tint pc, ret = 0;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func))\n\t\treturn 1;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &pc))\n\t\treturn 0;\n\n\tlocal_save_flags(flags);\n\tret = __trace_graph_entry(tr, trace, flags, pc);\n\tatomic_dec(&data->disabled);\n\tpreempt_enable_notrace();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wakeup_display_graph",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "223-234",
    "snippet": "static int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_func_tracer(tr, !set);\n\n\twakeup_reset(wakeup_trace);\n\ttr->max_latency = 0;\n\n\treturn start_func_tracer(tr, set);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_func_tracer",
          "args": [
            "tr",
            "set"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "start_func_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "201-213",
          "snippet": "static int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_reset",
          "args": [
            "wakeup_trace"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "520-531",
          "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_func_tracer",
          "args": [
            "tr",
            "!set"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "stop_func_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "215-220",
          "snippet": "static void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_func_tracer(tr, !set);\n\n\twakeup_reset(wakeup_trace);\n\ttr->max_latency = 0;\n\n\treturn start_func_tracer(tr, set);\n}"
  },
  {
    "function_name": "stop_func_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "215-220",
    "snippet": "static void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_wakeup_function",
          "args": [
            "tr",
            "graph"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_wakeup_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "179-179",
          "snippet": "static void unregister_wakeup_function(struct trace_array *tr, int graph) { }",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void unregister_wakeup_function(struct trace_array *tr, int graph) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}"
  },
  {
    "function_name": "start_func_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "201-213",
    "snippet": "static int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_is_enabled",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "596-605",
          "snippet": "int tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_wakeup_function",
          "args": [
            "tr",
            "graph",
            "0"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "register_wakeup_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "175-178",
          "snippet": "static int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wakeup_flag_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "186-199",
    "snippet": "static int wakeup_flag_changed(struct trace_array *tr, u32 mask, int set)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\n\tif (wakeup_function_set(tr, mask, set))\n\t\treturn 0;\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (mask & TRACE_ITER_DISPLAY_GRAPH)\n\t\treturn wakeup_display_graph(tr, set);\n#endif\n\n\treturn trace_keep_overwrite(tracer, mask, set);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_keep_overwrite",
          "args": [
            "tracer",
            "mask",
            "set"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "trace_keep_overwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "4344-4350",
          "snippet": "int trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & TRACE_ITER_OVERWRITE) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & TRACE_ITER_OVERWRITE) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_display_graph",
          "args": [
            "tr",
            "set"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_display_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "223-234",
          "snippet": "static int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_func_tracer(tr, !set);\n\n\twakeup_reset(wakeup_trace);\n\ttr->max_latency = 0;\n\n\treturn start_func_tracer(tr, set);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*wakeup_trace;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_func_tracer(tr, !set);\n\n\twakeup_reset(wakeup_trace);\n\ttr->max_latency = 0;\n\n\treturn start_func_tracer(tr, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_function_set",
          "args": [
            "tr",
            "mask",
            "set"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_function_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "180-183",
          "snippet": "static int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_flag_changed(struct trace_array *tr, u32 mask, int set)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\n\tif (wakeup_function_set(tr, mask, set))\n\t\treturn 0;\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (mask & TRACE_ITER_DISPLAY_GRAPH)\n\t\treturn wakeup_display_graph(tr, set);\n#endif\n\n\treturn trace_keep_overwrite(tracer, mask, set);\n}"
  },
  {
    "function_name": "wakeup_function_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "180-183",
    "snippet": "static int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_wakeup_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "179-179",
    "snippet": "static void unregister_wakeup_function(struct trace_array *tr, int graph) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void unregister_wakeup_function(struct trace_array *tr, int graph) { }"
  },
  {
    "function_name": "register_wakeup_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "175-178",
    "snippet": "static int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "wakeup_function_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "163-173",
    "snippet": "static int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\tif (!(mask & TRACE_ITER_FUNCTION))\n\t\treturn 0;\n\n\tif (set)\n\t\tregister_wakeup_function(tr, is_graph(tr), 1);\n\telse\n\t\tunregister_wakeup_function(tr, is_graph(tr));\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_wakeup_function",
          "args": [
            "tr",
            "is_graph(tr)"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_wakeup_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "179-179",
          "snippet": "static void unregister_wakeup_function(struct trace_array *tr, int graph) { }",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void unregister_wakeup_function(struct trace_array *tr, int graph) { }"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_wakeup_function",
          "args": [
            "tr",
            "is_graph(tr)",
            "1"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "register_wakeup_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "175-178",
          "snippet": "static int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\tif (!(mask & TRACE_ITER_FUNCTION))\n\t\treturn 0;\n\n\tif (set)\n\t\tregister_wakeup_function(tr, is_graph(tr), 1);\n\telse\n\t\tunregister_wakeup_function(tr, is_graph(tr));\n\treturn 1;\n}"
  },
  {
    "function_name": "unregister_wakeup_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "150-161",
    "snippet": "static void unregister_wakeup_function(struct trace_array *tr, int graph)\n{\n\tif (!function_enabled)\n\t\treturn;\n\n\tif (graph)\n\t\tunregister_ftrace_graph();\n\telse\n\t\tunregister_ftrace_function(tr->ops);\n\n\tfunction_enabled = false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_graph",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "7002-7019",
          "snippet": "void unregister_ftrace_graph(void)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = (trace_func_graph_ret_t)ftrace_stub;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nvoid unregister_ftrace_graph(void)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = (trace_func_graph_ret_t)ftrace_stub;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void unregister_wakeup_function(struct trace_array *tr, int graph)\n{\n\tif (!function_enabled)\n\t\treturn;\n\n\tif (graph)\n\t\tunregister_ftrace_graph();\n\telse\n\t\tunregister_ftrace_function(tr->ops);\n\n\tfunction_enabled = false;\n}"
  },
  {
    "function_name": "register_wakeup_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "130-148",
    "snippet": "static int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\tint ret;\n\n\t/* 'set' is set if TRACE_ITER_FUNCTION is about to be set */\n\tif (function_enabled || (!set && !(tr->trace_flags & TRACE_ITER_FUNCTION)))\n\t\treturn 0;\n\n\tif (graph)\n\t\tret = register_ftrace_graph(&wakeup_graph_return,\n\t\t\t\t\t    &wakeup_graph_entry);\n\telse\n\t\tret = register_ftrace_function(tr->ops);\n\n\tif (!ret)\n\t\tfunction_enabled = true;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_graph",
          "args": [
            "&wakeup_graph_return",
            "&wakeup_graph_entry"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6962-7000",
          "snippet": "int register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nint register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\tint ret;\n\n\t/* 'set' is set if TRACE_ITER_FUNCTION is about to be set */\n\tif (function_enabled || (!set && !(tr->trace_flags & TRACE_ITER_FUNCTION)))\n\t\treturn 0;\n\n\tif (graph)\n\t\tret = register_ftrace_graph(&wakeup_graph_return,\n\t\t\t\t\t    &wakeup_graph_entry);\n\telse\n\t\tret = register_ftrace_function(tr->ops);\n\n\tif (!ret)\n\t\tfunction_enabled = true;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wakeup_tracer_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "110-128",
    "snippet": "static void\nwakeup_tracer_call(unsigned long ip, unsigned long parent_ip,\n\t\t   struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tint pc;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &pc))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\ttrace_function(tr, ip, parent_ip, flags, pc);\n\tlocal_irq_restore(flags);\n\n\tatomic_dec(&data->disabled);\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "flags",
            "pc"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "320-329",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define __trace_function trace_function\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned long flags, int pc)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, flags, pc);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_prolog_preempt_disable",
          "args": [
            "tr",
            "&data",
            "&pc"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_preempt_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "74-105",
          "snippet": "static int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    int *pc)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*pc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_current_cpu;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    int *pc)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*pc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\nwakeup_tracer_call(unsigned long ip, unsigned long parent_ip,\n\t\t   struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tint pc;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &pc))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\ttrace_function(tr, ip, parent_ip, flags, pc);\n\tlocal_irq_restore(flags);\n\n\tatomic_dec(&data->disabled);\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "func_prolog_preempt_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "74-105",
    "snippet": "static int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    int *pc)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*pc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_current_cpu;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&(*data)->disabled"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "disabled != 1"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&(*data)->disabled"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->trace_buffer.data",
            "cpu"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!wakeup_task"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    int *pc)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*pc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}"
  },
  {
    "function_name": "wakeup_display_graph",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "45-48",
    "snippet": "static inline int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic inline int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\treturn 0;\n}"
  }
]