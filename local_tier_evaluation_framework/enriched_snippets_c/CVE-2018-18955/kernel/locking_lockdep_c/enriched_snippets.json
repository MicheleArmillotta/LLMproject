[
  {
    "function_name": "lockdep_rcu_suspicious",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4437-4481",
    "snippet": "void lockdep_rcu_suspicious(const char *file, const int line, const char *s)\n{\n\tstruct task_struct *curr = current;\n\n\t/* Note: the following can be executed concurrently, so be careful. */\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================\\n\");\n\tpr_warn(\"WARNING: suspicious RCU usage\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------\\n\");\n\tpr_warn(\"%s:%d %s!\\n\", file, line, s);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tpr_warn(\"\\n%srcu_scheduler_active = %d, debug_locks = %d\\n\",\n\t       !rcu_lockdep_current_cpu_online()\n\t\t\t? \"RCU used illegally from offline CPU!\\n\"\n\t\t\t: !rcu_is_watching()\n\t\t\t\t? \"RCU used illegally from idle CPU!\\n\"\n\t\t\t\t: \"\",\n\t       rcu_scheduler_active, debug_locks);\n\n\t/*\n\t * If a CPU is in the RCU-free window in idle (ie: in the section\n\t * between rcu_idle_enter() and rcu_idle_exit(), then RCU\n\t * considers that CPU to be in an \"extended quiescent state\",\n\t * which means that RCU will be completely ignoring that CPU.\n\t * Therefore, rcu_read_lock() and friends have absolutely no\n\t * effect on a CPU running in that state. In other words, even if\n\t * such an RCU-idle CPU has called rcu_read_lock(), RCU might well\n\t * delete data structures out from under it.  RCU really has no\n\t * choice here: we need to keep an RCU-free window in idle where\n\t * the CPU may possibly enter into low power mode. This way we can\n\t * notice an extended quiescent state to other CPUs that started a grace\n\t * period. Otherwise we would delay any grace period as long as we run\n\t * in the idle task.\n\t *\n\t * So complain bitterly if someone does call rcu_read_lock(),\n\t * rcu_read_lock_bh() and so on from extended quiescent states.\n\t */\n\tif (!rcu_is_watching())\n\t\tpr_warn(\"RCU used illegally from extended quiescent state!\\n\");\n\n\tlockdep_print_held_locks(curr);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 4479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 4478
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"RCU used illegally from extended quiescent state!\\n\""
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "901-909",
          "snippet": "bool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n%srcu_scheduler_active = %d, debug_locks = %d\\n\"",
            "!rcu_lockdep_current_cpu_online()\n\t\t\t? \"RCU used illegally from offline CPU!\\n\"\n\t\t\t: !rcu_is_watching()\n\t\t\t\t? \"RCU used illegally from idle CPU!\\n\"\n\t\t\t\t: \"\"",
            "rcu_scheduler_active",
            "debug_locks"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_current_cpu_online",
          "args": [],
          "line": 4450
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_current_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "945-960",
          "snippet": "bool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp))\n\t\tret = true;\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static int rcu_scheduler_fully_active",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic int rcu_scheduler_fully_active;\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp))\n\t\tret = true;\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\\n\""
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s:%d %s!\\n\"",
            "file",
            "line",
            "s"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-----------------------------\\n\""
          ],
          "line": 4446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: suspicious RCU usage\\n\""
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=============================\\n\""
          ],
          "line": 4443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_rcu_suspicious(const char *file, const int line, const char *s)\n{\n\tstruct task_struct *curr = current;\n\n\t/* Note: the following can be executed concurrently, so be careful. */\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================\\n\");\n\tpr_warn(\"WARNING: suspicious RCU usage\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------\\n\");\n\tpr_warn(\"%s:%d %s!\\n\", file, line, s);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tpr_warn(\"\\n%srcu_scheduler_active = %d, debug_locks = %d\\n\",\n\t       !rcu_lockdep_current_cpu_online()\n\t\t\t? \"RCU used illegally from offline CPU!\\n\"\n\t\t\t: !rcu_is_watching()\n\t\t\t\t? \"RCU used illegally from idle CPU!\\n\"\n\t\t\t\t: \"\",\n\t       rcu_scheduler_active, debug_locks);\n\n\t/*\n\t * If a CPU is in the RCU-free window in idle (ie: in the section\n\t * between rcu_idle_enter() and rcu_idle_exit(), then RCU\n\t * considers that CPU to be in an \"extended quiescent state\",\n\t * which means that RCU will be completely ignoring that CPU.\n\t * Therefore, rcu_read_lock() and friends have absolutely no\n\t * effect on a CPU running in that state. In other words, even if\n\t * such an RCU-idle CPU has called rcu_read_lock(), RCU might well\n\t * delete data structures out from under it.  RCU really has no\n\t * choice here: we need to keep an RCU-free window in idle where\n\t * the CPU may possibly enter into low power mode. This way we can\n\t * notice an extended quiescent state to other CPUs that started a grace\n\t * period. Otherwise we would delay any grace period as long as we run\n\t * in the idle task.\n\t *\n\t * So complain bitterly if someone does call rcu_read_lock(),\n\t * rcu_read_lock_bh() and so on from extended quiescent states.\n\t */\n\tif (!rcu_is_watching())\n\t\tpr_warn(\"RCU used illegally from extended quiescent state!\\n\");\n\n\tlockdep_print_held_locks(curr);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "lockdep_sys_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4413-4435",
    "snippet": "void lockdep_sys_exit(void)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(curr->lockdep_depth)) {\n\t\tif (!debug_locks_off())\n\t\t\treturn;\n\t\tpr_warn(\"\\n\");\n\t\tpr_warn(\"================================================\\n\");\n\t\tpr_warn(\"WARNING: lock held when returning to user space!\\n\");\n\t\tprint_kernel_ident();\n\t\tpr_warn(\"------------------------------------------------\\n\");\n\t\tpr_warn(\"%s/%d is leaving the kernel with locks still held!\\n\",\n\t\t\t\tcurr->comm, curr->pid);\n\t\tlockdep_print_held_locks(curr);\n\t}\n\n\t/*\n\t * The lock history for each syscall should be independent. So wipe the\n\t * slate clean on return to userspace.\n\t */\n\tlockdep_invariant_state(false);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_invariant_state",
          "args": [
            "false"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is leaving the kernel with locks still held!\\n\"",
            "curr->comm",
            "curr->pid"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"------------------------------------------------\\n\""
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 4423
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: lock held when returning to user space!\\n\""
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"================================================\\n\""
          ],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "curr->lockdep_depth"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_sys_exit(void)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(curr->lockdep_depth)) {\n\t\tif (!debug_locks_off())\n\t\t\treturn;\n\t\tpr_warn(\"\\n\");\n\t\tpr_warn(\"================================================\\n\");\n\t\tpr_warn(\"WARNING: lock held when returning to user space!\\n\");\n\t\tprint_kernel_ident();\n\t\tpr_warn(\"------------------------------------------------\\n\");\n\t\tpr_warn(\"%s/%d is leaving the kernel with locks still held!\\n\",\n\t\t\t\tcurr->comm, curr->pid);\n\t\tlockdep_print_held_locks(curr);\n\t}\n\n\t/*\n\t * The lock history for each syscall should be independent. So wipe the\n\t * slate clean on return to userspace.\n\t */\n\tlockdep_invariant_state(false);\n}"
  },
  {
    "function_name": "debug_show_held_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4403-4410",
    "snippet": "void debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "task"
          ],
          "line": 4409
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"INFO: lockdep is turned off.\\n\""
          ],
          "line": 4406
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}"
  },
  {
    "function_name": "debug_show_all_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4373-4395",
    "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=============================================\\n\\n\""
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4391
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_all_softlockup_watchdogs",
          "args": [],
          "line": 4389
        },
        "resolved": true,
        "details": {
          "function_name": "touch_all_softlockup_watchdogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "280-296",
          "snippet": "void touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tper_cpu(watchdog_touch_ts, cpu) = 0;\n\twq_watchdog_touch(-1);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);",
            "struct cpumask watchdog_allowed_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nstruct cpumask watchdog_allowed_mask;\n\nvoid touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tper_cpu(watchdog_touch_ts, cpu) = 0;\n\twq_watchdog_touch(-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "p"
          ],
          "line": 4387
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4383
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nShowing all locks held in the system:\\n\""
          ],
          "line": 4381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"INFO: lockdep is turned off.\\n\""
          ],
          "line": 4378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
  },
  {
    "function_name": "debug_check_no_locks_held",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4365-4369",
    "snippet": "void debug_check_no_locks_held(void)\n{\n\tif (unlikely(current->lockdep_depth > 0))\n\t\tprint_held_locks_bug();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_held_locks_bug",
          "args": [],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "print_held_locks_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4347-4363",
          "snippet": "static void print_held_locks_bug(void)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"====================================\\n\");\n\tpr_warn(\"WARNING: %s/%d still has locks held!\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------\\n\");\n\tlockdep_print_held_locks(current);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_held_locks_bug(void)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"====================================\\n\");\n\tpr_warn(\"WARNING: %s/%d still has locks held!\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------\\n\");\n\tlockdep_print_held_locks(current);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_depth > 0"
          ],
          "line": 4367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_held(void)\n{\n\tif (unlikely(current->lockdep_depth > 0))\n\t\tprint_held_locks_bug();\n}"
  },
  {
    "function_name": "print_held_locks_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4347-4363",
    "snippet": "static void print_held_locks_bug(void)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"====================================\\n\");\n\tpr_warn(\"WARNING: %s/%d still has locks held!\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------\\n\");\n\tlockdep_print_held_locks(current);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "current"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"------------------------------------\\n\""
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 4358
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: %s/%d still has locks held!\\n\"",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 4356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 4357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"====================================\\n\""
          ],
          "line": 4355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_held_locks_bug(void)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"====================================\\n\");\n\tpr_warn(\"WARNING: %s/%d still has locks held!\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------\\n\");\n\tlockdep_print_held_locks(current);\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "debug_check_no_locks_freed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4322-4344",
    "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_freed_lock_bug",
          "args": [
            "curr",
            "mem_from",
            "mem_from + mem_len",
            "hlock"
          ],
          "line": 4340
        },
        "resolved": true,
        "details": {
          "function_name": "print_freed_lock_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4287-4308",
          "snippet": "static void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=========================\\n\");\n\tpr_warn(\"WARNING: held lock freed!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------\\n\");\n\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",\n\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\n\tprint_lock(hlock);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=========================\\n\");\n\tpr_warn(\"WARNING: held lock freed!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------\\n\");\n\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",\n\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\n\tprint_lock(hlock);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "not_in_range",
          "args": [
            "mem_from",
            "mem_len",
            "hlock->instance",
            "sizeof(*hlock->instance)"
          ],
          "line": 4336
        },
        "resolved": true,
        "details": {
          "function_name": "not_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4310-4315",
          "snippet": "static inline int not_in_range(const void* mem_from, unsigned long mem_len,\n\t\t\t\tconst void* lock_from, unsigned long lock_len)\n{\n\treturn lock_from + lock_len <= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int not_in_range(const void* mem_from, unsigned long mem_len,\n\t\t\t\tconst void* lock_from, unsigned long lock_len)\n{\n\treturn lock_from + lock_len <= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 4329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "not_in_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4310-4315",
    "snippet": "static inline int not_in_range(const void* mem_from, unsigned long mem_len,\n\t\t\t\tconst void* lock_from, unsigned long lock_len)\n{\n\treturn lock_from + lock_len <= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int not_in_range(const void* mem_from, unsigned long mem_len,\n\t\t\t\tconst void* lock_from, unsigned long lock_len)\n{\n\treturn lock_from + lock_len <= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}"
  },
  {
    "function_name": "print_freed_lock_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4287-4308",
    "snippet": "static void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=========================\\n\");\n\tpr_warn(\"WARNING: held lock freed!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------\\n\");\n\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",\n\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\n\tprint_lock(hlock);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 4306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 4304
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "hlock"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\"",
            "curr->comm",
            "task_pid_nr(curr)",
            "mem_from",
            "mem_to-1"
          ],
          "line": 4301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-------------------------\\n\""
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 4299
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: held lock freed!\\n\""
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=========================\\n\""
          ],
          "line": 4297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 4296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=========================\\n\");\n\tpr_warn(\"WARNING: held lock freed!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------\\n\");\n\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",\n\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\n\tprint_lock(hlock);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "lockdep_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4259-4285",
    "snippet": "void __init lockdep_init(void)\n{\n\tprintk(\"Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\\n\");\n\n\tprintk(\"... MAX_LOCKDEP_SUBCLASSES:  %lu\\n\", MAX_LOCKDEP_SUBCLASSES);\n\tprintk(\"... MAX_LOCK_DEPTH:          %lu\\n\", MAX_LOCK_DEPTH);\n\tprintk(\"... MAX_LOCKDEP_KEYS:        %lu\\n\", MAX_LOCKDEP_KEYS);\n\tprintk(\"... CLASSHASH_SIZE:          %lu\\n\", CLASSHASH_SIZE);\n\tprintk(\"... MAX_LOCKDEP_ENTRIES:     %lu\\n\", MAX_LOCKDEP_ENTRIES);\n\tprintk(\"... MAX_LOCKDEP_CHAINS:      %lu\\n\", MAX_LOCKDEP_CHAINS);\n\tprintk(\"... CHAINHASH_SIZE:          %lu\\n\", CHAINHASH_SIZE);\n\n\tprintk(\" memory used by lock dependency info: %lu kB\\n\",\n\t\t(sizeof(struct lock_class) * MAX_LOCKDEP_KEYS +\n\t\tsizeof(struct list_head) * CLASSHASH_SIZE +\n\t\tsizeof(struct lock_list) * MAX_LOCKDEP_ENTRIES +\n\t\tsizeof(struct lock_chain) * MAX_LOCKDEP_CHAINS +\n\t\tsizeof(struct list_head) * CHAINHASH_SIZE\n#ifdef CONFIG_PROVE_LOCKING\n\t\t+ sizeof(struct circular_queue)\n#endif\n\t\t) / 1024\n\t\t);\n\n\tprintk(\" per task-struct memory footprint: %lu bytes\\n\",\n\t\tsizeof(struct held_lock) * MAX_LOCK_DEPTH);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CHAINHASH_SIZE\t\t(1UL << CHAINHASH_BITS)",
      "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" per task-struct memory footprint: %lu bytes\\n\"",
            "sizeof(struct held_lock) * MAX_LOCK_DEPTH"
          ],
          "line": 4283
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\\n\""
          ],
          "line": 4261
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAINHASH_SIZE\t\t(1UL << CHAINHASH_BITS)\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nvoid __init lockdep_init(void)\n{\n\tprintk(\"Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\\n\");\n\n\tprintk(\"... MAX_LOCKDEP_SUBCLASSES:  %lu\\n\", MAX_LOCKDEP_SUBCLASSES);\n\tprintk(\"... MAX_LOCK_DEPTH:          %lu\\n\", MAX_LOCK_DEPTH);\n\tprintk(\"... MAX_LOCKDEP_KEYS:        %lu\\n\", MAX_LOCKDEP_KEYS);\n\tprintk(\"... CLASSHASH_SIZE:          %lu\\n\", CLASSHASH_SIZE);\n\tprintk(\"... MAX_LOCKDEP_ENTRIES:     %lu\\n\", MAX_LOCKDEP_ENTRIES);\n\tprintk(\"... MAX_LOCKDEP_CHAINS:      %lu\\n\", MAX_LOCKDEP_CHAINS);\n\tprintk(\"... CHAINHASH_SIZE:          %lu\\n\", CHAINHASH_SIZE);\n\n\tprintk(\" memory used by lock dependency info: %lu kB\\n\",\n\t\t(sizeof(struct lock_class) * MAX_LOCKDEP_KEYS +\n\t\tsizeof(struct list_head) * CLASSHASH_SIZE +\n\t\tsizeof(struct lock_list) * MAX_LOCKDEP_ENTRIES +\n\t\tsizeof(struct lock_chain) * MAX_LOCKDEP_CHAINS +\n\t\tsizeof(struct list_head) * CHAINHASH_SIZE\n#ifdef CONFIG_PROVE_LOCKING\n\t\t+ sizeof(struct circular_queue)\n#endif\n\t\t) / 1024\n\t\t);\n\n\tprintk(\" per task-struct memory footprint: %lu bytes\\n\",\n\t\tsizeof(struct held_lock) * MAX_LOCK_DEPTH);\n}"
  },
  {
    "function_name": "lockdep_reset_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4207-4257",
    "snippet": "void lockdep_reset_lock(struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tunsigned long flags;\n\tint i, j;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\n\t/*\n\t * Remove all classes this lock might have:\n\t */\n\tfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\n\t\t/*\n\t\t * If the class exists we look it up and zap it:\n\t\t */\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(class);\n\t}\n\t/*\n\t * Debug check: in the end all mapped classes should\n\t * be gone.\n\t */\n\tlocked = graph_lock();\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tint match = 0;\n\n\t\t\tfor (j = 0; j < NR_LOCKDEP_CACHING_CLASSES; j++)\n\t\t\t\tmatch |= class == lock->class_cache[j];\n\n\t\t\tif (unlikely(match)) {\n\t\t\t\tif (debug_locks_off_graph_unlock()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We all just reset everything, how did it match?\n\t\t\t\t\t */\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t}\n\t\t\t\tgoto out_restore;\n\t\t\t}\n\t\t}\n\t}\n\tif (locked)\n\t\tgraph_unlock();\n\nout_restore:\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head classhash_table[CLASSHASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 4256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 4253
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 4246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "match"
          ],
          "line": 4241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "class",
            "head",
            "hash_entry"
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 4232
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "85-101",
          "snippet": "static int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zap_class",
          "args": [
            "class"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "zap_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4129-4149",
          "snippet": "static void zap_class(struct lock_class *class)\n{\n\tint i;\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor (i = 0; i < nr_list_entries; i++) {\n\t\tif (list_entries[i].class == class)\n\t\t\tlist_del_rcu(&list_entries[i].entry);\n\t}\n\t/*\n\t * Unhash the class and remove it from the all_lock_classes list:\n\t */\n\thlist_del_rcu(&class->hash_entry);\n\tlist_del_rcu(&class->lock_entry);\n\n\tRCU_INIT_POINTER(class->key, NULL);\n\tRCU_INIT_POINTER(class->name, NULL);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_list_entries;",
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic void zap_class(struct lock_class *class)\n{\n\tint i;\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor (i = 0; i < nr_list_entries; i++) {\n\t\tif (list_entries[i].class == class)\n\t\t\tlist_del_rcu(&list_entries[i].entry);\n\t}\n\t/*\n\t * Unhash the class and remove it from the all_lock_classes list:\n\t */\n\thlist_del_rcu(&class->hash_entry);\n\tlist_del_rcu(&class->lock_entry);\n\n\tRCU_INIT_POINTER(class->key, NULL);\n\tRCU_INIT_POINTER(class->name, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "look_up_lock_class",
          "args": [
            "lock",
            "j"
          ],
          "line": 4224
        },
        "resolved": true,
        "details": {
          "function_name": "look_up_lock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "649-704",
          "snippet": "static inline struct lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\n\nvoid lockdep_reset_lock(struct lockdep_map *lock)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tunsigned long flags;\n\tint i, j;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\n\t/*\n\t * Remove all classes this lock might have:\n\t */\n\tfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\n\t\t/*\n\t\t * If the class exists we look it up and zap it:\n\t\t */\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(class);\n\t}\n\t/*\n\t * Debug check: in the end all mapped classes should\n\t * be gone.\n\t */\n\tlocked = graph_lock();\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tint match = 0;\n\n\t\t\tfor (j = 0; j < NR_LOCKDEP_CACHING_CLASSES; j++)\n\t\t\t\tmatch |= class == lock->class_cache[j];\n\n\t\t\tif (unlikely(match)) {\n\t\t\t\tif (debug_locks_off_graph_unlock()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We all just reset everything, how did it match?\n\t\t\t\t\t */\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t}\n\t\t\t\tgoto out_restore;\n\t\t\t}\n\t\t}\n\t}\n\tif (locked)\n\t\tgraph_unlock();\n\nout_restore:\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lockdep_free_key_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4164-4205",
    "snippet": "void lockdep_free_key_range(void *start, unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tunsigned long flags;\n\tint i;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\tlocked = graph_lock();\n\n\t/*\n\t * Unhash all classes that were created by this module:\n\t */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (within(class->key, start, size))\n\t\t\t\tzap_class(class);\n\t\t\telse if (within(class->name, start, size))\n\t\t\t\tzap_class(class);\n\t\t}\n\t}\n\n\tif (locked)\n\t\tgraph_unlock();\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * Wait for any possible iterators from look_up_lock_class() to pass\n\t * before continuing to free the memory they refer to.\n\t *\n\t * sync_sched() is sufficient because the read-side is IRQ disable.\n\t */\n\tsynchronize_sched();\n\n\t/*\n\t * XXX at this point we could return the resources to the pool;\n\t * instead we leak them. We would need to change to bitmap allocators\n\t * instead of the linear allocators we have now.\n\t */\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head classhash_table[CLASSHASH_SIZE];",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 4198
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zap_class",
          "args": [
            "class"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "zap_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4129-4149",
          "snippet": "static void zap_class(struct lock_class *class)\n{\n\tint i;\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor (i = 0; i < nr_list_entries; i++) {\n\t\tif (list_entries[i].class == class)\n\t\t\tlist_del_rcu(&list_entries[i].entry);\n\t}\n\t/*\n\t * Unhash the class and remove it from the all_lock_classes list:\n\t */\n\thlist_del_rcu(&class->hash_entry);\n\tlist_del_rcu(&class->lock_entry);\n\n\tRCU_INIT_POINTER(class->key, NULL);\n\tRCU_INIT_POINTER(class->name, NULL);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_list_entries;",
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic void zap_class(struct lock_class *class)\n{\n\tint i;\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor (i = 0; i < nr_list_entries; i++) {\n\t\tif (list_entries[i].class == class)\n\t\t\tlist_del_rcu(&list_entries[i].entry);\n\t}\n\t/*\n\t * Unhash the class and remove it from the all_lock_classes list:\n\t */\n\thlist_del_rcu(&class->hash_entry);\n\tlist_del_rcu(&class->lock_entry);\n\n\tRCU_INIT_POINTER(class->key, NULL);\n\tRCU_INIT_POINTER(class->name, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "within",
          "args": [
            "class->name",
            "start",
            "size"
          ],
          "line": 4183
        },
        "resolved": true,
        "details": {
          "function_name": "within",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4151-4154",
          "snippet": "static inline int within(const void *addr, void *start, unsigned long size)\n{\n\treturn addr >= start && addr < start + size;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int within(const void *addr, void *start, unsigned long size)\n{\n\treturn addr >= start && addr < start + size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "class",
            "head",
            "hash_entry"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "85-101",
          "snippet": "static int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CLASSHASH_SIZE\t\t(1UL << CLASSHASH_BITS)\n\nstatic struct hlist_head classhash_table[CLASSHASH_SIZE];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nvoid lockdep_free_key_range(void *start, unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct hlist_head *head;\n\tunsigned long flags;\n\tint i;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\tlocked = graph_lock();\n\n\t/*\n\t * Unhash all classes that were created by this module:\n\t */\n\tfor (i = 0; i < CLASSHASH_SIZE; i++) {\n\t\thead = classhash_table + i;\n\t\thlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (within(class->key, start, size))\n\t\t\t\tzap_class(class);\n\t\t\telse if (within(class->name, start, size))\n\t\t\t\tzap_class(class);\n\t\t}\n\t}\n\n\tif (locked)\n\t\tgraph_unlock();\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * Wait for any possible iterators from look_up_lock_class() to pass\n\t * before continuing to free the memory they refer to.\n\t *\n\t * sync_sched() is sufficient because the read-side is IRQ disable.\n\t */\n\tsynchronize_sched();\n\n\t/*\n\t * XXX at this point we could return the resources to the pool;\n\t * instead we leak them. We would need to change to bitmap allocators\n\t * instead of the linear allocators we have now.\n\t */\n}"
  },
  {
    "function_name": "within",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4151-4154",
    "snippet": "static inline int within(const void *addr, void *start, unsigned long size)\n{\n\treturn addr >= start && addr < start + size;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int within(const void *addr, void *start, unsigned long size)\n{\n\treturn addr >= start && addr < start + size;\n}"
  },
  {
    "function_name": "zap_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4129-4149",
    "snippet": "static void zap_class(struct lock_class *class)\n{\n\tint i;\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor (i = 0; i < nr_list_entries; i++) {\n\t\tif (list_entries[i].class == class)\n\t\t\tlist_del_rcu(&list_entries[i].entry);\n\t}\n\t/*\n\t * Unhash the class and remove it from the all_lock_classes list:\n\t */\n\thlist_del_rcu(&class->hash_entry);\n\tlist_del_rcu(&class->lock_entry);\n\n\tRCU_INIT_POINTER(class->key, NULL);\n\tRCU_INIT_POINTER(class->name, NULL);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_list_entries;",
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "class->name",
            "NULL"
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "class->key",
            "NULL"
          ],
          "line": 4147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&class->lock_entry"
          ],
          "line": 4145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&class->hash_entry"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&list_entries[i].entry"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic void zap_class(struct lock_class *class)\n{\n\tint i;\n\n\t/*\n\t * Remove all dependencies this lock is\n\t * involved in:\n\t */\n\tfor (i = 0; i < nr_list_entries; i++) {\n\t\tif (list_entries[i].class == class)\n\t\t\tlist_del_rcu(&list_entries[i].entry);\n\t}\n\t/*\n\t * Unhash the class and remove it from the all_lock_classes list:\n\t */\n\thlist_del_rcu(&class->hash_entry);\n\tlist_del_rcu(&class->lock_entry);\n\n\tRCU_INIT_POINTER(class->key, NULL);\n\tRCU_INIT_POINTER(class->name, NULL);\n}"
  },
  {
    "function_name": "lockdep_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4110-4127",
    "snippet": "void lockdep_reset(void)\n{\n\tunsigned long flags;\n\tint i;\n\n\traw_local_irq_save(flags);\n\tcurrent->curr_chain_key = 0;\n\tcurrent->lockdep_depth = 0;\n\tcurrent->lockdep_recursion = 0;\n\tmemset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));\n\tnr_hardirq_chains = 0;\n\tnr_softirq_chains = 0;\n\tnr_process_chains = 0;\n\tdebug_locks = 1;\n\tfor (i = 0; i < CHAINHASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(chainhash_table + i);\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CHAINHASH_SIZE\t\t(1UL << CHAINHASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head chainhash_table[CHAINHASH_SIZE];",
      "unsigned int nr_hardirq_chains;",
      "unsigned int nr_softirq_chains;",
      "unsigned int nr_process_chains;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "chainhash_table + i"
          ],
          "line": 4125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "current->held_locks",
            "0",
            "MAX_LOCK_DEPTH*sizeof(struct held_lock)"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CHAINHASH_SIZE\t\t(1UL << CHAINHASH_BITS)\n\nstatic struct hlist_head chainhash_table[CHAINHASH_SIZE];\nunsigned int nr_hardirq_chains;\nunsigned int nr_softirq_chains;\nunsigned int nr_process_chains;\n\nvoid lockdep_reset(void)\n{\n\tunsigned long flags;\n\tint i;\n\n\traw_local_irq_save(flags);\n\tcurrent->curr_chain_key = 0;\n\tcurrent->lockdep_depth = 0;\n\tcurrent->lockdep_recursion = 0;\n\tmemset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));\n\tnr_hardirq_chains = 0;\n\tnr_softirq_chains = 0;\n\tnr_process_chains = 0;\n\tdebug_locks = 1;\n\tfor (i = 0; i < CHAINHASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(chainhash_table + i);\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_acquired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4085-4101",
    "snippet": "void lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lock_stat || !debug_locks))\n\t\treturn;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tcurrent->lockdep_recursion = 1;\n\t__lock_acquired(lock, ip);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define lock_stat 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_acquired",
          "args": [
            "lock",
            "ip"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_acquired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4015-4063",
          "snippet": "static void\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tu64 now, waittime = 0;\n\tint i, cpu;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Yay, we acquired ownership of this lock we didn't try to\n\t * acquire, how the heck did that happen?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, _RET_IP_);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tif (hlock->waittime_stamp) {\n\t\tnow = lockstat_clock();\n\t\twaittime = now - hlock->waittime_stamp;\n\t\thlock->holdtime_stamp = now;\n\t}\n\n\ttrace_lock_acquired(lock, ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (waittime) {\n\t\tif (hlock->read)\n\t\t\tlock_time_inc(&stats->read_waittime, waittime);\n\t\telse\n\t\t\tlock_time_inc(&stats->write_waittime, waittime);\n\t}\n\tif (lock->cpu != cpu)\n\t\tstats->bounces[bounce_acquired + !!hlock->read]++;\n\n\tlock->cpu = cpu;\n\tlock->ip = ip;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tu64 now, waittime = 0;\n\tint i, cpu;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Yay, we acquired ownership of this lock we didn't try to\n\t * acquire, how the heck did that happen?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, _RET_IP_);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tif (hlock->waittime_stamp) {\n\t\tnow = lockstat_clock();\n\t\twaittime = now - hlock->waittime_stamp;\n\t\thlock->holdtime_stamp = now;\n\t}\n\n\ttrace_lock_acquired(lock, ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (waittime) {\n\t\tif (hlock->read)\n\t\t\tlock_time_inc(&stats->read_waittime, waittime);\n\t\telse\n\t\t\tlock_time_inc(&stats->write_waittime, waittime);\n\t}\n\tif (lock->cpu != cpu)\n\t\tstats->bounces[bounce_acquired + !!hlock->read]++;\n\n\tlock->cpu = cpu;\n\tlock->ip = ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lock_stat || !debug_locks"
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nvoid lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lock_stat || !debug_locks))\n\t\treturn;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tcurrent->lockdep_recursion = 1;\n\t__lock_acquired(lock, ip);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_contended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4065-4082",
    "snippet": "void lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lock_stat || !debug_locks))\n\t\treturn;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tcurrent->lockdep_recursion = 1;\n\ttrace_lock_contended(lock, ip);\n\t__lock_contended(lock, ip);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define lock_stat 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_contended",
          "args": [
            "lock",
            "ip"
          ],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_contended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3974-4013",
          "snippet": "static void\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tint i, contention_point, contending_point;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Whee, we contended on this lock, except it seems we're not\n\t * actually trying to acquire anything much at all..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, ip);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\thlock->waittime_stamp = lockstat_clock();\n\n\tcontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\n\tcontending_point = lock_point(hlock_class(hlock)->contending_point,\n\t\t\t\t      lock->ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (contention_point < LOCKSTAT_POINTS)\n\t\tstats->contention_point[contention_point]++;\n\tif (contending_point < LOCKSTAT_POINTS)\n\t\tstats->contending_point[contending_point]++;\n\tif (lock->cpu != smp_processor_id())\n\t\tstats->bounces[bounce_contended + !!hlock->read]++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tint i, contention_point, contending_point;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Whee, we contended on this lock, except it seems we're not\n\t * actually trying to acquire anything much at all..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, ip);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\thlock->waittime_stamp = lockstat_clock();\n\n\tcontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\n\tcontending_point = lock_point(hlock_class(hlock)->contending_point,\n\t\t\t\t      lock->ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (contention_point < LOCKSTAT_POINTS)\n\t\tstats->contention_point[contention_point]++;\n\tif (contending_point < LOCKSTAT_POINTS)\n\t\tstats->contending_point[contending_point]++;\n\tif (lock->cpu != smp_processor_id())\n\t\tstats->bounces[bounce_contended + !!hlock->read]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_lock_contended",
          "args": [
            "lock",
            "ip"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 4072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lock_stat || !debug_locks"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nvoid lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!lock_stat || !debug_locks))\n\t\treturn;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tcurrent->lockdep_recursion = 1;\n\ttrace_lock_contended(lock, ip);\n\t__lock_contended(lock, ip);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "__lock_acquired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "4015-4063",
    "snippet": "static void\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tu64 now, waittime = 0;\n\tint i, cpu;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Yay, we acquired ownership of this lock we didn't try to\n\t * acquire, how the heck did that happen?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, _RET_IP_);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tif (hlock->waittime_stamp) {\n\t\tnow = lockstat_clock();\n\t\twaittime = now - hlock->waittime_stamp;\n\t\thlock->holdtime_stamp = now;\n\t}\n\n\ttrace_lock_acquired(lock, ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (waittime) {\n\t\tif (hlock->read)\n\t\t\tlock_time_inc(&stats->read_waittime, waittime);\n\t\telse\n\t\t\tlock_time_inc(&stats->write_waittime, waittime);\n\t}\n\tif (lock->cpu != cpu)\n\t\tstats->bounces[bounce_acquired + !!hlock->read]++;\n\n\tlock->cpu = cpu;\n\tlock->ip = ip;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_time_inc",
          "args": [
            "&stats->write_waittime",
            "waittime"
          ],
          "line": 4056
        },
        "resolved": true,
        "details": {
          "function_name": "lock_time_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "179-189",
          "snippet": "static void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_stats",
          "args": [
            "hlock_class(hlock)"
          ],
          "line": 4051
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "249-252",
          "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 4051
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_lock_acquired",
          "args": [
            "lock",
            "ip"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockstat_clock",
          "args": [],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "lockstat_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "158-161",
          "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 4042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock_contention_bug",
          "args": [
            "curr",
            "lock",
            "_RET_IP_"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_contention_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3945-3972",
          "snippet": "static int\nprint_lock_contention_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_lock_contention_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3436-3469",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!depth"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tu64 now, waittime = 0;\n\tint i, cpu;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Yay, we acquired ownership of this lock we didn't try to\n\t * acquire, how the heck did that happen?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, _RET_IP_);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tif (hlock->waittime_stamp) {\n\t\tnow = lockstat_clock();\n\t\twaittime = now - hlock->waittime_stamp;\n\t\thlock->holdtime_stamp = now;\n\t}\n\n\ttrace_lock_acquired(lock, ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (waittime) {\n\t\tif (hlock->read)\n\t\t\tlock_time_inc(&stats->read_waittime, waittime);\n\t\telse\n\t\t\tlock_time_inc(&stats->write_waittime, waittime);\n\t}\n\tif (lock->cpu != cpu)\n\t\tstats->bounces[bounce_acquired + !!hlock->read]++;\n\n\tlock->cpu = cpu;\n\tlock->ip = ip;\n}"
  },
  {
    "function_name": "__lock_contended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3974-4013",
    "snippet": "static void\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tint i, contention_point, contending_point;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Whee, we contended on this lock, except it seems we're not\n\t * actually trying to acquire anything much at all..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, ip);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\thlock->waittime_stamp = lockstat_clock();\n\n\tcontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\n\tcontending_point = lock_point(hlock_class(hlock)->contending_point,\n\t\t\t\t      lock->ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (contention_point < LOCKSTAT_POINTS)\n\t\tstats->contention_point[contention_point]++;\n\tif (contending_point < LOCKSTAT_POINTS)\n\t\tstats->contending_point[contending_point]++;\n\tif (lock->cpu != smp_processor_id())\n\t\tstats->bounces[bounce_contended + !!hlock->read]++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_stats",
          "args": [
            "hlock_class(hlock)"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "249-252",
          "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_point",
          "args": [
            "hlock_class(hlock)->contending_point",
            "lock->ip"
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "lock_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "163-177",
          "snippet": "static int lock_point(unsigned long points[], unsigned long ip)\n{\n\tint i;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int lock_point(unsigned long points[], unsigned long ip)\n{\n\tint i;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockstat_clock",
          "args": [],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "lockstat_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "158-161",
          "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_contention_bug",
          "args": [
            "curr",
            "lock",
            "ip"
          ],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_contention_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3945-3972",
          "snippet": "static int\nprint_lock_contention_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_lock_contention_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3436-3469",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!depth"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class_stats *stats;\n\tunsigned int depth;\n\tint i, contention_point, contending_point;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Whee, we contended on this lock, except it seems we're not\n\t * actually trying to acquire anything much at all..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock) {\n\t\tprint_lock_contention_bug(curr, lock, ip);\n\t\treturn;\n\t}\n\n\tif (hlock->instance != lock)\n\t\treturn;\n\n\thlock->waittime_stamp = lockstat_clock();\n\n\tcontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\n\tcontending_point = lock_point(hlock_class(hlock)->contending_point,\n\t\t\t\t      lock->ip);\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (contention_point < LOCKSTAT_POINTS)\n\t\tstats->contention_point[contention_point]++;\n\tif (contending_point < LOCKSTAT_POINTS)\n\t\tstats->contending_point[contending_point]++;\n\tif (lock->cpu != smp_processor_id())\n\t\tstats->bounces[bounce_contended + !!hlock->read]++;\n}"
  },
  {
    "function_name": "print_lock_contention_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3945-3972",
    "snippet": "static int\nprint_lock_contention_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 3965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"but there are no locks held!\\n\""
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "ip"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\") at:\\n\""
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lockdep_cache",
          "args": [
            "lock"
          ],
          "line": 3961
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "525-535",
          "snippet": "static void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to contend lock (\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 3960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"---------------------------------\\n\""
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 3957
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: bad contention detected!\\n\""
          ],
          "line": 3956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=================================\\n\""
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 3949
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_lock_contention_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=================================\\n\");\n\tpr_warn(\"WARNING: bad contention detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"---------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to contend lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no locks held!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_unpin_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3927-3941",
    "snippet": "void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\t__lock_unpin_lock(lock, cookie);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_unpin_lock",
          "args": [
            "lock",
            "cookie"
          ],
          "line": 3938
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_unpin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3723-3748",
          "snippet": "static void __lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (WARN(!hlock->pin_count, \"unpinning an unpinned lock\\n\"))\n\t\t\t\treturn;\n\n\t\t\thlock->pin_count -= cookie.val;\n\n\t\t\tif (WARN((int)hlock->pin_count < 0, \"pin count corrupted\\n\"))\n\t\t\t\thlock->pin_count = 0;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"unpinning an unheld lock\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (WARN(!hlock->pin_count, \"unpinning an unpinned lock\\n\"))\n\t\t\t\treturn;\n\n\t\t\thlock->pin_count -= cookie.val;\n\n\t\t\tif (WARN((int)hlock->pin_count < 0, \"pin count corrupted\\n\"))\n\t\t\t\thlock->pin_count = 0;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"unpinning an unheld lock\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\t__lock_unpin_lock(lock, cookie);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_repin_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3910-3924",
    "snippet": "void lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\t__lock_repin_lock(lock, cookie);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_repin_lock",
          "args": [
            "lock",
            "cookie"
          ],
          "line": 3921
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_repin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3703-3721",
          "snippet": "static void __lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\t__lock_repin_lock(lock, cookie);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_pin_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3890-3907",
    "snippet": "struct pin_cookie lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn cookie;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\tcookie = __lock_pin_lock(lock);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n\n\treturn cookie;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_pin_lock",
          "args": [
            "lock"
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_pin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3675-3701",
          "snippet": "static struct pin_cookie __lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn cookie;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\t/*\n\t\t\t * Grab 16bits of randomness; this is sufficient to not\n\t\t\t * be guessable and still allows some pin nesting in\n\t\t\t * our u32 pin_count.\n\t\t\t */\n\t\t\tcookie.val = 1 + (prandom_u32() >> 16);\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn cookie;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n\treturn cookie;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct pin_cookie __lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn cookie;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\t/*\n\t\t\t * Grab 16bits of randomness; this is sufficient to not\n\t\t\t * be guessable and still allows some pin nesting in\n\t\t\t * our u32 pin_count.\n\t\t\t */\n\t\t\tcookie.val = 1 + (prandom_u32() >> 16);\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn cookie;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct pin_cookie lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn cookie;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\tcookie = __lock_pin_lock(lock);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n\n\treturn cookie;\n}"
  },
  {
    "function_name": "lock_is_held_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3870-3887",
    "snippet": "int lock_is_held_type(const struct lockdep_map *lock, int read)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn 1; /* avoid false negative lockdep_assert_held() */\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\tret = __lock_is_held(lock, read);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_is_held",
          "args": [
            "lock",
            "read"
          ],
          "line": 3882
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_is_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3656-3673",
          "snippet": "static int __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || hlock->read == read)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || hlock->read == read)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 3879
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nint lock_is_held_type(const struct lockdep_map *lock, int read)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn 1; /* avoid false negative lockdep_assert_held() */\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\tret = __lock_is_held(lock, read);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lock_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3851-3867",
    "snippet": "void lock_release(struct lockdep_map *lock, int nested,\n\t\t\t  unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tcurrent->lockdep_recursion = 1;\n\ttrace_lock_release(lock, ip);\n\tif (__lock_release(lock, nested, ip))\n\t\tcheck_chain_key(current);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_chain_key",
          "args": [
            "current"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "check_chain_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2373-2418",
          "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_release",
          "args": [
            "lock",
            "nested",
            "ip"
          ],
          "line": 3863
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3579-3654",
          "snippet": "static int\n__lock_release(struct lockdep_map *lock, int nested, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * So we're all set to release this lock.. wait what lock? We don't\n\t * own any locks, you've been drinking again?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth <= 0))\n\t\t return print_unlock_imbalance_bug(curr, lock, ip);\n\n\t/*\n\t * Check whether the lock exists in the current stack\n\t * of held locks:\n\t */\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tif (hlock->instance == lock)\n\t\tlock_release_holdtime(hlock);\n\n\tWARN(hlock->pin_count, \"releasing a pinned lock\\n\");\n\n\tif (hlock->references) {\n\t\thlock->references--;\n\t\tif (hlock->references) {\n\t\t\t/*\n\t\t\t * We had, and after removing one, still have\n\t\t\t * references, the current lock stack is still\n\t\t\t * valid. We're done!\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We have the right lock to unlock, 'hlock' points to it.\n\t * Now we remove it from the stack, and add back the other\n\t * entries (if any), recalculating the hash along the way:\n\t */\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\t/*\n\t * The most likely case is when the unlock is on the innermost\n\t * lock. In this case, we are done!\n\t */\n\tif (i == depth-1)\n\t\treturn 1;\n\n\tif (reacquire_held_locks(curr, depth, i + 1))\n\t\treturn 0;\n\n\t/*\n\t * We had N bottles of beer on the wall, we drank one, but now\n\t * there's not N-1 bottles of beer left on the wall...\n\t */\n\tDEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth-1);\n\n\t/*\n\t * Since reacquire_held_locks() would have called check_chain_key()\n\t * indirectly via __lock_acquire(), we don't need to do it again\n\t * on return.\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\n__lock_release(struct lockdep_map *lock, int nested, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * So we're all set to release this lock.. wait what lock? We don't\n\t * own any locks, you've been drinking again?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth <= 0))\n\t\t return print_unlock_imbalance_bug(curr, lock, ip);\n\n\t/*\n\t * Check whether the lock exists in the current stack\n\t * of held locks:\n\t */\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tif (hlock->instance == lock)\n\t\tlock_release_holdtime(hlock);\n\n\tWARN(hlock->pin_count, \"releasing a pinned lock\\n\");\n\n\tif (hlock->references) {\n\t\thlock->references--;\n\t\tif (hlock->references) {\n\t\t\t/*\n\t\t\t * We had, and after removing one, still have\n\t\t\t * references, the current lock stack is still\n\t\t\t * valid. We're done!\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We have the right lock to unlock, 'hlock' points to it.\n\t * Now we remove it from the stack, and add back the other\n\t * entries (if any), recalculating the hash along the way:\n\t */\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\t/*\n\t * The most likely case is when the unlock is on the innermost\n\t * lock. In this case, we are done!\n\t */\n\tif (i == depth-1)\n\t\treturn 1;\n\n\tif (reacquire_held_locks(curr, depth, i + 1))\n\t\treturn 0;\n\n\t/*\n\t * We had N bottles of beer on the wall, we drank one, but now\n\t * there's not N-1 bottles of beer left on the wall...\n\t */\n\tDEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth-1);\n\n\t/*\n\t * Since reacquire_held_locks() would have called check_chain_key()\n\t * indirectly via __lock_acquire(), we don't need to do it again\n\t * on return.\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_lock_release",
          "args": [
            "lock",
            "ip"
          ],
          "line": 3862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 3860
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lock_release(struct lockdep_map *lock, int nested,\n\t\t\t  unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\tcurrent->lockdep_recursion = 1;\n\ttrace_lock_release(lock, ip);\n\tif (__lock_release(lock, nested, ip))\n\t\tcheck_chain_key(current);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3830-3848",
    "snippet": "void lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\ttrace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip);\n\t__lock_acquire(lock, subclass, trylock, read, check,\n\t\t       irqs_disabled_flags(flags), nest_lock, ip, 0, 0);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_acquire",
          "args": [
            "lock",
            "subclass",
            "trylock",
            "read",
            "check",
            "irqs_disabled_flags(flags)",
            "nest_lock",
            "ip",
            "0",
            "0"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3202-3368",
          "snippet": "static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes + 1;\n\n\tif (depth) {\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (hlock->references) {\n\t\t\t\t/*\n\t\t\t\t * Check: unsigned int references:12, overflow.\n\t\t\t\t */\n\t\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references == (1 << 12)-1))\n\t\t\t\t\treturn 0;\n\n\t\t\t\thlock->references++;\n\t\t\t} else {\n\t\t\t\thlock->references = 2;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check && !mark_irqflags(curr, hlock))\n\t\treturn 0;\n\n\t/* mark it as used: */\n\tif (!mark_lock(curr, hlock, LOCK_USED))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. ran straight out of our static allocation.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class_idx > MAX_LOCKDEP_KEYS))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != 0))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = 0;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, class_idx);\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1))\n\t\treturn print_lock_nested_lock_not_held(curr, hlock, ip);\n\n\tif (!validate_chain(curr, lock, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define prove_locking 0"
          ],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "unsigned int max_lockdep_depth;",
            "struct lock_class_key __lockdep_no_validate__;",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define prove_locking 0\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nunsigned int max_lockdep_depth;\nstruct lock_class_key __lockdep_no_validate__;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes + 1;\n\n\tif (depth) {\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (hlock->references) {\n\t\t\t\t/*\n\t\t\t\t * Check: unsigned int references:12, overflow.\n\t\t\t\t */\n\t\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references == (1 << 12)-1))\n\t\t\t\t\treturn 0;\n\n\t\t\t\thlock->references++;\n\t\t\t} else {\n\t\t\t\thlock->references = 2;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check && !mark_irqflags(curr, hlock))\n\t\treturn 0;\n\n\t/* mark it as used: */\n\tif (!mark_lock(curr, hlock, LOCK_USED))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. ran straight out of our static allocation.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class_idx > MAX_LOCKDEP_KEYS))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != 0))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = 0;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, class_idx);\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1))\n\t\treturn print_lock_nested_lock_not_held(curr, hlock, ip);\n\n\tif (!validate_chain(curr, lock, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_lock_acquire",
          "args": [
            "lock",
            "subclass",
            "trylock",
            "read",
            "check",
            "nest_lock",
            "ip"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nvoid lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcheck_flags(flags);\n\n\tcurrent->lockdep_recursion = 1;\n\ttrace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip);\n\t__lock_acquire(lock, subclass, trylock, read, check,\n\t\t       irqs_disabled_flags(flags), nest_lock, ip, 0, 0);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3809-3823",
    "snippet": "void lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->lockdep_recursion = 1;\n\tcheck_flags(flags);\n\tif (__lock_downgrade(lock, ip))\n\t\tcheck_chain_key(current);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_chain_key",
          "args": [
            "current"
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "check_chain_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2373-2418",
          "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_downgrade",
          "args": [
            "lock",
            "ip"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_downgrade",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3534-3570",
          "snippet": "static int __lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint i;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tWARN(hlock->read, \"downgrading a read lock\");\n\thlock->read = 1;\n\thlock->acquire_ip = ip;\n\n\tif (reacquire_held_locks(curr, depth, i))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint i;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tWARN(hlock->read, \"downgrading a read lock\");\n\thlock->read = 1;\n\thlock->acquire_ip = ip;\n\n\tif (reacquire_held_locks(curr, depth, i))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 3818
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->lockdep_recursion = 1;\n\tcheck_flags(flags);\n\tif (__lock_downgrade(lock, ip))\n\t\tcheck_chain_key(current);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "lock_set_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3790-3806",
    "snippet": "void lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t    struct lock_class_key *key, unsigned int subclass,\n\t\t    unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->lockdep_recursion = 1;\n\tcheck_flags(flags);\n\tif (__lock_set_class(lock, name, key, subclass, ip))\n\t\tcheck_chain_key(current);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_chain_key",
          "args": [
            "current"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "check_chain_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2373-2418",
          "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_set_class",
          "args": [
            "lock",
            "name",
            "key",
            "subclass",
            "ip"
          ],
          "line": 3802
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_set_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3492-3532",
          "snippet": "static int\n__lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t struct lock_class_key *key, unsigned int subclass,\n\t\t unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class *class;\n\tunsigned int depth;\n\tint i;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tlockdep_init_map(lock, name, key, 0);\n\tclass = register_lock_class(lock, subclass, 0);\n\thlock->class_idx = class - lock_classes + 1;\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tif (reacquire_held_locks(curr, depth, i))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int\n__lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t struct lock_class_key *key, unsigned int subclass,\n\t\t unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class *class;\n\tunsigned int depth;\n\tint i;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tlockdep_init_map(lock, name, key, 0);\n\tclass = register_lock_class(lock, subclass, 0);\n\thlock->class_idx = class - lock_classes + 1;\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tif (reacquire_held_locks(curr, depth, i))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3753-3788",
          "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t    struct lock_class_key *key, unsigned int subclass,\n\t\t    unsigned long ip)\n{\n\tunsigned long flags;\n\n\tif (unlikely(current->lockdep_recursion))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->lockdep_recursion = 1;\n\tcheck_flags(flags);\n\tif (__lock_set_class(lock, name, key, subclass, ip))\n\t\tcheck_chain_key(current);\n\tcurrent->lockdep_recursion = 0;\n\traw_local_irq_restore(flags);\n}"
  },
  {
    "function_name": "check_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3753-3788",
    "snippet": "static void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 3786
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2606-2621",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!current->softirqs_enabled"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "current->softirqs_enabled"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"possible reason: unannotated irqs-on.\\n\""
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!current->hardirqs_enabled"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "current->hardirqs_enabled"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_flags(unsigned long flags)\n{\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\\n    defined(CONFIG_TRACE_IRQFLAGS)\n\tif (!debug_locks)\n\t\treturn;\n\n\tif (irqs_disabled_flags(flags)) {\n\t\tif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-off.\\n\");\n\t\t}\n\t} else {\n\t\tif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\n\t\t\tprintk(\"possible reason: unannotated irqs-on.\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We dont accurately track softirq state in e.g.\n\t * hardirq contexts (such as on 4KSTACKS), so only\n\t * check if not in hardirq contexts:\n\t */\n\tif (!hardirq_count()) {\n\t\tif (softirq_count()) {\n\t\t\t/* like the above, but with softirqs */\n\t\t\tDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\n\t\t} else {\n\t\t\t/* lick the above, does it taste good? */\n\t\t\tDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\n\t\t}\n\t}\n\n\tif (!debug_locks)\n\t\tprint_irqtrace_events(current);\n#endif\n}"
  },
  {
    "function_name": "__lock_unpin_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3723-3748",
    "snippet": "static void __lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (WARN(!hlock->pin_count, \"unpinning an unpinned lock\\n\"))\n\t\t\t\treturn;\n\n\t\t\thlock->pin_count -= cookie.val;\n\n\t\t\tif (WARN((int)hlock->pin_count < 0, \"pin count corrupted\\n\"))\n\t\t\t\thlock->pin_count = 0;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"unpinning an unheld lock\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"unpinning an unheld lock\\n\""
          ],
          "line": 3747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "(int)hlock->pin_count < 0",
            "\"pin count corrupted\\n\""
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!hlock->pin_count",
            "\"unpinning an unpinned lock\\n\""
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 3734
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3399-3433",
          "snippet": "static int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (WARN(!hlock->pin_count, \"unpinning an unpinned lock\\n\"))\n\t\t\t\treturn;\n\n\t\t\thlock->pin_count -= cookie.val;\n\n\t\t\tif (WARN((int)hlock->pin_count < 0, \"pin count corrupted\\n\"))\n\t\t\t\thlock->pin_count = 0;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"unpinning an unheld lock\\n\");\n}"
  },
  {
    "function_name": "__lock_repin_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3703-3721",
    "snippet": "static void __lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"pinning an unheld lock\\n\""
          ],
          "line": 3720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3399-3433",
          "snippet": "static int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 3708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __lock_repin_lock(struct lockdep_map *lock, struct pin_cookie cookie)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n}"
  },
  {
    "function_name": "__lock_pin_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3675-3701",
    "snippet": "static struct pin_cookie __lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn cookie;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\t/*\n\t\t\t * Grab 16bits of randomness; this is sufficient to not\n\t\t\t * be guessable and still allows some pin nesting in\n\t\t\t * our u32 pin_count.\n\t\t\t */\n\t\t\tcookie.val = 1 + (prandom_u32() >> 16);\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn cookie;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n\treturn cookie;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"pinning an unheld lock\\n\""
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 3687
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3399-3433",
          "snippet": "static int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct pin_cookie __lock_pin_lock(struct lockdep_map *lock)\n{\n\tstruct pin_cookie cookie = NIL_COOKIE;\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn cookie;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\t/*\n\t\t\t * Grab 16bits of randomness; this is sufficient to not\n\t\t\t * be guessable and still allows some pin nesting in\n\t\t\t * our u32 pin_count.\n\t\t\t */\n\t\t\tcookie.val = 1 + (prandom_u32() >> 16);\n\t\t\thlock->pin_count += cookie.val;\n\t\t\treturn cookie;\n\t\t}\n\t}\n\n\tWARN(1, \"pinning an unheld lock\\n\");\n\treturn cookie;\n}"
  },
  {
    "function_name": "__lock_is_held",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3656-3673",
    "snippet": "static int __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || hlock->read == read)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3399-3433",
          "snippet": "static int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || hlock->read == read)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__lock_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3579-3654",
    "snippet": "static int\n__lock_release(struct lockdep_map *lock, int nested, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * So we're all set to release this lock.. wait what lock? We don't\n\t * own any locks, you've been drinking again?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth <= 0))\n\t\t return print_unlock_imbalance_bug(curr, lock, ip);\n\n\t/*\n\t * Check whether the lock exists in the current stack\n\t * of held locks:\n\t */\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tif (hlock->instance == lock)\n\t\tlock_release_holdtime(hlock);\n\n\tWARN(hlock->pin_count, \"releasing a pinned lock\\n\");\n\n\tif (hlock->references) {\n\t\thlock->references--;\n\t\tif (hlock->references) {\n\t\t\t/*\n\t\t\t * We had, and after removing one, still have\n\t\t\t * references, the current lock stack is still\n\t\t\t * valid. We're done!\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We have the right lock to unlock, 'hlock' points to it.\n\t * Now we remove it from the stack, and add back the other\n\t * entries (if any), recalculating the hash along the way:\n\t */\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\t/*\n\t * The most likely case is when the unlock is on the innermost\n\t * lock. In this case, we are done!\n\t */\n\tif (i == depth-1)\n\t\treturn 1;\n\n\tif (reacquire_held_locks(curr, depth, i + 1))\n\t\treturn 0;\n\n\t/*\n\t * We had N bottles of beer on the wall, we drank one, but now\n\t * there's not N-1 bottles of beer left on the wall...\n\t */\n\tDEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth-1);\n\n\t/*\n\t * Since reacquire_held_locks() would have called check_chain_key()\n\t * indirectly via __lock_acquire(), we don't need to do it again\n\t * on return.\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "curr->lockdep_depth != depth-1"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reacquire_held_locks",
          "args": [
            "curr",
            "depth",
            "i + 1"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "reacquire_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3471-3490",
          "snippet": "static int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t      int idx)\n{\n\tstruct held_lock *hlock;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tif (!__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t      int idx)\n{\n\tstruct held_lock *hlock;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tif (!__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "hlock->pin_count",
            "\"releasing a pinned lock\\n\""
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_release_holdtime",
          "args": [
            "hlock"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "lock_release_holdtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "271-273",
          "snippet": "static inline void lock_release_holdtime(struct held_lock *hlock)\n{\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void lock_release_holdtime(struct held_lock *hlock)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_unlock_imbalance_bug",
          "args": [
            "curr",
            "lock",
            "ip"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "print_unlock_imbalance_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3370-3397",
          "snippet": "static int\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 3602
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3436-3469",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "depth <= 0"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\n__lock_release(struct lockdep_map *lock, int nested, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * So we're all set to release this lock.. wait what lock? We don't\n\t * own any locks, you've been drinking again?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth <= 0))\n\t\t return print_unlock_imbalance_bug(curr, lock, ip);\n\n\t/*\n\t * Check whether the lock exists in the current stack\n\t * of held locks:\n\t */\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tif (hlock->instance == lock)\n\t\tlock_release_holdtime(hlock);\n\n\tWARN(hlock->pin_count, \"releasing a pinned lock\\n\");\n\n\tif (hlock->references) {\n\t\thlock->references--;\n\t\tif (hlock->references) {\n\t\t\t/*\n\t\t\t * We had, and after removing one, still have\n\t\t\t * references, the current lock stack is still\n\t\t\t * valid. We're done!\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * We have the right lock to unlock, 'hlock' points to it.\n\t * Now we remove it from the stack, and add back the other\n\t * entries (if any), recalculating the hash along the way:\n\t */\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\t/*\n\t * The most likely case is when the unlock is on the innermost\n\t * lock. In this case, we are done!\n\t */\n\tif (i == depth-1)\n\t\treturn 1;\n\n\tif (reacquire_held_locks(curr, depth, i + 1))\n\t\treturn 0;\n\n\t/*\n\t * We had N bottles of beer on the wall, we drank one, but now\n\t * there's not N-1 bottles of beer left on the wall...\n\t */\n\tDEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth-1);\n\n\t/*\n\t * Since reacquire_held_locks() would have called check_chain_key()\n\t * indirectly via __lock_acquire(), we don't need to do it again\n\t * on return.\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "__lock_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3534-3570",
    "snippet": "static int __lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint i;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tWARN(hlock->read, \"downgrading a read lock\");\n\thlock->read = 1;\n\thlock->acquire_ip = ip;\n\n\tif (reacquire_held_locks(curr, depth, i))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "curr->lockdep_depth != depth"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reacquire_held_locks",
          "args": [
            "curr",
            "depth",
            "i"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "reacquire_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3471-3490",
          "snippet": "static int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t      int idx)\n{\n\tstruct held_lock *hlock;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tif (!__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t      int idx)\n{\n\tstruct held_lock *hlock;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tif (!__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "hlock->read",
            "\"downgrading a read lock\""
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_unlock_imbalance_bug",
          "args": [
            "curr",
            "lock",
            "ip"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "print_unlock_imbalance_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3370-3397",
          "snippet": "static int\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3436-3469",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!depth"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_downgrade(struct lockdep_map *lock, unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint i;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tWARN(hlock->read, \"downgrading a read lock\");\n\thlock->read = 1;\n\thlock->acquire_ip = ip;\n\n\tif (reacquire_held_locks(curr, depth, i))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "__lock_set_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3492-3532",
    "snippet": "static int\n__lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t struct lock_class_key *key, unsigned int subclass,\n\t\t unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class *class;\n\tunsigned int depth;\n\tint i;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tlockdep_init_map(lock, name, key, 0);\n\tclass = register_lock_class(lock, subclass, 0);\n\thlock->class_idx = class - lock_classes + 1;\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tif (reacquire_held_locks(curr, depth, i))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "curr->lockdep_depth != depth"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reacquire_held_locks",
          "args": [
            "curr",
            "depth",
            "i"
          ],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "reacquire_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3471-3490",
          "snippet": "static int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t      int idx)\n{\n\tstruct held_lock *hlock;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tif (!__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t      int idx)\n{\n\tstruct held_lock *hlock;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tif (!__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_lock_class",
          "args": [
            "lock",
            "subclass",
            "0"
          ],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "register_lock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "739-836",
          "snippet": "static struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\t/*\n\t * Allocate a new key from the static array, and add it to\n\t * the hash:\n\t */\n\tif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tclass = lock_classes + nr_lock_classes++;\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tINIT_LIST_HEAD(&class->lock_entry);\n\tINIT_LIST_HEAD(&class->locks_before);\n\tINIT_LIST_HEAD(&class->locks_after);\n\tclass->name_version = count_matching_names(class);\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Add it to the global list of classes:\n\t */\n\tlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_lock_classes;",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_lock_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\t/*\n\t * Allocate a new key from the static array, and add it to\n\t * the hash:\n\t */\n\tif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tclass = lock_classes + nr_lock_classes++;\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tINIT_LIST_HEAD(&class->lock_entry);\n\tINIT_LIST_HEAD(&class->locks_before);\n\tINIT_LIST_HEAD(&class->locks_after);\n\tclass->name_version = count_matching_names(class);\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Add it to the global list of classes:\n\t */\n\tlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "lock",
            "name",
            "key",
            "0"
          ],
          "line": 3515
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_unlock_imbalance_bug",
          "args": [
            "curr",
            "lock",
            "ip"
          ],
          "line": 3513
        },
        "resolved": true,
        "details": {
          "function_name": "print_unlock_imbalance_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3370-3397",
          "snippet": "static int\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_held_lock",
          "args": [
            "curr",
            "lock",
            "depth",
            "&i"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "find_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3436-3469",
          "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!depth"
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int\n__lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t struct lock_class_key *key, unsigned int subclass,\n\t\t unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tstruct lock_class *class;\n\tunsigned int depth;\n\tint i;\n\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * This function is about (re)setting the class of a held lock,\n\t * yet we're not actually holding any locks. Naughty user!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!depth))\n\t\treturn 0;\n\n\thlock = find_held_lock(curr, lock, depth, &i);\n\tif (!hlock)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\tlockdep_init_map(lock, name, key, 0);\n\tclass = register_lock_class(lock, subclass, 0);\n\thlock->class_idx = class - lock_classes + 1;\n\n\tcurr->lockdep_depth = i;\n\tcurr->curr_chain_key = hlock->prev_chain_key;\n\n\tif (reacquire_held_locks(curr, depth, i))\n\t\treturn 0;\n\n\t/*\n\t * I took it apart and put it back together again, except now I have\n\t * these 'spare' parts.. where shall I put them.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "reacquire_held_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3471-3490",
    "snippet": "static int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t      int idx)\n{\n\tstruct held_lock *hlock;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tif (!__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lock_acquire",
          "args": [
            "hlock->instance",
            "hlock_class(hlock)->subclass",
            "hlock->trylock",
            "hlock->read",
            "hlock->check",
            "hlock->hardirqs_off",
            "hlock->nest_lock",
            "hlock->acquire_ip",
            "hlock->references",
            "hlock->pin_count"
          ],
          "line": 3480
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3202-3368",
          "snippet": "static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes + 1;\n\n\tif (depth) {\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (hlock->references) {\n\t\t\t\t/*\n\t\t\t\t * Check: unsigned int references:12, overflow.\n\t\t\t\t */\n\t\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references == (1 << 12)-1))\n\t\t\t\t\treturn 0;\n\n\t\t\t\thlock->references++;\n\t\t\t} else {\n\t\t\t\thlock->references = 2;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check && !mark_irqflags(curr, hlock))\n\t\treturn 0;\n\n\t/* mark it as used: */\n\tif (!mark_lock(curr, hlock, LOCK_USED))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. ran straight out of our static allocation.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class_idx > MAX_LOCKDEP_KEYS))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != 0))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = 0;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, class_idx);\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1))\n\t\treturn print_lock_nested_lock_not_held(curr, hlock, ip);\n\n\tif (!validate_chain(curr, lock, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define prove_locking 0"
          ],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "unsigned int max_lockdep_depth;",
            "struct lock_class_key __lockdep_no_validate__;",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define prove_locking 0\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nunsigned int max_lockdep_depth;\nstruct lock_class_key __lockdep_no_validate__;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes + 1;\n\n\tif (depth) {\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (hlock->references) {\n\t\t\t\t/*\n\t\t\t\t * Check: unsigned int references:12, overflow.\n\t\t\t\t */\n\t\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references == (1 << 12)-1))\n\t\t\t\t\treturn 0;\n\n\t\t\t\thlock->references++;\n\t\t\t} else {\n\t\t\t\thlock->references = 2;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check && !mark_irqflags(curr, hlock))\n\t\treturn 0;\n\n\t/* mark it as used: */\n\tif (!mark_lock(curr, hlock, LOCK_USED))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. ran straight out of our static allocation.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class_idx > MAX_LOCKDEP_KEYS))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != 0))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = 0;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, class_idx);\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1))\n\t\treturn print_lock_nested_lock_not_held(curr, hlock, ip);\n\n\tif (!validate_chain(curr, lock, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int reacquire_held_locks(struct task_struct *curr, unsigned int depth,\n\t\t\t      int idx)\n{\n\tstruct held_lock *hlock;\n\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tfor (hlock = curr->held_locks + idx; idx < depth; idx++, hlock++) {\n\t\tif (!__lock_acquire(hlock->instance,\n\t\t\t\t    hlock_class(hlock)->subclass,\n\t\t\t\t    hlock->trylock,\n\t\t\t\t    hlock->read, hlock->check,\n\t\t\t\t    hlock->hardirqs_off,\n\t\t\t\t    hlock->nest_lock, hlock->acquire_ip,\n\t\t\t\t    hlock->references, hlock->pin_count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "find_held_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3436-3469",
    "snippet": "static struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_held_lock",
          "args": [
            "hlock",
            "lock"
          ],
          "line": 3460
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3399-3433",
          "snippet": "static int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct held_lock *find_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct lockdep_map *lock,\n\t\t\t\t\tunsigned int depth, int *idx)\n{\n\tstruct held_lock *ret, *hlock, *prev_hlock;\n\tint i;\n\n\ti = depth - 1;\n\thlock = curr->held_locks + i;\n\tret = hlock;\n\tif (match_held_lock(hlock, lock))\n\t\tgoto out;\n\n\tret = NULL;\n\tfor (i--, prev_hlock = hlock--;\n\t     i >= 0;\n\t     i--, prev_hlock = hlock--) {\n\t\t/*\n\t\t * We must not cross into another context:\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context) {\n\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tret = hlock;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*idx = i;\n\treturn ret;\n}"
  },
  {
    "function_name": "match_held_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3399-3433",
    "snippet": "static int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!hlock->nest_lock"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "look_up_lock_class",
          "args": [
            "lock",
            "0"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "look_up_lock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "649-704",
          "snippet": "static inline struct lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_unlock_imbalance_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3370-3397",
    "snippet": "static int\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"but there are no more locks to release!\\n\""
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "ip"
          ],
          "line": 3388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\") at:\\n\""
          ],
          "line": 3387
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lockdep_cache",
          "args": [
            "lock"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "525-535",
          "snippet": "static void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to release lock (\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-------------------------------------\\n\""
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: bad unlock balance detected!\\n\""
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=====================================\\n\""
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\n\t\t\t   unsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================\\n\");\n\tpr_warn(\"WARNING: bad unlock balance detected!\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"-------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to release lock (\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lockdep_cache(lock);\n\tpr_cont(\") at:\\n\");\n\tprint_ip_sym(ip);\n\tpr_warn(\"but there are no more locks to release!\\n\");\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__lock_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3202-3368",
    "snippet": "static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes + 1;\n\n\tif (depth) {\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (hlock->references) {\n\t\t\t\t/*\n\t\t\t\t * Check: unsigned int references:12, overflow.\n\t\t\t\t */\n\t\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references == (1 << 12)-1))\n\t\t\t\t\treturn 0;\n\n\t\t\t\thlock->references++;\n\t\t\t} else {\n\t\t\t\thlock->references = 2;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check && !mark_irqflags(curr, hlock))\n\t\treturn 0;\n\n\t/* mark it as used: */\n\tif (!mark_lock(curr, hlock, LOCK_USED))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. ran straight out of our static allocation.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class_idx > MAX_LOCKDEP_KEYS))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != 0))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = 0;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, class_idx);\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1))\n\t\treturn print_lock_nested_lock_not_held(curr, hlock, ip);\n\n\tif (!validate_chain(curr, lock, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define prove_locking 0"
    ],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "unsigned int max_lockdep_depth;",
      "struct lock_class_key __lockdep_no_validate__;",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "curr->lockdep_depth > max_lockdep_depth"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_all_locks",
          "args": [],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4373-4395",
          "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "current"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"depth: %i  max: %lu!\\n\"",
            "curr->lockdep_depth",
            "MAX_LOCK_DEPTH"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_LOCK_DEPTH too low!\""
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "381-388",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 3352
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "curr->lockdep_depth >= MAX_LOCK_DEPTH"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_chain_key",
          "args": [
            "curr"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "check_chain_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2373-2418",
          "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_chain",
          "args": [
            "curr",
            "lock",
            "hlock",
            "chain_head",
            "chain_key"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "validate_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2361-2366",
          "snippet": "static inline int validate_chain(struct task_struct *curr,\n\t       \tstruct lockdep_map *lock, struct held_lock *hlock,\n\t\tint chain_head, u64 chain_key)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int validate_chain(struct task_struct *curr,\n\t       \tstruct lockdep_map *lock, struct held_lock *hlock,\n\t\tint chain_head, u64 chain_key)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_nested_lock_not_held",
          "args": [
            "curr",
            "hlock",
            "ip"
          ],
          "line": 3339
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_nested_lock_not_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3158-3190",
          "snippet": "static int\nprint_lock_nested_lock_not_held(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock,\n\t\t\t\tunsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"==================================\\n\");\n\tpr_warn(\"WARNING: Nested lock was not taken\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"\\nbut this task is not holding:\\n\");\n\tpr_warn(\"%s\\n\", hlock->nest_lock->name);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_lock_nested_lock_not_held(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock,\n\t\t\t\tunsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"==================================\\n\");\n\tpr_warn(\"WARNING: Nested lock was not taken\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"\\nbut this task is not holding:\\n\");\n\tpr_warn(\"%s\\n\", hlock->nest_lock->name);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lock_is_held",
          "args": [
            "nest_lock",
            "-1"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_is_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3656-3673",
          "snippet": "static int __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || hlock->read == read)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read)\n{\n\tstruct task_struct *curr = current;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tstruct held_lock *hlock = curr->held_locks + i;\n\n\t\tif (match_held_lock(hlock, lock)) {\n\t\t\tif (read == -1 || hlock->read == read)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_chain_key",
          "args": [
            "chain_key",
            "class_idx"
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_chain_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "310-317",
          "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
        }
      },
      {
        "call_info": {
          "callee": "separate_irq_context",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "separate_irq_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3013-3017",
          "snippet": "static inline int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "chain_key != 0"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "class_idx > MAX_LOCKDEP_KEYS"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_lock",
          "args": [
            "curr",
            "hlock",
            "LOCK_USED"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3024-3086",
          "snippet": "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask = 1 << new_bit, ret = 1;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\n\t\tgraph_unlock();\n\t\treturn 1;\n\t}\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (!save_trace(hlock_class(this)->usage_traces + new_bit))\n\t\treturn 0;\n\n\tswitch (new_bit) {\n#define LOCKDEP_STATE(__STATE)\t\t\t\\\n\tcase LOCK_USED_IN_##__STATE:\t\t\\\n\tcase LOCK_USED_IN_##__STATE##_READ:\t\\\n\tcase LOCK_ENABLED_##__STATE:\t\t\\\n\tcase LOCK_ENABLED_##__STATE##_READ:\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase LOCK_USED:\n\t\tdebug_atomic_dec(nr_unused_locks);\n\t\tbreak;\n\tdefault:\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};",
            "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask = 1 << new_bit, ret = 1;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\n\t\tgraph_unlock();\n\t\treturn 1;\n\t}\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (!save_trace(hlock_class(this)->usage_traces + new_bit))\n\t\treturn 0;\n\n\tswitch (new_bit) {\n#define LOCKDEP_STATE(__STATE)\t\t\t\\\n\tcase LOCK_USED_IN_##__STATE:\t\t\\\n\tcase LOCK_USED_IN_##__STATE##_READ:\t\\\n\tcase LOCK_ENABLED_##__STATE:\t\t\\\n\tcase LOCK_ENABLED_##__STATE##_READ:\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase LOCK_USED:\n\t\tdebug_atomic_dec(nr_unused_locks);\n\t\tbreak;\n\tdefault:\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_irqflags",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "mark_irqflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3002-3006",
          "snippet": "static inline int mark_irqflags(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int mark_irqflags(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockstat_clock",
          "args": [],
          "line": 3294
        },
        "resolved": true,
        "details": {
          "function_name": "lockstat_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "158-161",
          "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_irq_context",
          "args": [
            "curr"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "task_irq_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3008-3011",
          "snippet": "static inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!class"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "hlock->references == (1 << 12)-1"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "depth >= MAX_LOCK_DEPTH"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"#%d\"",
            "class->name_version"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "very_verbose",
          "args": [
            "class"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "very_verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "587-593",
          "snippet": "static int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define VERY_VERBOSE\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define VERY_VERBOSE\t\t0\n\nstatic int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_class_ops_inc",
          "args": [
            "class"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "debug_class_ops_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep_internals.h",
          "lines": "189-195",
          "snippet": "static inline void debug_class_ops_inc(struct lock_class *class)\n{\n\tint idx;\n\n\tidx = class - lock_classes;\n\t__debug_atomic_inc(lock_class_ops[idx]);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n\nstatic inline void debug_class_ops_inc(struct lock_class *class)\n{\n\tint idx;\n\n\tidx = class - lock_classes;\n\t__debug_atomic_inc(lock_class_ops[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_lock_class",
          "args": [
            "lock",
            "subclass",
            "0"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "register_lock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "739-836",
          "snippet": "static struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\t/*\n\t * Allocate a new key from the static array, and add it to\n\t * the hash:\n\t */\n\tif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tclass = lock_classes + nr_lock_classes++;\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tINIT_LIST_HEAD(&class->lock_entry);\n\tINIT_LIST_HEAD(&class->locks_before);\n\tINIT_LIST_HEAD(&class->locks_after);\n\tclass->name_version = count_matching_names(class);\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Add it to the global list of classes:\n\t */\n\tlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_lock_classes;",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_lock_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\t/*\n\t * Allocate a new key from the static array, and add it to\n\t * the hash:\n\t */\n\tif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tclass = lock_classes + nr_lock_classes++;\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tINIT_LIST_HEAD(&class->lock_entry);\n\tINIT_LIST_HEAD(&class->locks_before);\n\tINIT_LIST_HEAD(&class->locks_after);\n\tclass->name_version = count_matching_names(class);\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Add it to the global list of classes:\n\t */\n\tlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!class"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define prove_locking 0\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nunsigned int max_lockdep_depth;\nstruct lock_class_key __lockdep_no_validate__;\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t  int trylock, int read, int check, int hardirqs_off,\n\t\t\t  struct lockdep_map *nest_lock, unsigned long ip,\n\t\t\t  int references, int pin_count)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_class *class = NULL;\n\tstruct held_lock *hlock;\n\tunsigned int depth;\n\tint chain_head = 0;\n\tint class_idx;\n\tu64 chain_key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n\n\tif (!prove_locking || lock->key == &__lockdep_no_validate__)\n\t\tcheck = 0;\n\n\tif (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tclass = lock->class_cache[subclass];\n\t/*\n\t * Not cached?\n\t */\n\tif (unlikely(!class)) {\n\t\tclass = register_lock_class(lock, subclass, 0);\n\t\tif (!class)\n\t\t\treturn 0;\n\t}\n\n\tdebug_class_ops_inc(class);\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nacquire class [%px] %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * Add the lock to the list of currently held locks.\n\t * (we dont increase the depth just yet, up until the\n\t * dependency checks are done)\n\t */\n\tdepth = curr->lockdep_depth;\n\t/*\n\t * Ran out of static storage for our per-task lock stack again have we?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\n\t\treturn 0;\n\n\tclass_idx = class - lock_classes + 1;\n\n\tif (depth) {\n\t\thlock = curr->held_locks + depth - 1;\n\t\tif (hlock->class_idx == class_idx && nest_lock) {\n\t\t\tif (hlock->references) {\n\t\t\t\t/*\n\t\t\t\t * Check: unsigned int references:12, overflow.\n\t\t\t\t */\n\t\t\t\tif (DEBUG_LOCKS_WARN_ON(hlock->references == (1 << 12)-1))\n\t\t\t\t\treturn 0;\n\n\t\t\t\thlock->references++;\n\t\t\t} else {\n\t\t\t\thlock->references = 2;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\thlock = curr->held_locks + depth;\n\t/*\n\t * Plain impossible, we just registered it and checked it weren't no\n\t * NULL like.. I bet this mushroom I ate was good!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!class))\n\t\treturn 0;\n\thlock->class_idx = class_idx;\n\thlock->acquire_ip = ip;\n\thlock->instance = lock;\n\thlock->nest_lock = nest_lock;\n\thlock->irq_context = task_irq_context(curr);\n\thlock->trylock = trylock;\n\thlock->read = read;\n\thlock->check = check;\n\thlock->hardirqs_off = !!hardirqs_off;\n\thlock->references = references;\n#ifdef CONFIG_LOCK_STAT\n\thlock->waittime_stamp = 0;\n\thlock->holdtime_stamp = lockstat_clock();\n#endif\n\thlock->pin_count = pin_count;\n\n\tif (check && !mark_irqflags(curr, hlock))\n\t\treturn 0;\n\n\t/* mark it as used: */\n\tif (!mark_lock(curr, hlock, LOCK_USED))\n\t\treturn 0;\n\n\t/*\n\t * Calculate the chain hash: it's the combined hash of all the\n\t * lock keys along the dependency chain. We save the hash value\n\t * at every step so that we can get the current hash easily\n\t * after unlock. The chain hash is then used to cache dependency\n\t * results.\n\t *\n\t * The 'key ID' is what is the most compact key value to drive\n\t * the hash, not class->key.\n\t */\n\t/*\n\t * Whoops, we did it again.. ran straight out of our static allocation.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class_idx > MAX_LOCKDEP_KEYS))\n\t\treturn 0;\n\n\tchain_key = curr->curr_chain_key;\n\tif (!depth) {\n\t\t/*\n\t\t * How can we have a chain hash when we ain't got no keys?!\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_key != 0))\n\t\t\treturn 0;\n\t\tchain_head = 1;\n\t}\n\n\thlock->prev_chain_key = chain_key;\n\tif (separate_irq_context(curr, hlock)) {\n\t\tchain_key = 0;\n\t\tchain_head = 1;\n\t}\n\tchain_key = iterate_chain_key(chain_key, class_idx);\n\n\tif (nest_lock && !__lock_is_held(nest_lock, -1))\n\t\treturn print_lock_nested_lock_not_held(curr, hlock, ip);\n\n\tif (!validate_chain(curr, lock, hlock, chain_head, chain_key))\n\t\treturn 0;\n\n\tcurr->curr_chain_key = chain_key;\n\tcurr->lockdep_depth++;\n\tcheck_chain_key(curr);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn 0;\n#endif\n\tif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\n\t\tdebug_locks_off();\n\t\tprint_lockdep_off(\"BUG: MAX_LOCK_DEPTH too low!\");\n\t\tprintk(KERN_DEBUG \"depth: %i  max: %lu!\\n\",\n\t\t       curr->lockdep_depth, MAX_LOCK_DEPTH);\n\n\t\tlockdep_print_held_locks(current);\n\t\tdebug_show_all_locks();\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\tif (unlikely(curr->lockdep_depth > max_lockdep_depth))\n\t\tmax_lockdep_depth = curr->lockdep_depth;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "print_lock_nested_lock_not_held",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3158-3190",
    "snippet": "static int\nprint_lock_nested_lock_not_held(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock,\n\t\t\t\tunsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"==================================\\n\");\n\tpr_warn(\"WARNING: Nested lock was not taken\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"\\nbut this task is not holding:\\n\");\n\tpr_warn(\"%s\\n\", hlock->nest_lock->name);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 3184
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "hlock->nest_lock->name"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nbut this task is not holding:\\n\""
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "hlock"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"----------------------------------\\n\""
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: Nested lock was not taken\\n\""
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"==================================\\n\""
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_lock_nested_lock_not_held(struct task_struct *curr,\n\t\t\t\tstruct held_lock *hlock,\n\t\t\t\tunsigned long ip)\n{\n\tif (!debug_locks_off())\n\t\treturn 0;\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"==================================\\n\");\n\tpr_warn(\"WARNING: Nested lock was not taken\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------------\\n\");\n\n\tpr_warn(\"%s/%d is trying to lock:\\n\", curr->comm, task_pid_nr(curr));\n\tprint_lock(hlock);\n\n\tpr_warn(\"\\nbut this task is not holding:\\n\");\n\tpr_warn(\"%s\\n\", hlock->nest_lock->name);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lockdep_init_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3148-3152",
    "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lockdep_init_map",
          "args": [
            "lock",
            "name",
            "key",
            "subclass"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3091-3146",
          "snippet": "static void __lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_LOCKDEP_CACHING_CLASSES; i++)\n\t\tlock->class_cache[i] = NULL;\n\n#ifdef CONFIG_LOCK_STAT\n\tlock->cpu = raw_smp_processor_id();\n#endif\n\n\t/*\n\t * Can't be having no nameless bastards around this place!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!name)) {\n\t\tlock->name = \"NULL\";\n\t\treturn;\n\t}\n\n\tlock->name = name;\n\n\t/*\n\t * No key, no joy, we need to hash something.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!key))\n\t\treturn;\n\t/*\n\t * Sanity check, the lock-class key must be persistent:\n\t */\n\tif (!static_obj(key)) {\n\t\tprintk(\"BUG: key %px not in .data!\\n\", key);\n\t\t/*\n\t\t * What it says above ^^^^^, I suggest you read it.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn;\n\t}\n\tlock->key = key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tif (subclass) {\n\t\tunsigned long flags;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(current->lockdep_recursion))\n\t\t\treturn;\n\n\t\traw_local_irq_save(flags);\n\t\tcurrent->lockdep_recursion = 1;\n\t\tregister_lock_class(lock, subclass, 1);\n\t\tcurrent->lockdep_recursion = 0;\n\t\traw_local_irq_restore(flags);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void __lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_LOCKDEP_CACHING_CLASSES; i++)\n\t\tlock->class_cache[i] = NULL;\n\n#ifdef CONFIG_LOCK_STAT\n\tlock->cpu = raw_smp_processor_id();\n#endif\n\n\t/*\n\t * Can't be having no nameless bastards around this place!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!name)) {\n\t\tlock->name = \"NULL\";\n\t\treturn;\n\t}\n\n\tlock->name = name;\n\n\t/*\n\t * No key, no joy, we need to hash something.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!key))\n\t\treturn;\n\t/*\n\t * Sanity check, the lock-class key must be persistent:\n\t */\n\tif (!static_obj(key)) {\n\t\tprintk(\"BUG: key %px not in .data!\\n\", key);\n\t\t/*\n\t\t * What it says above ^^^^^, I suggest you read it.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn;\n\t}\n\tlock->key = key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tif (subclass) {\n\t\tunsigned long flags;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(current->lockdep_recursion))\n\t\t\treturn;\n\n\t\traw_local_irq_save(flags);\n\t\tcurrent->lockdep_recursion = 1;\n\t\tregister_lock_class(lock, subclass, 1);\n\t\tcurrent->lockdep_recursion = 0;\n\t\traw_local_irq_restore(flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
  },
  {
    "function_name": "__lockdep_init_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3091-3146",
    "snippet": "static void __lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_LOCKDEP_CACHING_CLASSES; i++)\n\t\tlock->class_cache[i] = NULL;\n\n#ifdef CONFIG_LOCK_STAT\n\tlock->cpu = raw_smp_processor_id();\n#endif\n\n\t/*\n\t * Can't be having no nameless bastards around this place!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!name)) {\n\t\tlock->name = \"NULL\";\n\t\treturn;\n\t}\n\n\tlock->name = name;\n\n\t/*\n\t * No key, no joy, we need to hash something.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!key))\n\t\treturn;\n\t/*\n\t * Sanity check, the lock-class key must be persistent:\n\t */\n\tif (!static_obj(key)) {\n\t\tprintk(\"BUG: key %px not in .data!\\n\", key);\n\t\t/*\n\t\t * What it says above ^^^^^, I suggest you read it.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn;\n\t}\n\tlock->key = key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tif (subclass) {\n\t\tunsigned long flags;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(current->lockdep_recursion))\n\t\t\treturn;\n\n\t\traw_local_irq_save(flags);\n\t\tcurrent->lockdep_recursion = 1;\n\t\tregister_lock_class(lock, subclass, 1);\n\t\tcurrent->lockdep_recursion = 0;\n\t\traw_local_irq_restore(flags);\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_lock_class",
          "args": [
            "lock",
            "subclass",
            "1"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "register_lock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "739-836",
          "snippet": "static struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\t/*\n\t * Allocate a new key from the static array, and add it to\n\t * the hash:\n\t */\n\tif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tclass = lock_classes + nr_lock_classes++;\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tINIT_LIST_HEAD(&class->lock_entry);\n\tINIT_LIST_HEAD(&class->locks_before);\n\tINIT_LIST_HEAD(&class->locks_after);\n\tclass->name_version = count_matching_names(class);\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Add it to the global list of classes:\n\t */\n\tlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_lock_classes;",
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_lock_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\t/*\n\t * Allocate a new key from the static array, and add it to\n\t * the hash:\n\t */\n\tif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tclass = lock_classes + nr_lock_classes++;\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tINIT_LIST_HEAD(&class->lock_entry);\n\tINIT_LIST_HEAD(&class->locks_before);\n\tINIT_LIST_HEAD(&class->locks_after);\n\tclass->name_version = count_matching_names(class);\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Add it to the global list of classes:\n\t */\n\tlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "current->lockdep_recursion"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "1"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"BUG: key %px not in .data!\\n\"",
            "key"
          ],
          "line": 3122
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "key"
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "599-624",
          "snippet": "static int static_obj(void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!key"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!name"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void __lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_LOCKDEP_CACHING_CLASSES; i++)\n\t\tlock->class_cache[i] = NULL;\n\n#ifdef CONFIG_LOCK_STAT\n\tlock->cpu = raw_smp_processor_id();\n#endif\n\n\t/*\n\t * Can't be having no nameless bastards around this place!\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!name)) {\n\t\tlock->name = \"NULL\";\n\t\treturn;\n\t}\n\n\tlock->name = name;\n\n\t/*\n\t * No key, no joy, we need to hash something.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!key))\n\t\treturn;\n\t/*\n\t * Sanity check, the lock-class key must be persistent:\n\t */\n\tif (!static_obj(key)) {\n\t\tprintk(\"BUG: key %px not in .data!\\n\", key);\n\t\t/*\n\t\t * What it says above ^^^^^, I suggest you read it.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn;\n\t}\n\tlock->key = key;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tif (subclass) {\n\t\tunsigned long flags;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(current->lockdep_recursion))\n\t\t\treturn;\n\n\t\traw_local_irq_save(flags);\n\t\tcurrent->lockdep_recursion = 1;\n\t\tregister_lock_class(lock, subclass, 1);\n\t\tcurrent->lockdep_recursion = 0;\n\t\traw_local_irq_restore(flags);\n\t}\n}"
  },
  {
    "function_name": "mark_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3024-3086",
    "snippet": "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask = 1 << new_bit, ret = 1;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\n\t\tgraph_unlock();\n\t\treturn 1;\n\t}\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (!save_trace(hlock_class(this)->usage_traces + new_bit))\n\t\treturn 0;\n\n\tswitch (new_bit) {\n#define LOCKDEP_STATE(__STATE)\t\t\t\\\n\tcase LOCK_USED_IN_##__STATE:\t\t\\\n\tcase LOCK_USED_IN_##__STATE##_READ:\t\\\n\tcase LOCK_ENABLED_##__STATE:\t\t\\\n\tcase LOCK_ENABLED_##__STATE##_READ:\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase LOCK_USED:\n\t\tdebug_atomic_dec(nr_unused_locks);\n\t\tbreak;\n\tdefault:\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};",
      "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "curr"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2606-2621",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "this"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\nmarked lock as {%s}:\\n\"",
            "usage_str[new_bit]"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 3073
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_dec",
          "args": [
            "nr_unused_locks"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_lock_irq",
          "args": [
            "curr",
            "this",
            "new_bit"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2994-3000",
          "snippet": "static inline\nint mark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tWARN_ON(1); /* Impossible innit? when we don't have TRACE_IRQFLAG */\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic inline\nint mark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tWARN_ON(1); /* Impossible innit? when we don't have TRACE_IRQFLAG */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [
            "hlock_class(this)->usage_traces + new_bit"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "390-426",
          "snippet": "static int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_stack_trace_entries;\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hlock_class(this)->usage_mask & new_mask"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "85-101",
          "snippet": "static int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "hlock_class(this)->usage_mask & new_mask"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask = 1 << new_bit, ret = 1;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\n\t\tgraph_unlock();\n\t\treturn 1;\n\t}\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (!save_trace(hlock_class(this)->usage_traces + new_bit))\n\t\treturn 0;\n\n\tswitch (new_bit) {\n#define LOCKDEP_STATE(__STATE)\t\t\t\\\n\tcase LOCK_USED_IN_##__STATE:\t\t\\\n\tcase LOCK_USED_IN_##__STATE##_READ:\t\\\n\tcase LOCK_ENABLED_##__STATE:\t\t\\\n\tcase LOCK_ENABLED_##__STATE##_READ:\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase LOCK_USED:\n\t\tdebug_atomic_dec(nr_unused_locks);\n\t\tbreak;\n\tdefault:\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "separate_irq_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3013-3017",
    "snippet": "static inline int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "task_irq_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3008-3011",
    "snippet": "static inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "mark_irqflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "3002-3006",
    "snippet": "static inline int mark_irqflags(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int mark_irqflags(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "mark_lock_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2994-3000",
    "snippet": "static inline\nint mark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tWARN_ON(1); /* Impossible innit? when we don't have TRACE_IRQFLAG */\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic inline\nint mark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tWARN_ON(1); /* Impossible innit? when we don't have TRACE_IRQFLAG */\n\treturn 1;\n}"
  },
  {
    "function_name": "separate_irq_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2969-2990",
    "snippet": "static int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\tunsigned int depth = curr->lockdep_depth;\n\n\t/*\n\t * Keep track of points where we cross into an interrupt context:\n\t */\n\tif (depth) {\n\t\tstruct held_lock *prev_hlock;\n\n\t\tprev_hlock = curr->held_locks + depth-1;\n\t\t/*\n\t\t * If we cross into another context, reset the\n\t\t * hash key (this also prevents the checking and the\n\t\t * adding of the dependency to 'prev'):\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int separate_irq_context(struct task_struct *curr,\n\t\tstruct held_lock *hlock)\n{\n\tunsigned int depth = curr->lockdep_depth;\n\n\t/*\n\t * Keep track of points where we cross into an interrupt context:\n\t */\n\tif (depth) {\n\t\tstruct held_lock *prev_hlock;\n\n\t\tprev_hlock = curr->held_locks + depth-1;\n\t\t/*\n\t\t * If we cross into another context, reset the\n\t\t * hash key (this also prevents the checking and the\n\t\t * adding of the dependency to 'prev'):\n\t\t */\n\t\tif (prev_hlock->irq_context != hlock->irq_context)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "task_irq_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2964-2967",
    "snippet": "static inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 2 * !!task->hardirq_context + !!task->softirq_context;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned int task_irq_context(struct task_struct *task)\n{\n\treturn 2 * !!task->hardirq_context + !!task->softirq_context;\n}"
  },
  {
    "function_name": "mark_irqflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2916-2962",
    "snippet": "static int mark_irqflags(struct task_struct *curr, struct held_lock *hlock)\n{\n\t/*\n\t * If non-trylock use in a hardirq or softirq context, then\n\t * mark the lock as used in these contexts:\n\t */\n\tif (!hlock->trylock) {\n\t\tif (hlock->read) {\n\t\t\tif (curr->hardirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_USED_IN_HARDIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t\tif (curr->softirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_USED_IN_SOFTIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (curr->hardirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock, LOCK_USED_IN_HARDIRQ))\n\t\t\t\t\treturn 0;\n\t\t\tif (curr->softirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock, LOCK_USED_IN_SOFTIRQ))\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!hlock->hardirqs_off) {\n\t\tif (hlock->read) {\n\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\tLOCK_ENABLED_HARDIRQ_READ))\n\t\t\t\treturn 0;\n\t\t\tif (curr->softirqs_enabled)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_ENABLED_SOFTIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\tLOCK_ENABLED_HARDIRQ))\n\t\t\t\treturn 0;\n\t\t\tif (curr->softirqs_enabled)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_ENABLED_SOFTIRQ))\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_lock",
          "args": [
            "curr",
            "hlock",
            "LOCK_ENABLED_SOFTIRQ"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3024-3086",
          "snippet": "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask = 1 << new_bit, ret = 1;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\n\t\tgraph_unlock();\n\t\treturn 1;\n\t}\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (!save_trace(hlock_class(this)->usage_traces + new_bit))\n\t\treturn 0;\n\n\tswitch (new_bit) {\n#define LOCKDEP_STATE(__STATE)\t\t\t\\\n\tcase LOCK_USED_IN_##__STATE:\t\t\\\n\tcase LOCK_USED_IN_##__STATE##_READ:\t\\\n\tcase LOCK_ENABLED_##__STATE:\t\t\\\n\tcase LOCK_ENABLED_##__STATE##_READ:\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase LOCK_USED:\n\t\tdebug_atomic_dec(nr_unused_locks);\n\t\tbreak;\n\tdefault:\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};",
            "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask = 1 << new_bit, ret = 1;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\n\t\tgraph_unlock();\n\t\treturn 1;\n\t}\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (!save_trace(hlock_class(this)->usage_traces + new_bit))\n\t\treturn 0;\n\n\tswitch (new_bit) {\n#define LOCKDEP_STATE(__STATE)\t\t\t\\\n\tcase LOCK_USED_IN_##__STATE:\t\t\\\n\tcase LOCK_USED_IN_##__STATE##_READ:\t\\\n\tcase LOCK_ENABLED_##__STATE:\t\t\\\n\tcase LOCK_ENABLED_##__STATE##_READ:\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase LOCK_USED:\n\t\tdebug_atomic_dec(nr_unused_locks);\n\t\tbreak;\n\tdefault:\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int mark_irqflags(struct task_struct *curr, struct held_lock *hlock)\n{\n\t/*\n\t * If non-trylock use in a hardirq or softirq context, then\n\t * mark the lock as used in these contexts:\n\t */\n\tif (!hlock->trylock) {\n\t\tif (hlock->read) {\n\t\t\tif (curr->hardirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_USED_IN_HARDIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t\tif (curr->softirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_USED_IN_SOFTIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (curr->hardirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock, LOCK_USED_IN_HARDIRQ))\n\t\t\t\t\treturn 0;\n\t\t\tif (curr->softirq_context)\n\t\t\t\tif (!mark_lock(curr, hlock, LOCK_USED_IN_SOFTIRQ))\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!hlock->hardirqs_off) {\n\t\tif (hlock->read) {\n\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\tLOCK_ENABLED_HARDIRQ_READ))\n\t\t\t\treturn 0;\n\t\t\tif (curr->softirqs_enabled)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_ENABLED_SOFTIRQ_READ))\n\t\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\tLOCK_ENABLED_HARDIRQ))\n\t\t\t\treturn 0;\n\t\t\tif (curr->softirqs_enabled)\n\t\t\t\tif (!mark_lock(curr, hlock,\n\t\t\t\t\t\tLOCK_ENABLED_SOFTIRQ))\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "trace_softirqs_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2887-2914",
    "snippet": "void trace_softirqs_off(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->softirqs_enabled) {\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurr->softirqs_enabled = 0;\n\t\tcurr->softirq_disable_ip = ip;\n\t\tcurr->softirq_disable_event = ++curr->irq_events;\n\t\tdebug_atomic_inc(softirqs_off_events);\n\t\t/*\n\t\t * Whoops, we wanted softirqs off, so why aren't they?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(!softirq_count());\n\t} else\n\t\tdebug_atomic_inc(redundant_softirqs_off);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "redundant_softirqs_off"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!softirq_count()"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "softirqs_off_events"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks || current->lockdep_recursion"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid trace_softirqs_off(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->softirqs_enabled) {\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurr->softirqs_enabled = 0;\n\t\tcurr->softirq_disable_ip = ip;\n\t\tcurr->softirq_disable_event = ++curr->irq_events;\n\t\tdebug_atomic_inc(softirqs_off_events);\n\t\t/*\n\t\t * Whoops, we wanted softirqs off, so why aren't they?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(!softirq_count());\n\t} else\n\t\tdebug_atomic_inc(redundant_softirqs_off);\n}"
  },
  {
    "function_name": "trace_softirqs_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2847-2882",
    "snippet": "void trace_softirqs_on(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tcurrent->lockdep_recursion = 1;\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurr->softirqs_enabled = 1;\n\tcurr->softirq_enable_ip = ip;\n\tcurr->softirq_enable_event = ++curr->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (curr->hardirqs_enabled)\n\t\tmark_held_locks(curr, SOFTIRQ);\n\tcurrent->lockdep_recursion = 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_held_locks",
          "args": [
            "curr",
            "SOFTIRQ"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "mark_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2718-2742",
          "snippet": "static int\nmark_held_locks(struct task_struct *curr, enum mark_type mark)\n{\n\tenum lock_usage_bit usage_bit;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tusage_bit = 2 + (mark << 2); /* ENABLED */\n\t\tif (hlock->read)\n\t\t\tusage_bit += 1; /* READ */\n\n\t\tBUG_ON(usage_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, usage_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_held_locks(struct task_struct *curr, enum mark_type mark)\n{\n\tenum lock_usage_bit usage_bit;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tusage_bit = 2 + (mark << 2); /* ENABLED */\n\t\tif (hlock->read)\n\t\t\tusage_bit += 1; /* READ */\n\n\t\tBUG_ON(usage_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, usage_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "softirqs_on_events"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "redundant_softirqs_on"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks || current->lockdep_recursion"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid trace_softirqs_on(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * We fancy IRQs being disabled here, see softirq.c, avoids\n\t * funny state and nesting things.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->softirqs_enabled) {\n\t\tdebug_atomic_inc(redundant_softirqs_on);\n\t\treturn;\n\t}\n\n\tcurrent->lockdep_recursion = 1;\n\t/*\n\t * We'll do an OFF -> ON transition:\n\t */\n\tcurr->softirqs_enabled = 1;\n\tcurr->softirq_enable_ip = ip;\n\tcurr->softirq_enable_event = ++curr->irq_events;\n\tdebug_atomic_inc(softirqs_on_events);\n\t/*\n\t * We are going to turn softirqs on, so set the\n\t * usage bit for all held locks, if hardirqs are\n\t * enabled too:\n\t */\n\tif (curr->hardirqs_enabled)\n\t\tmark_held_locks(curr, SOFTIRQ);\n\tcurrent->lockdep_recursion = 0;\n}"
  },
  {
    "function_name": "lockdep_hardirqs_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2818-2842",
    "snippet": "void lockdep_hardirqs_off(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->hardirqs_enabled) {\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurr->hardirqs_enabled = 0;\n\t\tcurr->hardirq_disable_ip = ip;\n\t\tcurr->hardirq_disable_event = ++curr->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "redundant_hardirqs_off"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "hardirqs_off_events"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks || current->lockdep_recursion"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_off(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->hardirqs_enabled) {\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurr->hardirqs_enabled = 0;\n\t\tcurr->hardirq_disable_ip = ip;\n\t\tcurr->hardirq_disable_event = ++curr->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n}"
  },
  {
    "function_name": "lockdep_hardirqs_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2774-2813",
    "snippet": "void lockdep_hardirqs_on(unsigned long ip)\n{\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\tif (unlikely(current->hardirqs_enabled)) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(unlikely(early_boot_irqs_disabled)))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(current->hardirq_context))\n\t\treturn;\n\n\tcurrent->lockdep_recursion = 1;\n\t__trace_hardirqs_on_caller(ip);\n\tcurrent->lockdep_recursion = 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_hardirqs_on_caller",
          "args": [
            "ip"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_hardirqs_on_caller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2747-2772",
          "snippet": "static void __trace_hardirqs_on_caller(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\t/* we'll do an OFF -> ON transition: */\n\tcurr->hardirqs_enabled = 1;\n\n\t/*\n\t * We are going to turn hardirqs on, so set the\n\t * usage bit for all held locks:\n\t */\n\tif (!mark_held_locks(curr, HARDIRQ))\n\t\treturn;\n\t/*\n\t * If we have softirqs enabled, then set the usage\n\t * bit for all held locks. (disabled hardirqs prevented\n\t * this bit from being set before)\n\t */\n\tif (curr->softirqs_enabled)\n\t\tif (!mark_held_locks(curr, SOFTIRQ))\n\t\t\treturn;\n\n\tcurr->hardirq_enable_ip = ip;\n\tcurr->hardirq_enable_event = ++curr->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __trace_hardirqs_on_caller(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\t/* we'll do an OFF -> ON transition: */\n\tcurr->hardirqs_enabled = 1;\n\n\t/*\n\t * We are going to turn hardirqs on, so set the\n\t * usage bit for all held locks:\n\t */\n\tif (!mark_held_locks(curr, HARDIRQ))\n\t\treturn;\n\t/*\n\t * If we have softirqs enabled, then set the usage\n\t * bit for all held locks. (disabled hardirqs prevented\n\t * this bit from being set before)\n\t */\n\tif (curr->softirqs_enabled)\n\t\tif (!mark_held_locks(curr, SOFTIRQ))\n\t\t\treturn;\n\n\tcurr->hardirq_enable_ip = ip;\n\tcurr->hardirq_enable_event = ++curr->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "current->hardirq_context"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "unlikely(early_boot_irqs_disabled)"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "early_boot_irqs_disabled"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__debug_atomic_inc",
          "args": [
            "redundant_hardirqs_on"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->hardirqs_enabled"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks || current->lockdep_recursion"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on(unsigned long ip)\n{\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\tif (unlikely(current->hardirqs_enabled)) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(unlikely(early_boot_irqs_disabled)))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(current->hardirq_context))\n\t\treturn;\n\n\tcurrent->lockdep_recursion = 1;\n\t__trace_hardirqs_on_caller(ip);\n\tcurrent->lockdep_recursion = 0;\n}"
  },
  {
    "function_name": "__trace_hardirqs_on_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2747-2772",
    "snippet": "static void __trace_hardirqs_on_caller(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\t/* we'll do an OFF -> ON transition: */\n\tcurr->hardirqs_enabled = 1;\n\n\t/*\n\t * We are going to turn hardirqs on, so set the\n\t * usage bit for all held locks:\n\t */\n\tif (!mark_held_locks(curr, HARDIRQ))\n\t\treturn;\n\t/*\n\t * If we have softirqs enabled, then set the usage\n\t * bit for all held locks. (disabled hardirqs prevented\n\t * this bit from being set before)\n\t */\n\tif (curr->softirqs_enabled)\n\t\tif (!mark_held_locks(curr, SOFTIRQ))\n\t\t\treturn;\n\n\tcurr->hardirq_enable_ip = ip;\n\tcurr->hardirq_enable_event = ++curr->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "hardirqs_on_events"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_held_locks",
          "args": [
            "curr",
            "SOFTIRQ"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "mark_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2718-2742",
          "snippet": "static int\nmark_held_locks(struct task_struct *curr, enum mark_type mark)\n{\n\tenum lock_usage_bit usage_bit;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tusage_bit = 2 + (mark << 2); /* ENABLED */\n\t\tif (hlock->read)\n\t\t\tusage_bit += 1; /* READ */\n\n\t\tBUG_ON(usage_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, usage_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_held_locks(struct task_struct *curr, enum mark_type mark)\n{\n\tenum lock_usage_bit usage_bit;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tusage_bit = 2 + (mark << 2); /* ENABLED */\n\t\tif (hlock->read)\n\t\t\tusage_bit += 1; /* READ */\n\n\t\tBUG_ON(usage_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, usage_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __trace_hardirqs_on_caller(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\t/* we'll do an OFF -> ON transition: */\n\tcurr->hardirqs_enabled = 1;\n\n\t/*\n\t * We are going to turn hardirqs on, so set the\n\t * usage bit for all held locks:\n\t */\n\tif (!mark_held_locks(curr, HARDIRQ))\n\t\treturn;\n\t/*\n\t * If we have softirqs enabled, then set the usage\n\t * bit for all held locks. (disabled hardirqs prevented\n\t * this bit from being set before)\n\t */\n\tif (curr->softirqs_enabled)\n\t\tif (!mark_held_locks(curr, SOFTIRQ))\n\t\t\treturn;\n\n\tcurr->hardirq_enable_ip = ip;\n\tcurr->hardirq_enable_event = ++curr->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
  },
  {
    "function_name": "mark_held_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2718-2742",
    "snippet": "static int\nmark_held_locks(struct task_struct *curr, enum mark_type mark)\n{\n\tenum lock_usage_bit usage_bit;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tusage_bit = 2 + (mark << 2); /* ENABLED */\n\t\tif (hlock->read)\n\t\t\tusage_bit += 1; /* READ */\n\n\t\tBUG_ON(usage_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, usage_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_lock",
          "args": [
            "curr",
            "hlock",
            "usage_bit"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3024-3086",
          "snippet": "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask = 1 << new_bit, ret = 1;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\n\t\tgraph_unlock();\n\t\treturn 1;\n\t}\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (!save_trace(hlock_class(this)->usage_traces + new_bit))\n\t\treturn 0;\n\n\tswitch (new_bit) {\n#define LOCKDEP_STATE(__STATE)\t\t\t\\\n\tcase LOCK_USED_IN_##__STATE:\t\t\\\n\tcase LOCK_USED_IN_##__STATE##_READ:\t\\\n\tcase LOCK_ENABLED_##__STATE:\t\t\\\n\tcase LOCK_ENABLED_##__STATE##_READ:\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase LOCK_USED:\n\t\tdebug_atomic_dec(nr_unused_locks);\n\t\tbreak;\n\tdefault:\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};",
            "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t\t     enum lock_usage_bit new_bit)\n{\n\tunsigned int new_mask = 1 << new_bit, ret = 1;\n\n\t/*\n\t * If already set then do not dirty the cacheline,\n\t * nor do any checks:\n\t */\n\tif (likely(hlock_class(this)->usage_mask & new_mask))\n\t\treturn 1;\n\n\tif (!graph_lock())\n\t\treturn 0;\n\t/*\n\t * Make sure we didn't race:\n\t */\n\tif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\n\t\tgraph_unlock();\n\t\treturn 1;\n\t}\n\n\thlock_class(this)->usage_mask |= new_mask;\n\n\tif (!save_trace(hlock_class(this)->usage_traces + new_bit))\n\t\treturn 0;\n\n\tswitch (new_bit) {\n#define LOCKDEP_STATE(__STATE)\t\t\t\\\n\tcase LOCK_USED_IN_##__STATE:\t\t\\\n\tcase LOCK_USED_IN_##__STATE##_READ:\t\\\n\tcase LOCK_ENABLED_##__STATE:\t\t\\\n\tcase LOCK_ENABLED_##__STATE##_READ:\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t\tret = mark_lock_irq(curr, this, new_bit);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase LOCK_USED:\n\t\tdebug_atomic_dec(nr_unused_locks);\n\t\tbreak;\n\tdefault:\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tgraph_unlock();\n\n\t/*\n\t * We must printk outside of the graph_lock:\n\t */\n\tif (ret == 2) {\n\t\tprintk(\"\\nmarked lock as {%s}:\\n\", usage_str[new_bit]);\n\t\tprint_lock(this);\n\t\tprint_irqtrace_events(curr);\n\t\tdump_stack();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "usage_bit >= LOCK_USAGE_STATES"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_held_locks(struct task_struct *curr, enum mark_type mark)\n{\n\tenum lock_usage_bit usage_bit;\n\tstruct held_lock *hlock;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tusage_bit = 2 + (mark << 2); /* ENABLED */\n\t\tif (hlock->read)\n\t\t\tusage_bit += 1; /* READ */\n\n\t\tBUG_ON(usage_bit >= LOCK_USAGE_STATES);\n\n\t\tif (!hlock->check)\n\t\t\tcontinue;\n\n\t\tif (!mark_lock(curr, hlock, usage_bit))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "mark_lock_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2657-2707",
    "snippet": "static int\nmark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tint excl_bit = exclusive_bit(new_bit);\n\tint read = new_bit & 1;\n\tint dir = new_bit & 2;\n\n\t/*\n\t * mark USED_IN has to look forwards -- to ensure no dependency\n\t * has ENABLED state, which would allow recursion deadlocks.\n\t *\n\t * mark ENABLED has to look backwards -- to ensure no dependee\n\t * has USED_IN state, which, again, would allow  recursion deadlocks.\n\t */\n\tcheck_usage_f usage = dir ?\n\t\tcheck_usage_backwards : check_usage_forwards;\n\n\t/*\n\t * Validate that this particular lock does not have conflicting\n\t * usage states.\n\t */\n\tif (!valid_state(curr, this, new_bit, excl_bit))\n\t\treturn 0;\n\n\t/*\n\t * Validate that the lock dependencies don't have conflicting usage\n\t * states.\n\t */\n\tif ((!read || !dir || STRICT_READ_CHECKS) &&\n\t\t\t!usage(curr, this, excl_bit, state_name(new_bit & ~1)))\n\t\treturn 0;\n\n\t/*\n\t * Check for read in write conflicts\n\t */\n\tif (!read) {\n\t\tif (!valid_state(curr, this, new_bit, excl_bit + 1))\n\t\t\treturn 0;\n\n\t\tif (STRICT_READ_CHECKS &&\n\t\t\t!usage(curr, this, excl_bit + 1,\n\t\t\t\tstate_name(new_bit + 1)))\n\t\t\treturn 0;\n\t}\n\n\tif (state_verbose(new_bit, hlock_class(this)))\n\t\treturn 2;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define STRICT_READ_CHECKS\t1"
    ],
    "globals_used": [
      "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "state_verbose",
          "args": [
            "new_bit",
            "hlock_class(this)"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "state_verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2648-2652",
          "snippet": "static inline int state_verbose(enum lock_usage_bit bit,\n\t\t\t\tstruct lock_class *class)\n{\n\treturn state_verbose_f[bit >> 2](class);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int state_verbose(enum lock_usage_bit bit,\n\t\t\t\tstruct lock_class *class)\n{\n\treturn state_verbose_f[bit >> 2](class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "curr",
            "this",
            "excl_bit + 1",
            "state_name(new_bit + 1)"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "check_usage_backwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2586-2604",
          "snippet": "static int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list root;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\troot.parent = NULL;\n\troot.class = hlock_class(this);\n\tret = find_usage_backwards(&root, bit, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, irqclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list root;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\troot.parent = NULL;\n\troot.class = hlock_class(this);\n\tret = find_usage_backwards(&root, bit, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, irqclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "state_name",
          "args": [
            "new_bit + 1"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1622-1625",
          "snippet": "static inline const char *state_name(enum lock_usage_bit bit)\n{\n\treturn (bit & 1) ? state_rnames[bit >> 2] : state_names[bit >> 2];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\treturn (bit & 1) ? state_rnames[bit >> 2] : state_names[bit >> 2];\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_state",
          "args": [
            "curr",
            "this",
            "new_bit",
            "excl_bit + 1"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "valid_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2480-2487",
          "snippet": "static inline int\nvalid_state(struct task_struct *curr, struct held_lock *this,\n\t    enum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\n{\n\tif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit)))\n\t\treturn print_usage_bug(curr, this, bad_bit, new_bit);\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic inline int\nvalid_state(struct task_struct *curr, struct held_lock *this,\n\t    enum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\n{\n\tif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit)))\n\t\treturn print_usage_bug(curr, this, bad_bit, new_bit);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exclusive_bit",
          "args": [
            "new_bit"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "exclusive_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1627-1647",
          "snippet": "static int exclusive_bit(int new_bit)\n{\n\t/*\n\t * USED_IN\n\t * USED_IN_READ\n\t * ENABLED\n\t * ENABLED_READ\n\t *\n\t * bit 0 - write/read\n\t * bit 1 - used_in/enabled\n\t * bit 2+  state\n\t */\n\n\tint state = new_bit & ~3;\n\tint dir = new_bit & 2;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ 2);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int exclusive_bit(int new_bit)\n{\n\t/*\n\t * USED_IN\n\t * USED_IN_READ\n\t * ENABLED\n\t * ENABLED_READ\n\t *\n\t * bit 0 - write/read\n\t * bit 1 - used_in/enabled\n\t * bit 2+  state\n\t */\n\n\tint state = new_bit & ~3;\n\tint dir = new_bit & 2;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define STRICT_READ_CHECKS\t1\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\nmark_lock_irq(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit new_bit)\n{\n\tint excl_bit = exclusive_bit(new_bit);\n\tint read = new_bit & 1;\n\tint dir = new_bit & 2;\n\n\t/*\n\t * mark USED_IN has to look forwards -- to ensure no dependency\n\t * has ENABLED state, which would allow recursion deadlocks.\n\t *\n\t * mark ENABLED has to look backwards -- to ensure no dependee\n\t * has USED_IN state, which, again, would allow  recursion deadlocks.\n\t */\n\tcheck_usage_f usage = dir ?\n\t\tcheck_usage_backwards : check_usage_forwards;\n\n\t/*\n\t * Validate that this particular lock does not have conflicting\n\t * usage states.\n\t */\n\tif (!valid_state(curr, this, new_bit, excl_bit))\n\t\treturn 0;\n\n\t/*\n\t * Validate that the lock dependencies don't have conflicting usage\n\t * states.\n\t */\n\tif ((!read || !dir || STRICT_READ_CHECKS) &&\n\t\t\t!usage(curr, this, excl_bit, state_name(new_bit & ~1)))\n\t\treturn 0;\n\n\t/*\n\t * Check for read in write conflicts\n\t */\n\tif (!read) {\n\t\tif (!valid_state(curr, this, new_bit, excl_bit + 1))\n\t\t\treturn 0;\n\n\t\tif (STRICT_READ_CHECKS &&\n\t\t\t!usage(curr, this, excl_bit + 1,\n\t\t\t\tstate_name(new_bit + 1)))\n\t\t\treturn 0;\n\t}\n\n\tif (state_verbose(new_bit, hlock_class(this)))\n\t\treturn 2;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "state_verbose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2648-2652",
    "snippet": "static inline int state_verbose(enum lock_usage_bit bit,\n\t\t\t\tstruct lock_class *class)\n{\n\treturn state_verbose_f[bit >> 2](class);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state_verbose_f[bit >> 2]",
          "args": [
            "class"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int state_verbose(enum lock_usage_bit bit,\n\t\t\t\tstruct lock_class *class)\n{\n\treturn state_verbose_f[bit >> 2](class);\n}"
  },
  {
    "function_name": "SOFTIRQ_verbose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2631-2637",
    "snippet": "static int SOFTIRQ_verbose(struct lock_class *class)\n{\n#if SOFTIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_filter",
          "args": [
            "class"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "class_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "350-363",
          "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int SOFTIRQ_verbose(struct lock_class *class)\n{\n#if SOFTIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "HARDIRQ_verbose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2623-2629",
    "snippet": "static int HARDIRQ_verbose(struct lock_class *class)\n{\n#if HARDIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_filter",
          "args": [
            "class"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "class_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "350-363",
          "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int HARDIRQ_verbose(struct lock_class *class)\n{\n#if HARDIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "print_irqtrace_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2606-2621",
    "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"softirqs last disabled at (%u): [<%px>] %pS\\n\"",
            "curr->softirq_disable_event",
            "(void *)curr->softirq_disable_ip",
            "(void *)curr->softirq_disable_ip"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"irq event stamp: %u\\n\"",
            "curr->irq_events"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}"
  },
  {
    "function_name": "check_usage_backwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2586-2604",
    "snippet": "static int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list root;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\troot.parent = NULL;\n\troot.class = hlock_class(this);\n\tret = find_usage_backwards(&root, bit, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, irqclass);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_irq_inversion_bug",
          "args": [
            "curr",
            "&root",
            "target_entry",
            "this",
            "0",
            "irqclass"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "print_irq_inversion_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2497-2556",
          "snippet": "static int\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\tif (!save_trace(&root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\tif (!save_trace(&root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_bfs_bug",
          "args": [
            "ret"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "print_bfs_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1226-1237",
          "snippet": "static noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_usage_backwards",
          "args": [
            "&root",
            "bit",
            "&target_entry"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "find_usage_backwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1375-1386",
          "snippet": "static int\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list root;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\troot.parent = NULL;\n\troot.class = hlock_class(this);\n\tret = find_usage_backwards(&root, bit, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, irqclass);\n}"
  },
  {
    "function_name": "check_usage_forwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2562-2580",
    "snippet": "static int\ncheck_usage_forwards(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit bit, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list root;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\troot.parent = NULL;\n\troot.class = hlock_class(this);\n\tret = find_usage_forwards(&root, bit, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, irqclass);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_irq_inversion_bug",
          "args": [
            "curr",
            "&root",
            "target_entry",
            "this",
            "1",
            "irqclass"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "print_irq_inversion_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2497-2556",
          "snippet": "static int\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\tif (!save_trace(&root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\tif (!save_trace(&root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_bfs_bug",
          "args": [
            "ret"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "print_bfs_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1226-1237",
          "snippet": "static noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_usage_forwards",
          "args": [
            "&root",
            "bit",
            "&target_entry"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "find_usage_forwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1352-1363",
          "snippet": "static int\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\ncheck_usage_forwards(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit bit, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list root;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\troot.parent = NULL;\n\troot.class = hlock_class(this);\n\tret = find_usage_forwards(&root, bit, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, irqclass);\n}"
  },
  {
    "function_name": "print_irq_inversion_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2497-2556",
    "snippet": "static int\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\tif (!save_trace(&root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_shortest_lock_dependencies",
          "args": [
            "other",
            "root"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "print_shortest_lock_dependencies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1417-1443",
          "snippet": "static void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\tstruct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\tprint_stack_trace(&entry->trace, 2);\n\t\tprintk(\"\\n\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n\n\treturn;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\tstruct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\tprint_stack_trace(&entry->trace, 2);\n\t\tprintk(\"\\n\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [
            "&root->trace"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "390-426",
          "snippet": "static int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_stack_trace_entries;\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\""
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_irq_lock_scenario",
          "args": [
            "other",
            "root",
            "middle ? middle->class : other->class",
            "root->class"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "print_irq_lock_scenario",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1445-1499",
          "snippet": "static void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "entry"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "969-972",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"lockdep:%s bad path found in chain graph\\n\"",
            "__func__"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_depth",
          "args": [
            "other"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "974-984",
          "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\""
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "other->class"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "514-523",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"but this lock was taken by another, %s-safe lock in the past:\\n\"",
            "irqclass"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"but this lock took another, %s-unsafe lock in the past:\\n\"",
            "irqclass"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "this"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d just changed the state of lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"--------------------------------------------------------\\n\""
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: possible irq lock inversion dependency detected\\n\""
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"========================================================\\n\""
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = NULL;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"========================================================\\n\");\n\tpr_warn(\"WARNING: possible irq lock inversion dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(this);\n\tif (forwards)\n\t\tpr_warn(\"but this lock took another, %s-unsafe lock in the past:\\n\", irqclass);\n\telse\n\t\tpr_warn(\"but this lock was taken by another, %s-safe lock in the past:\\n\", irqclass);\n\tprint_lock_name(other->class);\n\tpr_warn(\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\");\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\n\t/* Find a middle lock (if one exists) */\n\tdepth = get_lock_depth(other);\n\tdo {\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tpr_warn(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmiddle = entry;\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && entry != root && (depth >= 0));\n\tif (forwards)\n\t\tprint_irq_lock_scenario(root, other,\n\t\t\tmiddle ? middle->class : root->class, other->class);\n\telse\n\t\tprint_irq_lock_scenario(other, root,\n\t\t\tmiddle ? middle->class : other->class, root->class);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\");\n\tif (!save_trace(&root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(other, root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "valid_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2480-2487",
    "snippet": "static inline int\nvalid_state(struct task_struct *curr, struct held_lock *this,\n\t    enum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\n{\n\tif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit)))\n\t\treturn print_usage_bug(curr, this, bad_bit, new_bit);\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_usage_bug",
          "args": [
            "curr",
            "this",
            "bad_bit",
            "new_bit"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2438-2475",
          "snippet": "static int\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\ttrace_hardirq_context(curr), hardirq_count() >> HARDIRQ_SHIFT,\n\t\ttrace_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\ttrace_hardirqs_enabled(curr),\n\t\ttrace_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_stack_trace(hlock_class(this)->usage_traces + prev_bit, 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};",
            "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic int\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\ttrace_hardirq_context(curr), hardirq_count() >> HARDIRQ_SHIFT,\n\t\ttrace_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\ttrace_hardirqs_enabled(curr),\n\t\ttrace_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_stack_trace(hlock_class(this)->usage_traces + prev_bit, 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hlock_class(this)->usage_mask & (1 << bad_bit)"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic inline int\nvalid_state(struct task_struct *curr, struct held_lock *this,\n\t    enum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\n{\n\tif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit)))\n\t\treturn print_usage_bug(curr, this, bad_bit, new_bit);\n\treturn 1;\n}"
  },
  {
    "function_name": "print_usage_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2438-2475",
    "snippet": "static int\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\ttrace_hardirq_context(curr), hardirq_count() >> HARDIRQ_SHIFT,\n\t\ttrace_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\ttrace_hardirqs_enabled(curr),\n\t\ttrace_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_stack_trace(hlock_class(this)->usage_traces + prev_bit, 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};",
      "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 2469
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage_bug_scenario",
          "args": [
            "this"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage_bug_scenario",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2420-2436",
          "snippet": "static void\nprint_usage_bug_scenario(struct held_lock *lock)\n{\n\tstruct lock_class *class = hlock_class(lock);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_usage_bug_scenario(struct held_lock *lock)\n{\n\tstruct lock_class *class = hlock_class(lock);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "curr"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2606-2621",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "hlock_class(this)->usage_traces + prev_bit",
            "1"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "print_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stacktrace.c",
          "lines": "14-23",
          "snippet": "void print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\nvoid print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "this"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"{%s} state was registered at:\\n\"",
            "usage_str[prev_bit]"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "this"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)",
            "trace_hardirq_context(curr)",
            "hardirq_count() >> HARDIRQ_SHIFT",
            "trace_softirq_context(curr)",
            "softirq_count() >> SOFTIRQ_SHIFT",
            "trace_hardirqs_enabled(curr)",
            "trace_softirqs_enabled(curr)"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_softirqs_enabled",
          "args": [
            "curr"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_enabled",
          "args": [
            "curr"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_softirq_context",
          "args": [
            "curr"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirq_context",
          "args": [
            "curr"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"inconsistent {%s} -> {%s} usage.\\n\"",
            "usage_str[prev_bit]",
            "usage_str[new_bit]"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"--------------------------------\\n\""
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: inconsistent lock state\\n\""
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"================================\\n\""
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\nstatic int\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\n\t\tenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"================================\\n\");\n\tpr_warn(\"WARNING: inconsistent lock state\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------\\n\");\n\n\tpr_warn(\"inconsistent {%s} -> {%s} usage.\\n\",\n\t\tusage_str[prev_bit], usage_str[new_bit]);\n\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\ttrace_hardirq_context(curr), hardirq_count() >> HARDIRQ_SHIFT,\n\t\ttrace_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\n\t\ttrace_hardirqs_enabled(curr),\n\t\ttrace_softirqs_enabled(curr));\n\tprint_lock(this);\n\n\tpr_warn(\"{%s} state was registered at:\\n\", usage_str[prev_bit]);\n\tprint_stack_trace(hlock_class(this)->usage_traces + prev_bit, 1);\n\n\tprint_irqtrace_events(curr);\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_usage_bug_scenario(this);\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_usage_bug_scenario",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2420-2436",
    "snippet": "static void\nprint_usage_bug_scenario(struct held_lock *lock)\n{\n\tstruct lock_class *class = hlock_class(lock);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n *** DEADLOCK ***\\n\\n\""
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "class"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "496-512",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "lock"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_usage_bug_scenario(struct held_lock *lock)\n{\n\tstruct lock_class *class = hlock_class(lock);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
  },
  {
    "function_name": "check_chain_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2373-2418",
    "snippet": "static void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\"",
            "curr->lockdep_depth",
            "i",
            "(unsigned long long)chain_key",
            "(unsigned long long)curr->curr_chain_key"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_chain_key",
          "args": [
            "chain_key",
            "hlock->class_idx"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_chain_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "310-317",
          "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "hlock->class_idx > MAX_LOCKDEP_KEYS"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\"",
            "curr->lockdep_depth",
            "i",
            "(unsigned long long)chain_key",
            "(unsigned long long)hlock->prev_chain_key"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void check_chain_key(struct task_struct *curr)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tstruct held_lock *hlock, *prev_hlock = NULL;\n\tunsigned int i;\n\tu64 chain_key = 0;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tif (chain_key != hlock->prev_chain_key) {\n\t\t\tdebug_locks_off();\n\t\t\t/*\n\t\t\t * We got mighty confused, our chain keys don't match\n\t\t\t * with what we expect, someone trample on our task state?\n\t\t\t */\n\t\t\tWARN(1, \"hm#1, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\t\tcurr->lockdep_depth, i,\n\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t(unsigned long long)hlock->prev_chain_key);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Whoops ran out of static storage again?\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(hlock->class_idx > MAX_LOCKDEP_KEYS))\n\t\t\treturn;\n\n\t\tif (prev_hlock && (prev_hlock->irq_context !=\n\t\t\t\t\t\t\thlock->irq_context))\n\t\t\tchain_key = 0;\n\t\tchain_key = iterate_chain_key(chain_key, hlock->class_idx);\n\t\tprev_hlock = hlock;\n\t}\n\tif (chain_key != curr->curr_chain_key) {\n\t\tdebug_locks_off();\n\t\t/*\n\t\t * More smoking hash instead of calculating it, damn see these\n\t\t * numbers float.. I bet that a pink elephant stepped on my memory.\n\t\t */\n\t\tWARN(1, \"hm#2, depth: %u [%u], %016Lx != %016Lx\\n\",\n\t\t\tcurr->lockdep_depth, i,\n\t\t\t(unsigned long long)chain_key,\n\t\t\t(unsigned long long)curr->curr_chain_key);\n\t}\n#endif\n}"
  },
  {
    "function_name": "validate_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2361-2366",
    "snippet": "static inline int validate_chain(struct task_struct *curr,\n\t       \tstruct lockdep_map *lock, struct held_lock *hlock,\n\t\tint chain_head, u64 chain_key)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int validate_chain(struct task_struct *curr,\n\t       \tstruct lockdep_map *lock, struct held_lock *hlock,\n\t\tint chain_head, u64 chain_key)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "validate_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2304-2359",
    "snippet": "static int validate_chain(struct task_struct *curr, struct lockdep_map *lock,\n\t\tstruct held_lock *hlock, int chain_head, u64 chain_key)\n{\n\t/*\n\t * Trylock needs to maintain the stack of held locks, but it\n\t * does not add new dependencies, because trylock can be done\n\t * in any order.\n\t *\n\t * We look up the chain_key and do the O(N^2) check and update of\n\t * the dependencies only if this is a new dependency chain.\n\t * (If lookup_chain_cache_add() return with 1 it acquires\n\t * graph_lock for us)\n\t */\n\tif (!hlock->trylock && hlock->check &&\n\t    lookup_chain_cache_add(curr, hlock, chain_key)) {\n\t\t/*\n\t\t * Check whether last held lock:\n\t\t *\n\t\t * - is irq-safe, if this lock is irq-unsafe\n\t\t * - is softirq-safe, if this lock is hardirq-unsafe\n\t\t *\n\t\t * And check whether the new lock's dependency graph\n\t\t * could lead back to the previous lock.\n\t\t *\n\t\t * any of these scenarios could lead to a deadlock. If\n\t\t * All validations\n\t\t */\n\t\tint ret = check_deadlock(curr, hlock, lock, hlock->read);\n\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Mark recursive read, as we jump over it when\n\t\t * building dependencies (just like we jump over\n\t\t * trylock entries):\n\t\t */\n\t\tif (ret == 2)\n\t\t\thlock->read = 2;\n\t\t/*\n\t\t * Add dependency only if this lock is not the head\n\t\t * of the chain, and if it's not a secondary read-lock:\n\t\t */\n\t\tif (!chain_head && ret != 2) {\n\t\t\tif (!check_prevs_add(curr, hlock))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tgraph_unlock();\n\t} else {\n\t\t/* after lookup_chain_cache_add(): */\n\t\tif (unlikely(!debug_locks))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_prevs_add",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "check_prevs_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1940-2016",
          "snippet": "static int\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\n{\n\tint depth = curr->lockdep_depth;\n\tstruct held_lock *hlock;\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.max_entries = 0,\n\t\t.entries = NULL,\n\t\t.skip = 0,\n\t};\n\n\t/*\n\t * Debugging checks.\n\t *\n\t * Depth must not be zero for a non-head lock:\n\t */\n\tif (!depth)\n\t\tgoto out_bug;\n\t/*\n\t * At least two relevant locks must exist for this\n\t * to be a head:\n\t */\n\tif (curr->held_locks[depth].irq_context !=\n\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\tgoto out_bug;\n\n\tfor (;;) {\n\t\tint distance = curr->lockdep_depth - depth + 1;\n\t\thlock = curr->held_locks + depth - 1;\n\n\t\t/*\n\t\t * Only non-recursive-read entries get new dependencies\n\t\t * added:\n\t\t */\n\t\tif (hlock->read != 2 && hlock->check) {\n\t\t\tint ret = check_prev_add(curr, hlock, next, distance, &trace, save_trace);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Stop after the first non-trylock entry,\n\t\t\t * as non-trylock entries have added their\n\t\t\t * own direct dependencies already, so this\n\t\t\t * lock is connected to them indirectly:\n\t\t\t */\n\t\t\tif (!hlock->trylock)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdepth--;\n\t\t/*\n\t\t * End of lock-stack?\n\t\t */\n\t\tif (!depth)\n\t\t\tbreak;\n\t\t/*\n\t\t * Stop the search if we cross into another context:\n\t\t */\n\t\tif (curr->held_locks[depth].irq_context !=\n\t\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\t\tbreak;\n\t}\n\treturn 1;\nout_bug:\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Clearly we all shouldn't be here, but since we made it we\n\t * can reliable say we messed up our state. See the above two\n\t * gotos for reasons why we could possibly end up here.\n\t */\n\tWARN_ON(1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\n{\n\tint depth = curr->lockdep_depth;\n\tstruct held_lock *hlock;\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.max_entries = 0,\n\t\t.entries = NULL,\n\t\t.skip = 0,\n\t};\n\n\t/*\n\t * Debugging checks.\n\t *\n\t * Depth must not be zero for a non-head lock:\n\t */\n\tif (!depth)\n\t\tgoto out_bug;\n\t/*\n\t * At least two relevant locks must exist for this\n\t * to be a head:\n\t */\n\tif (curr->held_locks[depth].irq_context !=\n\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\tgoto out_bug;\n\n\tfor (;;) {\n\t\tint distance = curr->lockdep_depth - depth + 1;\n\t\thlock = curr->held_locks + depth - 1;\n\n\t\t/*\n\t\t * Only non-recursive-read entries get new dependencies\n\t\t * added:\n\t\t */\n\t\tif (hlock->read != 2 && hlock->check) {\n\t\t\tint ret = check_prev_add(curr, hlock, next, distance, &trace, save_trace);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Stop after the first non-trylock entry,\n\t\t\t * as non-trylock entries have added their\n\t\t\t * own direct dependencies already, so this\n\t\t\t * lock is connected to them indirectly:\n\t\t\t */\n\t\t\tif (!hlock->trylock)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdepth--;\n\t\t/*\n\t\t * End of lock-stack?\n\t\t */\n\t\tif (!depth)\n\t\t\tbreak;\n\t\t/*\n\t\t * Stop the search if we cross into another context:\n\t\t */\n\t\tif (curr->held_locks[depth].irq_context !=\n\t\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\t\tbreak;\n\t}\n\treturn 1;\nout_bug:\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Clearly we all shouldn't be here, but since we made it we\n\t * can reliable say we messed up our state. See the above two\n\t * gotos for reasons why we could possibly end up here.\n\t */\n\tWARN_ON(1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_deadlock",
          "args": [
            "curr",
            "hlock",
            "lock",
            "hlock->read"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "check_deadlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1774-1808",
          "snippet": "static int\ncheck_deadlock(struct task_struct *curr, struct held_lock *next,\n\t       struct lockdep_map *next_instance, int read)\n{\n\tstruct held_lock *prev;\n\tstruct held_lock *nest = NULL;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tprev = curr->held_locks + i;\n\n\t\tif (prev->instance == next->nest_lock)\n\t\t\tnest = prev;\n\n\t\tif (hlock_class(prev) != hlock_class(next))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Allow read-after-read recursion of the same\n\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):\n\t\t */\n\t\tif ((read == 2) && prev->read)\n\t\t\treturn 2;\n\n\t\t/*\n\t\t * We're holding the nest_lock, which serializes this lock's\n\t\t * nesting behaviour.\n\t\t */\n\t\tif (nest)\n\t\t\treturn 2;\n\n\t\treturn print_deadlock_bug(curr, prev, next);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_deadlock(struct task_struct *curr, struct held_lock *next,\n\t       struct lockdep_map *next_instance, int read)\n{\n\tstruct held_lock *prev;\n\tstruct held_lock *nest = NULL;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tprev = curr->held_locks + i;\n\n\t\tif (prev->instance == next->nest_lock)\n\t\t\tnest = prev;\n\n\t\tif (hlock_class(prev) != hlock_class(next))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Allow read-after-read recursion of the same\n\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):\n\t\t */\n\t\tif ((read == 2) && prev->read)\n\t\t\treturn 2;\n\n\t\t/*\n\t\t * We're holding the nest_lock, which serializes this lock's\n\t\t * nesting behaviour.\n\t\t */\n\t\tif (nest)\n\t\t\treturn 2;\n\n\t\treturn print_deadlock_bug(curr, prev, next);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_chain_cache_add",
          "args": [
            "curr",
            "hlock",
            "chain_key"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_chain_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2259-2302",
          "snippet": "static inline int lookup_chain_cache_add(struct task_struct *curr,\n\t\t\t\t\t struct held_lock *hlock,\n\t\t\t\t\t u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct lock_chain *chain = lookup_chain_cache(chain_key);\n\n\tif (chain) {\ncache_hit:\n\t\tif (!check_no_collision(curr, hlock, chain))\n\t\t\treturn 0;\n\n\t\tif (very_verbose(class)) {\n\t\t\tprintk(\"\\nhash chain already cached, key: \"\n\t\t\t\t\t\"%016Lx tail class: [%px] %s\\n\",\n\t\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t\tclass->key, class->name);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\",\n\t\t\t(unsigned long long)chain_key, class->key, class->name);\n\t}\n\n\tif (!graph_lock())\n\t\treturn 0;\n\n\t/*\n\t * We have to walk the chain again locked - to avoid duplicates:\n\t */\n\tchain = lookup_chain_cache(chain_key);\n\tif (chain) {\n\t\tgraph_unlock();\n\t\tgoto cache_hit;\n\t}\n\n\tif (!add_chain_cache(curr, hlock, chain_key))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int lookup_chain_cache_add(struct task_struct *curr,\n\t\t\t\t\t struct held_lock *hlock,\n\t\t\t\t\t u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct lock_chain *chain = lookup_chain_cache(chain_key);\n\n\tif (chain) {\ncache_hit:\n\t\tif (!check_no_collision(curr, hlock, chain))\n\t\t\treturn 0;\n\n\t\tif (very_verbose(class)) {\n\t\t\tprintk(\"\\nhash chain already cached, key: \"\n\t\t\t\t\t\"%016Lx tail class: [%px] %s\\n\",\n\t\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t\tclass->key, class->name);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\",\n\t\t\t(unsigned long long)chain_key, class->key, class->name);\n\t}\n\n\tif (!graph_lock())\n\t\treturn 0;\n\n\t/*\n\t * We have to walk the chain again locked - to avoid duplicates:\n\t */\n\tchain = lookup_chain_cache(chain_key);\n\tif (chain) {\n\t\tgraph_unlock();\n\t\tgoto cache_hit;\n\t}\n\n\tif (!add_chain_cache(curr, hlock, chain_key))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int validate_chain(struct task_struct *curr, struct lockdep_map *lock,\n\t\tstruct held_lock *hlock, int chain_head, u64 chain_key)\n{\n\t/*\n\t * Trylock needs to maintain the stack of held locks, but it\n\t * does not add new dependencies, because trylock can be done\n\t * in any order.\n\t *\n\t * We look up the chain_key and do the O(N^2) check and update of\n\t * the dependencies only if this is a new dependency chain.\n\t * (If lookup_chain_cache_add() return with 1 it acquires\n\t * graph_lock for us)\n\t */\n\tif (!hlock->trylock && hlock->check &&\n\t    lookup_chain_cache_add(curr, hlock, chain_key)) {\n\t\t/*\n\t\t * Check whether last held lock:\n\t\t *\n\t\t * - is irq-safe, if this lock is irq-unsafe\n\t\t * - is softirq-safe, if this lock is hardirq-unsafe\n\t\t *\n\t\t * And check whether the new lock's dependency graph\n\t\t * could lead back to the previous lock.\n\t\t *\n\t\t * any of these scenarios could lead to a deadlock. If\n\t\t * All validations\n\t\t */\n\t\tint ret = check_deadlock(curr, hlock, lock, hlock->read);\n\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Mark recursive read, as we jump over it when\n\t\t * building dependencies (just like we jump over\n\t\t * trylock entries):\n\t\t */\n\t\tif (ret == 2)\n\t\t\thlock->read = 2;\n\t\t/*\n\t\t * Add dependency only if this lock is not the head\n\t\t * of the chain, and if it's not a secondary read-lock:\n\t\t */\n\t\tif (!chain_head && ret != 2) {\n\t\t\tif (!check_prevs_add(curr, hlock))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tgraph_unlock();\n\t} else {\n\t\t/* after lookup_chain_cache_add(): */\n\t\tif (unlikely(!debug_locks))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "lookup_chain_cache_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2259-2302",
    "snippet": "static inline int lookup_chain_cache_add(struct task_struct *curr,\n\t\t\t\t\t struct held_lock *hlock,\n\t\t\t\t\t u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct lock_chain *chain = lookup_chain_cache(chain_key);\n\n\tif (chain) {\ncache_hit:\n\t\tif (!check_no_collision(curr, hlock, chain))\n\t\t\treturn 0;\n\n\t\tif (very_verbose(class)) {\n\t\t\tprintk(\"\\nhash chain already cached, key: \"\n\t\t\t\t\t\"%016Lx tail class: [%px] %s\\n\",\n\t\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t\tclass->key, class->name);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\",\n\t\t\t(unsigned long long)chain_key, class->key, class->name);\n\t}\n\n\tif (!graph_lock())\n\t\treturn 0;\n\n\t/*\n\t * We have to walk the chain again locked - to avoid duplicates:\n\t */\n\tchain = lookup_chain_cache(chain_key);\n\tif (chain) {\n\t\tgraph_unlock();\n\t\tgoto cache_hit;\n\t}\n\n\tif (!add_chain_cache(curr, hlock, chain_key))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_chain_cache",
          "args": [
            "curr",
            "hlock",
            "chain_key"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2159-2230",
          "snippet": "static inline int add_chain_cache(struct task_struct *curr,\n\t\t\t\t  struct held_lock *hlock,\n\t\t\t\t  u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\tint i, j;\n\n\t/*\n\t * Allocate a new chain entry from the static array, and add\n\t * it to the hash:\n\t */\n\n\t/*\n\t * We might need to take the graph lock, ensure we've got IRQs\n\t * disabled to make this an IRQ-safe lock.. for recursion reasons\n\t * lockdep won't complain about its own locking errors.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tif (unlikely(nr_lock_chains >= MAX_LOCKDEP_CHAINS)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAINS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\tchain = lock_chains + nr_lock_chains++;\n\tchain->chain_key = chain_key;\n\tchain->irq_context = hlock->irq_context;\n\ti = get_first_held_lock(curr, hlock);\n\tchain->depth = curr->lockdep_depth + 1 - i;\n\n\tBUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));\n\tBUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));\n\tBUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));\n\n\tif (likely(nr_chain_hlocks + chain->depth <= MAX_LOCKDEP_CHAIN_HLOCKS)) {\n\t\tchain->base = nr_chain_hlocks;\n\t\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\t\tint lock_id = curr->held_locks[i].class_idx - 1;\n\t\t\tchain_hlocks[chain->base + j] = lock_id;\n\t\t}\n\t\tchain_hlocks[chain->base + j] = class - lock_classes;\n\t}\n\n\tif (nr_chain_hlocks < MAX_LOCKDEP_CHAIN_HLOCKS)\n\t\tnr_chain_hlocks += chain->depth;\n\n#ifdef CONFIG_DEBUG_LOCKDEP\n\t/*\n\t * Important for check_no_collision().\n\t */\n\tif (unlikely(nr_chain_hlocks > MAX_LOCKDEP_CHAIN_HLOCKS)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n#endif\n\n\thlist_add_head_rcu(&chain->entry, hash_head);\n\tdebug_atomic_inc(chain_lookup_misses);\n\tinc_chains();\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline int add_chain_cache(struct task_struct *curr,\n\t\t\t\t  struct held_lock *hlock,\n\t\t\t\t  u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\tint i, j;\n\n\t/*\n\t * Allocate a new chain entry from the static array, and add\n\t * it to the hash:\n\t */\n\n\t/*\n\t * We might need to take the graph lock, ensure we've got IRQs\n\t * disabled to make this an IRQ-safe lock.. for recursion reasons\n\t * lockdep won't complain about its own locking errors.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tif (unlikely(nr_lock_chains >= MAX_LOCKDEP_CHAINS)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAINS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\tchain = lock_chains + nr_lock_chains++;\n\tchain->chain_key = chain_key;\n\tchain->irq_context = hlock->irq_context;\n\ti = get_first_held_lock(curr, hlock);\n\tchain->depth = curr->lockdep_depth + 1 - i;\n\n\tBUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));\n\tBUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));\n\tBUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));\n\n\tif (likely(nr_chain_hlocks + chain->depth <= MAX_LOCKDEP_CHAIN_HLOCKS)) {\n\t\tchain->base = nr_chain_hlocks;\n\t\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\t\tint lock_id = curr->held_locks[i].class_idx - 1;\n\t\t\tchain_hlocks[chain->base + j] = lock_id;\n\t\t}\n\t\tchain_hlocks[chain->base + j] = class - lock_classes;\n\t}\n\n\tif (nr_chain_hlocks < MAX_LOCKDEP_CHAIN_HLOCKS)\n\t\tnr_chain_hlocks += chain->depth;\n\n#ifdef CONFIG_DEBUG_LOCKDEP\n\t/*\n\t * Important for check_no_collision().\n\t */\n\tif (unlikely(nr_chain_hlocks > MAX_LOCKDEP_CHAIN_HLOCKS)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n#endif\n\n\thlist_add_head_rcu(&chain->entry, hash_head);\n\tdebug_atomic_inc(chain_lookup_misses);\n\tinc_chains();\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_chain_cache",
          "args": [
            "chain_key"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_chain_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2235-2251",
          "snippet": "static inline struct lock_chain *lookup_chain_cache(u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\n\t/*\n\t * We can walk it lock-free, because entries only get added\n\t * to the hash:\n\t */\n\thlist_for_each_entry_rcu(chain, hash_head, entry) {\n\t\tif (chain->chain_key == chain_key) {\n\t\t\tdebug_atomic_inc(chain_lookup_hits);\n\t\t\treturn chain;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_chain *lookup_chain_cache(u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\n\t/*\n\t * We can walk it lock-free, because entries only get added\n\t * to the hash:\n\t */\n\thlist_for_each_entry_rcu(chain, hash_head, entry) {\n\t\tif (chain->chain_key == chain_key) {\n\t\t\tdebug_atomic_inc(chain_lookup_hits);\n\t\t\treturn chain;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "85-101",
          "snippet": "static int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\"",
            "(unsigned long long)chain_key",
            "class->key",
            "class->name"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "very_verbose",
          "args": [
            "class"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "very_verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "587-593",
          "snippet": "static int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define VERY_VERBOSE\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define VERY_VERBOSE\t\t0\n\nstatic int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_no_collision",
          "args": [
            "curr",
            "hlock",
            "chain"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "check_no_collision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2126-2150",
          "snippet": "static int check_no_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock,\n\t\t\tstruct lock_chain *chain)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tint i, j, id;\n\n\ti = get_first_held_lock(curr, hlock);\n\n\tif (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {\n\t\tprint_collision(curr, hlock, chain);\n\t\treturn 0;\n\t}\n\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tid = curr->held_locks[i].class_idx - 1;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {\n\t\t\tprint_collision(curr, hlock, chain);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int check_no_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock,\n\t\t\tstruct lock_chain *chain)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tint i, j, id;\n\n\ti = get_first_held_lock(curr, hlock);\n\n\tif (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {\n\t\tprint_collision(curr, hlock, chain);\n\t\treturn 0;\n\t}\n\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tid = curr->held_locks[i].class_idx - 1;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {\n\t\t\tprint_collision(curr, hlock, chain);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int lookup_chain_cache_add(struct task_struct *curr,\n\t\t\t\t\t struct held_lock *hlock,\n\t\t\t\t\t u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct lock_chain *chain = lookup_chain_cache(chain_key);\n\n\tif (chain) {\ncache_hit:\n\t\tif (!check_no_collision(curr, hlock, chain))\n\t\t\treturn 0;\n\n\t\tif (very_verbose(class)) {\n\t\t\tprintk(\"\\nhash chain already cached, key: \"\n\t\t\t\t\t\"%016Lx tail class: [%px] %s\\n\",\n\t\t\t\t\t(unsigned long long)chain_key,\n\t\t\t\t\tclass->key, class->name);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (very_verbose(class)) {\n\t\tprintk(\"\\nnew hash chain, key: %016Lx tail class: [%px] %s\\n\",\n\t\t\t(unsigned long long)chain_key, class->key, class->name);\n\t}\n\n\tif (!graph_lock())\n\t\treturn 0;\n\n\t/*\n\t * We have to walk the chain again locked - to avoid duplicates:\n\t */\n\tchain = lookup_chain_cache(chain_key);\n\tif (chain) {\n\t\tgraph_unlock();\n\t\tgoto cache_hit;\n\t}\n\n\tif (!add_chain_cache(curr, hlock, chain_key))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "lookup_chain_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2235-2251",
    "snippet": "static inline struct lock_chain *lookup_chain_cache(u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\n\t/*\n\t * We can walk it lock-free, because entries only get added\n\t * to the hash:\n\t */\n\thlist_for_each_entry_rcu(chain, hash_head, entry) {\n\t\tif (chain->chain_key == chain_key) {\n\t\t\tdebug_atomic_inc(chain_lookup_hits);\n\t\t\treturn chain;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "chain_lookup_hits"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "chain",
            "hash_head",
            "entry"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chainhashentry",
          "args": [
            "chain_key"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_chain *lookup_chain_cache(u64 chain_key)\n{\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\n\t/*\n\t * We can walk it lock-free, because entries only get added\n\t * to the hash:\n\t */\n\thlist_for_each_entry_rcu(chain, hash_head, entry) {\n\t\tif (chain->chain_key == chain_key) {\n\t\t\tdebug_atomic_inc(chain_lookup_hits);\n\t\t\treturn chain;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "add_chain_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2159-2230",
    "snippet": "static inline int add_chain_cache(struct task_struct *curr,\n\t\t\t\t  struct held_lock *hlock,\n\t\t\t\t  u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\tint i, j;\n\n\t/*\n\t * Allocate a new chain entry from the static array, and add\n\t * it to the hash:\n\t */\n\n\t/*\n\t * We might need to take the graph lock, ensure we've got IRQs\n\t * disabled to make this an IRQ-safe lock.. for recursion reasons\n\t * lockdep won't complain about its own locking errors.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tif (unlikely(nr_lock_chains >= MAX_LOCKDEP_CHAINS)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAINS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\tchain = lock_chains + nr_lock_chains++;\n\tchain->chain_key = chain_key;\n\tchain->irq_context = hlock->irq_context;\n\ti = get_first_held_lock(curr, hlock);\n\tchain->depth = curr->lockdep_depth + 1 - i;\n\n\tBUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));\n\tBUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));\n\tBUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));\n\n\tif (likely(nr_chain_hlocks + chain->depth <= MAX_LOCKDEP_CHAIN_HLOCKS)) {\n\t\tchain->base = nr_chain_hlocks;\n\t\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\t\tint lock_id = curr->held_locks[i].class_idx - 1;\n\t\t\tchain_hlocks[chain->base + j] = lock_id;\n\t\t}\n\t\tchain_hlocks[chain->base + j] = class - lock_classes;\n\t}\n\n\tif (nr_chain_hlocks < MAX_LOCKDEP_CHAIN_HLOCKS)\n\t\tnr_chain_hlocks += chain->depth;\n\n#ifdef CONFIG_DEBUG_LOCKDEP\n\t/*\n\t * Important for check_no_collision().\n\t */\n\tif (unlikely(nr_chain_hlocks > MAX_LOCKDEP_CHAIN_HLOCKS)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n#endif\n\n\thlist_add_head_rcu(&chain->entry, hash_head);\n\tdebug_atomic_inc(chain_lookup_misses);\n\tinc_chains();\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_chains",
          "args": [],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "inc_chains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1711-1714",
          "snippet": "static inline void inc_chains(void)\n{\n\tnr_process_chains++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nr_process_chains;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned int nr_process_chains;\n\nstatic inline void inc_chains(void)\n{\n\tnr_process_chains++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "chain_lookup_misses"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&chain->entry",
            "hash_head"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\""
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "381-388",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_chain_hlocks > MAX_LOCKDEP_CHAIN_HLOCKS"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "nr_chain_hlocks + chain->depth <= MAX_LOCKDEP_CHAIN_HLOCKS"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes)"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "lock_classes"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(1UL << 6)  <= ARRAY_SIZE(curr->held_locks)"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "curr->held_locks"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(1UL << 24) <= ARRAY_SIZE(chain_hlocks)"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "chain_hlocks"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_first_held_lock",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2031-2045",
          "snippet": "static inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_lock_chains >= MAX_LOCKDEP_CHAINS"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chainhashentry",
          "args": [
            "chain_key"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline int add_chain_cache(struct task_struct *curr,\n\t\t\t\t  struct held_lock *hlock,\n\t\t\t\t  u64 chain_key)\n{\n\tstruct lock_class *class = hlock_class(hlock);\n\tstruct hlist_head *hash_head = chainhashentry(chain_key);\n\tstruct lock_chain *chain;\n\tint i, j;\n\n\t/*\n\t * Allocate a new chain entry from the static array, and add\n\t * it to the hash:\n\t */\n\n\t/*\n\t * We might need to take the graph lock, ensure we've got IRQs\n\t * disabled to make this an IRQ-safe lock.. for recursion reasons\n\t * lockdep won't complain about its own locking errors.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn 0;\n\n\tif (unlikely(nr_lock_chains >= MAX_LOCKDEP_CHAINS)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAINS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n\tchain = lock_chains + nr_lock_chains++;\n\tchain->chain_key = chain_key;\n\tchain->irq_context = hlock->irq_context;\n\ti = get_first_held_lock(curr, hlock);\n\tchain->depth = curr->lockdep_depth + 1 - i;\n\n\tBUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));\n\tBUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));\n\tBUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));\n\n\tif (likely(nr_chain_hlocks + chain->depth <= MAX_LOCKDEP_CHAIN_HLOCKS)) {\n\t\tchain->base = nr_chain_hlocks;\n\t\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\t\tint lock_id = curr->held_locks[i].class_idx - 1;\n\t\t\tchain_hlocks[chain->base + j] = lock_id;\n\t\t}\n\t\tchain_hlocks[chain->base + j] = class - lock_classes;\n\t}\n\n\tif (nr_chain_hlocks < MAX_LOCKDEP_CHAIN_HLOCKS)\n\t\tnr_chain_hlocks += chain->depth;\n\n#ifdef CONFIG_DEBUG_LOCKDEP\n\t/*\n\t * Important for check_no_collision().\n\t */\n\tif (unlikely(nr_chain_hlocks > MAX_LOCKDEP_CHAIN_HLOCKS)) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!\");\n\t\tdump_stack();\n\t\treturn 0;\n\t}\n#endif\n\n\thlist_add_head_rcu(&chain->entry, hash_head);\n\tdebug_atomic_inc(chain_lookup_misses);\n\tinc_chains();\n\n\treturn 1;\n}"
  },
  {
    "function_name": "check_no_collision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2126-2150",
    "snippet": "static int check_no_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock,\n\t\t\tstruct lock_chain *chain)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tint i, j, id;\n\n\ti = get_first_held_lock(curr, hlock);\n\n\tif (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {\n\t\tprint_collision(curr, hlock, chain);\n\t\treturn 0;\n\t}\n\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tid = curr->held_locks[i].class_idx - 1;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {\n\t\t\tprint_collision(curr, hlock, chain);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_collision",
          "args": [
            "curr",
            "hlock",
            "chain"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "print_collision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2097-2117",
          "snippet": "static void print_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock_next,\n\t\t\tstruct lock_chain *chain)\n{\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================\\n\");\n\tpr_warn(\"WARNING: chain_key collision\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------\\n\");\n\tpr_warn(\"%s/%d: \", current->comm, task_pid_nr(current));\n\tpr_warn(\"Hash chain already cached but the contents don't match!\\n\");\n\n\tpr_warn(\"Held locks:\");\n\tprint_chain_keys_held_locks(curr, hlock_next);\n\n\tpr_warn(\"Locks in cached chain:\");\n\tprint_chain_keys_chain(chain);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock_next,\n\t\t\tstruct lock_chain *chain)\n{\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================\\n\");\n\tpr_warn(\"WARNING: chain_key collision\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------\\n\");\n\tpr_warn(\"%s/%d: \", current->comm, task_pid_nr(current));\n\tpr_warn(\"Hash chain already cached but the contents don't match!\\n\");\n\n\tpr_warn(\"Held locks:\");\n\tprint_chain_keys_held_locks(curr, hlock_next);\n\n\tpr_warn(\"Locks in cached chain:\");\n\tprint_chain_keys_chain(chain);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "chain_hlocks[chain->base + j] != id"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "chain->depth != curr->lockdep_depth - (i - 1)"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_first_held_lock",
          "args": [
            "curr",
            "hlock"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2031-2045",
          "snippet": "static inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int check_no_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock,\n\t\t\tstruct lock_chain *chain)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tint i, j, id;\n\n\ti = get_first_held_lock(curr, hlock);\n\n\tif (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {\n\t\tprint_collision(curr, hlock, chain);\n\t\treturn 0;\n\t}\n\n\tfor (j = 0; j < chain->depth - 1; j++, i++) {\n\t\tid = curr->held_locks[i].class_idx - 1;\n\n\t\tif (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {\n\t\t\tprint_collision(curr, hlock, chain);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "print_collision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2097-2117",
    "snippet": "static void print_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock_next,\n\t\t\tstruct lock_chain *chain)\n{\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================\\n\");\n\tpr_warn(\"WARNING: chain_key collision\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------\\n\");\n\tpr_warn(\"%s/%d: \", current->comm, task_pid_nr(current));\n\tpr_warn(\"Hash chain already cached but the contents don't match!\\n\");\n\n\tpr_warn(\"Held locks:\");\n\tprint_chain_keys_held_locks(curr, hlock_next);\n\n\tpr_warn(\"Locks in cached chain:\");\n\tprint_chain_keys_chain(chain);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_chain_keys_chain",
          "args": [
            "chain"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "print_chain_keys_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2081-2095",
          "snippet": "static void print_chain_keys_chain(struct lock_chain *chain)\n{\n\tint i;\n\tu64 chain_key = 0;\n\tint class_id;\n\n\tprintk(\"depth: %u\\n\", chain->depth);\n\tfor (i = 0; i < chain->depth; i++) {\n\t\tclass_id = chain_hlocks[chain->base + i];\n\t\tchain_key = print_chain_key_iteration(class_id + 1, chain_key);\n\n\t\tprint_lock_name(lock_classes + class_id);\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic void print_chain_keys_chain(struct lock_chain *chain)\n{\n\tint i;\n\tu64 chain_key = 0;\n\tint class_id;\n\n\tprintk(\"depth: %u\\n\", chain->depth);\n\tfor (i = 0; i < chain->depth; i++) {\n\t\tclass_id = chain_hlocks[chain->base + i];\n\t\tchain_key = print_chain_key_iteration(class_id + 1, chain_key);\n\n\t\tprint_lock_name(lock_classes + class_id);\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Locks in cached chain:\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_chain_keys_held_locks",
          "args": [
            "curr",
            "hlock_next"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "print_chain_keys_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2061-2079",
          "snippet": "static void\nprint_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)\n{\n\tstruct held_lock *hlock;\n\tu64 chain_key = 0;\n\tint depth = curr->lockdep_depth;\n\tint i;\n\n\tprintk(\"depth: %u\\n\", depth + 1);\n\tfor (i = get_first_held_lock(curr, hlock_next); i < depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tchain_key = print_chain_key_iteration(hlock->class_idx, chain_key);\n\n\t\tprint_lock(hlock);\n\t}\n\n\tprint_chain_key_iteration(hlock_next->class_idx, chain_key);\n\tprint_lock(hlock_next);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)\n{\n\tstruct held_lock *hlock;\n\tu64 chain_key = 0;\n\tint depth = curr->lockdep_depth;\n\tint i;\n\n\tprintk(\"depth: %u\\n\", depth + 1);\n\tfor (i = get_first_held_lock(curr, hlock_next); i < depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tchain_key = print_chain_key_iteration(hlock->class_idx, chain_key);\n\n\t\tprint_lock(hlock);\n\t}\n\n\tprint_chain_key_iteration(hlock_next->class_idx, chain_key);\n\tprint_lock(hlock_next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Held locks:\""
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Hash chain already cached but the contents don't match!\\n\""
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d: \"",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"----------------------------\\n\""
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: chain_key collision\\n\""
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"============================\\n\""
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_collision(struct task_struct *curr,\n\t\t\tstruct held_lock *hlock_next,\n\t\t\tstruct lock_chain *chain)\n{\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================\\n\");\n\tpr_warn(\"WARNING: chain_key collision\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"----------------------------\\n\");\n\tpr_warn(\"%s/%d: \", current->comm, task_pid_nr(current));\n\tpr_warn(\"Hash chain already cached but the contents don't match!\\n\");\n\n\tpr_warn(\"Held locks:\");\n\tprint_chain_keys_held_locks(curr, hlock_next);\n\n\tpr_warn(\"Locks in cached chain:\");\n\tprint_chain_keys_chain(chain);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n}"
  },
  {
    "function_name": "print_chain_keys_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2081-2095",
    "snippet": "static void print_chain_keys_chain(struct lock_chain *chain)\n{\n\tint i;\n\tu64 chain_key = 0;\n\tint class_id;\n\n\tprintk(\"depth: %u\\n\", chain->depth);\n\tfor (i = 0; i < chain->depth; i++) {\n\t\tclass_id = chain_hlocks[chain->base + i];\n\t\tchain_key = print_chain_key_iteration(class_id + 1, chain_key);\n\n\t\tprint_lock_name(lock_classes + class_id);\n\t\tprintk(\"\\n\");\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "lock_classes + class_id"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "514-523",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_chain_key_iteration",
          "args": [
            "class_id + 1",
            "chain_key"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "print_chain_key_iteration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2051-2059",
          "snippet": "static u64 print_chain_key_iteration(int class_idx, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, class_idx);\n\n\tprintk(\" class_idx:%d -> chain_key:%016Lx\",\n\t\tclass_idx,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic u64 print_chain_key_iteration(int class_idx, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, class_idx);\n\n\tprintk(\" class_idx:%d -> chain_key:%016Lx\",\n\t\tclass_idx,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"depth: %u\\n\"",
            "chain->depth"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic void print_chain_keys_chain(struct lock_chain *chain)\n{\n\tint i;\n\tu64 chain_key = 0;\n\tint class_id;\n\n\tprintk(\"depth: %u\\n\", chain->depth);\n\tfor (i = 0; i < chain->depth; i++) {\n\t\tclass_id = chain_hlocks[chain->base + i];\n\t\tchain_key = print_chain_key_iteration(class_id + 1, chain_key);\n\n\t\tprint_lock_name(lock_classes + class_id);\n\t\tprintk(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "print_chain_keys_held_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2061-2079",
    "snippet": "static void\nprint_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)\n{\n\tstruct held_lock *hlock;\n\tu64 chain_key = 0;\n\tint depth = curr->lockdep_depth;\n\tint i;\n\n\tprintk(\"depth: %u\\n\", depth + 1);\n\tfor (i = get_first_held_lock(curr, hlock_next); i < depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tchain_key = print_chain_key_iteration(hlock->class_idx, chain_key);\n\n\t\tprint_lock(hlock);\n\t}\n\n\tprint_chain_key_iteration(hlock_next->class_idx, chain_key);\n\tprint_lock(hlock_next);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "hlock_next"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_chain_key_iteration",
          "args": [
            "hlock_next->class_idx",
            "chain_key"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "print_chain_key_iteration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2051-2059",
          "snippet": "static u64 print_chain_key_iteration(int class_idx, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, class_idx);\n\n\tprintk(\" class_idx:%d -> chain_key:%016Lx\",\n\t\tclass_idx,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic u64 print_chain_key_iteration(int class_idx, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, class_idx);\n\n\tprintk(\" class_idx:%d -> chain_key:%016Lx\",\n\t\tclass_idx,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_held_lock",
          "args": [
            "curr",
            "hlock_next"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2031-2045",
          "snippet": "static inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"depth: %u\\n\"",
            "depth + 1"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)\n{\n\tstruct held_lock *hlock;\n\tu64 chain_key = 0;\n\tint depth = curr->lockdep_depth;\n\tint i;\n\n\tprintk(\"depth: %u\\n\", depth + 1);\n\tfor (i = get_first_held_lock(curr, hlock_next); i < depth; i++) {\n\t\thlock = curr->held_locks + i;\n\t\tchain_key = print_chain_key_iteration(hlock->class_idx, chain_key);\n\n\t\tprint_lock(hlock);\n\t}\n\n\tprint_chain_key_iteration(hlock_next->class_idx, chain_key);\n\tprint_lock(hlock_next);\n}"
  },
  {
    "function_name": "print_chain_key_iteration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2051-2059",
    "snippet": "static u64 print_chain_key_iteration(int class_idx, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, class_idx);\n\n\tprintk(\" class_idx:%d -> chain_key:%016Lx\",\n\t\tclass_idx,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" class_idx:%d -> chain_key:%016Lx\"",
            "class_idx",
            "(unsigned long long)new_chain_key"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_chain_key",
          "args": [
            "chain_key",
            "class_idx"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_chain_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "310-317",
          "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic u64 print_chain_key_iteration(int class_idx, u64 chain_key)\n{\n\tu64 new_chain_key = iterate_chain_key(chain_key, class_idx);\n\n\tprintk(\" class_idx:%d -> chain_key:%016Lx\",\n\t\tclass_idx,\n\t\t(unsigned long long)new_chain_key);\n\treturn new_chain_key;\n}"
  },
  {
    "function_name": "get_first_held_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2031-2045",
    "snippet": "static inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int get_first_held_lock(struct task_struct *curr,\n\t\t\t\t\tstruct held_lock *hlock)\n{\n\tint i;\n\tstruct held_lock *hlock_curr;\n\n\tfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\n\t\thlock_curr = curr->held_locks + i;\n\t\tif (hlock_curr->irq_context != hlock->irq_context)\n\t\t\tbreak;\n\n\t}\n\n\treturn ++i;\n}"
  },
  {
    "function_name": "lock_chain_get_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "2023-2026",
    "snippet": "struct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)\n{\n\treturn lock_classes + chain_hlocks[chain->base + i];\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstruct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)\n{\n\treturn lock_classes + chain_hlocks[chain->base + i];\n}"
  },
  {
    "function_name": "check_prevs_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1940-2016",
    "snippet": "static int\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\n{\n\tint depth = curr->lockdep_depth;\n\tstruct held_lock *hlock;\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.max_entries = 0,\n\t\t.entries = NULL,\n\t\t.skip = 0,\n\t};\n\n\t/*\n\t * Debugging checks.\n\t *\n\t * Depth must not be zero for a non-head lock:\n\t */\n\tif (!depth)\n\t\tgoto out_bug;\n\t/*\n\t * At least two relevant locks must exist for this\n\t * to be a head:\n\t */\n\tif (curr->held_locks[depth].irq_context !=\n\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\tgoto out_bug;\n\n\tfor (;;) {\n\t\tint distance = curr->lockdep_depth - depth + 1;\n\t\thlock = curr->held_locks + depth - 1;\n\n\t\t/*\n\t\t * Only non-recursive-read entries get new dependencies\n\t\t * added:\n\t\t */\n\t\tif (hlock->read != 2 && hlock->check) {\n\t\t\tint ret = check_prev_add(curr, hlock, next, distance, &trace, save_trace);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Stop after the first non-trylock entry,\n\t\t\t * as non-trylock entries have added their\n\t\t\t * own direct dependencies already, so this\n\t\t\t * lock is connected to them indirectly:\n\t\t\t */\n\t\t\tif (!hlock->trylock)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdepth--;\n\t\t/*\n\t\t * End of lock-stack?\n\t\t */\n\t\tif (!depth)\n\t\t\tbreak;\n\t\t/*\n\t\t * Stop the search if we cross into another context:\n\t\t */\n\t\tif (curr->held_locks[depth].irq_context !=\n\t\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\t\tbreak;\n\t}\n\treturn 1;\nout_bug:\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Clearly we all shouldn't be here, but since we made it we\n\t * can reliable say we messed up our state. See the above two\n\t * gotos for reasons why we could possibly end up here.\n\t */\n\tWARN_ON(1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_prev_add",
          "args": [
            "curr",
            "hlock",
            "next",
            "distance",
            "&trace",
            "save_trace"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "check_prev_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1832-1932",
          "snippet": "static int\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\n\t       struct held_lock *next, int distance, struct stack_trace *trace,\n\t       int (*save)(struct stack_trace *trace))\n{\n\tstruct lock_list *uninitialized_var(target_entry);\n\tstruct lock_list *entry;\n\tstruct lock_list this;\n\tint ret;\n\n\t/*\n\t * Prove that the new <prev> -> <next> dependency would not\n\t * create a circular dependency in the graph. (We do this by\n\t * forward-recursing into the graph starting at <next>, and\n\t * checking whether we can reach <prev>.)\n\t *\n\t * We are using global variables to control the recursion, to\n\t * keep the stackframe size of the recursive functions low:\n\t */\n\tthis.class = hlock_class(next);\n\tthis.parent = NULL;\n\tret = check_noncircular(&this, hlock_class(prev), &target_entry);\n\tif (unlikely(!ret)) {\n\t\tif (!trace->entries) {\n\t\t\t/*\n\t\t\t * If @save fails here, the printing might trigger\n\t\t\t * a WARN but because of the !nr_entries it should\n\t\t\t * not do bad things.\n\t\t\t */\n\t\t\tsave(trace);\n\t\t}\n\t\treturn print_circular_bug(&this, target_entry, next, prev, trace);\n\t}\n\telse if (unlikely(ret < 0))\n\t\treturn print_bfs_bug(ret);\n\n\tif (!check_prev_add_irq(curr, prev, next))\n\t\treturn 0;\n\n\t/*\n\t * For recursive read-locks we do all the dependency checks,\n\t * but we dont store read-triggered dependencies (only\n\t * write-triggered dependencies). This ensures that only the\n\t * write-side dependencies matter, and that if for example a\n\t * write-lock never takes any other locks, then the reads are\n\t * equivalent to a NOP.\n\t */\n\tif (next->read == 2 || prev->read == 2)\n\t\treturn 1;\n\t/*\n\t * Is the <prev> -> <next> dependency already present?\n\t *\n\t * (this may occur even though this is a new chain: consider\n\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3\n\t *  chains - the second one will be new, but L1 already has\n\t *  L2 added to its dependency list, due to the first chain.)\n\t */\n\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\n\t\tif (entry->class == hlock_class(next)) {\n\t\t\tif (distance == 1)\n\t\t\t\tentry->distance = 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Is the <prev> -> <next> link redundant?\n\t */\n\tthis.class = hlock_class(prev);\n\tthis.parent = NULL;\n\tret = check_redundant(&this, hlock_class(next), &target_entry);\n\tif (!ret) {\n\t\tdebug_atomic_inc(nr_redundant);\n\t\treturn 2;\n\t}\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\n\n\tif (!trace->entries && !save(trace))\n\t\treturn 0;\n\n\t/*\n\t * Ok, all validations passed, add the new lock\n\t * to the previous lock's dependency list:\n\t */\n\tret = add_lock_to_list(hlock_class(next),\n\t\t\t       &hlock_class(prev)->locks_after,\n\t\t\t       next->acquire_ip, distance, trace);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = add_lock_to_list(hlock_class(prev),\n\t\t\t       &hlock_class(next)->locks_before,\n\t\t\t       next->acquire_ip, distance, trace);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 2;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\n\t       struct held_lock *next, int distance, struct stack_trace *trace,\n\t       int (*save)(struct stack_trace *trace))\n{\n\tstruct lock_list *uninitialized_var(target_entry);\n\tstruct lock_list *entry;\n\tstruct lock_list this;\n\tint ret;\n\n\t/*\n\t * Prove that the new <prev> -> <next> dependency would not\n\t * create a circular dependency in the graph. (We do this by\n\t * forward-recursing into the graph starting at <next>, and\n\t * checking whether we can reach <prev>.)\n\t *\n\t * We are using global variables to control the recursion, to\n\t * keep the stackframe size of the recursive functions low:\n\t */\n\tthis.class = hlock_class(next);\n\tthis.parent = NULL;\n\tret = check_noncircular(&this, hlock_class(prev), &target_entry);\n\tif (unlikely(!ret)) {\n\t\tif (!trace->entries) {\n\t\t\t/*\n\t\t\t * If @save fails here, the printing might trigger\n\t\t\t * a WARN but because of the !nr_entries it should\n\t\t\t * not do bad things.\n\t\t\t */\n\t\t\tsave(trace);\n\t\t}\n\t\treturn print_circular_bug(&this, target_entry, next, prev, trace);\n\t}\n\telse if (unlikely(ret < 0))\n\t\treturn print_bfs_bug(ret);\n\n\tif (!check_prev_add_irq(curr, prev, next))\n\t\treturn 0;\n\n\t/*\n\t * For recursive read-locks we do all the dependency checks,\n\t * but we dont store read-triggered dependencies (only\n\t * write-triggered dependencies). This ensures that only the\n\t * write-side dependencies matter, and that if for example a\n\t * write-lock never takes any other locks, then the reads are\n\t * equivalent to a NOP.\n\t */\n\tif (next->read == 2 || prev->read == 2)\n\t\treturn 1;\n\t/*\n\t * Is the <prev> -> <next> dependency already present?\n\t *\n\t * (this may occur even though this is a new chain: consider\n\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3\n\t *  chains - the second one will be new, but L1 already has\n\t *  L2 added to its dependency list, due to the first chain.)\n\t */\n\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\n\t\tif (entry->class == hlock_class(next)) {\n\t\t\tif (distance == 1)\n\t\t\t\tentry->distance = 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Is the <prev> -> <next> link redundant?\n\t */\n\tthis.class = hlock_class(prev);\n\tthis.parent = NULL;\n\tret = check_redundant(&this, hlock_class(next), &target_entry);\n\tif (!ret) {\n\t\tdebug_atomic_inc(nr_redundant);\n\t\treturn 2;\n\t}\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\n\n\tif (!trace->entries && !save(trace))\n\t\treturn 0;\n\n\t/*\n\t * Ok, all validations passed, add the new lock\n\t * to the previous lock's dependency list:\n\t */\n\tret = add_lock_to_list(hlock_class(next),\n\t\t\t       &hlock_class(prev)->locks_after,\n\t\t\t       next->acquire_ip, distance, trace);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = add_lock_to_list(hlock_class(prev),\n\t\t\t       &hlock_class(next)->locks_before,\n\t\t\t       next->acquire_ip, distance, trace);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\n{\n\tint depth = curr->lockdep_depth;\n\tstruct held_lock *hlock;\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.max_entries = 0,\n\t\t.entries = NULL,\n\t\t.skip = 0,\n\t};\n\n\t/*\n\t * Debugging checks.\n\t *\n\t * Depth must not be zero for a non-head lock:\n\t */\n\tif (!depth)\n\t\tgoto out_bug;\n\t/*\n\t * At least two relevant locks must exist for this\n\t * to be a head:\n\t */\n\tif (curr->held_locks[depth].irq_context !=\n\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\tgoto out_bug;\n\n\tfor (;;) {\n\t\tint distance = curr->lockdep_depth - depth + 1;\n\t\thlock = curr->held_locks + depth - 1;\n\n\t\t/*\n\t\t * Only non-recursive-read entries get new dependencies\n\t\t * added:\n\t\t */\n\t\tif (hlock->read != 2 && hlock->check) {\n\t\t\tint ret = check_prev_add(curr, hlock, next, distance, &trace, save_trace);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Stop after the first non-trylock entry,\n\t\t\t * as non-trylock entries have added their\n\t\t\t * own direct dependencies already, so this\n\t\t\t * lock is connected to them indirectly:\n\t\t\t */\n\t\t\tif (!hlock->trylock)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdepth--;\n\t\t/*\n\t\t * End of lock-stack?\n\t\t */\n\t\tif (!depth)\n\t\t\tbreak;\n\t\t/*\n\t\t * Stop the search if we cross into another context:\n\t\t */\n\t\tif (curr->held_locks[depth].irq_context !=\n\t\t\t\tcurr->held_locks[depth-1].irq_context)\n\t\t\tbreak;\n\t}\n\treturn 1;\nout_bug:\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Clearly we all shouldn't be here, but since we made it we\n\t * can reliable say we messed up our state. See the above two\n\t * gotos for reasons why we could possibly end up here.\n\t */\n\tWARN_ON(1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_prev_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1832-1932",
    "snippet": "static int\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\n\t       struct held_lock *next, int distance, struct stack_trace *trace,\n\t       int (*save)(struct stack_trace *trace))\n{\n\tstruct lock_list *uninitialized_var(target_entry);\n\tstruct lock_list *entry;\n\tstruct lock_list this;\n\tint ret;\n\n\t/*\n\t * Prove that the new <prev> -> <next> dependency would not\n\t * create a circular dependency in the graph. (We do this by\n\t * forward-recursing into the graph starting at <next>, and\n\t * checking whether we can reach <prev>.)\n\t *\n\t * We are using global variables to control the recursion, to\n\t * keep the stackframe size of the recursive functions low:\n\t */\n\tthis.class = hlock_class(next);\n\tthis.parent = NULL;\n\tret = check_noncircular(&this, hlock_class(prev), &target_entry);\n\tif (unlikely(!ret)) {\n\t\tif (!trace->entries) {\n\t\t\t/*\n\t\t\t * If @save fails here, the printing might trigger\n\t\t\t * a WARN but because of the !nr_entries it should\n\t\t\t * not do bad things.\n\t\t\t */\n\t\t\tsave(trace);\n\t\t}\n\t\treturn print_circular_bug(&this, target_entry, next, prev, trace);\n\t}\n\telse if (unlikely(ret < 0))\n\t\treturn print_bfs_bug(ret);\n\n\tif (!check_prev_add_irq(curr, prev, next))\n\t\treturn 0;\n\n\t/*\n\t * For recursive read-locks we do all the dependency checks,\n\t * but we dont store read-triggered dependencies (only\n\t * write-triggered dependencies). This ensures that only the\n\t * write-side dependencies matter, and that if for example a\n\t * write-lock never takes any other locks, then the reads are\n\t * equivalent to a NOP.\n\t */\n\tif (next->read == 2 || prev->read == 2)\n\t\treturn 1;\n\t/*\n\t * Is the <prev> -> <next> dependency already present?\n\t *\n\t * (this may occur even though this is a new chain: consider\n\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3\n\t *  chains - the second one will be new, but L1 already has\n\t *  L2 added to its dependency list, due to the first chain.)\n\t */\n\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\n\t\tif (entry->class == hlock_class(next)) {\n\t\t\tif (distance == 1)\n\t\t\t\tentry->distance = 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Is the <prev> -> <next> link redundant?\n\t */\n\tthis.class = hlock_class(prev);\n\tthis.parent = NULL;\n\tret = check_redundant(&this, hlock_class(next), &target_entry);\n\tif (!ret) {\n\t\tdebug_atomic_inc(nr_redundant);\n\t\treturn 2;\n\t}\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\n\n\tif (!trace->entries && !save(trace))\n\t\treturn 0;\n\n\t/*\n\t * Ok, all validations passed, add the new lock\n\t * to the previous lock's dependency list:\n\t */\n\tret = add_lock_to_list(hlock_class(next),\n\t\t\t       &hlock_class(prev)->locks_after,\n\t\t\t       next->acquire_ip, distance, trace);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = add_lock_to_list(hlock_class(prev),\n\t\t\t       &hlock_class(next)->locks_before,\n\t\t\t       next->acquire_ip, distance, trace);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 2;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_lock_to_list",
          "args": [
            "hlock_class(prev)",
            "&hlock_class(next)->locks_before",
            "next->acquire_ip",
            "distance",
            "trace"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "add_lock_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "859-883",
          "snippet": "static int add_lock_to_list(struct lock_class *this, struct list_head *head,\n\t\t\t    unsigned long ip, int distance,\n\t\t\t    struct stack_trace *trace)\n{\n\tstruct lock_list *entry;\n\t/*\n\t * Lock not present yet - get a new dependency struct and\n\t * add it to the list:\n\t */\n\tentry = alloc_list_entry();\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->class = this;\n\tentry->distance = distance;\n\tentry->trace = *trace;\n\t/*\n\t * Both allocation and removal are done under the graph lock; but\n\t * iteration is under RCU-sched; see look_up_lock_class() and\n\t * lockdep_free_key_range().\n\t */\n\tlist_add_tail_rcu(&entry->entry, head);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic int add_lock_to_list(struct lock_class *this, struct list_head *head,\n\t\t\t    unsigned long ip, int distance,\n\t\t\t    struct stack_trace *trace)\n{\n\tstruct lock_list *entry;\n\t/*\n\t * Lock not present yet - get a new dependency struct and\n\t * add it to the list:\n\t */\n\tentry = alloc_list_entry();\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->class = this;\n\tentry->distance = distance;\n\tentry->trace = *trace;\n\t/*\n\t * Both allocation and removal are done under the graph lock; but\n\t * iteration is under RCU-sched; see look_up_lock_class() and\n\t * lockdep_free_key_range().\n\t */\n\tlist_add_tail_rcu(&entry->entry, head);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "next"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save",
          "args": [
            "trace"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "390-426",
          "snippet": "static int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_stack_trace_entries;\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_bfs_bug",
          "args": [
            "ret"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "print_bfs_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1226-1237",
          "snippet": "static noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_redundant"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_redundant",
          "args": [
            "&this",
            "hlock_class(next)",
            "&target_entry"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "check_redundant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1315-1326",
          "snippet": "static noinline int\ncheck_redundant(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_redundant_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\ncheck_redundant(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_redundant_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&hlock_class(prev)->locks_after",
            "entry"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_prev_add_irq",
          "args": [
            "curr",
            "prev",
            "next"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "check_prev_add_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1704-1709",
          "snippet": "static inline int\ncheck_prev_add_irq(struct task_struct *curr, struct held_lock *prev,\n\t\tstruct held_lock *next)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int\ncheck_prev_add_irq(struct task_struct *curr, struct held_lock *prev,\n\t\tstruct held_lock *next)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_circular_bug",
          "args": [
            "&this",
            "target_entry",
            "next",
            "prev",
            "trace"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1185-1224",
          "snippet": "static noinline int print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt,\n\t\t\t\tstruct stack_trace *trace)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tif (!save_trace(&this->trace))\n\t\treturn 0;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic noinline int print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt,\n\t\t\t\tstruct stack_trace *trace)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tif (!save_trace(&this->trace))\n\t\treturn 0;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ret"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_noncircular",
          "args": [
            "&this",
            "hlock_class(prev)",
            "&target_entry"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "check_noncircular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1302-1313",
          "snippet": "static noinline int\ncheck_noncircular(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\ncheck_noncircular(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\n\t       struct held_lock *next, int distance, struct stack_trace *trace,\n\t       int (*save)(struct stack_trace *trace))\n{\n\tstruct lock_list *uninitialized_var(target_entry);\n\tstruct lock_list *entry;\n\tstruct lock_list this;\n\tint ret;\n\n\t/*\n\t * Prove that the new <prev> -> <next> dependency would not\n\t * create a circular dependency in the graph. (We do this by\n\t * forward-recursing into the graph starting at <next>, and\n\t * checking whether we can reach <prev>.)\n\t *\n\t * We are using global variables to control the recursion, to\n\t * keep the stackframe size of the recursive functions low:\n\t */\n\tthis.class = hlock_class(next);\n\tthis.parent = NULL;\n\tret = check_noncircular(&this, hlock_class(prev), &target_entry);\n\tif (unlikely(!ret)) {\n\t\tif (!trace->entries) {\n\t\t\t/*\n\t\t\t * If @save fails here, the printing might trigger\n\t\t\t * a WARN but because of the !nr_entries it should\n\t\t\t * not do bad things.\n\t\t\t */\n\t\t\tsave(trace);\n\t\t}\n\t\treturn print_circular_bug(&this, target_entry, next, prev, trace);\n\t}\n\telse if (unlikely(ret < 0))\n\t\treturn print_bfs_bug(ret);\n\n\tif (!check_prev_add_irq(curr, prev, next))\n\t\treturn 0;\n\n\t/*\n\t * For recursive read-locks we do all the dependency checks,\n\t * but we dont store read-triggered dependencies (only\n\t * write-triggered dependencies). This ensures that only the\n\t * write-side dependencies matter, and that if for example a\n\t * write-lock never takes any other locks, then the reads are\n\t * equivalent to a NOP.\n\t */\n\tif (next->read == 2 || prev->read == 2)\n\t\treturn 1;\n\t/*\n\t * Is the <prev> -> <next> dependency already present?\n\t *\n\t * (this may occur even though this is a new chain: consider\n\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3\n\t *  chains - the second one will be new, but L1 already has\n\t *  L2 added to its dependency list, due to the first chain.)\n\t */\n\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\n\t\tif (entry->class == hlock_class(next)) {\n\t\t\tif (distance == 1)\n\t\t\t\tentry->distance = 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Is the <prev> -> <next> link redundant?\n\t */\n\tthis.class = hlock_class(prev);\n\tthis.parent = NULL;\n\tret = check_redundant(&this, hlock_class(next), &target_entry);\n\tif (!ret) {\n\t\tdebug_atomic_inc(nr_redundant);\n\t\treturn 2;\n\t}\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\n\n\tif (!trace->entries && !save(trace))\n\t\treturn 0;\n\n\t/*\n\t * Ok, all validations passed, add the new lock\n\t * to the previous lock's dependency list:\n\t */\n\tret = add_lock_to_list(hlock_class(next),\n\t\t\t       &hlock_class(prev)->locks_after,\n\t\t\t       next->acquire_ip, distance, trace);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = add_lock_to_list(hlock_class(prev),\n\t\t\t       &hlock_class(next)->locks_before,\n\t\t\t       next->acquire_ip, distance, trace);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 2;\n}"
  },
  {
    "function_name": "check_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1774-1808",
    "snippet": "static int\ncheck_deadlock(struct task_struct *curr, struct held_lock *next,\n\t       struct lockdep_map *next_instance, int read)\n{\n\tstruct held_lock *prev;\n\tstruct held_lock *nest = NULL;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tprev = curr->held_locks + i;\n\n\t\tif (prev->instance == next->nest_lock)\n\t\t\tnest = prev;\n\n\t\tif (hlock_class(prev) != hlock_class(next))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Allow read-after-read recursion of the same\n\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):\n\t\t */\n\t\tif ((read == 2) && prev->read)\n\t\t\treturn 2;\n\n\t\t/*\n\t\t * We're holding the nest_lock, which serializes this lock's\n\t\t * nesting behaviour.\n\t\t */\n\t\tif (nest)\n\t\t\treturn 2;\n\n\t\treturn print_deadlock_bug(curr, prev, next);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_deadlock_bug",
          "args": [
            "curr",
            "prev",
            "next"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "print_deadlock_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1738-1764",
          "snippet": "static int\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\n\t\t   struct held_lock *next)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: possible recursive locking detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(next);\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\tprint_lock(prev);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_deadlock_scenario(next, prev);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\n\t\t   struct held_lock *next)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: possible recursive locking detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(next);\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\tprint_lock(prev);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_deadlock_scenario(next, prev);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "next"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int\ncheck_deadlock(struct task_struct *curr, struct held_lock *next,\n\t       struct lockdep_map *next_instance, int read)\n{\n\tstruct held_lock *prev;\n\tstruct held_lock *nest = NULL;\n\tint i;\n\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\tprev = curr->held_locks + i;\n\n\t\tif (prev->instance == next->nest_lock)\n\t\t\tnest = prev;\n\n\t\tif (hlock_class(prev) != hlock_class(next))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Allow read-after-read recursion of the same\n\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):\n\t\t */\n\t\tif ((read == 2) && prev->read)\n\t\t\treturn 2;\n\n\t\t/*\n\t\t * We're holding the nest_lock, which serializes this lock's\n\t\t * nesting behaviour.\n\t\t */\n\t\tif (nest)\n\t\t\treturn 2;\n\n\t\treturn print_deadlock_bug(curr, prev, next);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "print_deadlock_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1738-1764",
    "snippet": "static int\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\n\t\t   struct held_lock *next)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: possible recursive locking detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(next);\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\tprint_lock(prev);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_deadlock_scenario(next, prev);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_deadlock_scenario",
          "args": [
            "next",
            "prev"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "print_deadlock_scenario",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1718-1736",
          "snippet": "static void\nprint_deadlock_scenario(struct held_lock *nxt,\n\t\t\t     struct held_lock *prv)\n{\n\tstruct lock_class *next = hlock_class(nxt);\n\tstruct lock_class *prev = hlock_class(prv);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(prev);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(next);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n\tprintk(\" May be due to missing lock nesting notation\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_deadlock_scenario(struct held_lock *nxt,\n\t\t\t     struct held_lock *prv)\n{\n\tstruct lock_class *next = hlock_class(nxt);\n\tstruct lock_class *prev = hlock_class(prv);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(prev);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(next);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n\tprintk(\" May be due to missing lock nesting notation\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\""
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "prev"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nbut task is already holding lock:\\n\""
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to acquire lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"--------------------------------------------\\n\""
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: possible recursive locking detected\\n\""
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"============================================\\n\""
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\n\t\t   struct held_lock *next)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: possible recursive locking detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"--------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(next);\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\tprint_lock(prev);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\");\n\tprint_deadlock_scenario(next, prev);\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_deadlock_scenario",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1718-1736",
    "snippet": "static void\nprint_deadlock_scenario(struct held_lock *nxt,\n\t\t\t     struct held_lock *prv)\n{\n\tstruct lock_class *next = hlock_class(nxt);\n\tstruct lock_class *prev = hlock_class(prv);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(prev);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(next);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n\tprintk(\" May be due to missing lock nesting notation\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" May be due to missing lock nesting notation\\n\\n\""
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "next"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "496-512",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "prv"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_deadlock_scenario(struct held_lock *nxt,\n\t\t\t     struct held_lock *prv)\n{\n\tstruct lock_class *next = hlock_class(nxt);\n\tstruct lock_class *prev = hlock_class(prv);\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0\\n\");\n\tprintk(\"       ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(prev);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(next);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n\tprintk(\" May be due to missing lock nesting notation\\n\\n\");\n}"
  },
  {
    "function_name": "inc_chains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1711-1714",
    "snippet": "static inline void inc_chains(void)\n{\n\tnr_process_chains++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_process_chains;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned int nr_process_chains;\n\nstatic inline void inc_chains(void)\n{\n\tnr_process_chains++;\n}"
  },
  {
    "function_name": "check_prev_add_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1704-1709",
    "snippet": "static inline int\ncheck_prev_add_irq(struct task_struct *curr, struct held_lock *prev,\n\t\tstruct held_lock *next)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int\ncheck_prev_add_irq(struct task_struct *curr, struct held_lock *prev,\n\t\tstruct held_lock *next)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "inc_chains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1690-1700",
    "snippet": "static void inc_chains(void)\n{\n\tif (current->hardirq_context)\n\t\tnr_hardirq_chains++;\n\telse {\n\t\tif (current->softirq_context)\n\t\t\tnr_softirq_chains++;\n\t\telse\n\t\t\tnr_process_chains++;\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_hardirq_chains;",
      "unsigned int nr_softirq_chains;",
      "unsigned int nr_process_chains;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned int nr_hardirq_chains;\nunsigned int nr_softirq_chains;\nunsigned int nr_process_chains;\n\nstatic void inc_chains(void)\n{\n\tif (current->hardirq_context)\n\t\tnr_hardirq_chains++;\n\telse {\n\t\tif (current->softirq_context)\n\t\t\tnr_softirq_chains++;\n\t\telse\n\t\t\tnr_process_chains++;\n\t}\n}"
  },
  {
    "function_name": "check_prev_add_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1677-1688",
    "snippet": "static int\ncheck_prev_add_irq(struct task_struct *curr, struct held_lock *prev,\n\t\tstruct held_lock *next)\n{\n#define LOCKDEP_STATE(__STATE)\t\t\t\t\t\t\\\n\tif (!check_irq_usage(curr, prev, next, LOCK_USED_IN_##__STATE))\t\\\n\t\treturn 0;\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\ncheck_prev_add_irq(struct task_struct *curr, struct held_lock *prev,\n\t\tstruct held_lock *next)\n{\n#define LOCKDEP_STATE(__STATE)\t\t\t\t\t\t\\\n\tif (!check_irq_usage(curr, prev, next, LOCK_USED_IN_##__STATE))\t\\\n\t\treturn 0;\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\treturn 1;\n}"
  },
  {
    "function_name": "check_irq_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1649-1675",
    "snippet": "static int check_irq_usage(struct task_struct *curr, struct held_lock *prev,\n\t\t\t   struct held_lock *next, enum lock_usage_bit bit)\n{\n\t/*\n\t * Prove that the new dependency does not connect a hardirq-safe\n\t * lock with a hardirq-unsafe lock - to achieve this we search\n\t * the backwards-subgraph starting at <prev>, and the\n\t * forwards-subgraph starting at <next>:\n\t */\n\tif (!check_usage(curr, prev, next, bit,\n\t\t\t   exclusive_bit(bit), state_name(bit)))\n\t\treturn 0;\n\n\tbit++; /* _READ */\n\n\t/*\n\t * Prove that the new dependency does not connect a hardirq-safe-read\n\t * lock with a hardirq-unsafe lock - to achieve this we search\n\t * the backwards-subgraph starting at <prev>, and the\n\t * forwards-subgraph starting at <next>:\n\t */\n\tif (!check_usage(curr, prev, next, bit,\n\t\t\t   exclusive_bit(bit), state_name(bit)))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_usage",
          "args": [
            "curr",
            "prev",
            "next",
            "bit",
            "exclusive_bit(bit)",
            "state_name(bit)"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "check_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1575-1606",
          "snippet": "static int\ncheck_usage(struct task_struct *curr, struct held_lock *prev,\n\t    struct held_lock *next, enum lock_usage_bit bit_backwards,\n\t    enum lock_usage_bit bit_forwards, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list this, that;\n\tstruct lock_list *uninitialized_var(target_entry);\n\tstruct lock_list *uninitialized_var(target_entry1);\n\n\tthis.parent = NULL;\n\n\tthis.class = hlock_class(prev);\n\tret = find_usage_backwards(&this, bit_backwards, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\tthat.parent = NULL;\n\tthat.class = hlock_class(next);\n\tret = find_usage_forwards(&that, bit_forwards, &target_entry1);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_bad_irq_dependency(curr, &this, &that,\n\t\t\ttarget_entry, target_entry1,\n\t\t\tprev, next,\n\t\t\tbit_backwards, bit_forwards, irqclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\ncheck_usage(struct task_struct *curr, struct held_lock *prev,\n\t    struct held_lock *next, enum lock_usage_bit bit_backwards,\n\t    enum lock_usage_bit bit_forwards, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list this, that;\n\tstruct lock_list *uninitialized_var(target_entry);\n\tstruct lock_list *uninitialized_var(target_entry1);\n\n\tthis.parent = NULL;\n\n\tthis.class = hlock_class(prev);\n\tret = find_usage_backwards(&this, bit_backwards, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\tthat.parent = NULL;\n\tthat.class = hlock_class(next);\n\tret = find_usage_forwards(&that, bit_forwards, &target_entry1);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_bad_irq_dependency(curr, &this, &that,\n\t\t\ttarget_entry, target_entry1,\n\t\t\tprev, next,\n\t\t\tbit_backwards, bit_forwards, irqclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "state_name",
          "args": [
            "bit"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1622-1625",
          "snippet": "static inline const char *state_name(enum lock_usage_bit bit)\n{\n\treturn (bit & 1) ? state_rnames[bit >> 2] : state_names[bit >> 2];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\treturn (bit & 1) ? state_rnames[bit >> 2] : state_names[bit >> 2];\n}"
        }
      },
      {
        "call_info": {
          "callee": "exclusive_bit",
          "args": [
            "bit"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "exclusive_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1627-1647",
          "snippet": "static int exclusive_bit(int new_bit)\n{\n\t/*\n\t * USED_IN\n\t * USED_IN_READ\n\t * ENABLED\n\t * ENABLED_READ\n\t *\n\t * bit 0 - write/read\n\t * bit 1 - used_in/enabled\n\t * bit 2+  state\n\t */\n\n\tint state = new_bit & ~3;\n\tint dir = new_bit & 2;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ 2);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int exclusive_bit(int new_bit)\n{\n\t/*\n\t * USED_IN\n\t * USED_IN_READ\n\t * ENABLED\n\t * ENABLED_READ\n\t *\n\t * bit 0 - write/read\n\t * bit 1 - used_in/enabled\n\t * bit 2+  state\n\t */\n\n\tint state = new_bit & ~3;\n\tint dir = new_bit & 2;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int check_irq_usage(struct task_struct *curr, struct held_lock *prev,\n\t\t\t   struct held_lock *next, enum lock_usage_bit bit)\n{\n\t/*\n\t * Prove that the new dependency does not connect a hardirq-safe\n\t * lock with a hardirq-unsafe lock - to achieve this we search\n\t * the backwards-subgraph starting at <prev>, and the\n\t * forwards-subgraph starting at <next>:\n\t */\n\tif (!check_usage(curr, prev, next, bit,\n\t\t\t   exclusive_bit(bit), state_name(bit)))\n\t\treturn 0;\n\n\tbit++; /* _READ */\n\n\t/*\n\t * Prove that the new dependency does not connect a hardirq-safe-read\n\t * lock with a hardirq-unsafe lock - to achieve this we search\n\t * the backwards-subgraph starting at <prev>, and the\n\t * forwards-subgraph starting at <next>:\n\t */\n\tif (!check_usage(curr, prev, next, bit,\n\t\t\t   exclusive_bit(bit), state_name(bit)))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "exclusive_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1627-1647",
    "snippet": "static int exclusive_bit(int new_bit)\n{\n\t/*\n\t * USED_IN\n\t * USED_IN_READ\n\t * ENABLED\n\t * ENABLED_READ\n\t *\n\t * bit 0 - write/read\n\t * bit 1 - used_in/enabled\n\t * bit 2+  state\n\t */\n\n\tint state = new_bit & ~3;\n\tint dir = new_bit & 2;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ 2);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic int exclusive_bit(int new_bit)\n{\n\t/*\n\t * USED_IN\n\t * USED_IN_READ\n\t * ENABLED\n\t * ENABLED_READ\n\t *\n\t * bit 0 - write/read\n\t * bit 1 - used_in/enabled\n\t * bit 2+  state\n\t */\n\n\tint state = new_bit & ~3;\n\tint dir = new_bit & 2;\n\n\t/*\n\t * keep state, bit flip the direction and strip read.\n\t */\n\treturn state | (dir ^ 2);\n}"
  },
  {
    "function_name": "state_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1622-1625",
    "snippet": "static inline const char *state_name(enum lock_usage_bit bit)\n{\n\treturn (bit & 1) ? state_rnames[bit >> 2] : state_names[bit >> 2];\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\treturn (bit & 1) ? state_rnames[bit >> 2] : state_names[bit >> 2];\n}"
  },
  {
    "function_name": "check_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1575-1606",
    "snippet": "static int\ncheck_usage(struct task_struct *curr, struct held_lock *prev,\n\t    struct held_lock *next, enum lock_usage_bit bit_backwards,\n\t    enum lock_usage_bit bit_forwards, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list this, that;\n\tstruct lock_list *uninitialized_var(target_entry);\n\tstruct lock_list *uninitialized_var(target_entry1);\n\n\tthis.parent = NULL;\n\n\tthis.class = hlock_class(prev);\n\tret = find_usage_backwards(&this, bit_backwards, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\tthat.parent = NULL;\n\tthat.class = hlock_class(next);\n\tret = find_usage_forwards(&that, bit_forwards, &target_entry1);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_bad_irq_dependency(curr, &this, &that,\n\t\t\ttarget_entry, target_entry1,\n\t\t\tprev, next,\n\t\t\tbit_backwards, bit_forwards, irqclass);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_bad_irq_dependency",
          "args": [
            "curr",
            "&this",
            "&that",
            "target_entry",
            "target_entry1",
            "prev",
            "next",
            "bit_backwards",
            "bit_forwards",
            "irqclass"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "print_bad_irq_dependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1501-1573",
          "snippet": "static int\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================================\\n\");\n\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tcurr->hardirq_context, hardirq_count() >> HARDIRQ_SHIFT,\n\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\n\t\tcurr->hardirqs_enabled,\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tpr_warn(\"\\nand this task is already holding:\\n\");\n\tprint_lock(prev);\n\tpr_warn(\"which would create a new lock dependency:\\n\");\n\tprint_lock_name(hlock_class(prev));\n\tpr_cont(\" ->\");\n\tprint_lock_name(hlock_class(next));\n\tpr_cont(\"\\n\");\n\n\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);\n\n\tprint_stack_trace(backwards_entry->class->usage_traces + bit1, 1);\n\n\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);\n\tpr_warn(\"...\");\n\n\tprint_stack_trace(forwards_entry->class->usage_traces + bit2, 1);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);\n\tif (!save_trace(&prev_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(backwards_entry, prev_root);\n\n\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");\n\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);\n\tif (!save_trace(&next_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================================\\n\");\n\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tcurr->hardirq_context, hardirq_count() >> HARDIRQ_SHIFT,\n\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\n\t\tcurr->hardirqs_enabled,\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tpr_warn(\"\\nand this task is already holding:\\n\");\n\tprint_lock(prev);\n\tpr_warn(\"which would create a new lock dependency:\\n\");\n\tprint_lock_name(hlock_class(prev));\n\tpr_cont(\" ->\");\n\tprint_lock_name(hlock_class(next));\n\tpr_cont(\"\\n\");\n\n\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);\n\n\tprint_stack_trace(backwards_entry->class->usage_traces + bit1, 1);\n\n\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);\n\tpr_warn(\"...\");\n\n\tprint_stack_trace(forwards_entry->class->usage_traces + bit2, 1);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);\n\tif (!save_trace(&prev_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(backwards_entry, prev_root);\n\n\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");\n\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);\n\tif (!save_trace(&next_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_bfs_bug",
          "args": [
            "ret"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "print_bfs_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1226-1237",
          "snippet": "static noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_usage_forwards",
          "args": [
            "&that",
            "bit_forwards",
            "&target_entry1"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "find_usage_forwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1352-1363",
          "snippet": "static int\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "next"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_usage_backwards",
          "args": [
            "&this",
            "bit_backwards",
            "&target_entry"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "find_usage_backwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1375-1386",
          "snippet": "static int\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\ncheck_usage(struct task_struct *curr, struct held_lock *prev,\n\t    struct held_lock *next, enum lock_usage_bit bit_backwards,\n\t    enum lock_usage_bit bit_forwards, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list this, that;\n\tstruct lock_list *uninitialized_var(target_entry);\n\tstruct lock_list *uninitialized_var(target_entry1);\n\n\tthis.parent = NULL;\n\n\tthis.class = hlock_class(prev);\n\tret = find_usage_backwards(&this, bit_backwards, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\tthat.parent = NULL;\n\tthat.class = hlock_class(next);\n\tret = find_usage_forwards(&that, bit_forwards, &target_entry1);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_bad_irq_dependency(curr, &this, &that,\n\t\t\ttarget_entry, target_entry1,\n\t\t\tprev, next,\n\t\t\tbit_backwards, bit_forwards, irqclass);\n}"
  },
  {
    "function_name": "print_bad_irq_dependency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1501-1573",
    "snippet": "static int\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================================\\n\");\n\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tcurr->hardirq_context, hardirq_count() >> HARDIRQ_SHIFT,\n\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\n\t\tcurr->hardirqs_enabled,\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tpr_warn(\"\\nand this task is already holding:\\n\");\n\tprint_lock(prev);\n\tpr_warn(\"which would create a new lock dependency:\\n\");\n\tprint_lock_name(hlock_class(prev));\n\tpr_cont(\" ->\");\n\tprint_lock_name(hlock_class(next));\n\tpr_cont(\"\\n\");\n\n\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);\n\n\tprint_stack_trace(backwards_entry->class->usage_traces + bit1, 1);\n\n\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);\n\tpr_warn(\"...\");\n\n\tprint_stack_trace(forwards_entry->class->usage_traces + bit2, 1);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);\n\tif (!save_trace(&prev_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(backwards_entry, prev_root);\n\n\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");\n\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);\n\tif (!save_trace(&next_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_shortest_lock_dependencies",
          "args": [
            "forwards_entry",
            "next_root"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "print_shortest_lock_dependencies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1417-1443",
          "snippet": "static void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\tstruct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\tprint_stack_trace(&entry->trace, 2);\n\t\tprintk(\"\\n\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n\n\treturn;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\tstruct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\tprint_stack_trace(&entry->trace, 2);\n\t\tprintk(\"\\n\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [
            "&next_root->trace"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "390-426",
          "snippet": "static int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_stack_trace_entries;\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\" and %s-irq-unsafe lock:\\n\"",
            "irqclass"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nthe dependencies between the lock to be acquired\""
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\"",
            "irqclass"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_irq_lock_scenario",
          "args": [
            "backwards_entry",
            "forwards_entry",
            "hlock_class(prev)",
            "hlock_class(next)"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "print_irq_lock_scenario",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1445-1499",
          "snippet": "static void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "next"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nother info that might help us debug this:\\n\\n\""
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "forwards_entry->class->usage_traces + bit2",
            "1"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "print_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stacktrace.c",
          "lines": "14-23",
          "snippet": "void print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\nvoid print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"...\""
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n... which became %s-irq-unsafe at:\\n\"",
            "irqclass"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "forwards_entry->class"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "514-523",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nto a %s-irq-unsafe lock:\\n\"",
            "irqclass"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n... which became %s-irq-safe at:\\n\"",
            "irqclass"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\"",
            "irqclass"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"which would create a new lock dependency:\\n\""
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "prev"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nand this task is already holding:\\n\""
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)",
            "curr->hardirq_context",
            "hardirq_count() >> HARDIRQ_SHIFT",
            "curr->softirq_context",
            "softirq_count() >> SOFTIRQ_SHIFT",
            "curr->hardirqs_enabled",
            "curr->softirqs_enabled"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "softirq_count",
          "args": [],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"-----------------------------------------------------\\n\""
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\"",
            "irqclass",
            "irqclass"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"=====================================================\\n\""
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=====================================================\\n\");\n\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tpr_warn(\"-----------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tcurr->hardirq_context, hardirq_count() >> HARDIRQ_SHIFT,\n\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\n\t\tcurr->hardirqs_enabled,\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tpr_warn(\"\\nand this task is already holding:\\n\");\n\tprint_lock(prev);\n\tpr_warn(\"which would create a new lock dependency:\\n\");\n\tprint_lock_name(hlock_class(prev));\n\tpr_cont(\" ->\");\n\tprint_lock_name(hlock_class(next));\n\tpr_cont(\"\\n\");\n\n\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);\n\n\tprint_stack_trace(backwards_entry->class->usage_traces + bit1, 1);\n\n\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);\n\tpr_warn(\"...\");\n\n\tprint_stack_trace(forwards_entry->class->usage_traces + bit2, 1);\n\n\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);\n\tif (!save_trace(&prev_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(backwards_entry, prev_root);\n\n\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");\n\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);\n\tif (!save_trace(&next_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tpr_warn(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_irq_lock_scenario",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1445-1499",
    "snippet": "static void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n *** DEADLOCK ***\\n\\n\""
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "safe_class"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "496-512",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(unsafe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               local_irq_disable();\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(middle_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  <Interrupt>\\n\");\n\tprintk(\"    lock(\");\n\t__print_lock_name(safe_class);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
  },
  {
    "function_name": "print_shortest_lock_dependencies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1417-1443",
    "snippet": "static void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\tstruct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\tprint_stack_trace(&entry->trace, 2);\n\t\tprintk(\"\\n\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n\n\treturn;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "entry"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "969-972",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"lockdep:%s bad path found in chain graph\\n\"",
            "__func__"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "&entry->trace",
            "2"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "print_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stacktrace.c",
          "lines": "14-23",
          "snippet": "void print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\nvoid print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%*s ... acquired at:\\n\"",
            "depth",
            "\"\""
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_class_header",
          "args": [
            "entry->class",
            "depth"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_class_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1388-1412",
          "snippet": "static void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_USAGE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_stack_trace(class->usage_traces + bit, len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};\n\nstatic void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_USAGE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_stack_trace(class->usage_traces + bit, len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_depth",
          "args": [
            "leaf"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "974-984",
          "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\tstruct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t/*compute depth from generated tree by BFS*/\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"%*s ... acquired at:\\n\", depth, \"\");\n\t\tprint_stack_trace(&entry->trace, 2);\n\t\tprintk(\"\\n\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"lockdep:%s bad path found in chain graph\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n\n\treturn;\n}"
  },
  {
    "function_name": "print_lock_class_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1388-1412",
    "snippet": "static void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_USAGE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_stack_trace(class->usage_traces + bit, len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%*s ... key      at: [<%px>] %pS\\n\"",
            "depth",
            "\"\"",
            "class->key",
            "class->key"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "class->usage_traces + bit",
            "len"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "print_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stacktrace.c",
          "lines": "14-23",
          "snippet": "void print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\nvoid print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" at:\\n\""
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" ops: %lu\"",
            "debug_class_ops_read(class)"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_class_ops_read",
          "args": [
            "class"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "debug_class_ops_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep_internals.h",
          "lines": "197-206",
          "snippet": "static inline unsigned long debug_class_ops_read(struct lock_class *class)\n{\n\tint idx, cpu;\n\tunsigned long ops = 0;\n\n\tidx = class - lock_classes;\n\tfor_each_possible_cpu(cpu)\n\t\tops += per_cpu(lockdep_stats.lock_class_ops[idx], cpu);\n\treturn ops;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n\nstatic inline unsigned long debug_class_ops_read(struct lock_class *class)\n{\n\tint idx, cpu;\n\tunsigned long ops = 0;\n\n\tidx = class - lock_classes;\n\tfor_each_possible_cpu(cpu)\n\t\tops += per_cpu(lockdep_stats.lock_class_ops[idx], cpu);\n\treturn ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "class"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "514-523",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic const char *usage_str[] =\n{\n#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\t[LOCK_USED] = \"INITIAL USE\",\n};\n\nstatic void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"%*s->\", depth, \"\");\n\tprint_lock_name(class);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tprintk(KERN_CONT \" ops: %lu\", debug_class_ops_read(class));\n#endif\n\tprintk(KERN_CONT \" {\\n\");\n\n\tfor (bit = 0; bit < LOCK_USAGE_STATES; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"%*s   %s\", depth, \"\", usage_str[bit]);\n\t\t\tlen += printk(KERN_CONT \" at:\\n\");\n\t\t\tprint_stack_trace(class->usage_traces + bit, len);\n\t\t}\n\t}\n\tprintk(\"%*s }\\n\", depth, \"\");\n\n\tprintk(\"%*s ... key      at: [<%px>] %pS\\n\",\n\t\tdepth, \"\", class->key, class->key);\n}"
  },
  {
    "function_name": "find_usage_backwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1375-1386",
    "snippet": "static int\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_backwards",
          "args": [
            "root",
            "(void *)bit",
            "usage_match",
            "target_entry"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_backwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1064-1071",
          "snippet": "static inline int __bfs_backwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 0);\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __bfs_backwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 0);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_find_usage_backwards_checks"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}"
  },
  {
    "function_name": "find_usage_forwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1352-1363",
    "snippet": "static int\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_forwards",
          "args": [
            "root",
            "(void *)bit",
            "usage_match",
            "target_entry"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_forwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1055-1062",
          "snippet": "static inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_find_usage_forwards_checks"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}"
  },
  {
    "function_name": "usage_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1335-1338",
    "snippet": "static inline int usage_match(struct lock_list *entry, void *bit)\n{\n\treturn entry->class->usage_mask & (1 << (enum lock_usage_bit)bit);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int usage_match(struct lock_list *entry, void *bit)\n{\n\treturn entry->class->usage_mask & (1 << (enum lock_usage_bit)bit);\n}"
  },
  {
    "function_name": "check_redundant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1315-1326",
    "snippet": "static noinline int\ncheck_redundant(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_redundant_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_forwards",
          "args": [
            "root",
            "target",
            "class_equal",
            "target_entry"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_forwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1055-1062",
          "snippet": "static inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_redundant_checks"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\ncheck_redundant(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_redundant_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}"
  },
  {
    "function_name": "check_noncircular",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1302-1313",
    "snippet": "static noinline int\ncheck_noncircular(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_forwards",
          "args": [
            "root",
            "target",
            "class_equal",
            "target_entry"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_forwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1055-1062",
          "snippet": "static inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_cyclic_checks"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\ncheck_noncircular(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}"
  },
  {
    "function_name": "lockdep_count_backward_deps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1281-1296",
    "snippet": "unsigned long lockdep_count_backward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\tthis.parent = NULL;\n\tthis.class = class;\n\n\traw_local_irq_save(flags);\n\tarch_spin_lock(&lockdep_lock);\n\tret = __lockdep_count_backward_deps(&this);\n\tarch_spin_unlock(&lockdep_lock);\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&lockdep_lock"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lockdep_count_backward_deps",
          "args": [
            "&this"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_count_backward_deps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1271-1279",
          "snippet": "static unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_backwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_backwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&lockdep_lock"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nunsigned long lockdep_count_backward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\tthis.parent = NULL;\n\tthis.class = class;\n\n\traw_local_irq_save(flags);\n\tarch_spin_lock(&lockdep_lock);\n\tret = __lockdep_count_backward_deps(&this);\n\tarch_spin_unlock(&lockdep_lock);\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__lockdep_count_backward_deps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1271-1279",
    "snippet": "static unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_backwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_backwards",
          "args": [
            "this",
            "(void *)&count",
            "noop_count",
            "&target_entry"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_backwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1064-1071",
          "snippet": "static inline int __bfs_backwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 0);\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __bfs_backwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 0);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_backwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}"
  },
  {
    "function_name": "lockdep_count_forward_deps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1254-1269",
    "snippet": "unsigned long lockdep_count_forward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\tthis.parent = NULL;\n\tthis.class = class;\n\n\traw_local_irq_save(flags);\n\tarch_spin_lock(&lockdep_lock);\n\tret = __lockdep_count_forward_deps(&this);\n\tarch_spin_unlock(&lockdep_lock);\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&lockdep_lock"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lockdep_count_forward_deps",
          "args": [
            "&this"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "__lockdep_count_forward_deps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1245-1253",
          "snippet": "static unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_forwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_forwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&lockdep_lock"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nunsigned long lockdep_count_forward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\tthis.parent = NULL;\n\tthis.class = class;\n\n\traw_local_irq_save(flags);\n\tarch_spin_lock(&lockdep_lock);\n\tret = __lockdep_count_forward_deps(&this);\n\tarch_spin_unlock(&lockdep_lock);\n\traw_local_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__lockdep_count_forward_deps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1245-1253",
    "snippet": "static unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_forwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs_forwards",
          "args": [
            "this",
            "(void *)&count",
            "noop_count",
            "&target_entry"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs_forwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1055-1062",
          "snippet": "static inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_forwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}"
  },
  {
    "function_name": "noop_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1239-1243",
    "snippet": "static int noop_count(struct lock_list *entry, void *data)\n{\n\t(*(unsigned long *)data)++;\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int noop_count(struct lock_list *entry, void *data)\n{\n\t(*(unsigned long *)data)++;\n\treturn 0;\n}"
  },
  {
    "function_name": "print_bfs_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1226-1237",
    "snippet": "static noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"lockdep bfs error:%d\\n\"",
            "ret"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t/*\n\t * Breadth-first-search failed, graph got corrupted?\n\t */\n\tWARN(1, \"lockdep bfs error:%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_circular_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1185-1224",
    "snippet": "static noinline int print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt,\n\t\t\t\tstruct stack_trace *trace)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tif (!save_trace(&this->trace))\n\t\treturn 0;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\nstack backtrace:\\n\""
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_print_held_locks",
          "args": [
            "curr"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_print_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "558-577",
          "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_circular_lock_scenario",
          "args": [
            "check_src",
            "check_tgt",
            "first_parent"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_lock_scenario",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1096-1144",
          "snippet": "static void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (parent != source) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(source);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(parent);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(target);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(parent);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(source);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (parent != source) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(source);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(parent);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(target);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(parent);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(source);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "parent"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "969-972",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_circular_bug_entry",
          "args": [
            "parent",
            "--depth"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_bug_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1083-1094",
          "snippet": "static noinline int\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn 0;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_stack_trace(&target->trace, 6);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn 0;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_stack_trace(&target->trace, 6);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_circular_bug_header",
          "args": [
            "target",
            "depth",
            "check_src",
            "check_tgt"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_bug_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1150-1178",
          "snippet": "static noinline int\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"======================================================\\n\");\n\tpr_warn(\"WARNING: possible circular locking dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\n\tprint_lock(check_tgt);\n\tpr_warn(\"\\nwhich lock already depends on the new lock.\\n\\n\");\n\tpr_warn(\"\\nthe existing dependency chain (in reverse order) is:\\n\");\n\n\tprint_circular_bug_entry(entry, depth);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"======================================================\\n\");\n\tpr_warn(\"WARNING: possible circular locking dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\n\tprint_lock(check_tgt);\n\tpr_warn(\"\\nwhich lock already depends on the new lock.\\n\\n\");\n\tpr_warn(\"\\nthe existing dependency chain (in reverse order) is:\\n\");\n\n\tprint_circular_bug_entry(entry, depth);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_depth",
          "args": [
            "target"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "974-984",
          "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_trace",
          "args": [
            "&this->trace"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "save_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "390-426",
          "snippet": "static int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_stack_trace_entries;",
            "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_stack_trace_entries;\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic noinline int print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt,\n\t\t\t\tstruct stack_trace *trace)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tif (!save_trace(&this->trace))\n\t\treturn 0;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"\\nother info that might help us debug this:\\n\\n\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"\\nstack backtrace:\\n\");\n\tdump_stack();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "class_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1180-1183",
    "snippet": "static inline int class_equal(struct lock_list *entry, void *data)\n{\n\treturn entry->class == data;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int class_equal(struct lock_list *entry, void *data)\n{\n\treturn entry->class == data;\n}"
  },
  {
    "function_name": "print_circular_bug_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1150-1178",
    "snippet": "static noinline int\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"======================================================\\n\");\n\tpr_warn(\"WARNING: possible circular locking dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\n\tprint_lock(check_tgt);\n\tpr_warn(\"\\nwhich lock already depends on the new lock.\\n\\n\");\n\tpr_warn(\"\\nthe existing dependency chain (in reverse order) is:\\n\");\n\n\tprint_circular_bug_entry(entry, depth);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_circular_bug_entry",
          "args": [
            "entry",
            "depth"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "print_circular_bug_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "1083-1094",
          "snippet": "static noinline int\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn 0;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_stack_trace(&target->trace, 6);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn 0;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_stack_trace(&target->trace, 6);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nthe existing dependency chain (in reverse order) is:\\n\""
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nwhich lock already depends on the new lock.\\n\\n\""
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "check_tgt"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\nbut task is already holding lock:\\n\""
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s/%d is trying to acquire lock:\\n\"",
            "curr->comm",
            "task_pid_nr(curr)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "curr"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"------------------------------------------------------\\n\""
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_kernel_ident",
          "args": [],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "print_kernel_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "579-585",
          "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: possible circular locking dependency detected\\n\""
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"======================================================\\n\""
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"\\n\""
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"======================================================\\n\");\n\tpr_warn(\"WARNING: possible circular locking dependency detected\\n\");\n\tprint_kernel_ident();\n\tpr_warn(\"------------------------------------------------------\\n\");\n\tpr_warn(\"%s/%d is trying to acquire lock:\\n\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\n\tpr_warn(\"\\nbut task is already holding lock:\\n\");\n\n\tprint_lock(check_tgt);\n\tpr_warn(\"\\nwhich lock already depends on the new lock.\\n\\n\");\n\tpr_warn(\"\\nthe existing dependency chain (in reverse order) is:\\n\");\n\n\tprint_circular_bug_entry(entry, depth);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_circular_lock_scenario",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1096-1144",
    "snippet": "static void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (parent != source) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(source);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(parent);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(target);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(parent);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(source);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n *** DEADLOCK ***\\n\\n\""
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "source"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "496-512",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "tgt"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t/*\n\t * A direct locking problem where unsafe_class lock is taken\n\t * directly by safe_class lock, then all we need to show\n\t * is the deadlock scenario, as it is obvious that the\n\t * unsafe lock is taken under the safe lock.\n\t *\n\t * But if there is a chain instead, where the safe lock takes\n\t * an intermediate lock (middle_class) where this lock is\n\t * not the same as the safe lock, then the lock chain is\n\t * used to describe the problem. Otherwise we would need\n\t * to show a different CPU case for each link in the chain\n\t * from the safe_class lock to the unsafe_class lock.\n\t */\n\tif (parent != source) {\n\t\tprintk(\"Chain exists of:\\n  \");\n\t\t__print_lock_name(source);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(parent);\n\t\tprintk(KERN_CONT \" --> \");\n\t\t__print_lock_name(target);\n\t\tprintk(KERN_CONT \"\\n\\n\");\n\t}\n\n\tprintk(\" Possible unsafe locking scenario:\\n\\n\");\n\tprintk(\"       CPU0                    CPU1\\n\");\n\tprintk(\"       ----                    ----\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(parent);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"                               lock(\");\n\t__print_lock_name(target);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"  lock(\");\n\t__print_lock_name(source);\n\tprintk(KERN_CONT \");\\n\");\n\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");\n}"
  },
  {
    "function_name": "print_circular_bug_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1083-1094",
    "snippet": "static noinline int\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn 0;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_stack_trace(&target->trace, 6);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "&target->trace",
            "6"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "print_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stacktrace.c",
          "lines": "14-23",
          "snippet": "void print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\nvoid print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \":\\n\""
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "target->class"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "514-523",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n-> #%u\"",
            "depth"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinline int\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn 0;\n\tprintk(\"\\n-> #%u\", depth);\n\tprint_lock_name(target->class);\n\tprintk(KERN_CONT \":\\n\");\n\tprint_stack_trace(&target->trace, 6);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__bfs_backwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1064-1071",
    "snippet": "static inline int __bfs_backwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 0);\n\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs",
          "args": [
            "src_entry",
            "data",
            "match",
            "target_entry",
            "0"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "986-1053",
          "snippet": "static int __bfs(struct lock_list *source_entry,\n\t\t void *data,\n\t\t int (*match)(struct lock_list *entry, void *data),\n\t\t struct lock_list **target_entry,\n\t\t int forward)\n{\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tstruct circular_queue *cq = &lock_cq;\n\tint ret = 1;\n\n\tif (match(source_entry, data)) {\n\t\t*target_entry = source_entry;\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tif (forward)\n\t\thead = &source_entry->class->locks_after;\n\telse\n\t\thead = &source_entry->class->locks_before;\n\n\tif (list_empty(head))\n\t\tgoto exit;\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, (unsigned long)source_entry);\n\n\twhile (!__cq_empty(cq)) {\n\t\tstruct lock_list *lock;\n\n\t\t__cq_dequeue(cq, (unsigned long *)&lock);\n\n\t\tif (!lock->class) {\n\t\t\tret = -2;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (forward)\n\t\t\thead = &lock->class->locks_after;\n\t\telse\n\t\t\thead = &lock->class->locks_before;\n\n\t\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tif (!lock_accessed(entry)) {\n\t\t\t\tunsigned int cq_depth;\n\t\t\t\tmark_lock_accessed(entry, lock);\n\t\t\t\tif (match(entry, data)) {\n\t\t\t\t\t*target_entry = entry;\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tif (__cq_enqueue(cq, (unsigned long)entry)) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __bfs(struct lock_list *source_entry,\n\t\t void *data,\n\t\t int (*match)(struct lock_list *entry, void *data),\n\t\t struct lock_list **target_entry,\n\t\t int forward)\n{\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tstruct circular_queue *cq = &lock_cq;\n\tint ret = 1;\n\n\tif (match(source_entry, data)) {\n\t\t*target_entry = source_entry;\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tif (forward)\n\t\thead = &source_entry->class->locks_after;\n\telse\n\t\thead = &source_entry->class->locks_before;\n\n\tif (list_empty(head))\n\t\tgoto exit;\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, (unsigned long)source_entry);\n\n\twhile (!__cq_empty(cq)) {\n\t\tstruct lock_list *lock;\n\n\t\t__cq_dequeue(cq, (unsigned long *)&lock);\n\n\t\tif (!lock->class) {\n\t\t\tret = -2;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (forward)\n\t\t\thead = &lock->class->locks_after;\n\t\telse\n\t\t\thead = &lock->class->locks_before;\n\n\t\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tif (!lock_accessed(entry)) {\n\t\t\t\tunsigned int cq_depth;\n\t\t\t\tmark_lock_accessed(entry, lock);\n\t\t\t\tif (match(entry, data)) {\n\t\t\t\t\t*target_entry = entry;\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tif (__cq_enqueue(cq, (unsigned long)entry)) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __bfs_backwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 0);\n\n}"
  },
  {
    "function_name": "__bfs_forwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "1055-1062",
    "snippet": "static inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bfs",
          "args": [
            "src_entry",
            "data",
            "match",
            "target_entry",
            "1"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "__bfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "986-1053",
          "snippet": "static int __bfs(struct lock_list *source_entry,\n\t\t void *data,\n\t\t int (*match)(struct lock_list *entry, void *data),\n\t\t struct lock_list **target_entry,\n\t\t int forward)\n{\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tstruct circular_queue *cq = &lock_cq;\n\tint ret = 1;\n\n\tif (match(source_entry, data)) {\n\t\t*target_entry = source_entry;\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tif (forward)\n\t\thead = &source_entry->class->locks_after;\n\telse\n\t\thead = &source_entry->class->locks_before;\n\n\tif (list_empty(head))\n\t\tgoto exit;\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, (unsigned long)source_entry);\n\n\twhile (!__cq_empty(cq)) {\n\t\tstruct lock_list *lock;\n\n\t\t__cq_dequeue(cq, (unsigned long *)&lock);\n\n\t\tif (!lock->class) {\n\t\t\tret = -2;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (forward)\n\t\t\thead = &lock->class->locks_after;\n\t\telse\n\t\t\thead = &lock->class->locks_before;\n\n\t\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tif (!lock_accessed(entry)) {\n\t\t\t\tunsigned int cq_depth;\n\t\t\t\tmark_lock_accessed(entry, lock);\n\t\t\t\tif (match(entry, data)) {\n\t\t\t\t\t*target_entry = entry;\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tif (__cq_enqueue(cq, (unsigned long)entry)) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __bfs(struct lock_list *source_entry,\n\t\t void *data,\n\t\t int (*match)(struct lock_list *entry, void *data),\n\t\t struct lock_list **target_entry,\n\t\t int forward)\n{\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tstruct circular_queue *cq = &lock_cq;\n\tint ret = 1;\n\n\tif (match(source_entry, data)) {\n\t\t*target_entry = source_entry;\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tif (forward)\n\t\thead = &source_entry->class->locks_after;\n\telse\n\t\thead = &source_entry->class->locks_before;\n\n\tif (list_empty(head))\n\t\tgoto exit;\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, (unsigned long)source_entry);\n\n\twhile (!__cq_empty(cq)) {\n\t\tstruct lock_list *lock;\n\n\t\t__cq_dequeue(cq, (unsigned long *)&lock);\n\n\t\tif (!lock->class) {\n\t\t\tret = -2;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (forward)\n\t\t\thead = &lock->class->locks_after;\n\t\telse\n\t\t\thead = &lock->class->locks_before;\n\n\t\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tif (!lock_accessed(entry)) {\n\t\t\t\tunsigned int cq_depth;\n\t\t\t\tmark_lock_accessed(entry, lock);\n\t\t\t\tif (match(entry, data)) {\n\t\t\t\t\t*target_entry = entry;\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tif (__cq_enqueue(cq, (unsigned long)entry)) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}"
  },
  {
    "function_name": "__bfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "986-1053",
    "snippet": "static int __bfs(struct lock_list *source_entry,\n\t\t void *data,\n\t\t int (*match)(struct lock_list *entry, void *data),\n\t\t struct lock_list **target_entry,\n\t\t int forward)\n{\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tstruct circular_queue *cq = &lock_cq;\n\tint ret = 1;\n\n\tif (match(source_entry, data)) {\n\t\t*target_entry = source_entry;\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tif (forward)\n\t\thead = &source_entry->class->locks_after;\n\telse\n\t\thead = &source_entry->class->locks_before;\n\n\tif (list_empty(head))\n\t\tgoto exit;\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, (unsigned long)source_entry);\n\n\twhile (!__cq_empty(cq)) {\n\t\tstruct lock_list *lock;\n\n\t\t__cq_dequeue(cq, (unsigned long *)&lock);\n\n\t\tif (!lock->class) {\n\t\t\tret = -2;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (forward)\n\t\t\thead = &lock->class->locks_after;\n\t\telse\n\t\t\thead = &lock->class->locks_before;\n\n\t\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tif (!lock_accessed(entry)) {\n\t\t\t\tunsigned int cq_depth;\n\t\t\t\tmark_lock_accessed(entry, lock);\n\t\t\t\tif (match(entry, data)) {\n\t\t\t\t\t*target_entry = entry;\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tif (__cq_enqueue(cq, (unsigned long)entry)) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cq_get_elem_count",
          "args": [
            "cq"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_get_elem_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "944-947",
          "snippet": "static inline unsigned int  __cq_get_elem_count(struct circular_queue *cq)\n{\n\treturn (cq->rear - cq->front) & CQ_MASK;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic inline unsigned int  __cq_get_elem_count(struct circular_queue *cq)\n{\n\treturn (cq->rear - cq->front) & CQ_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cq_enqueue",
          "args": [
            "cq",
            "(unsigned long)entry"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "924-932",
          "snippet": "static inline int __cq_enqueue(struct circular_queue *cq, unsigned long elem)\n{\n\tif (__cq_full(cq))\n\t\treturn -1;\n\n\tcq->element[cq->rear] = elem;\n\tcq->rear = (cq->rear + 1) & CQ_MASK;\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic inline int __cq_enqueue(struct circular_queue *cq, unsigned long elem)\n{\n\tif (__cq_full(cq))\n\t\treturn -1;\n\n\tcq->element[cq->rear] = elem;\n\tcq->rear = (cq->rear + 1) & CQ_MASK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "entry",
            "data"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "match_held_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3399-3433",
          "snippet": "static int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic int match_held_lock(const struct held_lock *hlock,\n\t\t\t\t\tconst struct lockdep_map *lock)\n{\n\tif (hlock->instance == lock)\n\t\treturn 1;\n\n\tif (hlock->references) {\n\t\tconst struct lock_class *class = lock->class_cache[0];\n\n\t\tif (!class)\n\t\t\tclass = look_up_lock_class(lock, 0);\n\n\t\t/*\n\t\t * If look_up_lock_class() failed to find a class, we're trying\n\t\t * to test if we hold a lock that has never yet been acquired.\n\t\t * Clearly if the lock hasn't been acquired _ever_, we're not\n\t\t * holding it either, so report failure.\n\t\t */\n\t\tif (!class)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * References, but not a lock we're actually ref-counting?\n\t\t * State got messed up, follow the sites that change ->references\n\t\t * and try to make sense of it.\n\t\t */\n\t\tif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\n\t\t\treturn 0;\n\n\t\tif (hlock->class_idx == class - lock_classes + 1)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_lock_accessed",
          "args": [
            "entry",
            "lock"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lock_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "949-958",
          "snippet": "static inline void mark_lock_accessed(struct lock_list *lock,\n\t\t\t\t\tstruct lock_list *parent)\n{\n\tunsigned long nr;\n\n\tnr = lock - list_entries;\n\tWARN_ON(nr >= nr_list_entries); /* Out-of-bounds, input fail */\n\tlock->parent = parent;\n\tlock->class->dep_gen_id = lockdep_dependency_gen_id;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_list_entries;",
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic inline void mark_lock_accessed(struct lock_list *lock,\n\t\t\t\t\tstruct lock_list *parent)\n{\n\tunsigned long nr;\n\n\tnr = lock - list_entries;\n\tWARN_ON(nr >= nr_list_entries); /* Out-of-bounds, input fail */\n\tlock->parent = parent;\n\tlock->class->dep_gen_id = lockdep_dependency_gen_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_accessed",
          "args": [
            "entry"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "lock_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "960-967",
          "snippet": "static inline unsigned long lock_accessed(struct lock_list *lock)\n{\n\tunsigned long nr;\n\n\tnr = lock - list_entries;\n\tWARN_ON(nr >= nr_list_entries); /* Out-of-bounds, input fail */\n\treturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_list_entries;",
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic inline unsigned long lock_accessed(struct lock_list *lock)\n{\n\tunsigned long nr;\n\n\tnr = lock - list_entries;\n\tWARN_ON(nr >= nr_list_entries); /* Out-of-bounds, input fail */\n\treturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "entry",
            "head",
            "entry"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cq_dequeue",
          "args": [
            "cq",
            "(unsigned long *)&lock"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "934-942",
          "snippet": "static inline int __cq_dequeue(struct circular_queue *cq, unsigned long *elem)\n{\n\tif (__cq_empty(cq))\n\t\treturn -1;\n\n\t*elem = cq->element[cq->front];\n\tcq->front = (cq->front + 1) & CQ_MASK;\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic inline int __cq_dequeue(struct circular_queue *cq, unsigned long *elem)\n{\n\tif (__cq_empty(cq))\n\t\treturn -1;\n\n\t*elem = cq->element[cq->front];\n\tcq->front = (cq->front + 1) & CQ_MASK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cq_empty",
          "args": [
            "cq"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "914-917",
          "snippet": "static inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cq_init",
          "args": [
            "cq"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "908-912",
          "snippet": "static inline void __cq_init(struct circular_queue *cq)\n{\n\tcq->front = cq->rear = 0;\n\tlockdep_dependency_gen_id++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void __cq_init(struct circular_queue *cq)\n{\n\tcq->front = cq->rear = 0;\n\tlockdep_dependency_gen_id++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int __bfs(struct lock_list *source_entry,\n\t\t void *data,\n\t\t int (*match)(struct lock_list *entry, void *data),\n\t\t struct lock_list **target_entry,\n\t\t int forward)\n{\n\tstruct lock_list *entry;\n\tstruct list_head *head;\n\tstruct circular_queue *cq = &lock_cq;\n\tint ret = 1;\n\n\tif (match(source_entry, data)) {\n\t\t*target_entry = source_entry;\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tif (forward)\n\t\thead = &source_entry->class->locks_after;\n\telse\n\t\thead = &source_entry->class->locks_before;\n\n\tif (list_empty(head))\n\t\tgoto exit;\n\n\t__cq_init(cq);\n\t__cq_enqueue(cq, (unsigned long)source_entry);\n\n\twhile (!__cq_empty(cq)) {\n\t\tstruct lock_list *lock;\n\n\t\t__cq_dequeue(cq, (unsigned long *)&lock);\n\n\t\tif (!lock->class) {\n\t\t\tret = -2;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (forward)\n\t\t\thead = &lock->class->locks_after;\n\t\telse\n\t\t\thead = &lock->class->locks_before;\n\n\t\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\t\tlist_for_each_entry_rcu(entry, head, entry) {\n\t\t\tif (!lock_accessed(entry)) {\n\t\t\t\tunsigned int cq_depth;\n\t\t\t\tmark_lock_accessed(entry, lock);\n\t\t\t\tif (match(entry, data)) {\n\t\t\t\t\t*target_entry = entry;\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tif (__cq_enqueue(cq, (unsigned long)entry)) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tcq_depth = __cq_get_elem_count(cq);\n\t\t\t\tif (max_bfs_queue_depth < cq_depth)\n\t\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}"
  },
  {
    "function_name": "get_lock_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "974-984",
    "snippet": "static inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_lock_parent",
          "args": [
            "child"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "969-972",
          "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int get_lock_depth(struct lock_list *child)\n{\n\tint depth = 0;\n\tstruct lock_list *parent;\n\n\twhile ((parent = get_lock_parent(child))) {\n\t\tchild = parent;\n\t\tdepth++;\n\t}\n\treturn depth;\n}"
  },
  {
    "function_name": "get_lock_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "969-972",
    "snippet": "static inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\n{\n\treturn child->parent;\n}"
  },
  {
    "function_name": "lock_accessed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "960-967",
    "snippet": "static inline unsigned long lock_accessed(struct lock_list *lock)\n{\n\tunsigned long nr;\n\n\tnr = lock - list_entries;\n\tWARN_ON(nr >= nr_list_entries); /* Out-of-bounds, input fail */\n\treturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_list_entries;",
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nr >= nr_list_entries"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic inline unsigned long lock_accessed(struct lock_list *lock)\n{\n\tunsigned long nr;\n\n\tnr = lock - list_entries;\n\tWARN_ON(nr >= nr_list_entries); /* Out-of-bounds, input fail */\n\treturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\n}"
  },
  {
    "function_name": "mark_lock_accessed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "949-958",
    "snippet": "static inline void mark_lock_accessed(struct lock_list *lock,\n\t\t\t\t\tstruct lock_list *parent)\n{\n\tunsigned long nr;\n\n\tnr = lock - list_entries;\n\tWARN_ON(nr >= nr_list_entries); /* Out-of-bounds, input fail */\n\tlock->parent = parent;\n\tlock->class->dep_gen_id = lockdep_dependency_gen_id;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_list_entries;",
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nr >= nr_list_entries"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic inline void mark_lock_accessed(struct lock_list *lock,\n\t\t\t\t\tstruct lock_list *parent)\n{\n\tunsigned long nr;\n\n\tnr = lock - list_entries;\n\tWARN_ON(nr >= nr_list_entries); /* Out-of-bounds, input fail */\n\tlock->parent = parent;\n\tlock->class->dep_gen_id = lockdep_dependency_gen_id;\n}"
  },
  {
    "function_name": "__cq_get_elem_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "944-947",
    "snippet": "static inline unsigned int  __cq_get_elem_count(struct circular_queue *cq)\n{\n\treturn (cq->rear - cq->front) & CQ_MASK;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic inline unsigned int  __cq_get_elem_count(struct circular_queue *cq)\n{\n\treturn (cq->rear - cq->front) & CQ_MASK;\n}"
  },
  {
    "function_name": "__cq_dequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "934-942",
    "snippet": "static inline int __cq_dequeue(struct circular_queue *cq, unsigned long *elem)\n{\n\tif (__cq_empty(cq))\n\t\treturn -1;\n\n\t*elem = cq->element[cq->front];\n\tcq->front = (cq->front + 1) & CQ_MASK;\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cq_empty",
          "args": [
            "cq"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "914-917",
          "snippet": "static inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic inline int __cq_dequeue(struct circular_queue *cq, unsigned long *elem)\n{\n\tif (__cq_empty(cq))\n\t\treturn -1;\n\n\t*elem = cq->element[cq->front];\n\tcq->front = (cq->front + 1) & CQ_MASK;\n\treturn 0;\n}"
  },
  {
    "function_name": "__cq_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "924-932",
    "snippet": "static inline int __cq_enqueue(struct circular_queue *cq, unsigned long elem)\n{\n\tif (__cq_full(cq))\n\t\treturn -1;\n\n\tcq->element[cq->rear] = elem;\n\tcq->rear = (cq->rear + 1) & CQ_MASK;\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cq_full",
          "args": [
            "cq"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "__cq_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "919-922",
          "snippet": "static inline int __cq_full(struct circular_queue *cq)\n{\n\treturn ((cq->rear + 1) & CQ_MASK) == cq->front;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic inline int __cq_full(struct circular_queue *cq)\n{\n\treturn ((cq->rear + 1) & CQ_MASK) == cq->front;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic inline int __cq_enqueue(struct circular_queue *cq, unsigned long elem)\n{\n\tif (__cq_full(cq))\n\t\treturn -1;\n\n\tcq->element[cq->rear] = elem;\n\tcq->rear = (cq->rear + 1) & CQ_MASK;\n\treturn 0;\n}"
  },
  {
    "function_name": "__cq_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "919-922",
    "snippet": "static inline int __cq_full(struct circular_queue *cq)\n{\n\treturn ((cq->rear + 1) & CQ_MASK) == cq->front;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define CQ_MASK\t\t\t\t(MAX_CIRCULAR_QUEUE_SIZE-1)\n\nstatic inline int __cq_full(struct circular_queue *cq)\n{\n\treturn ((cq->rear + 1) & CQ_MASK) == cq->front;\n}"
  },
  {
    "function_name": "__cq_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "914-917",
    "snippet": "static inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int __cq_empty(struct circular_queue *cq)\n{\n\treturn (cq->front == cq->rear);\n}"
  },
  {
    "function_name": "__cq_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "908-912",
    "snippet": "static inline void __cq_init(struct circular_queue *cq)\n{\n\tcq->front = cq->rear = 0;\n\tlockdep_dependency_gen_id++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void __cq_init(struct circular_queue *cq)\n{\n\tcq->front = cq->rear = 0;\n\tlockdep_dependency_gen_id++;\n}"
  },
  {
    "function_name": "add_lock_to_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "859-883",
    "snippet": "static int add_lock_to_list(struct lock_class *this, struct list_head *head,\n\t\t\t    unsigned long ip, int distance,\n\t\t\t    struct stack_trace *trace)\n{\n\tstruct lock_list *entry;\n\t/*\n\t * Lock not present yet - get a new dependency struct and\n\t * add it to the list:\n\t */\n\tentry = alloc_list_entry();\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->class = this;\n\tentry->distance = distance;\n\tentry->trace = *trace;\n\t/*\n\t * Both allocation and removal are done under the graph lock; but\n\t * iteration is under RCU-sched; see look_up_lock_class() and\n\t * lockdep_free_key_range().\n\t */\n\tlist_add_tail_rcu(&entry->entry, head);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&entry->entry",
            "head"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_list_entry",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_list_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "843-854",
          "snippet": "static struct lock_list *alloc_list_entry(void)\n{\n\tif (nr_list_entries >= MAX_LOCKDEP_ENTRIES) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_ENTRIES too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\treturn list_entries + nr_list_entries++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long nr_list_entries;",
            "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic struct lock_list *alloc_list_entry(void)\n{\n\tif (nr_list_entries >= MAX_LOCKDEP_ENTRIES) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_ENTRIES too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\treturn list_entries + nr_list_entries++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic int add_lock_to_list(struct lock_class *this, struct list_head *head,\n\t\t\t    unsigned long ip, int distance,\n\t\t\t    struct stack_trace *trace)\n{\n\tstruct lock_list *entry;\n\t/*\n\t * Lock not present yet - get a new dependency struct and\n\t * add it to the list:\n\t */\n\tentry = alloc_list_entry();\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->class = this;\n\tentry->distance = distance;\n\tentry->trace = *trace;\n\t/*\n\t * Both allocation and removal are done under the graph lock; but\n\t * iteration is under RCU-sched; see look_up_lock_class() and\n\t * lockdep_free_key_range().\n\t */\n\tlist_add_tail_rcu(&entry->entry, head);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_list_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "843-854",
    "snippet": "static struct lock_list *alloc_list_entry(void)\n{\n\tif (nr_list_entries >= MAX_LOCKDEP_ENTRIES) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_ENTRIES too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\treturn list_entries + nr_list_entries++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_list_entries;",
      "static struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_LOCKDEP_ENTRIES too low!\""
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "381-388",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_list_entries;\nstatic struct lock_list list_entries[MAX_LOCKDEP_ENTRIES];\n\nstatic struct lock_list *alloc_list_entry(void)\n{\n\tif (nr_list_entries >= MAX_LOCKDEP_ENTRIES) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn NULL;\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_ENTRIES too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\treturn list_entries + nr_list_entries++;\n}"
  },
  {
    "function_name": "register_lock_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "739-836",
    "snippet": "static struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\t/*\n\t * Allocate a new key from the static array, and add it to\n\t * the hash:\n\t */\n\tif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tclass = lock_classes + nr_lock_classes++;\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tINIT_LIST_HEAD(&class->lock_entry);\n\tINIT_LIST_HEAD(&class->locks_before);\n\tINIT_LIST_HEAD(&class->locks_after);\n\tclass->name_version = count_matching_names(class);\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Add it to the global list of classes:\n\t */\n\tlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_lock_classes;",
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "class->subclass != subclass"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graph_unlock",
          "args": [],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_lock",
          "args": [],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "graph_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "85-101",
          "snippet": "static int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"#%d\"",
            "class->name_version"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\nnew class %px: %s\"",
            "class->key",
            "class->name"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "class"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "SOFTIRQ_verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2631-2637",
          "snippet": "static int SOFTIRQ_verbose(struct lock_class *class)\n{\n#if SOFTIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int SOFTIRQ_verbose(struct lock_class *class)\n{\n#if SOFTIRQ_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&class->lock_entry",
            "&all_lock_classes"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&class->hash_entry",
            "hash_head"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_matching_names",
          "args": [
            "class"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "count_matching_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "631-647",
          "snippet": "static int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->name)\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(class, &all_lock_classes, lock_entry) {\n\t\tif (new_class->key - new_class->subclass == class->key)\n\t\t\treturn class->name_version;\n\t\tif (class->name && !strcmp(class->name, new_class->name))\n\t\t\tcount = max(count, class->name_version);\n\t}\n\n\treturn count + 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->name)\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(class, &all_lock_classes, lock_entry) {\n\t\tif (new_class->key - new_class->subclass == class->key)\n\t\t\treturn class->name_version;\n\t\tif (class->name && !strcmp(class->name, new_class->name))\n\t\t\tcount = max(count, class->name_version);\n\t}\n\n\treturn count + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&class->locks_after"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&class->locks_before"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&class->lock_entry"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_inc",
          "args": [
            "nr_unused_locks"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_LOCKDEP_KEYS too low!\""
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "381-388",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "class",
            "hash_head",
            "hash_entry"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "classhashentry",
          "args": [
            "key"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "lock->key"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "599-624",
          "snippet": "static int static_obj(void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_lock_key",
          "args": [
            "lock"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "assign_lock_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "711-732",
          "snippet": "static bool assign_lock_key(struct lockdep_map *lock)\n{\n\tunsigned long can_addr, addr = (unsigned long)lock;\n\n\tif (__is_kernel_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (__is_module_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (static_obj(lock))\n\t\tlock->key = (void *)lock;\n\telse {\n\t\t/* Debug-check: all keys must be persistent! */\n\t\tdebug_locks_off();\n\t\tpr_err(\"INFO: trying to register non-static key.\\n\");\n\t\tpr_err(\"the code is fine but needs lockdep annotation.\\n\");\n\t\tpr_err(\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic bool assign_lock_key(struct lockdep_map *lock)\n{\n\tunsigned long can_addr, addr = (unsigned long)lock;\n\n\tif (__is_kernel_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (__is_module_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (static_obj(lock))\n\t\tlock->key = (void *)lock;\n\telse {\n\t\t/* Debug-check: all keys must be persistent! */\n\t\tdebug_locks_off();\n\t\tpr_err(\"INFO: trying to register non-static key.\\n\");\n\t\tpr_err(\"the code is fine but needs lockdep annotation.\\n\");\n\t\tpr_err(\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "class"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "look_up_lock_class",
          "args": [
            "lock",
            "subclass"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "look_up_lock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "649-704",
          "snippet": "static inline struct lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_lock_classes;\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic struct lock_class *\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tDEBUG_LOCKS_WARN_ON(!irqs_disabled());\n\n\tclass = look_up_lock_class(lock, subclass);\n\tif (likely(class))\n\t\tgoto out_set_class_cache;\n\n\tif (!lock->key) {\n\t\tif (!assign_lock_key(lock))\n\t\t\treturn NULL;\n\t} else if (!static_obj(lock->key)) {\n\t\treturn NULL;\n\t}\n\n\tkey = lock->key->subkeys + subclass;\n\thash_head = classhashentry(key);\n\n\tif (!graph_lock()) {\n\t\treturn NULL;\n\t}\n\t/*\n\t * We have to do the hash-walk again, to avoid races\n\t * with another CPU:\n\t */\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key)\n\t\t\tgoto out_unlock_set;\n\t}\n\n\t/*\n\t * Allocate a new key from the static array, and add it to\n\t * the hash:\n\t */\n\tif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\n\t\tif (!debug_locks_off_graph_unlock()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tprint_lockdep_off(\"BUG: MAX_LOCKDEP_KEYS too low!\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tclass = lock_classes + nr_lock_classes++;\n\tdebug_atomic_inc(nr_unused_locks);\n\tclass->key = key;\n\tclass->name = lock->name;\n\tclass->subclass = subclass;\n\tINIT_LIST_HEAD(&class->lock_entry);\n\tINIT_LIST_HEAD(&class->locks_before);\n\tINIT_LIST_HEAD(&class->locks_after);\n\tclass->name_version = count_matching_names(class);\n\t/*\n\t * We use RCU's safe list-add method to make\n\t * parallel walking of the hash-list safe:\n\t */\n\thlist_add_head_rcu(&class->hash_entry, hash_head);\n\t/*\n\t * Add it to the global list of classes:\n\t */\n\tlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\n\n\tif (verbose(class)) {\n\t\tgraph_unlock();\n\n\t\tprintk(\"\\nnew class %px: %s\", class->key, class->name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tdump_stack();\n\n\t\tif (!graph_lock()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\nout_unlock_set:\n\tgraph_unlock();\n\nout_set_class_cache:\n\tif (!subclass || force)\n\t\tlock->class_cache[0] = class;\n\telse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\n\t\tlock->class_cache[subclass] = class;\n\n\t/*\n\t * Hash collision, did we smoke some? We found a class with a matching\n\t * hash but the subclass -- which is hashed in -- didn't match.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\n\t\treturn NULL;\n\n\treturn class;\n}"
  },
  {
    "function_name": "assign_lock_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "711-732",
    "snippet": "static bool assign_lock_key(struct lockdep_map *lock)\n{\n\tunsigned long can_addr, addr = (unsigned long)lock;\n\n\tif (__is_kernel_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (__is_module_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (static_obj(lock))\n\t\tlock->key = (void *)lock;\n\telse {\n\t\t/* Debug-check: all keys must be persistent! */\n\t\tdebug_locks_off();\n\t\tpr_err(\"INFO: trying to register non-static key.\\n\");\n\t\tpr_err(\"the code is fine but needs lockdep annotation.\\n\");\n\t\tpr_err(\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"turning off the locking correctness validator.\\n\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"the code is fine but needs lockdep annotation.\\n\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: trying to register non-static key.\\n\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_obj",
          "args": [
            "lock"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "static_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "599-624",
          "snippet": "static int static_obj(void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__is_module_percpu_address",
          "args": [
            "addr",
            "&can_addr"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "__is_module_percpu_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "756-759",
          "snippet": "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__is_kernel_percpu_address",
          "args": [
            "addr",
            "&can_addr"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic bool assign_lock_key(struct lockdep_map *lock)\n{\n\tunsigned long can_addr, addr = (unsigned long)lock;\n\n\tif (__is_kernel_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (__is_module_percpu_address(addr, &can_addr))\n\t\tlock->key = (void *)can_addr;\n\telse if (static_obj(lock))\n\t\tlock->key = (void *)lock;\n\telse {\n\t\t/* Debug-check: all keys must be persistent! */\n\t\tdebug_locks_off();\n\t\tpr_err(\"INFO: trying to register non-static key.\\n\");\n\t\tpr_err(\"the code is fine but needs lockdep annotation.\\n\");\n\t\tpr_err(\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "look_up_lock_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "649-704",
    "snippet": "static inline struct lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "class->name != lock->name"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "class",
            "hash_head",
            "hash_entry"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "classhashentry",
          "args": [
            "key"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lock->key"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\""
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\"",
            "subclass"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "subclass >= MAX_LOCKDEP_SUBCLASSES"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline struct lock_class *\nlook_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)\n{\n\tstruct lockdep_subclass_key *key;\n\tstruct hlist_head *hash_head;\n\tstruct lock_class *class;\n\n\tif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\n\t\tdebug_locks_off();\n\t\tprintk(KERN_ERR\n\t\t\t\"BUG: looking up invalid subclass: %u\\n\", subclass);\n\t\tprintk(KERN_ERR\n\t\t\t\"turning off the locking correctness validator.\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If it is not initialised then it has never been locked,\n\t * so it won't be present in the hash table.\n\t */\n\tif (unlikely(!lock->key))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE: the class-key must be unique. For dynamic locks, a static\n\t * lock_class_key variable is passed in through the mutex_init()\n\t * (or spin_lock_init()) call - which acts as the key. For static\n\t * locks we use the lock object itself as the key.\n\t */\n\tBUILD_BUG_ON(sizeof(struct lock_class_key) >\n\t\t\tsizeof(struct lockdep_map));\n\n\tkey = lock->key->subkeys + subclass;\n\n\thash_head = classhashentry(key);\n\n\t/*\n\t * We do an RCU walk of the hash, see lockdep_free_key_range().\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(class, hash_head, hash_entry) {\n\t\tif (class->key == key) {\n\t\t\t/*\n\t\t\t * Huh! same key, different name? Did someone trample\n\t\t\t * on some memory? We're most confused.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(class->name != lock->name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "count_matching_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "631-647",
    "snippet": "static int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->name)\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(class, &all_lock_classes, lock_entry) {\n\t\tif (new_class->key - new_class->subclass == class->key)\n\t\t\treturn class->name_version;\n\t\tif (class->name && !strcmp(class->name, new_class->name))\n\t\t\tcount = max(count, class->name_version);\n\t}\n\n\treturn count + 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "count",
            "class->name_version"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "class->name",
            "new_class->name"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "class",
            "&all_lock_classes",
            "lock_entry"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->name)\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(class, &all_lock_classes, lock_entry) {\n\t\tif (new_class->key - new_class->subclass == class->key)\n\t\t\treturn class->name_version;\n\t\tif (class->name && !strcmp(class->name, new_class->name))\n\t\t\tcount = max(count, class->name_version);\n\t}\n\n\treturn count + 1;\n}"
  },
  {
    "function_name": "static_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "599-624",
    "snippet": "static int static_obj(void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_module_percpu_address",
          "args": [
            "addr"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "is_module_percpu_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "751-754",
          "snippet": "bool is_module_percpu_address(unsigned long addr)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool is_module_percpu_address(unsigned long addr)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_module_address",
          "args": [
            "addr"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "is_module_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4300-4309",
          "snippet": "bool is_module_address(unsigned long addr)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tret = __module_address(addr) != NULL;\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool is_module_address(unsigned long addr)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tret = __module_address(addr) != NULL;\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kernel_percpu_address",
          "args": [
            "addr"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_is_kernel_data",
          "args": [
            "addr"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int static_obj(void *obj)\n{\n\tunsigned long start = (unsigned long) &_stext,\n\t\t      end   = (unsigned long) &_end,\n\t\t      addr  = (unsigned long) obj;\n\n\t/*\n\t * static variable?\n\t */\n\tif ((addr >= start) && (addr < end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t/*\n\t * in-kernel percpu var?\n\t */\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t/*\n\t * module static or percpu var?\n\t */\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}"
  },
  {
    "function_name": "very_verbose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "587-593",
    "snippet": "static int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define VERY_VERBOSE\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_filter",
          "args": [
            "class"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "class_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "350-363",
          "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define VERY_VERBOSE\t\t0\n\nstatic int very_verbose(struct lock_class *class)\n{\n#if VERY_VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "print_kernel_ident",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "579-585",
    "snippet": "static void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s %.*s %s\\n\"",
            "init_utsname()->release",
            "(int)strcspn(init_utsname()->version, \" \")",
            "init_utsname()->version",
            "print_tainted()"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "print_tainted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "344-365",
          "snippet": "const char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
            "const struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nconst struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};\n\nconst char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "init_utsname()->version",
            "\" \""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_kernel_ident(void)\n{\n\tprintk(\"%s %.*s %s\\n\", init_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version,\n\t\tprint_tainted());\n}"
  },
  {
    "function_name": "lockdep_print_held_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "558-577",
    "snippet": "static void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_lock",
          "args": [
            "p->held_locks + i"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "537-556",
          "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static int __lock_is_held(const struct lockdep_map *lock, int read);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" #%d: \"",
            "i"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%d lock%s held by %s/%d:\\n\"",
            "depth",
            "depth > 1 ? \"s\" : \"\"",
            "p->comm",
            "task_pid_nr(p)"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->lockdep_depth"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lockdep_print_held_locks(struct task_struct *p)\n{\n\tint i, depth = READ_ONCE(p->lockdep_depth);\n\n\tif (!depth)\n\t\tprintk(\"no locks held by %s/%d.\\n\", p->comm, task_pid_nr(p));\n\telse\n\t\tprintk(\"%d lock%s held by %s/%d:\\n\", depth,\n\t\t       depth > 1 ? \"s\" : \"\", p->comm, task_pid_nr(p));\n\t/*\n\t * It's not reliable to print a task's held locks if it's not sleeping\n\t * and it's not the current task.\n\t */\n\tif (p->state == TASK_RUNNING && p != current)\n\t\treturn;\n\tfor (i = 0; i < depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(p->held_locks + i);\n\t}\n}"
  },
  {
    "function_name": "print_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "537-556",
    "snippet": "static void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \", at: %pS\\n\"",
            "(void *)hlock->acquire_ip"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lock_name",
          "args": [
            "lock_classes + class_idx - 1"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "514-523",
          "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"<RELEASED>\\n\""
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void print_lock(struct held_lock *hlock)\n{\n\t/*\n\t * We can be called locklessly through debug_show_all_locks() so be\n\t * extra careful, the hlock might have been released and cleared.\n\t */\n\tunsigned int class_idx = hlock->class_idx;\n\n\t/* Don't re-read hlock->class_idx, can't use READ_ONCE() on bitfields: */\n\tbarrier();\n\n\tif (!class_idx || (class_idx - 1) >= MAX_LOCKDEP_KEYS) {\n\t\tprintk(KERN_CONT \"<RELEASED>\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%p\", hlock->instance);\n\tprint_lock_name(lock_classes + class_idx - 1);\n\tprintk(KERN_CONT \", at: %pS\\n\", (void *)hlock->acquire_ip);\n}"
  },
  {
    "function_name": "print_lockdep_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "525-535",
    "snippet": "static void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%s\"",
            "name"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_key_name",
          "args": [
            "lock->key->subkeys",
            "str"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__get_key_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "458-461",
          "snippet": "const char * __get_key_name(struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nconst char * __get_key_name(struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lockdep_cache(struct lockdep_map *lock)\n{\n\tconst char *name;\n\tchar str[KSYM_NAME_LEN];\n\n\tname = lock->name;\n\tif (!name)\n\t\tname = __get_key_name(lock->key->subkeys, str);\n\n\tprintk(KERN_CONT \"%s\", name);\n}"
  },
  {
    "function_name": "print_lock_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "514-523",
    "snippet": "static void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"){%s}\"",
            "usage"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_lock_name",
          "args": [
            "class"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__print_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "496-512",
          "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" (\""
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_usage_chars",
          "args": [
            "class",
            "usage"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "get_usage_chars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "483-494",
          "snippet": "void get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void print_lock_name(struct lock_class *class)\n{\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tget_usage_chars(class, usage);\n\n\tprintk(KERN_CONT \" (\");\n\t__print_lock_name(class);\n\tprintk(KERN_CONT \"){%s}\", usage);\n}"
  },
  {
    "function_name": "__print_lock_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "496-512",
    "snippet": "static void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"/%d\"",
            "class->subclass"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_key_name",
          "args": [
            "class->key",
            "str"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__get_key_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "458-461",
          "snippet": "const char * __get_key_name(struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nconst char * __get_key_name(struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void __print_lock_name(struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name;\n\n\tname = class->name;\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tprintk(KERN_CONT \"%s\", name);\n\t} else {\n\t\tprintk(KERN_CONT \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tprintk(KERN_CONT \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tprintk(KERN_CONT \"/%d\", class->subclass);\n\t}\n}"
  },
  {
    "function_name": "get_usage_chars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "483-494",
    "snippet": "void get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}"
  },
  {
    "function_name": "get_usage_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "468-481",
    "snippet": "static char get_usage_char(struct lock_class *class, enum lock_usage_bit bit)\n{\n\tchar c = '.';\n\n\tif (class->usage_mask & lock_flag(bit + 2))\n\t\tc = '+';\n\tif (class->usage_mask & lock_flag(bit)) {\n\t\tc = '-';\n\t\tif (class->usage_mask & lock_flag(bit + 2))\n\t\t\tc = '?';\n\t}\n\n\treturn c;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_flag",
          "args": [
            "bit + 2"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "lock_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "463-466",
          "snippet": "static inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic char get_usage_char(struct lock_class *class, enum lock_usage_bit bit)\n{\n\tchar c = '.';\n\n\tif (class->usage_mask & lock_flag(bit + 2))\n\t\tc = '+';\n\tif (class->usage_mask & lock_flag(bit)) {\n\t\tc = '-';\n\t\tif (class->usage_mask & lock_flag(bit + 2))\n\t\t\tc = '?';\n\t}\n\n\treturn c;\n}"
  },
  {
    "function_name": "lock_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "463-466",
    "snippet": "static inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline unsigned long lock_flag(enum lock_usage_bit bit)\n{\n\treturn 1UL << bit;\n}"
  },
  {
    "function_name": "__get_key_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "458-461",
    "snippet": "const char * __get_key_name(struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "(unsigned long)key",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nconst char * __get_key_name(struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}"
  },
  {
    "function_name": "save_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "390-426",
    "snippet": "static int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long nr_stack_trace_entries;",
      "static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_lockdep_off",
          "args": [
            "\"BUG: MAX_STACK_TRACE_ENTRIES too low!\""
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "print_lockdep_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "381-388",
          "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define lock_stat 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off_graph_unlock",
          "args": [],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_stack_trace",
          "args": [
            "trace"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long nr_stack_trace_entries;\nstatic unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];\n\nstatic int save_trace(struct stack_trace *trace)\n{\n\ttrace->nr_entries = 0;\n\ttrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\n\ttrace->entries = stack_trace + nr_stack_trace_entries;\n\n\ttrace->skip = 3;\n\n\tsave_stack_trace(trace);\n\n\t/*\n\t * Some daft arches put -1 at the end to indicate its a full trace.\n\t *\n\t * <rant> this is buggy anyway, since it takes a whole extra entry so a\n\t * complete trace that maxes out the entries provided will be reported\n\t * as incomplete, friggin useless </rant>\n\t */\n\tif (trace->nr_entries != 0 &&\n\t    trace->entries[trace->nr_entries-1] == ULONG_MAX)\n\t\ttrace->nr_entries--;\n\n\ttrace->max_entries = trace->nr_entries;\n\n\tnr_stack_trace_entries += trace->nr_entries;\n\n\tif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\n\t\tif (!debug_locks_off_graph_unlock())\n\t\t\treturn 0;\n\n\t\tprint_lockdep_off(\"BUG: MAX_STACK_TRACE_ENTRIES too low!\");\n\t\tdump_stack();\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "print_lockdep_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "381-388",
    "snippet": "static void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define lock_stat 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "printk_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "35-41",
          "snippet": "static void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_task(struct task_struct *p)\n{\n\tif (p)\n\t\tprintk(\"%16s:%5d [%p, %3d]\", p->comm, task_pid_nr(p), p, p->prio);\n\telse\n\t\tprintk(\"<none>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s\\n\"",
            "bug_msg"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "printk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "43-58",
          "snippet": "static void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\n{\n\tif (lock->name)\n\t\tprintk(\" [%p] {%s}\\n\",\n\t\t\tlock, lock->name);\n\telse\n\t\tprintk(\" [%p] {%s:%d}\\n\",\n\t\t\tlock, lock->file, lock->line);\n\n\tif (print_owner && rt_mutex_owner(lock)) {\n\t\tprintk(\".. ->owner: %p\\n\", lock->owner);\n\t\tprintk(\".. held by:  \");\n\t\tprintk_task(rt_mutex_owner(lock));\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic void print_lockdep_off(const char *bug_msg)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", bug_msg);\n\tprintk(KERN_DEBUG \"turning off the locking correctness validator.\\n\");\n#ifdef CONFIG_LOCK_STAT\n\tprintk(KERN_DEBUG \"Please attach the output of /proc/lock_stat to the bug report\\n\");\n#endif\n}"
  },
  {
    "function_name": "verbose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "366-372",
    "snippet": "static int verbose(struct lock_class *class)\n{\n#if VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define VERBOSE\t\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_filter",
          "args": [
            "class"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "class_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "350-363",
          "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define VERBOSE\t\t\t0\n\nstatic int verbose(struct lock_class *class)\n{\n#if VERBOSE\n\treturn class_filter(class);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "class_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "350-363",
    "snippet": "static int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "class->name",
            "\"&struct->lockfield\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "class->name",
            "\"lockname\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int class_filter(struct lock_class *class)\n{\n#if 0\n\t/* Example */\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"lockname\"))\n\t\treturn 1;\n\tif (class->name_version == 1 &&\n\t\t\t!strcmp(class->name, \"&struct->lockfield\"))\n\t\treturn 1;\n#endif\n\t/* Filter everything else. 1 would be to allow everything else */\n\treturn 0;\n}"
  },
  {
    "function_name": "lockdep_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "325-328",
    "snippet": "void lockdep_on(void)\n{\n\tcurrent->lockdep_recursion--;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_on(void)\n{\n\tcurrent->lockdep_recursion--;\n}"
  },
  {
    "function_name": "lockdep_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "319-322",
    "snippet": "void lockdep_off(void)\n{\n\tcurrent->lockdep_recursion++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_off(void)\n{\n\tcurrent->lockdep_recursion++;\n}"
  },
  {
    "function_name": "iterate_chain_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "310-317",
    "snippet": "static inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jhash_mix",
          "args": [
            "idx",
            "k0",
            "k1"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 iterate_chain_key(u64 key, u32 idx)\n{\n\tu32 k0 = key, k1 = key >> 32;\n\n\t__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */\n\n\treturn k0 | (u64)k1 << 32;\n}"
  },
  {
    "function_name": "lock_release_holdtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "271-273",
    "snippet": "static inline void lock_release_holdtime(struct held_lock *hlock)\n{\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void lock_release_holdtime(struct held_lock *hlock)\n{\n}"
  },
  {
    "function_name": "lock_release_holdtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "254-269",
    "snippet": "static void lock_release_holdtime(struct held_lock *hlock)\n{\n\tstruct lock_class_stats *stats;\n\tu64 holdtime;\n\n\tif (!lock_stat)\n\t\treturn;\n\n\tholdtime = lockstat_clock() - hlock->holdtime_stamp;\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (hlock->read)\n\t\tlock_time_inc(&stats->read_holdtime, holdtime);\n\telse\n\t\tlock_time_inc(&stats->write_holdtime, holdtime);\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [
      "#define lock_stat 0"
    ],
    "globals_used": [
      "static int __lock_is_held(const struct lockdep_map *lock, int read);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_time_inc",
          "args": [
            "&stats->write_holdtime",
            "holdtime"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "lock_time_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "179-189",
          "snippet": "static void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_stats",
          "args": [
            "hlock_class(hlock)"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "249-252",
          "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlock_class",
          "args": [
            "hlock"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "hlock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "143-153",
          "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockstat_clock",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "lockstat_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "158-161",
          "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#define lock_stat 0\n\nstatic int __lock_is_held(const struct lockdep_map *lock, int read);\n\nstatic void lock_release_holdtime(struct held_lock *hlock)\n{\n\tstruct lock_class_stats *stats;\n\tu64 holdtime;\n\n\tif (!lock_stat)\n\t\treturn;\n\n\tholdtime = lockstat_clock() - hlock->holdtime_stamp;\n\n\tstats = get_lock_stats(hlock_class(hlock));\n\tif (hlock->read)\n\t\tlock_time_inc(&stats->read_holdtime, holdtime);\n\telse\n\t\tlock_time_inc(&stats->write_holdtime, holdtime);\n}"
  },
  {
    "function_name": "get_lock_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "249-252",
    "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "cpu_lock_stats"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
  },
  {
    "function_name": "clear_lock_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "235-247",
    "snippet": "void clear_lock_stats(struct lock_class *class)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *cpu_stats =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tmemset(cpu_stats, 0, sizeof(struct lock_class_stats));\n\t}\n\tmemset(class->contention_point, 0, sizeof(class->contention_point));\n\tmemset(class->contending_point, 0, sizeof(class->contending_point));\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "class->contending_point",
            "0",
            "sizeof(class->contending_point)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "class->contention_point",
            "0",
            "sizeof(class->contention_point)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cpu_stats",
            "0",
            "sizeof(struct lock_class_stats)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_lock_stats",
            "cpu"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nvoid clear_lock_stats(struct lock_class *class)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *cpu_stats =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tmemset(cpu_stats, 0, sizeof(struct lock_class_stats));\n\t}\n\tmemset(class->contention_point, 0, sizeof(class->contention_point));\n\tmemset(class->contending_point, 0, sizeof(class->contending_point));\n}"
  },
  {
    "function_name": "lock_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "206-233",
    "snippet": "struct lock_class_stats lock_stats(struct lock_class *class)\n{\n\tstruct lock_class_stats stats;\n\tint cpu, i;\n\n\tmemset(&stats, 0, sizeof(struct lock_class_stats));\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *pcs =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.contention_point); i++)\n\t\t\tstats.contention_point[i] += pcs->contention_point[i];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.contending_point); i++)\n\t\t\tstats.contending_point[i] += pcs->contending_point[i];\n\n\t\tlock_time_add(&pcs->read_waittime, &stats.read_waittime);\n\t\tlock_time_add(&pcs->write_waittime, &stats.write_waittime);\n\n\t\tlock_time_add(&pcs->read_holdtime, &stats.read_holdtime);\n\t\tlock_time_add(&pcs->write_holdtime, &stats.write_holdtime);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.bounces); i++)\n\t\t\tstats.bounces[i] += pcs->bounces[i];\n\t}\n\n\treturn stats;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stats.bounces"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_time_add",
          "args": [
            "&pcs->write_holdtime",
            "&stats.write_holdtime"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "lock_time_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "191-204",
          "snippet": "static inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\n{\n\tif (!src->nr)\n\t\treturn;\n\n\tif (src->max > dst->max)\n\t\tdst->max = src->max;\n\n\tif (src->min < dst->min || !dst->nr)\n\t\tdst->min = src->min;\n\n\tdst->total += src->total;\n\tdst->nr += src->nr;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\n{\n\tif (!src->nr)\n\t\treturn;\n\n\tif (src->max > dst->max)\n\t\tdst->max = src->max;\n\n\tif (src->min < dst->min || !dst->nr)\n\t\tdst->min = src->min;\n\n\tdst->total += src->total;\n\tdst->nr += src->nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stats.contending_point"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stats.contention_point"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_lock_stats",
            "cpu"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&stats",
            "0",
            "sizeof(struct lock_class_stats)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstruct lock_class_stats lock_stats(struct lock_class *class)\n{\n\tstruct lock_class_stats stats;\n\tint cpu, i;\n\n\tmemset(&stats, 0, sizeof(struct lock_class_stats));\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *pcs =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.contention_point); i++)\n\t\t\tstats.contention_point[i] += pcs->contention_point[i];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.contending_point); i++)\n\t\t\tstats.contending_point[i] += pcs->contending_point[i];\n\n\t\tlock_time_add(&pcs->read_waittime, &stats.read_waittime);\n\t\tlock_time_add(&pcs->write_waittime, &stats.write_waittime);\n\n\t\tlock_time_add(&pcs->read_holdtime, &stats.read_holdtime);\n\t\tlock_time_add(&pcs->write_holdtime, &stats.write_holdtime);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stats.bounces); i++)\n\t\t\tstats.bounces[i] += pcs->bounces[i];\n\t}\n\n\treturn stats;\n}"
  },
  {
    "function_name": "lock_time_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "191-204",
    "snippet": "static inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\n{\n\tif (!src->nr)\n\t\treturn;\n\n\tif (src->max > dst->max)\n\t\tdst->max = src->max;\n\n\tif (src->min < dst->min || !dst->nr)\n\t\tdst->min = src->min;\n\n\tdst->total += src->total;\n\tdst->nr += src->nr;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\n{\n\tif (!src->nr)\n\t\treturn;\n\n\tif (src->max > dst->max)\n\t\tdst->max = src->max;\n\n\tif (src->min < dst->min || !dst->nr)\n\t\tdst->min = src->min;\n\n\tdst->total += src->total;\n\tdst->nr += src->nr;\n}"
  },
  {
    "function_name": "lock_time_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "179-189",
    "snippet": "static void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time > lt->max)\n\t\tlt->max = time;\n\n\tif (time < lt->min || !lt->nr)\n\t\tlt->min = time;\n\n\tlt->total += time;\n\tlt->nr++;\n}"
  },
  {
    "function_name": "lock_point",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "163-177",
    "snippet": "static int lock_point(unsigned long points[], unsigned long ip)\n{\n\tint i;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic int lock_point(unsigned long points[], unsigned long ip)\n{\n\tint i;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}"
  },
  {
    "function_name": "lockstat_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "158-161",
    "snippet": "static inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline u64 lockstat_clock(void)\n{\n\treturn local_clock();\n}"
  },
  {
    "function_name": "hlock_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "143-153",
    "snippet": "static inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "1"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\n\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\n{\n\tif (!hlock->class_idx) {\n\t\t/*\n\t\t * Someone passed in garbage, we give up.\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn lock_classes + hlock->class_idx - 1;\n}"
  },
  {
    "function_name": "debug_locks_off_graph_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "122-129",
    "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&lockdep_lock"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "graph_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "103-116",
    "snippet": "static inline int graph_unlock(void)\n{\n\tif (debug_locks && !arch_spin_is_locked(&lockdep_lock)) {\n\t\t/*\n\t\t * The lockdep graph lock isn't locked while we expect it to\n\t\t * be, we're confused now, bye!\n\t\t */\n\t\treturn DEBUG_LOCKS_WARN_ON(1);\n\t}\n\n\tcurrent->lockdep_recursion--;\n\tarch_spin_unlock(&lockdep_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&lockdep_lock"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "1"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_is_locked",
          "args": [
            "&lockdep_lock"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int graph_unlock(void)\n{\n\tif (debug_locks && !arch_spin_is_locked(&lockdep_lock)) {\n\t\t/*\n\t\t * The lockdep graph lock isn't locked while we expect it to\n\t\t * be, we're confused now, bye!\n\t\t */\n\t\treturn DEBUG_LOCKS_WARN_ON(1);\n\t}\n\n\tcurrent->lockdep_recursion--;\n\tarch_spin_unlock(&lockdep_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "graph_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
    "lines": "85-101",
    "snippet": "static int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}",
    "includes": [
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include \"lockdep_states.h\"",
      "#include <trace/events/lock.h>",
      "#include \"lockdep_internals.h\"",
      "#include <asm/sections.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jhash.h>",
      "#include <linux/random.h>",
      "#include <linux/gfp.h>",
      "#include <linux/bitops.h>",
      "#include <linux/stringify.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/hash.h>",
      "#include <linux/utsname.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&lockdep_lock"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&lockdep_lock"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic int graph_lock(void)\n{\n\tarch_spin_lock(&lockdep_lock);\n\t/*\n\t * Make sure that if another CPU detected a bug while\n\t * walking the graph we dont change it (while the other\n\t * CPU is busy printing out stuff with the graph lock\n\t * dropped already)\n\t */\n\tif (!debug_locks) {\n\t\tarch_spin_unlock(&lockdep_lock);\n\t\treturn 0;\n\t}\n\t/* prevent any recursions within lockdep from causing deadlocks */\n\tcurrent->lockdep_recursion++;\n\treturn 1;\n}"
  }
]