[
  {
    "function_name": "seccomp_sysctl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1329-1340",
    "snippet": "static int __init seccomp_sysctl_init(void)\n{\n\tstruct ctl_table_header *hdr;\n\n\thdr = register_sysctl_paths(seccomp_sysctl_path, seccomp_sysctl_table);\n\tif (!hdr)\n\t\tpr_warn(\"seccomp: sysctl registration failed\\n\");\n\telse\n\t\tkmemleak_not_leak(hdr);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_not_leak",
          "args": [
            "hdr"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"seccomp: sysctl registration failed\\n\""
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_sysctl_paths",
          "args": [
            "seccomp_sysctl_path",
            "seccomp_sysctl_table"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int __init seccomp_sysctl_init(void)\n{\n\tstruct ctl_table_header *hdr;\n\n\thdr = register_sysctl_paths(seccomp_sysctl_path, seccomp_sysctl_table);\n\tif (!hdr)\n\t\tpr_warn(\"seccomp: sysctl registration failed\\n\");\n\telse\n\t\tkmemleak_not_leak(hdr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_actions_logged_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1288-1305",
    "snippet": "static int seccomp_actions_logged_handler(struct ctl_table *ro_table, int write,\n\t\t\t\t\t  void __user *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tint ret;\n\n\tif (write) {\n\t\tu32 actions_logged = 0;\n\t\tu32 old_actions_logged = seccomp_actions_logged;\n\n\t\tret = write_actions_logged(ro_table, buffer, lenp, ppos,\n\t\t\t\t\t   &actions_logged);\n\t\taudit_actions_logged(actions_logged, old_actions_logged, ret);\n\t} else\n\t\tret = read_actions_logged(ro_table, buffer, lenp, ppos);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_actions_logged",
          "args": [
            "ro_table",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "read_actions_logged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1209-1225",
          "snippet": "static int read_actions_logged(struct ctl_table *ro_table, void __user *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int read_actions_logged(struct ctl_table *ro_table, void __user *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_actions_logged",
          "args": [
            "actions_logged",
            "old_actions_logged",
            "ret"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "audit_actions_logged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1256-1286",
          "snippet": "static void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_actions_logged",
          "args": [
            "ro_table",
            "buffer",
            "lenp",
            "ppos",
            "&actions_logged"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "write_actions_logged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1227-1254",
          "snippet": "static int write_actions_logged(struct ctl_table *ro_table, void __user *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [
            "#define SECCOMP_LOG_ALLOW\t\t(1 << 6)"
          ],
          "globals_used": [
            "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_ALLOW\t\t(1 << 6)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int write_actions_logged(struct ctl_table *ro_table, void __user *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int seccomp_actions_logged_handler(struct ctl_table *ro_table, int write,\n\t\t\t\t\t  void __user *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tint ret;\n\n\tif (write) {\n\t\tu32 actions_logged = 0;\n\t\tu32 old_actions_logged = seccomp_actions_logged;\n\n\t\tret = write_actions_logged(ro_table, buffer, lenp, ppos,\n\t\t\t\t\t   &actions_logged);\n\t\taudit_actions_logged(actions_logged, old_actions_logged, ret);\n\t} else\n\t\tret = read_actions_logged(ro_table, buffer, lenp, ppos);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_actions_logged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1256-1286",
    "snippet": "static void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_seccomp_actions_logged",
          "args": [
            "new",
            "old",
            "!ret"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "audit_seccomp_actions_logged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2503-2521",
          "snippet": "void audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab, \"op=seccomp-logging\");\n\taudit_log_format(ab, \" actions=%s\", names);\n\taudit_log_format(ab, \" old-actions=%s\", old_names);\n\taudit_log_format(ab, \" res=%d\", res);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab, \"op=seccomp-logging\");\n\taudit_log_format(ab, \" actions=%s\", names);\n\taudit_log_format(ab, \" old-actions=%s\", old_names);\n\taudit_log_format(ab, \" res=%d\", res);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_names_from_actions_logged",
          "args": [
            "old_names",
            "sizeof(old_names)",
            "old_actions_logged",
            "\",\""
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_names_from_actions_logged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1143-1175",
          "snippet": "static bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "old_names",
            "0",
            "sizeof(old_names)"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "names",
            "0",
            "sizeof(names)"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}"
  },
  {
    "function_name": "write_actions_logged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1227-1254",
    "snippet": "static int write_actions_logged(struct ctl_table *ro_table, void __user *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [
      "#define SECCOMP_LOG_ALLOW\t\t(1 << 6)"
    ],
    "globals_used": [
      "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_actions_logged_from_names",
          "args": [
            "actions_logged",
            "table.data"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_actions_logged_from_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1192-1207",
          "snippet": "static bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dostring",
          "args": [
            "&table",
            "1",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dostring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3182-3186",
          "snippet": "int proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "names",
            "0",
            "sizeof(names)"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_ALLOW\t\t(1 << 6)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int write_actions_logged(struct ctl_table *ro_table, void __user *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}"
  },
  {
    "function_name": "read_actions_logged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1209-1225",
    "snippet": "static int read_actions_logged(struct ctl_table *ro_table, void __user *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dostring",
          "args": [
            "&table",
            "0",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dostring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3182-3186",
          "snippet": "int proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_names_from_actions_logged",
          "args": [
            "names",
            "sizeof(names)",
            "seccomp_actions_logged",
            "\" \""
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_names_from_actions_logged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1143-1175",
          "snippet": "static bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "names",
            "0",
            "sizeof(names)"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int read_actions_logged(struct ctl_table *ro_table, void __user *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "seccomp_actions_logged_from_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1192-1207",
    "snippet": "static bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_action_logged_from_name",
          "args": [
            "&action_logged",
            "name"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_action_logged_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1177-1190",
          "snippet": "static bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&names",
            "\" \""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "seccomp_action_logged_from_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1177-1190",
    "snippet": "static bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cur->name",
            "name"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "seccomp_names_from_actions_logged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1143-1175",
    "snippet": "static bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "names",
            "cur->name",
            "size"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "names",
            "sep",
            "size"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "seccomp_get_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1071-1104",
    "snippet": "long seccomp_get_metadata(struct task_struct *task,\n\t\t\t  unsigned long size, void __user *data)\n{\n\tlong ret;\n\tstruct seccomp_filter *filter;\n\tstruct seccomp_metadata kmd = {};\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tsize = min_t(unsigned long, size, sizeof(kmd));\n\n\tif (size < sizeof(kmd.filter_off))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))\n\t\treturn -EFAULT;\n\n\tfilter = get_nth_filter(task, kmd.filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tif (filter->log)\n\t\tkmd.flags |= SECCOMP_FILTER_FLAG_LOG;\n\n\tret = size;\n\tif (copy_to_user(data, &kmd, size))\n\t\tret = -EFAULT;\n\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "filter"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "509-517",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "data",
            "&kmd",
            "size"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filter"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filter"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nth_filter",
          "args": [
            "task",
            "kmd.filter_off"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "get_nth_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "987-1031",
          "snippet": "static struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&kmd.filter_off",
            "data",
            "sizeof(kmd.filter_off)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "size",
            "sizeof(kmd)"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong seccomp_get_metadata(struct task_struct *task,\n\t\t\t  unsigned long size, void __user *data)\n{\n\tlong ret;\n\tstruct seccomp_filter *filter;\n\tstruct seccomp_metadata kmd = {};\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tsize = min_t(unsigned long, size, sizeof(kmd));\n\n\tif (size < sizeof(kmd.filter_off))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))\n\t\treturn -EFAULT;\n\n\tfilter = get_nth_filter(task, kmd.filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tif (filter->log)\n\t\tkmd.flags |= SECCOMP_FILTER_FLAG_LOG;\n\n\tret = size;\n\tif (copy_to_user(data, &kmd, size))\n\t\tret = -EFAULT;\n\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_get_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "1033-1069",
    "snippet": "long seccomp_get_filter(struct task_struct *task, unsigned long filter_off,\n\t\t\tvoid __user *data)\n{\n\tstruct seccomp_filter *filter;\n\tstruct sock_fprog_kern *fprog;\n\tlong ret;\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tfilter = get_nth_filter(task, filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tfprog = filter->prog->orig_prog;\n\tif (!fprog) {\n\t\t/* This must be a new non-cBPF filter, since we save\n\t\t * every cBPF filter's orig_prog above when\n\t\t * CONFIG_CHECKPOINT_RESTORE is enabled.\n\t\t */\n\t\tret = -EMEDIUMTYPE;\n\t\tgoto out;\n\t}\n\n\tret = fprog->len;\n\tif (!data)\n\t\tgoto out;\n\n\tif (copy_to_user(data, fprog->filter, bpf_classic_proglen(fprog)))\n\t\tret = -EFAULT;\n\nout:\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "filter"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "509-517",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "data",
            "fprog->filter",
            "bpf_classic_proglen(fprog)"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_classic_proglen",
          "args": [
            "fprog"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filter"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filter"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nth_filter",
          "args": [
            "task",
            "filter_off"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "get_nth_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "987-1031",
          "snippet": "static struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong seccomp_get_filter(struct task_struct *task, unsigned long filter_off,\n\t\t\tvoid __user *data)\n{\n\tstruct seccomp_filter *filter;\n\tstruct sock_fprog_kern *fprog;\n\tlong ret;\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tfilter = get_nth_filter(task, filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tfprog = filter->prog->orig_prog;\n\tif (!fprog) {\n\t\t/* This must be a new non-cBPF filter, since we save\n\t\t * every cBPF filter's orig_prog above when\n\t\t * CONFIG_CHECKPOINT_RESTORE is enabled.\n\t\t */\n\t\tret = -EMEDIUMTYPE;\n\t\tgoto out;\n\t}\n\n\tret = fprog->len;\n\tif (!data)\n\t\tgoto out;\n\n\tif (copy_to_user(data, fprog->filter, bpf_classic_proglen(fprog)))\n\t\tret = -EFAULT;\n\nout:\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_nth_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "987-1031",
    "snippet": "static struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "orig"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "509-517",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_seccomp_filter",
          "args": [
            "filter"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "__get_seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "486-490",
          "snippet": "static void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\t/* Reference count is bounded by the number of total processes. */\n\trefcount_inc(&filter->usage);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\t/* Reference count is bounded by the number of total processes. */\n\trefcount_inc(&filter->usage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "count != 1 || !filter"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}"
  },
  {
    "function_name": "prctl_set_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "959-984",
    "snippet": "long prctl_set_seccomp(unsigned long seccomp_mode, char __user *filter)\n{\n\tunsigned int op;\n\tchar __user *uargs;\n\n\tswitch (seccomp_mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\top = SECCOMP_SET_MODE_STRICT;\n\t\t/*\n\t\t * Setting strict mode through prctl always ignored filter,\n\t\t * so make sure it is always NULL here to pass the internal\n\t\t * check in do_seccomp().\n\t\t */\n\t\tuargs = NULL;\n\t\tbreak;\n\tcase SECCOMP_MODE_FILTER:\n\t\top = SECCOMP_SET_MODE_FILTER;\n\t\tuargs = filter;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* prctl interface doesn't have flags, so they are always zero. */\n\treturn do_seccomp(op, 0, uargs);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_seccomp",
          "args": [
            "op",
            "0",
            "uargs"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "do_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "926-944",
          "snippet": "static long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       const char __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       const char __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong prctl_set_seccomp(unsigned long seccomp_mode, char __user *filter)\n{\n\tunsigned int op;\n\tchar __user *uargs;\n\n\tswitch (seccomp_mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\top = SECCOMP_SET_MODE_STRICT;\n\t\t/*\n\t\t * Setting strict mode through prctl always ignored filter,\n\t\t * so make sure it is always NULL here to pass the internal\n\t\t * check in do_seccomp().\n\t\t */\n\t\tuargs = NULL;\n\t\tbreak;\n\tcase SECCOMP_MODE_FILTER:\n\t\top = SECCOMP_SET_MODE_FILTER;\n\t\tuargs = filter;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* prctl interface doesn't have flags, so they are always zero. */\n\treturn do_seccomp(op, 0, uargs);\n}"
  },
  {
    "function_name": "do_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "926-944",
    "snippet": "static long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       const char __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_get_action_avail",
          "args": [
            "uargs"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_get_action_avail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "902-923",
          "snippet": "static long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_set_mode_filter",
          "args": [
            "flags",
            "uargs"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_set_mode_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "895-899",
          "snippet": "static inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_set_mode_strict",
          "args": [],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_set_mode_strict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "814-834",
          "snippet": "static long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       const char __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "seccomp_get_action_avail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "902-923",
    "snippet": "static long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&action",
            "uaction",
            "sizeof(action)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_set_mode_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "895-899",
    "snippet": "static inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "seccomp_set_mode_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "850-893",
    "snippet": "static long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t    const char __user *filter)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_FILTER;\n\tstruct seccomp_filter *prepared = NULL;\n\tlong ret = -EINVAL;\n\n\t/* Validate flags. */\n\tif (flags & ~SECCOMP_FILTER_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/* Prepare the new filter before holding any locks. */\n\tprepared = seccomp_prepare_user_filter(filter);\n\tif (IS_ERR(prepared))\n\t\treturn PTR_ERR(prepared);\n\n\t/*\n\t * Make sure we cannot change seccomp or nnp state via TSYNC\n\t * while another thread is in the middle of calling exec.\n\t */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC &&\n\t    mutex_lock_killable(&current->signal->cred_guard_mutex))\n\t\tgoto out_free;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n\tret = seccomp_attach_filter(flags, prepared);\n\tif (ret)\n\t\tgoto out;\n\t/* Do not free the successfully attached filter. */\n\tprepared = NULL;\n\n\tseccomp_assign_mode(current, seccomp_mode, flags);\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\nout_free:\n\tseccomp_filter_free(prepared);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_filter_free",
          "args": [
            "prepared"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "501-507",
          "snippet": "static inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_assign_mode",
          "args": [
            "current",
            "seccomp_mode",
            "flags"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_assign_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "234-250",
          "snippet": "static inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure TIF_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_tsk_thread_flag(task, TIF_SECCOMP);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure TIF_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_tsk_thread_flag(task, TIF_SECCOMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_attach_filter",
          "args": [
            "flags",
            "prepared"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_attach_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "444-484",
          "snippet": "static long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate resulting filter length. */\n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */\n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t/* If thread sync has been requested, check that it is possible. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set log flag, if present. */\n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t/*\n\t * If there is an existing filter, make it the prev and don't drop its\n\t * task reference.\n\t */\n\tfilter->prev = current->seccomp.filter;\n\tcurrent->seccomp.filter = filter;\n\n\t/* Now that the new filter is in place, synchronize to all threads. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [
            "#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))\n\nstatic long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate resulting filter length. */\n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */\n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t/* If thread sync has been requested, check that it is possible. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set log flag, if present. */\n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t/*\n\t * If there is an existing filter, make it the prev and don't drop its\n\t * task reference.\n\t */\n\tfilter->prev = current->seccomp.filter;\n\tcurrent->seccomp.filter = filter;\n\n\t/* Now that the new filter is in place, synchronize to all threads. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_may_assign_mode",
          "args": [
            "seccomp_mode"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_may_assign_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "222-230",
          "snippet": "static inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "__mutex_lock_killable_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1336-1340",
          "snippet": "__sched\n__mutex_lock_killable_slowpath(struct mutex *lock)\n{\n\treturn __mutex_lock(lock, TASK_KILLABLE, 0, NULL, _RET_IP_);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__mutex_lock_killable_slowpath(struct mutex *lock)\n{\n\treturn __mutex_lock(lock, TASK_KILLABLE, 0, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prepared"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prepared"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_prepare_user_filter",
          "args": [
            "filter"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_prepare_user_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "413-433",
          "snippet": "static struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else /* falls through to the if below. */\n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else /* falls through to the if below. */\n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t    const char __user *filter)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_FILTER;\n\tstruct seccomp_filter *prepared = NULL;\n\tlong ret = -EINVAL;\n\n\t/* Validate flags. */\n\tif (flags & ~SECCOMP_FILTER_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/* Prepare the new filter before holding any locks. */\n\tprepared = seccomp_prepare_user_filter(filter);\n\tif (IS_ERR(prepared))\n\t\treturn PTR_ERR(prepared);\n\n\t/*\n\t * Make sure we cannot change seccomp or nnp state via TSYNC\n\t * while another thread is in the middle of calling exec.\n\t */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC &&\n\t    mutex_lock_killable(&current->signal->cred_guard_mutex))\n\t\tgoto out_free;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n\tret = seccomp_attach_filter(flags, prepared);\n\tif (ret)\n\t\tgoto out;\n\t/* Do not free the successfully attached filter. */\n\tprepared = NULL;\n\n\tseccomp_assign_mode(current, seccomp_mode, flags);\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\nout_free:\n\tseccomp_filter_free(prepared);\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_set_mode_strict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "814-834",
    "snippet": "static long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_assign_mode",
          "args": [
            "current",
            "seccomp_mode",
            "0"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_assign_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "234-250",
          "snippet": "static inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure TIF_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_tsk_thread_flag(task, TIF_SECCOMP);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure TIF_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_tsk_thread_flag(task, TIF_SECCOMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_TSC",
          "args": [],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_may_assign_mode",
          "args": [
            "seccomp_mode"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_may_assign_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "222-230",
          "snippet": "static inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "prctl_get_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "802-805",
    "snippet": "long prctl_get_seccomp(void)\n{\n\treturn current->seccomp.mode;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong prctl_get_seccomp(void)\n{\n\treturn current->seccomp.mode;\n}"
  },
  {
    "function_name": "__secure_computing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "778-799",
    "snippet": "int __secure_computing(const struct seccomp_data *sd)\n{\n\tint mode = current->seccomp.mode;\n\tint this_syscall;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn 0;\n\n\tthis_syscall = sd ? sd->nr :\n\t\tsyscall_get_nr(current, task_pt_regs(current));\n\n\tswitch (mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */\n\t\treturn 0;\n\tcase SECCOMP_MODE_FILTER:\n\t\treturn __seccomp_filter(this_syscall, sd, false);\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__seccomp_filter",
          "args": [
            "this_syscall",
            "sd",
            "false"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "__seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "771-775",
          "snippet": "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__secure_computing_strict",
          "args": [
            "this_syscall"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "__secure_computing_strict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "617-634",
          "snippet": "static void __secure_computing_strict(int this_syscall)\n{\n\tconst int *syscall_whitelist = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tsyscall_whitelist = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*syscall_whitelist == this_syscall)\n\t\t\treturn;\n\t} while (*++syscall_whitelist);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t0, /* null terminated */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t0, /* null terminated */\n};\n\nstatic void __secure_computing_strict(int this_syscall)\n{\n\tconst int *syscall_whitelist = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tsyscall_whitelist = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*syscall_whitelist == this_syscall)\n\t\t\treturn;\n\t} while (*++syscall_whitelist);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "current",
            "task_pt_regs(current)"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "current"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->ptrace & PT_SUSPEND_SECCOMP"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CHECKPOINT_RESTORE"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nint __secure_computing(const struct seccomp_data *sd)\n{\n\tint mode = current->seccomp.mode;\n\tint this_syscall;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn 0;\n\n\tthis_syscall = sd ? sd->nr :\n\t\tsyscall_get_nr(current, task_pt_regs(current));\n\n\tswitch (mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */\n\t\treturn 0;\n\tcase SECCOMP_MODE_FILTER:\n\t\treturn __seccomp_filter(this_syscall, sd, false);\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "__seccomp_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "771-775",
    "snippet": "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n}"
  },
  {
    "function_name": "__seccomp_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "655-769",
    "snippet": "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tu32 filter_ret, action;\n\tstruct seccomp_filter *match = NULL;\n\tint data;\n\n\t/*\n\t * Make sure that any changes to mode from another thread have\n\t * been seen after TIF_SECCOMP was seen.\n\t */\n\trmb();\n\n\tfilter_ret = seccomp_run_filters(sd, &match);\n\tdata = filter_ret & SECCOMP_RET_DATA;\n\taction = filter_ret & SECCOMP_RET_ACTION_FULL;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ERRNO:\n\t\t/* Set low-order bits as an errno, capped at MAX_ERRNO. */\n\t\tif (data > MAX_ERRNO)\n\t\t\tdata = MAX_ERRNO;\n\t\tsyscall_set_return_value(current, task_pt_regs(current),\n\t\t\t\t\t -data, 0);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRAP:\n\t\t/* Show the handler the original registers. */\n\t\tsyscall_rollback(current, task_pt_regs(current));\n\t\t/* Let the filter pass back 16 bits of data. */\n\t\tseccomp_send_sigsys(this_syscall, data);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRACE:\n\t\t/* We've been put in this state by the ptracer already. */\n\t\tif (recheck_after_trace)\n\t\t\treturn 0;\n\n\t\t/* ENOSYS these calls if there is no tracer attached. */\n\t\tif (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {\n\t\t\tsyscall_set_return_value(current,\n\t\t\t\t\t\t task_pt_regs(current),\n\t\t\t\t\t\t -ENOSYS, 0);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Allow the BPF to provide the event message */\n\t\tptrace_event(PTRACE_EVENT_SECCOMP, data);\n\t\t/*\n\t\t * The delivery of a fatal signal during event\n\t\t * notification may silently skip tracer notification,\n\t\t * which could leave us with a potentially unmodified\n\t\t * syscall that the tracer would have liked to have\n\t\t * changed. Since the process is about to die, we just\n\t\t * force the syscall to be skipped and let the signal\n\t\t * kill the process and correctly handle any tracer exit\n\t\t * notifications.\n\t\t */\n\t\tif (fatal_signal_pending(current))\n\t\t\tgoto skip;\n\t\t/* Check if the tracer forced the syscall to be skipped. */\n\t\tthis_syscall = syscall_get_nr(current, task_pt_regs(current));\n\t\tif (this_syscall < 0)\n\t\t\tgoto skip;\n\n\t\t/*\n\t\t * Recheck the syscall, since it may have changed. This\n\t\t * intentionally uses a NULL struct seccomp_data to force\n\t\t * a reload of all registers. This does not goto skip since\n\t\t * a skip would have already been reported.\n\t\t */\n\t\tif (__seccomp_filter(this_syscall, NULL, true))\n\t\t\treturn -1;\n\n\t\treturn 0;\n\n\tcase SECCOMP_RET_LOG:\n\t\tseccomp_log(this_syscall, 0, action, true);\n\t\treturn 0;\n\n\tcase SECCOMP_RET_ALLOW:\n\t\t/*\n\t\t * Note that the \"match\" filter will always be NULL for\n\t\t * this action since SECCOMP_RET_ALLOW is the starting\n\t\t * state in seccomp_run_filters().\n\t\t */\n\t\treturn 0;\n\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tseccomp_log(this_syscall, SIGSYS, action, true);\n\t\t/* Dump core only if this is the last remaining thread. */\n\t\tif (action == SECCOMP_RET_KILL_PROCESS ||\n\t\t    get_nr_threads(current) == 1) {\n\t\t\tkernel_siginfo_t info;\n\n\t\t\t/* Show the original registers in the dump. */\n\t\t\tsyscall_rollback(current, task_pt_regs(current));\n\t\t\t/* Trigger a manual coredump since do_exit skips it. */\n\t\t\tseccomp_init_siginfo(&info, this_syscall, data);\n\t\t\tdo_coredump(&info);\n\t\t}\n\t\tif (action == SECCOMP_RET_KILL_PROCESS)\n\t\t\tdo_group_exit(SIGSYS);\n\t\telse\n\t\t\tdo_exit(SIGSYS);\n\t}\n\n\tunreachable();\n\nskip:\n\tseccomp_log(this_syscall, 0, action, match ? match->log : false);\n\treturn -1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_log",
          "args": [
            "this_syscall",
            "0",
            "action",
            "match ? match->log : false"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "567-605",
          "snippet": "static inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [
            "#define SECCOMP_LOG_LOG\t\t\t(1 << 5)",
            "#define SECCOMP_LOG_TRACE\t\t(1 << 4)",
            "#define SECCOMP_LOG_ERRNO\t\t(1 << 3)",
            "#define SECCOMP_LOG_TRAP\t\t(1 << 2)",
            "#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)",
            "#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)"
          ],
          "globals_used": [
            "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_LOG\t\t\t(1 << 5)\n#define SECCOMP_LOG_TRACE\t\t(1 << 4)\n#define SECCOMP_LOG_ERRNO\t\t(1 << 3)\n#define SECCOMP_LOG_TRAP\t\t(1 << 2)\n#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)\n#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreachable",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "SIGSYS"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "765-925",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_group_exit",
          "args": [
            "SIGSYS"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "do_group_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "946-972",
          "snippet": "void\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tBUG_ON(exit_code & 0x80); /* core dumps don't get here */\n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tBUG_ON(exit_code & 0x80); /* core dumps don't get here */\n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_coredump",
          "args": [
            "&info"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_init_siginfo",
          "args": [
            "&info",
            "this_syscall",
            "data"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_init_siginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "525-534",
          "snippet": "static void seccomp_init_siginfo(kernel_siginfo_t *info, int syscall, int reason)\n{\n\tclear_siginfo(info);\n\tinfo->si_signo = SIGSYS;\n\tinfo->si_code = SYS_SECCOMP;\n\tinfo->si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo->si_errno = reason;\n\tinfo->si_arch = syscall_get_arch();\n\tinfo->si_syscall = syscall;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_init_siginfo(kernel_siginfo_t *info, int syscall, int reason)\n{\n\tclear_siginfo(info);\n\tinfo->si_signo = SIGSYS;\n\tinfo->si_code = SYS_SECCOMP;\n\tinfo->si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo->si_errno = reason;\n\tinfo->si_arch = syscall_get_arch();\n\tinfo->si_syscall = syscall;\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_rollback",
          "args": [
            "current",
            "task_pt_regs(current)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "current"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_threads",
          "args": [
            "current"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__seccomp_filter",
          "args": [
            "this_syscall",
            "NULL",
            "true"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "__seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "771-775",
          "snippet": "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "current",
            "task_pt_regs(current)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "current"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_event",
          "args": [
            "PTRACE_EVENT_SECCOMP",
            "data"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_set_return_value",
          "args": [
            "current",
            "task_pt_regs(current)",
            "-ENOSYS",
            "0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "current"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_event_enabled",
          "args": [
            "current",
            "PTRACE_EVENT_SECCOMP"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_send_sigsys",
          "args": [
            "this_syscall",
            "data"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_send_sigsys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "543-548",
          "snippet": "static void seccomp_send_sigsys(int syscall, int reason)\n{\n\tstruct kernel_siginfo info;\n\tseccomp_init_siginfo(&info, syscall, reason);\n\tforce_sig_info(SIGSYS, &info, current);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_send_sigsys(int syscall, int reason)\n{\n\tstruct kernel_siginfo info;\n\tseccomp_init_siginfo(&info, syscall, reason);\n\tforce_sig_info(SIGSYS, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_rollback",
          "args": [
            "current",
            "task_pt_regs(current)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "current"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_set_return_value",
          "args": [
            "current",
            "task_pt_regs(current)",
            "-data",
            "0"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "current"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_run_filters",
          "args": [
            "sd",
            "&match"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_run_filters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "188-219",
          "snippet": "static u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tstruct seccomp_data sd_local;\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t/* Make sure cross-thread synced filter points somewhere sane. */\n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t/* Ensure unexpected behavior doesn't result in failing open. */\n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (!sd) {\n\t\tpopulate_seccomp_data(&sd_local);\n\t\tsd = &sd_local;\n\t}\n\n\t/*\n\t * All filters in the list are evaluated and the lowest BPF return\n\t * value always takes priority (ignoring the DATA).\n\t */\n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = BPF_PROG_RUN(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tstruct seccomp_data sd_local;\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t/* Make sure cross-thread synced filter points somewhere sane. */\n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t/* Ensure unexpected behavior doesn't result in failing open. */\n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (!sd) {\n\t\tpopulate_seccomp_data(&sd_local);\n\t\tsd = &sd_local;\n\t}\n\n\t/*\n\t * All filters in the list are evaluated and the lowest BPF return\n\t * value always takes priority (ignoring the DATA).\n\t */\n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = BPF_PROG_RUN(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tu32 filter_ret, action;\n\tstruct seccomp_filter *match = NULL;\n\tint data;\n\n\t/*\n\t * Make sure that any changes to mode from another thread have\n\t * been seen after TIF_SECCOMP was seen.\n\t */\n\trmb();\n\n\tfilter_ret = seccomp_run_filters(sd, &match);\n\tdata = filter_ret & SECCOMP_RET_DATA;\n\taction = filter_ret & SECCOMP_RET_ACTION_FULL;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ERRNO:\n\t\t/* Set low-order bits as an errno, capped at MAX_ERRNO. */\n\t\tif (data > MAX_ERRNO)\n\t\t\tdata = MAX_ERRNO;\n\t\tsyscall_set_return_value(current, task_pt_regs(current),\n\t\t\t\t\t -data, 0);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRAP:\n\t\t/* Show the handler the original registers. */\n\t\tsyscall_rollback(current, task_pt_regs(current));\n\t\t/* Let the filter pass back 16 bits of data. */\n\t\tseccomp_send_sigsys(this_syscall, data);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRACE:\n\t\t/* We've been put in this state by the ptracer already. */\n\t\tif (recheck_after_trace)\n\t\t\treturn 0;\n\n\t\t/* ENOSYS these calls if there is no tracer attached. */\n\t\tif (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {\n\t\t\tsyscall_set_return_value(current,\n\t\t\t\t\t\t task_pt_regs(current),\n\t\t\t\t\t\t -ENOSYS, 0);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Allow the BPF to provide the event message */\n\t\tptrace_event(PTRACE_EVENT_SECCOMP, data);\n\t\t/*\n\t\t * The delivery of a fatal signal during event\n\t\t * notification may silently skip tracer notification,\n\t\t * which could leave us with a potentially unmodified\n\t\t * syscall that the tracer would have liked to have\n\t\t * changed. Since the process is about to die, we just\n\t\t * force the syscall to be skipped and let the signal\n\t\t * kill the process and correctly handle any tracer exit\n\t\t * notifications.\n\t\t */\n\t\tif (fatal_signal_pending(current))\n\t\t\tgoto skip;\n\t\t/* Check if the tracer forced the syscall to be skipped. */\n\t\tthis_syscall = syscall_get_nr(current, task_pt_regs(current));\n\t\tif (this_syscall < 0)\n\t\t\tgoto skip;\n\n\t\t/*\n\t\t * Recheck the syscall, since it may have changed. This\n\t\t * intentionally uses a NULL struct seccomp_data to force\n\t\t * a reload of all registers. This does not goto skip since\n\t\t * a skip would have already been reported.\n\t\t */\n\t\tif (__seccomp_filter(this_syscall, NULL, true))\n\t\t\treturn -1;\n\n\t\treturn 0;\n\n\tcase SECCOMP_RET_LOG:\n\t\tseccomp_log(this_syscall, 0, action, true);\n\t\treturn 0;\n\n\tcase SECCOMP_RET_ALLOW:\n\t\t/*\n\t\t * Note that the \"match\" filter will always be NULL for\n\t\t * this action since SECCOMP_RET_ALLOW is the starting\n\t\t * state in seccomp_run_filters().\n\t\t */\n\t\treturn 0;\n\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tseccomp_log(this_syscall, SIGSYS, action, true);\n\t\t/* Dump core only if this is the last remaining thread. */\n\t\tif (action == SECCOMP_RET_KILL_PROCESS ||\n\t\t    get_nr_threads(current) == 1) {\n\t\t\tkernel_siginfo_t info;\n\n\t\t\t/* Show the original registers in the dump. */\n\t\t\tsyscall_rollback(current, task_pt_regs(current));\n\t\t\t/* Trigger a manual coredump since do_exit skips it. */\n\t\t\tseccomp_init_siginfo(&info, this_syscall, data);\n\t\t\tdo_coredump(&info);\n\t\t}\n\t\tif (action == SECCOMP_RET_KILL_PROCESS)\n\t\t\tdo_group_exit(SIGSYS);\n\t\telse\n\t\t\tdo_exit(SIGSYS);\n\t}\n\n\tunreachable();\n\nskip:\n\tseccomp_log(this_syscall, 0, action, match ? match->log : false);\n\treturn -1;\n}"
  },
  {
    "function_name": "secure_computing_strict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "637-651",
    "snippet": "void secure_computing_strict(int this_syscall)\n{\n\tint mode = current->seccomp.mode;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn;\n\n\tif (mode == SECCOMP_MODE_DISABLED)\n\t\treturn;\n\telse if (mode == SECCOMP_MODE_STRICT)\n\t\t__secure_computing_strict(this_syscall);\n\telse\n\t\tBUG();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__secure_computing_strict",
          "args": [
            "this_syscall"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__secure_computing_strict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "617-634",
          "snippet": "static void __secure_computing_strict(int this_syscall)\n{\n\tconst int *syscall_whitelist = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tsyscall_whitelist = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*syscall_whitelist == this_syscall)\n\t\t\treturn;\n\t} while (*++syscall_whitelist);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t0, /* null terminated */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t0, /* null terminated */\n};\n\nstatic void __secure_computing_strict(int this_syscall)\n{\n\tconst int *syscall_whitelist = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tsyscall_whitelist = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*syscall_whitelist == this_syscall)\n\t\t\treturn;\n\t} while (*++syscall_whitelist);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->ptrace & PT_SUSPEND_SECCOMP"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CHECKPOINT_RESTORE"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid secure_computing_strict(int this_syscall)\n{\n\tint mode = current->seccomp.mode;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn;\n\n\tif (mode == SECCOMP_MODE_DISABLED)\n\t\treturn;\n\telse if (mode == SECCOMP_MODE_STRICT)\n\t\t__secure_computing_strict(this_syscall);\n\telse\n\t\tBUG();\n}"
  },
  {
    "function_name": "__secure_computing_strict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "617-634",
    "snippet": "static void __secure_computing_strict(int this_syscall)\n{\n\tconst int *syscall_whitelist = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tsyscall_whitelist = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*syscall_whitelist == this_syscall)\n\t\t\treturn;\n\t} while (*++syscall_whitelist);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t0, /* null terminated */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "SIGKILL"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "765-925",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_log",
          "args": [
            "this_syscall",
            "SIGKILL",
            "SECCOMP_RET_KILL_THREAD",
            "true"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "567-605",
          "snippet": "static inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [
            "#define SECCOMP_LOG_LOG\t\t\t(1 << 5)",
            "#define SECCOMP_LOG_TRACE\t\t(1 << 4)",
            "#define SECCOMP_LOG_ERRNO\t\t(1 << 3)",
            "#define SECCOMP_LOG_TRAP\t\t(1 << 2)",
            "#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)",
            "#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)"
          ],
          "globals_used": [
            "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_LOG\t\t\t(1 << 5)\n#define SECCOMP_LOG_TRACE\t\t(1 << 4)\n#define SECCOMP_LOG_ERRNO\t\t(1 << 3)\n#define SECCOMP_LOG_TRAP\t\t(1 << 2)\n#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)\n#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_compat_mode1_syscalls",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t0, /* null terminated */\n};\n\nstatic void __secure_computing_strict(int this_syscall)\n{\n\tconst int *syscall_whitelist = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tsyscall_whitelist = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*syscall_whitelist == this_syscall)\n\t\t\treturn;\n\t} while (*++syscall_whitelist);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}"
  },
  {
    "function_name": "seccomp_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "567-605",
    "snippet": "static inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [
      "#define SECCOMP_LOG_LOG\t\t\t(1 << 5)",
      "#define SECCOMP_LOG_TRACE\t\t(1 << 4)",
      "#define SECCOMP_LOG_ERRNO\t\t(1 << 3)",
      "#define SECCOMP_LOG_TRAP\t\t(1 << 2)",
      "#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)",
      "#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)"
    ],
    "globals_used": [
      "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_seccomp",
          "args": [
            "syscall",
            "signr",
            "action"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "audit_seccomp_actions_logged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2503-2521",
          "snippet": "void audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab, \"op=seccomp-logging\");\n\taudit_log_format(ab, \" actions=%s\", names);\n\taudit_log_format(ab, \" old-actions=%s\", old_names);\n\taudit_log_format(ab, \" res=%d\", res);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab, \"op=seccomp-logging\");\n\taudit_log_format(ab, \" actions=%s\", names);\n\taudit_log_format(ab, \" old-actions=%s\", old_names);\n\taudit_log_format(ab, \" res=%d\", res);\n\taudit_log_end(ab);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_LOG\t\t\t(1 << 5)\n#define SECCOMP_LOG_TRACE\t\t(1 << 4)\n#define SECCOMP_LOG_ERRNO\t\t(1 << 3)\n#define SECCOMP_LOG_TRAP\t\t(1 << 2)\n#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)\n#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}"
  },
  {
    "function_name": "seccomp_send_sigsys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "543-548",
    "snippet": "static void seccomp_send_sigsys(int syscall, int reason)\n{\n\tstruct kernel_siginfo info;\n\tseccomp_init_siginfo(&info, syscall, reason);\n\tforce_sig_info(SIGSYS, &info, current);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "SIGSYS",
            "&info",
            "current"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1230-1258",
          "snippet": "int\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_init_siginfo",
          "args": [
            "&info",
            "syscall",
            "reason"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_init_siginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "525-534",
          "snippet": "static void seccomp_init_siginfo(kernel_siginfo_t *info, int syscall, int reason)\n{\n\tclear_siginfo(info);\n\tinfo->si_signo = SIGSYS;\n\tinfo->si_code = SYS_SECCOMP;\n\tinfo->si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo->si_errno = reason;\n\tinfo->si_arch = syscall_get_arch();\n\tinfo->si_syscall = syscall;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_init_siginfo(kernel_siginfo_t *info, int syscall, int reason)\n{\n\tclear_siginfo(info);\n\tinfo->si_signo = SIGSYS;\n\tinfo->si_code = SYS_SECCOMP;\n\tinfo->si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo->si_errno = reason;\n\tinfo->si_arch = syscall_get_arch();\n\tinfo->si_syscall = syscall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_send_sigsys(int syscall, int reason)\n{\n\tstruct kernel_siginfo info;\n\tseccomp_init_siginfo(&info, syscall, reason);\n\tforce_sig_info(SIGSYS, &info, current);\n}"
  },
  {
    "function_name": "seccomp_init_siginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "525-534",
    "snippet": "static void seccomp_init_siginfo(kernel_siginfo_t *info, int syscall, int reason)\n{\n\tclear_siginfo(info);\n\tinfo->si_signo = SIGSYS;\n\tinfo->si_code = SYS_SECCOMP;\n\tinfo->si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo->si_errno = reason;\n\tinfo->si_arch = syscall_get_arch();\n\tinfo->si_syscall = syscall;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KSTK_EIP",
          "args": [
            "current"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "info"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_init_siginfo(kernel_siginfo_t *info, int syscall, int reason)\n{\n\tclear_siginfo(info);\n\tinfo->si_signo = SIGSYS;\n\tinfo->si_code = SYS_SECCOMP;\n\tinfo->si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo->si_errno = reason;\n\tinfo->si_arch = syscall_get_arch();\n\tinfo->si_syscall = syscall;\n}"
  },
  {
    "function_name": "put_seccomp_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "520-523",
    "snippet": "void put_seccomp_filter(struct task_struct *tsk)\n{\n\t__put_seccomp_filter(tsk->seccomp.filter);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "tsk->seccomp.filter"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "509-517",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid put_seccomp_filter(struct task_struct *tsk)\n{\n\t__put_seccomp_filter(tsk->seccomp.filter);\n}"
  },
  {
    "function_name": "__put_seccomp_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "509-517",
    "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_filter_free",
          "args": [
            "freeme"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "501-507",
          "snippet": "static inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&orig->usage"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->usage)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
  },
  {
    "function_name": "seccomp_filter_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "501-507",
    "snippet": "static inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_destroy",
          "args": [
            "filter->prog"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}"
  },
  {
    "function_name": "get_seccomp_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "493-499",
    "snippet": "void get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_seccomp_filter",
          "args": [
            "orig"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__get_seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "486-490",
          "snippet": "static void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\t/* Reference count is bounded by the number of total processes. */\n\trefcount_inc(&filter->usage);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\t/* Reference count is bounded by the number of total processes. */\n\trefcount_inc(&filter->usage);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n}"
  },
  {
    "function_name": "__get_seccomp_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "486-490",
    "snippet": "static void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\t/* Reference count is bounded by the number of total processes. */\n\trefcount_inc(&filter->usage);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&filter->usage"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "50-53",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\t/* Reference count is bounded by the number of total processes. */\n\trefcount_inc(&filter->usage);\n}"
  },
  {
    "function_name": "seccomp_attach_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "444-484",
    "snippet": "static long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate resulting filter length. */\n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */\n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t/* If thread sync has been requested, check that it is possible. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set log flag, if present. */\n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t/*\n\t * If there is an existing filter, make it the prev and don't drop its\n\t * task reference.\n\t */\n\tfilter->prev = current->seccomp.filter;\n\tcurrent->seccomp.filter = filter;\n\n\t/* Now that the new filter is in place, synchronize to all threads. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [
      "#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_sync_threads",
          "args": [
            "flags"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_sync_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "316-360",
          "snippet": "static inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Synchronize all threads. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t/* Skip current, since it needs no changes. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t/* Get a task reference for the new leaf node. */\n\t\tget_seccomp_filter(caller);\n\t\t/*\n\t\t * Drop the task reference to the shared ancestor since\n\t\t * current's path will hold a reference.  (This also\n\t\t * allows a put before the assignment.)\n\t\t */\n\t\tput_seccomp_filter(thread);\n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\n\t\t/*\n\t\t * Don't let an unprivileged task work around\n\t\t * the no_new_privs restriction by creating\n\t\t * a thread that sets it up, enters seccomp,\n\t\t * then dies.\n\t\t */\n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t/*\n\t\t * Opt the other thread into seccomp if needed.\n\t\t * As threads are considered to be trust-realm\n\t\t * equivalent (see ptrace_may_access), it is safe to\n\t\t * allow one thread to transition the other.\n\t\t */\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Synchronize all threads. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t/* Skip current, since it needs no changes. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t/* Get a task reference for the new leaf node. */\n\t\tget_seccomp_filter(caller);\n\t\t/*\n\t\t * Drop the task reference to the shared ancestor since\n\t\t * current's path will hold a reference.  (This also\n\t\t * allows a put before the assignment.)\n\t\t */\n\t\tput_seccomp_filter(thread);\n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\n\t\t/*\n\t\t * Don't let an unprivileged task work around\n\t\t * the no_new_privs restriction by creating\n\t\t * a thread that sets it up, enters seccomp,\n\t\t * then dies.\n\t\t */\n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t/*\n\t\t * Opt the other thread into seccomp if needed.\n\t\t * As threads are considered to be trust-realm\n\t\t * equivalent (see ptrace_may_access), it is safe to\n\t\t * allow one thread to transition the other.\n\t\t */\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_can_sync_threads",
          "args": [],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_can_sync_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "275-306",
          "snippet": "static inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate all threads being eligible for synchronization. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t/* Skip current, since it is initiating the sync. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t/* Return the first thread that cannot be synchronized. */\n\t\tfailed = task_pid_vnr(thread);\n\t\t/* If the pid cannot be resolved, then return -ESRCH */\n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate all threads being eligible for synchronization. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t/* Skip current, since it is initiating the sync. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t/* Return the first thread that cannot be synchronized. */\n\t\tfailed = task_pid_vnr(thread);\n\t\t/* If the pid cannot be resolved, then return -ESRCH */\n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))\n\nstatic long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate resulting filter length. */\n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */\n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t/* If thread sync has been requested, check that it is possible. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set log flag, if present. */\n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t/*\n\t * If there is an existing filter, make it the prev and don't drop its\n\t * task reference.\n\t */\n\tfilter->prev = current->seccomp.filter;\n\tcurrent->seccomp.filter = filter;\n\n\t/* Now that the new filter is in place, synchronize to all threads. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_prepare_user_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "413-433",
    "snippet": "static struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else /* falls through to the if below. */\n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_prepare_filter",
          "args": [
            "&fprog"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_prepare_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "368-405",
          "snippet": "static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig = IS_ENABLED(CONFIG_CHECKPOINT_RESTORE);\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t/*\n\t * Installing a seccomp filter requires that the task has\n\t * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.\n\t * This avoids scenarios where unprivileged tasks can affect the\n\t * behavior of privileged children.\n\t */\n\tif (!task_no_new_privs(current) &&\n\t    security_capable_noaudit(current_cred(), current_user_ns(),\n\t\t\t\t     CAP_SYS_ADMIN) != 0)\n\t\treturn ERR_PTR(-EACCES);\n\n\t/* Allocate a new seccomp_filter */\n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->usage, 1);\n\n\treturn sfilter;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig = IS_ENABLED(CONFIG_CHECKPOINT_RESTORE);\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t/*\n\t * Installing a seccomp filter requires that the task has\n\t * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.\n\t * This avoids scenarios where unprivileged tasks can affect the\n\t * behavior of privileged children.\n\t */\n\tif (!task_no_new_privs(current) &&\n\t    security_capable_noaudit(current_cred(), current_user_ns(),\n\t\t\t\t     CAP_SYS_ADMIN) != 0)\n\t\treturn ERR_PTR(-EACCES);\n\n\t/* Allocate a new seccomp_filter */\n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->usage, 1);\n\n\treturn sfilter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&fprog",
            "user_filter",
            "sizeof(fprog)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "fprog32.filter"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&fprog32",
            "user_filter",
            "sizeof(fprog32)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else /* falls through to the if below. */\n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}"
  },
  {
    "function_name": "seccomp_prepare_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "368-405",
    "snippet": "static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig = IS_ENABLED(CONFIG_CHECKPOINT_RESTORE);\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t/*\n\t * Installing a seccomp filter requires that the task has\n\t * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.\n\t * This avoids scenarios where unprivileged tasks can affect the\n\t * behavior of privileged children.\n\t */\n\tif (!task_no_new_privs(current) &&\n\t    security_capable_noaudit(current_cred(), current_user_ns(),\n\t\t\t\t     CAP_SYS_ADMIN) != 0)\n\t\treturn ERR_PTR(-EACCES);\n\n\t/* Allocate a new seccomp_filter */\n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->usage, 1);\n\n\treturn sfilter;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&sfilter->usage",
            "1"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sfilter"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_create_from_user",
          "args": [
            "&sfilter->prog",
            "fprog",
            "seccomp_check_filter",
            "save_orig"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sfilter)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_capable_noaudit",
          "args": [
            "current_cred()",
            "current_user_ns()",
            "CAP_SYS_ADMIN"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "current"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "INT_MAX / fprog->len < sizeof(struct sock_filter)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CHECKPOINT_RESTORE"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig = IS_ENABLED(CONFIG_CHECKPOINT_RESTORE);\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t/*\n\t * Installing a seccomp filter requires that the task has\n\t * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.\n\t * This avoids scenarios where unprivileged tasks can affect the\n\t * behavior of privileged children.\n\t */\n\tif (!task_no_new_privs(current) &&\n\t    security_capable_noaudit(current_cred(), current_user_ns(),\n\t\t\t\t     CAP_SYS_ADMIN) != 0)\n\t\treturn ERR_PTR(-EACCES);\n\n\t/* Allocate a new seccomp_filter */\n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->usage, 1);\n\n\treturn sfilter;\n}"
  },
  {
    "function_name": "seccomp_sync_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "316-360",
    "snippet": "static inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Synchronize all threads. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t/* Skip current, since it needs no changes. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t/* Get a task reference for the new leaf node. */\n\t\tget_seccomp_filter(caller);\n\t\t/*\n\t\t * Drop the task reference to the shared ancestor since\n\t\t * current's path will hold a reference.  (This also\n\t\t * allows a put before the assignment.)\n\t\t */\n\t\tput_seccomp_filter(thread);\n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\n\t\t/*\n\t\t * Don't let an unprivileged task work around\n\t\t * the no_new_privs restriction by creating\n\t\t * a thread that sets it up, enters seccomp,\n\t\t * then dies.\n\t\t */\n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t/*\n\t\t * Opt the other thread into seccomp if needed.\n\t\t * As threads are considered to be trust-realm\n\t\t * equivalent (see ptrace_may_access), it is safe to\n\t\t * allow one thread to transition the other.\n\t\t */\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_assign_mode",
          "args": [
            "thread",
            "SECCOMP_MODE_FILTER",
            "flags"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_assign_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "234-250",
          "snippet": "static inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure TIF_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_tsk_thread_flag(task, TIF_SECCOMP);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure TIF_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_tsk_thread_flag(task, TIF_SECCOMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_set_no_new_privs",
          "args": [
            "thread"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "caller"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&thread->seccomp.filter",
            "caller->seccomp.filter"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_seccomp_filter",
          "args": [
            "thread"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "put_seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "520-523",
          "snippet": "void put_seccomp_filter(struct task_struct *tsk)\n{\n\t__put_seccomp_filter(tsk->seccomp.filter);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid put_seccomp_filter(struct task_struct *tsk)\n{\n\t__put_seccomp_filter(tsk->seccomp.filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seccomp_filter",
          "args": [
            "caller"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "get_seccomp_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "493-499",
          "snippet": "void get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "caller",
            "thread"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&current->signal->cred_guard_mutex)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Synchronize all threads. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t/* Skip current, since it needs no changes. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t/* Get a task reference for the new leaf node. */\n\t\tget_seccomp_filter(caller);\n\t\t/*\n\t\t * Drop the task reference to the shared ancestor since\n\t\t * current's path will hold a reference.  (This also\n\t\t * allows a put before the assignment.)\n\t\t */\n\t\tput_seccomp_filter(thread);\n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\n\t\t/*\n\t\t * Don't let an unprivileged task work around\n\t\t * the no_new_privs restriction by creating\n\t\t * a thread that sets it up, enters seccomp,\n\t\t * then dies.\n\t\t */\n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t/*\n\t\t * Opt the other thread into seccomp if needed.\n\t\t * As threads are considered to be trust-realm\n\t\t * equivalent (see ptrace_may_access), it is safe to\n\t\t * allow one thread to transition the other.\n\t\t */\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}"
  },
  {
    "function_name": "seccomp_can_sync_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "275-306",
    "snippet": "static inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate all threads being eligible for synchronization. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t/* Skip current, since it is initiating the sync. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t/* Return the first thread that cannot be synchronized. */\n\t\tfailed = task_pid_vnr(thread);\n\t\t/* If the pid cannot be resolved, then return -ESRCH */\n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "failed == 0"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "thread"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ancestor",
          "args": [
            "thread->seccomp.filter",
            "caller->seccomp.filter"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "is_ancestor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "254-264",
          "snippet": "static int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t/* NULL is the root ancestor. */\n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t/* NULL is the root ancestor. */\n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "caller",
            "thread"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&current->signal->cred_guard_mutex)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate all threads being eligible for synchronization. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t/* Skip current, since it is initiating the sync. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t/* Return the first thread that cannot be synchronized. */\n\t\tfailed = task_pid_vnr(thread);\n\t\t/* If the pid cannot be resolved, then return -ESRCH */\n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_ancestor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "254-264",
    "snippet": "static int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t/* NULL is the root ancestor. */\n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t/* NULL is the root ancestor. */\n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_assign_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "234-250",
    "snippet": "static inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure TIF_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_tsk_thread_flag(task, TIF_SECCOMP);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SECCOMP"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_seccomp_spec_mitigate",
          "args": [
            "task"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "arch_seccomp_spec_mitigate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "232-232",
          "snippet": "void __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure TIF_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_tsk_thread_flag(task, TIF_SECCOMP);\n}"
  },
  {
    "function_name": "arch_seccomp_spec_mitigate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "232-232",
    "snippet": "void __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }"
  },
  {
    "function_name": "seccomp_may_assign_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "222-230",
    "snippet": "static inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "seccomp_run_filters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "188-219",
    "snippet": "static u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tstruct seccomp_data sd_local;\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t/* Make sure cross-thread synced filter points somewhere sane. */\n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t/* Ensure unexpected behavior doesn't result in failing open. */\n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (!sd) {\n\t\tpopulate_seccomp_data(&sd_local);\n\t\tsd = &sd_local;\n\t}\n\n\t/*\n\t * All filters in the list are evaluated and the lowest BPF return\n\t * value always takes priority (ignoring the DATA).\n\t */\n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = BPF_PROG_RUN(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACTION_ONLY",
          "args": [
            "ret"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACTION_ONLY",
          "args": [
            "cur_ret"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_PROG_RUN",
          "args": [
            "f->prog",
            "sd"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_seccomp_data",
          "args": [
            "&sd_local"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "populate_seccomp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "78-94",
          "snippet": "static void populate_seccomp_data(struct seccomp_data *sd)\n{\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch();\n\tsyscall_get_arguments(task, regs, 0, 6, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void populate_seccomp_data(struct seccomp_data *sd)\n{\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch();\n\tsyscall_get_arguments(task, regs, 0, 6, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "f == NULL"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current->seccomp.filter"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tstruct seccomp_data sd_local;\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t/* Make sure cross-thread synced filter points somewhere sane. */\n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t/* Ensure unexpected behavior doesn't result in failing open. */\n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (!sd) {\n\t\tpopulate_seccomp_data(&sd_local);\n\t\tsd = &sd_local;\n\t}\n\n\t/*\n\t * All filters in the list are evaluated and the lowest BPF return\n\t * value always takes priority (ignoring the DATA).\n\t */\n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = BPF_PROG_RUN(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_check_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "108-176",
    "snippet": "static int seccomp_check_filter(struct sock_filter *filter, unsigned int flen)\n{\n\tint pc;\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->code;\n\t\tu32 k = ftest->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tftest->code = BPF_LDX | BPF_W | BPF_ABS;\n\t\t\t/* 32-bit aligned and not out of bounds. */\n\t\t\tif (k >= sizeof(struct seccomp_data) || k & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\tcase BPF_LD | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LD | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\tcase BPF_LDX | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LDX | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\t/* Explicitly include allowed calls. */\n\t\tcase BPF_RET | BPF_K:\n\t\tcase BPF_RET | BPF_A:\n\t\tcase BPF_ALU | BPF_ADD | BPF_K:\n\t\tcase BPF_ALU | BPF_ADD | BPF_X:\n\t\tcase BPF_ALU | BPF_SUB | BPF_K:\n\t\tcase BPF_ALU | BPF_SUB | BPF_X:\n\t\tcase BPF_ALU | BPF_MUL | BPF_K:\n\t\tcase BPF_ALU | BPF_MUL | BPF_X:\n\t\tcase BPF_ALU | BPF_DIV | BPF_K:\n\t\tcase BPF_ALU | BPF_DIV | BPF_X:\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\tcase BPF_ALU | BPF_AND | BPF_X:\n\t\tcase BPF_ALU | BPF_OR | BPF_K:\n\t\tcase BPF_ALU | BPF_OR | BPF_X:\n\t\tcase BPF_ALU | BPF_XOR | BPF_K:\n\t\tcase BPF_ALU | BPF_XOR | BPF_X:\n\t\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\tcase BPF_ALU | BPF_NEG:\n\t\tcase BPF_LD | BPF_IMM:\n\t\tcase BPF_LDX | BPF_IMM:\n\t\tcase BPF_MISC | BPF_TAX:\n\t\tcase BPF_MISC | BPF_TXA:\n\t\tcase BPF_LD | BPF_MEM:\n\t\tcase BPF_LDX | BPF_MEM:\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\tcase BPF_JMP | BPF_JA:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_X:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_X:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_X:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int seccomp_check_filter(struct sock_filter *filter, unsigned int flen)\n{\n\tint pc;\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->code;\n\t\tu32 k = ftest->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tftest->code = BPF_LDX | BPF_W | BPF_ABS;\n\t\t\t/* 32-bit aligned and not out of bounds. */\n\t\t\tif (k >= sizeof(struct seccomp_data) || k & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\tcase BPF_LD | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LD | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\tcase BPF_LDX | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LDX | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\t/* Explicitly include allowed calls. */\n\t\tcase BPF_RET | BPF_K:\n\t\tcase BPF_RET | BPF_A:\n\t\tcase BPF_ALU | BPF_ADD | BPF_K:\n\t\tcase BPF_ALU | BPF_ADD | BPF_X:\n\t\tcase BPF_ALU | BPF_SUB | BPF_K:\n\t\tcase BPF_ALU | BPF_SUB | BPF_X:\n\t\tcase BPF_ALU | BPF_MUL | BPF_K:\n\t\tcase BPF_ALU | BPF_MUL | BPF_X:\n\t\tcase BPF_ALU | BPF_DIV | BPF_K:\n\t\tcase BPF_ALU | BPF_DIV | BPF_X:\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\tcase BPF_ALU | BPF_AND | BPF_X:\n\t\tcase BPF_ALU | BPF_OR | BPF_K:\n\t\tcase BPF_ALU | BPF_OR | BPF_X:\n\t\tcase BPF_ALU | BPF_XOR | BPF_K:\n\t\tcase BPF_ALU | BPF_XOR | BPF_X:\n\t\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\tcase BPF_ALU | BPF_NEG:\n\t\tcase BPF_LD | BPF_IMM:\n\t\tcase BPF_LDX | BPF_IMM:\n\t\tcase BPF_MISC | BPF_TAX:\n\t\tcase BPF_MISC | BPF_TXA:\n\t\tcase BPF_LD | BPF_MEM:\n\t\tcase BPF_LDX | BPF_MEM:\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\tcase BPF_JMP | BPF_JA:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_X:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_X:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_X:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "populate_seccomp_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "78-94",
    "snippet": "static void populate_seccomp_data(struct seccomp_data *sd)\n{\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch();\n\tsyscall_get_arguments(task, regs, 0, 6, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KSTK_EIP",
          "args": [
            "task"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_arguments",
          "args": [
            "task",
            "regs",
            "0",
            "6",
            "args"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "task",
            "regs"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "task"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void populate_seccomp_data(struct seccomp_data *sd)\n{\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch();\n\tsyscall_get_arguments(task, regs, 0, 6, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}"
  },
  {
    "function_name": "seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
    "lines": "946-950",
    "snippet": "SYSCALL_DEFINE3(seccomp, unsigned int, op, unsigned int, flags,\n\t\t\t const char __user *, uargs)\n{\n\treturn do_seccomp(op, flags, uargs);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/security.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nSYSCALL_DEFINE3(seccomp, unsigned int, op, unsigned int, flags,\n\t\t\t const char __user *, uargs)\n{\n\treturn do_seccomp(op, flags, uargs);\n}"
  }
]