[
  {
    "function_name": "synchronize_rcu_expedited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "822-834",
    "snippet": "void synchronize_rcu_expedited(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* If only one CPU, this is automatically a grace period. */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t_synchronize_rcu_expedited(sync_sched_exp_handler);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_synchronize_rcu_expedited",
          "args": [
            "sync_sched_exp_handler"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "_synchronize_rcu_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "605-644",
          "snippet": "static void _synchronize_rcu_expedited(smp_call_func_t func)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(rcu_scheduler_active == RCU_SCHEDULER_INIT)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(func, s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_func = func;\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void _synchronize_rcu_expedited(smp_call_func_t func)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(rcu_scheduler_active == RCU_SCHEDULER_INIT)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(func, s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_func = func;\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_blocking_is_gp",
          "args": [],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_blocking_is_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "810-819",
          "snippet": "static int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\tret = num_online_cpus() <= 1;\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\tret = num_online_cpus() <= 1;\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map)",
            "\"Illegal synchronize_rcu_expedited() in RCU read-side critical section\""
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_sched_lock_map"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_lock_map"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_bh_lock_map"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nvoid synchronize_rcu_expedited(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* If only one CPU, this is automatically a grace period. */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t_synchronize_rcu_expedited(sync_sched_exp_handler);\n}"
  },
  {
    "function_name": "rcu_blocking_is_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "810-819",
    "snippet": "static int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\tret = num_online_cpus() <= 1;\n\tpreempt_enable();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\tret = num_online_cpus() <= 1;\n\tpreempt_enable();\n\treturn ret;\n}"
  },
  {
    "function_name": "sync_sched_exp_online_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "787-799",
    "snippet": "static void sync_sched_exp_online_cleanup(int cpu)\n{\n\tstruct rcu_data *rdp;\n\tint ret;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask))\n\t\treturn;\n\tret = smp_call_function_single(cpu, sync_sched_exp_handler, NULL, 0);\n\tWARN_ON_ONCE(ret);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "sync_sched_exp_handler",
            "NULL",
            "0"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "11-23",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu)\n{\n\tstruct rcu_data *rdp;\n\tint ret;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask))\n\t\treturn;\n\tret = smp_call_function_single(cpu, sync_sched_exp_handler, NULL, 0);\n\tWARN_ON_ONCE(ret);\n}"
  },
  {
    "function_name": "sync_sched_exp_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "765-784",
    "snippet": "static void sync_sched_exp_handler(void *unused)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask) ||\n\t    __this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\tif (rcu_is_cpu_rrupt_from_idle()) {\n\t\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\t\treturn;\n\t}\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, true);\n\t/* Store .exp before .rcu_urgent_qs. */\n\tsmp_store_release(this_cpu_ptr(&rcu_data.rcu_urgent_qs), true);\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "this_cpu_ptr(&rcu_data.rcu_urgent_qs)",
            "true"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_data.cpu_no_qs.b.exp",
            "true"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "this_cpu_ptr(&rcu_data)"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "261-265",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_cpu_rrupt_from_idle",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_cpu_rrupt_from_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "377-381",
          "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.cpu_no_qs.b.exp"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_sched_exp_handler(void *unused)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask) ||\n\t    __this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\tif (rcu_is_cpu_rrupt_from_idle()) {\n\t\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\t\treturn;\n\t}\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, true);\n\t/* Store .exp before .rcu_urgent_qs. */\n\tsmp_store_release(this_cpu_ptr(&rcu_data.rcu_urgent_qs), true);\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}"
  },
  {
    "function_name": "synchronize_rcu_expedited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "749-759",
    "snippet": "void synchronize_rcu_expedited(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\t_synchronize_rcu_expedited(sync_rcu_exp_handler);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_synchronize_rcu_expedited",
          "args": [
            "sync_rcu_exp_handler"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "_synchronize_rcu_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "605-644",
          "snippet": "static void _synchronize_rcu_expedited(smp_call_func_t func)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(rcu_scheduler_active == RCU_SCHEDULER_INIT)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(func, s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_func = func;\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void _synchronize_rcu_expedited(smp_call_func_t func)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(rcu_scheduler_active == RCU_SCHEDULER_INIT)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(func, s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_func = func;\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map)",
            "\"Illegal synchronize_rcu_expedited() in RCU read-side critical section\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_sched_lock_map"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_lock_map"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_bh_lock_map"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nvoid synchronize_rcu_expedited(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\t_synchronize_rcu_expedited(sync_rcu_exp_handler);\n}"
  },
  {
    "function_name": "sync_sched_exp_online_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "725-727",
    "snippet": "static void sync_sched_exp_online_cleanup(int cpu)\n{\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu)\n{\n}"
  },
  {
    "function_name": "sync_rcu_exp_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "655-722",
    "snippet": "static void sync_rcu_exp_handler(void *unused)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct task_struct *t = current;\n\n\t/*\n\t * First, the common case of not being in an RCU read-side\n\t * critical section.  If also enabled or idle, immediately\n\t * report the quiescent state, otherwise defer.\n\t */\n\tif (!t->rcu_read_lock_nesting) {\n\t\tif (!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK)) ||\n\t\t    rcu_dynticks_curr_cpu_in_eqs()) {\n\t\t\trcu_report_exp_rdp(rdp);\n\t\t} else {\n\t\t\trdp->deferred_qs = true;\n\t\t\tset_tsk_need_resched(t);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Second, the less-common case of being in an RCU read-side\n\t * critical section.  In this case we can count on a future\n\t * rcu_read_unlock().  However, this rcu_read_unlock() might\n\t * execute on some other CPU, but in that case there will be\n\t * a future context switch.  Either way, if the expedited\n\t * grace period is still waiting on this CPU, set ->deferred_qs\n\t * so that the eventual quiescent state will be reported.\n\t * Note that there is a large group of race conditions that\n\t * can have caused this quiescent state to already have been\n\t * reported, so we really do need to check ->expmask.\n\t */\n\tif (t->rcu_read_lock_nesting > 0) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmask & rdp->grpmask)\n\t\t\trdp->deferred_qs = true;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\n\t/*\n\t * The final and least likely case is where the interrupted\n\t * code was just about to or just finished exiting the RCU-preempt\n\t * read-side critical section, and no, we can't tell which.\n\t * So either way, set ->deferred_qs to flag later code that\n\t * a quiescent state is required.\n\t *\n\t * If the CPU is fully enabled (or if some buggy RCU-preempt\n\t * read-side critical section is being used from idle), just\n\t * invoke rcu_preempt_defer_qs() to immediately report the\n\t * quiescent state.  We cannot use rcu_read_unlock_special()\n\t * because we are in an interrupt handler, which will cause that\n\t * function to take an early exit without doing anything.\n\t *\n\t * Otherwise, force a context switch after the CPU enables everything.\n\t */\n\trdp->deferred_qs = true;\n\tif (!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK)) ||\n\t    WARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs())) {\n\t\trcu_preempt_deferred_qs(t);\n\t} else {\n\t\tset_tsk_need_resched(t);\n\t\tset_preempt_need_resched();\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "t"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "t"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1038-1038",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_dynticks_curr_cpu_in_eqs()"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "288-293",
          "snippet": "bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "t"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "rdp"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "261-265",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_rcu_exp_handler(void *unused)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct task_struct *t = current;\n\n\t/*\n\t * First, the common case of not being in an RCU read-side\n\t * critical section.  If also enabled or idle, immediately\n\t * report the quiescent state, otherwise defer.\n\t */\n\tif (!t->rcu_read_lock_nesting) {\n\t\tif (!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK)) ||\n\t\t    rcu_dynticks_curr_cpu_in_eqs()) {\n\t\t\trcu_report_exp_rdp(rdp);\n\t\t} else {\n\t\t\trdp->deferred_qs = true;\n\t\t\tset_tsk_need_resched(t);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Second, the less-common case of being in an RCU read-side\n\t * critical section.  In this case we can count on a future\n\t * rcu_read_unlock().  However, this rcu_read_unlock() might\n\t * execute on some other CPU, but in that case there will be\n\t * a future context switch.  Either way, if the expedited\n\t * grace period is still waiting on this CPU, set ->deferred_qs\n\t * so that the eventual quiescent state will be reported.\n\t * Note that there is a large group of race conditions that\n\t * can have caused this quiescent state to already have been\n\t * reported, so we really do need to check ->expmask.\n\t */\n\tif (t->rcu_read_lock_nesting > 0) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmask & rdp->grpmask)\n\t\t\trdp->deferred_qs = true;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\n\t/*\n\t * The final and least likely case is where the interrupted\n\t * code was just about to or just finished exiting the RCU-preempt\n\t * read-side critical section, and no, we can't tell which.\n\t * So either way, set ->deferred_qs to flag later code that\n\t * a quiescent state is required.\n\t *\n\t * If the CPU is fully enabled (or if some buggy RCU-preempt\n\t * read-side critical section is being used from idle), just\n\t * invoke rcu_preempt_defer_qs() to immediately report the\n\t * quiescent state.  We cannot use rcu_read_unlock_special()\n\t * because we are in an interrupt handler, which will cause that\n\t * function to take an early exit without doing anything.\n\t *\n\t * Otherwise, force a context switch after the CPU enables everything.\n\t */\n\trdp->deferred_qs = true;\n\tif (!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK)) ||\n\t    WARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs())) {\n\t\trcu_preempt_deferred_qs(t);\n\t} else {\n\t\tset_tsk_need_resched(t);\n\t\tset_preempt_need_resched();\n\t}\n}"
  },
  {
    "function_name": "_synchronize_rcu_expedited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "605-644",
    "snippet": "static void _synchronize_rcu_expedited(smp_call_func_t func)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(rcu_scheduler_active == RCU_SCHEDULER_INIT)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(func, s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_func = func;\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.exp_mutex"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "rnp->exp_wq[rcu_seq_ctr(s) & 0x3]",
            "sync_exp_work_done(s)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_exp_work_done",
          "args": [
            "s"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "sync_exp_work_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "268-277",
          "snippet": "static bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\t/* Ensure test happens before caller kfree(). */\n\t\tsmp_mb__before_atomic(); /* ^^^ */\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\t/* Ensure test happens before caller kfree(). */\n\t\tsmp_mb__before_atomic(); /* ^^^ */\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "s"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "raw_smp_processor_id()"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "rcu_gp_wq",
            "&rew.rew_work"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "77-97",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&rew.rew_work",
            "wait_rcu_exp_gp"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_sel_wait_wake",
          "args": [
            "func",
            "s"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_sel_wait_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "581-588",
          "snippet": "static void rcu_exp_sel_wait_wake(smp_call_func_t func, unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus(func);\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_sel_wait_wake(smp_call_func_t func, unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus(func);\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rcu_scheduler_active == RCU_SCHEDULER_INIT"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_funnel_lock",
          "args": [
            "s"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "exp_funnel_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "286-337",
          "snippet": "static bool exp_funnel_lock(unsigned long s)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\t/* Low-contention fastpath. */\n\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s) &&\n\t    (rnp == rnp_root ||\n\t     ULONG_CMP_LT(READ_ONCE(rnp_root->exp_seq_rq), s)) &&\n\t    mutex_trylock(&rcu_state.exp_mutex))\n\t\tgoto fastpath;\n\n\t/*\n\t * Each pass through the following loop works its way up\n\t * the rcu_node tree, returning if others have done the work or\n\t * otherwise falls through to acquire ->exp_mutex.  The mapping\n\t * from CPU to rcu_node structure can be inexact, as it is just\n\t * promoting locality and is not strictly needed for correctness.\n\t */\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tif (sync_exp_work_done(s))\n\t\t\treturn true;\n\n\t\t/* Work not done, either wait here or go up. */\n\t\tspin_lock(&rnp->exp_lock);\n\t\tif (ULONG_CMP_GE(rnp->exp_seq_rq, s)) {\n\n\t\t\t/* Someone else doing GP, so wait for them. */\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t\t  rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t  TPS(\"wait\"));\n\t\t\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t\t\t   sync_exp_work_done(s));\n\t\t\treturn true;\n\t\t}\n\t\trnp->exp_seq_rq = s; /* Followers can wait on us. */\n\t\tspin_unlock(&rnp->exp_lock);\n\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t  rnp->grplo, rnp->grphi, TPS(\"nxtlvl\"));\n\t}\n\tmutex_lock(&rcu_state.exp_mutex);\nfastpath:\n\tif (sync_exp_work_done(s)) {\n\t\tmutex_unlock(&rcu_state.exp_mutex);\n\t\treturn true;\n\t}\n\trcu_exp_gp_seq_start();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"start\"));\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool exp_funnel_lock(unsigned long s)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\t/* Low-contention fastpath. */\n\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s) &&\n\t    (rnp == rnp_root ||\n\t     ULONG_CMP_LT(READ_ONCE(rnp_root->exp_seq_rq), s)) &&\n\t    mutex_trylock(&rcu_state.exp_mutex))\n\t\tgoto fastpath;\n\n\t/*\n\t * Each pass through the following loop works its way up\n\t * the rcu_node tree, returning if others have done the work or\n\t * otherwise falls through to acquire ->exp_mutex.  The mapping\n\t * from CPU to rcu_node structure can be inexact, as it is just\n\t * promoting locality and is not strictly needed for correctness.\n\t */\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tif (sync_exp_work_done(s))\n\t\t\treturn true;\n\n\t\t/* Work not done, either wait here or go up. */\n\t\tspin_lock(&rnp->exp_lock);\n\t\tif (ULONG_CMP_GE(rnp->exp_seq_rq, s)) {\n\n\t\t\t/* Someone else doing GP, so wait for them. */\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t\t  rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t  TPS(\"wait\"));\n\t\t\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t\t\t   sync_exp_work_done(s));\n\t\t\treturn true;\n\t\t}\n\t\trnp->exp_seq_rq = s; /* Followers can wait on us. */\n\t\tspin_unlock(&rnp->exp_lock);\n\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t  rnp->grplo, rnp->grphi, TPS(\"nxtlvl\"));\n\t}\n\tmutex_lock(&rcu_state.exp_mutex);\nfastpath:\n\tif (sync_exp_work_done(s)) {\n\t\tmutex_unlock(&rcu_state.exp_mutex);\n\t\treturn true;\n\t}\n\trcu_exp_gp_seq_start();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"start\"));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_snap",
          "args": [],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "54-62",
          "snippet": "static unsigned long rcu_exp_gp_seq_snap(void)\n{\n\tunsigned long s;\n\n\tsmp_mb(); /* Caller's modifications seen first by other CPUs. */\n\ts = rcu_seq_snap(&rcu_state.expedited_sequence);\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"snap\"));\n\treturn s;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic unsigned long rcu_exp_gp_seq_snap(void)\n{\n\tunsigned long s;\n\n\tsmp_mb(); /* Caller's modifications seen first by other CPUs. */\n\ts = rcu_seq_snap(&rcu_state.expedited_sequence);\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"snap\"));\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_rcu_gp",
          "args": [
            "call_rcu"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_normal",
          "args": [],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "133-137",
          "snippet": "bool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void _synchronize_rcu_expedited(smp_call_func_t func)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(rcu_scheduler_active == RCU_SCHEDULER_INIT)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(func, s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_func = func;\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n}"
  },
  {
    "function_name": "wait_rcu_exp_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "593-599",
    "snippet": "static void wait_rcu_exp_gp(struct work_struct *wp)\n{\n\tstruct rcu_exp_work *rewp;\n\n\trewp = container_of(wp, struct rcu_exp_work, rew_work);\n\trcu_exp_sel_wait_wake(rewp->rew_func, rewp->rew_s);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_exp_sel_wait_wake",
          "args": [
            "rewp->rew_func",
            "rewp->rew_s"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_sel_wait_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "581-588",
          "snippet": "static void rcu_exp_sel_wait_wake(smp_call_func_t func, unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus(func);\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_sel_wait_wake(smp_call_func_t func, unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus(func);\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wp",
            "structrcu_exp_work",
            "rew_work"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void wait_rcu_exp_gp(struct work_struct *wp)\n{\n\tstruct rcu_exp_work *rewp;\n\n\trewp = container_of(wp, struct rcu_exp_work, rew_work);\n\trcu_exp_sel_wait_wake(rewp->rew_func, rewp->rew_s);\n}"
  },
  {
    "function_name": "rcu_exp_sel_wait_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "581-588",
    "snippet": "static void rcu_exp_sel_wait_wake(smp_call_func_t func, unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus(func);\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_exp_wait_wake",
          "args": [
            "s"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_wait_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "548-575",
          "snippet": "static void rcu_exp_wait_wake(unsigned long s)\n{\n\tstruct rcu_node *rnp;\n\n\tsynchronize_sched_expedited_wait();\n\trcu_exp_gp_seq_end();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"end\"));\n\n\t/*\n\t * Switch over to wakeup mode, allowing the next GP, but -only- the\n\t * next GP, to proceed.\n\t */\n\tmutex_lock(&rcu_state.exp_wake_mutex);\n\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s)) {\n\t\t\tspin_lock(&rnp->exp_lock);\n\t\t\t/* Recheck, avoid hang in case someone just arrived. */\n\t\t\tif (ULONG_CMP_LT(rnp->exp_seq_rq, s))\n\t\t\t\trnp->exp_seq_rq = s;\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t}\n\t\tsmp_mb(); /* All above changes before wakeup. */\n\t\twake_up_all(&rnp->exp_wq[rcu_seq_ctr(rcu_state.expedited_sequence) & 0x3]);\n\t}\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"endwake\"));\n\tmutex_unlock(&rcu_state.exp_wake_mutex);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_wait_wake(unsigned long s)\n{\n\tstruct rcu_node *rnp;\n\n\tsynchronize_sched_expedited_wait();\n\trcu_exp_gp_seq_end();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"end\"));\n\n\t/*\n\t * Switch over to wakeup mode, allowing the next GP, but -only- the\n\t * next GP, to proceed.\n\t */\n\tmutex_lock(&rcu_state.exp_wake_mutex);\n\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s)) {\n\t\t\tspin_lock(&rnp->exp_lock);\n\t\t\t/* Recheck, avoid hang in case someone just arrived. */\n\t\t\tif (ULONG_CMP_LT(rnp->exp_seq_rq, s))\n\t\t\t\trnp->exp_seq_rq = s;\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t}\n\t\tsmp_mb(); /* All above changes before wakeup. */\n\t\twake_up_all(&rnp->exp_wq[rcu_seq_ctr(rcu_state.expedited_sequence) & 0x3]);\n\t}\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"endwake\"));\n\tmutex_unlock(&rcu_state.exp_wake_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_rcu_exp_select_cpus",
          "args": [
            "func"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_exp_select_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "429-466",
          "snippet": "static void sync_rcu_exp_select_cpus(smp_call_func_t func)\n{\n\tint cpu;\n\tstruct rcu_node *rnp;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"reset\"));\n\tsync_exp_reset_tree();\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"select\"));\n\n\t/* Schedule work for each leaf rcu_node structure. */\n\trcu_for_each_leaf_node(rnp) {\n\t\trnp->exp_need_flush = false;\n\t\tif (!READ_ONCE(rnp->expmask))\n\t\t\tcontinue; /* Avoid early boot non-existent wq. */\n\t\trnp->rew.rew_func = func;\n\t\tif (!READ_ONCE(rcu_par_gp_wq) ||\n\t\t    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||\n\t\t    rcu_is_last_leaf_node(rnp)) {\n\t\t\t/* No workqueues yet or last leaf, do direct call. */\n\t\t\tsync_rcu_exp_select_node_cpus(&rnp->rew.rew_work);\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_WORK(&rnp->rew.rew_work, sync_rcu_exp_select_node_cpus);\n\t\tpreempt_disable();\n\t\tcpu = cpumask_next(rnp->grplo - 1, cpu_online_mask);\n\t\t/* If all offline, queue the work on an unbound CPU. */\n\t\tif (unlikely(cpu > rnp->grphi))\n\t\t\tcpu = WORK_CPU_UNBOUND;\n\t\tqueue_work_on(cpu, rcu_par_gp_wq, &rnp->rew.rew_work);\n\t\tpreempt_enable();\n\t\trnp->exp_need_flush = true;\n\t}\n\n\t/* Wait for workqueue jobs (if any) to complete. */\n\trcu_for_each_leaf_node(rnp)\n\t\tif (rnp->exp_need_flush)\n\t\t\tflush_work(&rnp->rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_rcu_exp_select_cpus(smp_call_func_t func)\n{\n\tint cpu;\n\tstruct rcu_node *rnp;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"reset\"));\n\tsync_exp_reset_tree();\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"select\"));\n\n\t/* Schedule work for each leaf rcu_node structure. */\n\trcu_for_each_leaf_node(rnp) {\n\t\trnp->exp_need_flush = false;\n\t\tif (!READ_ONCE(rnp->expmask))\n\t\t\tcontinue; /* Avoid early boot non-existent wq. */\n\t\trnp->rew.rew_func = func;\n\t\tif (!READ_ONCE(rcu_par_gp_wq) ||\n\t\t    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||\n\t\t    rcu_is_last_leaf_node(rnp)) {\n\t\t\t/* No workqueues yet or last leaf, do direct call. */\n\t\t\tsync_rcu_exp_select_node_cpus(&rnp->rew.rew_work);\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_WORK(&rnp->rew.rew_work, sync_rcu_exp_select_node_cpus);\n\t\tpreempt_disable();\n\t\tcpu = cpumask_next(rnp->grplo - 1, cpu_online_mask);\n\t\t/* If all offline, queue the work on an unbound CPU. */\n\t\tif (unlikely(cpu > rnp->grphi))\n\t\t\tcpu = WORK_CPU_UNBOUND;\n\t\tqueue_work_on(cpu, rcu_par_gp_wq, &rnp->rew.rew_work);\n\t\tpreempt_enable();\n\t\trnp->exp_need_flush = true;\n\t}\n\n\t/* Wait for workqueue jobs (if any) to complete. */\n\trcu_for_each_leaf_node(rnp)\n\t\tif (rnp->exp_need_flush)\n\t\t\tflush_work(&rnp->rew.rew_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_sel_wait_wake(smp_call_func_t func, unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus(func);\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}"
  },
  {
    "function_name": "rcu_exp_wait_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "548-575",
    "snippet": "static void rcu_exp_wait_wake(unsigned long s)\n{\n\tstruct rcu_node *rnp;\n\n\tsynchronize_sched_expedited_wait();\n\trcu_exp_gp_seq_end();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"end\"));\n\n\t/*\n\t * Switch over to wakeup mode, allowing the next GP, but -only- the\n\t * next GP, to proceed.\n\t */\n\tmutex_lock(&rcu_state.exp_wake_mutex);\n\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s)) {\n\t\t\tspin_lock(&rnp->exp_lock);\n\t\t\t/* Recheck, avoid hang in case someone just arrived. */\n\t\t\tif (ULONG_CMP_LT(rnp->exp_seq_rq, s))\n\t\t\t\trnp->exp_seq_rq = s;\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t}\n\t\tsmp_mb(); /* All above changes before wakeup. */\n\t\twake_up_all(&rnp->exp_wq[rcu_seq_ctr(rcu_state.expedited_sequence) & 0x3]);\n\t}\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"endwake\"));\n\tmutex_unlock(&rcu_state.exp_wake_mutex);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.exp_wake_mutex"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"endwake\")"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"endwake\""
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&rnp->exp_wq[rcu_seq_ctr(rcu_state.expedited_sequence) & 0x3]"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "49-69",
          "snippet": "void swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "rcu_state.expedited_sequence"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rnp->exp_seq_rq",
            "s"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "READ_ONCE(rnp->exp_seq_rq)",
            "s"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_seq_rq"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_state.exp_wake_mutex"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"end\")"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"end\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_end",
          "args": [],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "45-49",
          "snippet": "static void rcu_exp_gp_seq_end(void)\n{\n\trcu_seq_end(&rcu_state.expedited_sequence);\n\tsmp_mb(); /* Ensure that consecutive grace periods serialize. */\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_gp_seq_end(void)\n{\n\trcu_seq_end(&rcu_state.expedited_sequence);\n\tsmp_mb(); /* Ensure that consecutive grace periods serialize. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched_expedited_wait",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_wait_wake(unsigned long s)\n{\n\tstruct rcu_node *rnp;\n\n\tsynchronize_sched_expedited_wait();\n\trcu_exp_gp_seq_end();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"end\"));\n\n\t/*\n\t * Switch over to wakeup mode, allowing the next GP, but -only- the\n\t * next GP, to proceed.\n\t */\n\tmutex_lock(&rcu_state.exp_wake_mutex);\n\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s)) {\n\t\t\tspin_lock(&rnp->exp_lock);\n\t\t\t/* Recheck, avoid hang in case someone just arrived. */\n\t\t\tif (ULONG_CMP_LT(rnp->exp_seq_rq, s))\n\t\t\t\trnp->exp_seq_rq = s;\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t}\n\t\tsmp_mb(); /* All above changes before wakeup. */\n\t\twake_up_all(&rnp->exp_wq[rcu_seq_ctr(rcu_state.expedited_sequence) & 0x3]);\n\t}\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"endwake\"));\n\tmutex_unlock(&rcu_state.exp_wake_mutex);\n}"
  },
  {
    "function_name": "synchronize_sched_expedited_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "468-540",
    "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "454-470",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t       0",
            "#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_STALL_DELAY_DELTA\t       0\n#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cpu_task",
          "args": [
            "cpu"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cpu_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "7007-7011",
          "snippet": "void dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" l=%u:%d-%d:%#lx/%c\"",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->expmask",
            "\".T\"[!!rnp->exp_tasks]"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_rcu_preempt_exp_done_unlocked",
          "args": [
            "rnp"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_preempt_exp_done_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "174-184",
          "snippet": "static bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"blocking rcu_node structures:\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" } %lu jiffies s: %lu root: %#lx/%c\\n\"",
            "jiffies - jiffies_start",
            "rcu_state.expedited_sequence",
            "rnp_root->expmask",
            "\".T\"[!!rnp_root->exp_tasks]"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %d-%c%c%c\"",
            "cpu",
            "\"O.\"[!!cpu_online(cpu)]",
            "\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)]",
            "\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_print_task_exp_stall",
          "args": [
            "rnp"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_print_task_exp_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1062-1065",
          "snippet": "static int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: %s detected expedited stalls on CPUs/tasks: {\"",
            "rcu_state.name"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic_on_rcu_stall",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "panic_on_rcu_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1222-1226",
          "snippet": "static void panic_on_rcu_stall(void)\n{\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_rcu_stall"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint sysctl_panic_on_rcu_stall;\n\nstatic void panic_on_rcu_stall(void)\n{\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_timeout_exclusive",
          "args": [
            "rcu_state.expedited_wq",
            "sync_rcu_preempt_exp_done_unlocked(rnp_root)",
            "jiffies_stall"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_exp_gp_seq_endval()",
            "TPS(\"startwait\")"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"startwait\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_endval",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_endval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "37-40",
          "snippet": "static __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
  },
  {
    "function_name": "sync_rcu_exp_select_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "429-466",
    "snippet": "static void sync_rcu_exp_select_cpus(smp_call_func_t func)\n{\n\tint cpu;\n\tstruct rcu_node *rnp;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"reset\"));\n\tsync_exp_reset_tree();\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"select\"));\n\n\t/* Schedule work for each leaf rcu_node structure. */\n\trcu_for_each_leaf_node(rnp) {\n\t\trnp->exp_need_flush = false;\n\t\tif (!READ_ONCE(rnp->expmask))\n\t\t\tcontinue; /* Avoid early boot non-existent wq. */\n\t\trnp->rew.rew_func = func;\n\t\tif (!READ_ONCE(rcu_par_gp_wq) ||\n\t\t    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||\n\t\t    rcu_is_last_leaf_node(rnp)) {\n\t\t\t/* No workqueues yet or last leaf, do direct call. */\n\t\t\tsync_rcu_exp_select_node_cpus(&rnp->rew.rew_work);\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_WORK(&rnp->rew.rew_work, sync_rcu_exp_select_node_cpus);\n\t\tpreempt_disable();\n\t\tcpu = cpumask_next(rnp->grplo - 1, cpu_online_mask);\n\t\t/* If all offline, queue the work on an unbound CPU. */\n\t\tif (unlikely(cpu > rnp->grphi))\n\t\t\tcpu = WORK_CPU_UNBOUND;\n\t\tqueue_work_on(cpu, rcu_par_gp_wq, &rnp->rew.rew_work);\n\t\tpreempt_enable();\n\t\trnp->exp_need_flush = true;\n\t}\n\n\t/* Wait for workqueue jobs (if any) to complete. */\n\trcu_for_each_leaf_node(rnp)\n\t\tif (rnp->exp_need_flush)\n\t\t\tflush_work(&rnp->rew.rew_work);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&rnp->rew.rew_work"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2936-2939",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cpu",
            "rcu_par_gp_wq",
            "&rnp->rew.rew_work"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1477-1492",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu > rnp->grphi"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "rnp->grplo - 1",
            "cpu_online_mask"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&rnp->rew.rew_work",
            "sync_rcu_exp_select_node_cpus"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_rcu_exp_select_node_cpus",
          "args": [
            "&rnp->rew.rew_work"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_exp_select_node_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "343-423",
          "snippet": "static void sync_rcu_exp_select_node_cpus(struct work_struct *wp)\n{\n\tint cpu;\n\tunsigned long flags;\n\tsmp_call_func_t func;\n\tunsigned long mask_ofl_test;\n\tunsigned long mask_ofl_ipi;\n\tint ret;\n\tstruct rcu_exp_work *rewp =\n\t\tcontainer_of(wp, struct rcu_exp_work, rew_work);\n\tstruct rcu_node *rnp = container_of(rewp, struct rcu_node, rew);\n\n\tfunc = rewp->rew_func;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/* Each pass checks a CPU for identity, offline, and idle. */\n\tmask_ofl_test = 0;\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tunsigned long mask = leaf_node_cpu_bit(rnp, cpu);\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tint snap;\n\n\t\tif (raw_smp_processor_id() == cpu ||\n\t\t    !(rnp->qsmaskinitnext & mask)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t} else {\n\t\t\tsnap = rcu_dynticks_snap(rdp);\n\t\t\tif (rcu_dynticks_in_eqs(snap))\n\t\t\t\tmask_ofl_test |= mask;\n\t\t\telse\n\t\t\t\trdp->exp_dynticks_snap = snap;\n\t\t}\n\t}\n\tmask_ofl_ipi = rnp->expmask & ~mask_ofl_test;\n\n\t/*\n\t * Need to wait for any blocked tasks as well.\tNote that\n\t * additional blocking tasks will also block the expedited GP\n\t * until such time as the ->expmask bits are cleared.\n\t */\n\tif (rcu_preempt_has_tasks(rnp))\n\t\trnp->exp_tasks = rnp->blkd_tasks.next;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t/* IPI the remaining CPUs for expedited quiescent state. */\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tunsigned long mask = leaf_node_cpu_bit(rnp, cpu);\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t\tif (!(mask_ofl_ipi & mask))\n\t\t\tcontinue;\nretry_ipi:\n\t\tif (rcu_dynticks_in_eqs_since(rdp, rdp->exp_dynticks_snap)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tcontinue;\n\t\t}\n\t\tret = smp_call_function_single(cpu, func, NULL, 0);\n\t\tif (!ret) {\n\t\t\tmask_ofl_ipi &= ~mask;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Failed, raced with CPU hotplug operation. */\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif ((rnp->qsmaskinitnext & mask) &&\n\t\t    (rnp->expmask & mask)) {\n\t\t\t/* Online, so delay for a bit and try again. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"selectofl\"));\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tgoto retry_ipi;\n\t\t}\n\t\t/* CPU really is offline, so we can ignore it. */\n\t\tif (!(rnp->expmask & mask))\n\t\t\tmask_ofl_ipi &= ~mask;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t/* Report quiescent states for those that went offline. */\n\tmask_ofl_test |= mask_ofl_ipi;\n\tif (mask_ofl_test)\n\t\trcu_report_exp_cpu_mult(rnp, mask_ofl_test, false);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_rcu_exp_select_node_cpus(struct work_struct *wp)\n{\n\tint cpu;\n\tunsigned long flags;\n\tsmp_call_func_t func;\n\tunsigned long mask_ofl_test;\n\tunsigned long mask_ofl_ipi;\n\tint ret;\n\tstruct rcu_exp_work *rewp =\n\t\tcontainer_of(wp, struct rcu_exp_work, rew_work);\n\tstruct rcu_node *rnp = container_of(rewp, struct rcu_node, rew);\n\n\tfunc = rewp->rew_func;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/* Each pass checks a CPU for identity, offline, and idle. */\n\tmask_ofl_test = 0;\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tunsigned long mask = leaf_node_cpu_bit(rnp, cpu);\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tint snap;\n\n\t\tif (raw_smp_processor_id() == cpu ||\n\t\t    !(rnp->qsmaskinitnext & mask)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t} else {\n\t\t\tsnap = rcu_dynticks_snap(rdp);\n\t\t\tif (rcu_dynticks_in_eqs(snap))\n\t\t\t\tmask_ofl_test |= mask;\n\t\t\telse\n\t\t\t\trdp->exp_dynticks_snap = snap;\n\t\t}\n\t}\n\tmask_ofl_ipi = rnp->expmask & ~mask_ofl_test;\n\n\t/*\n\t * Need to wait for any blocked tasks as well.\tNote that\n\t * additional blocking tasks will also block the expedited GP\n\t * until such time as the ->expmask bits are cleared.\n\t */\n\tif (rcu_preempt_has_tasks(rnp))\n\t\trnp->exp_tasks = rnp->blkd_tasks.next;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t/* IPI the remaining CPUs for expedited quiescent state. */\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tunsigned long mask = leaf_node_cpu_bit(rnp, cpu);\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t\tif (!(mask_ofl_ipi & mask))\n\t\t\tcontinue;\nretry_ipi:\n\t\tif (rcu_dynticks_in_eqs_since(rdp, rdp->exp_dynticks_snap)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tcontinue;\n\t\t}\n\t\tret = smp_call_function_single(cpu, func, NULL, 0);\n\t\tif (!ret) {\n\t\t\tmask_ofl_ipi &= ~mask;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Failed, raced with CPU hotplug operation. */\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif ((rnp->qsmaskinitnext & mask) &&\n\t\t    (rnp->expmask & mask)) {\n\t\t\t/* Online, so delay for a bit and try again. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"selectofl\"));\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tgoto retry_ipi;\n\t\t}\n\t\t/* CPU really is offline, so we can ignore it. */\n\t\tif (!(rnp->expmask & mask))\n\t\t\tmask_ofl_ipi &= ~mask;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t/* Report quiescent states for those that went offline. */\n\tmask_ofl_test |= mask_ofl_ipi;\n\tif (mask_ofl_test)\n\t\trcu_report_exp_cpu_mult(rnp, mask_ofl_test, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_last_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_par_gp_wq"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_exp_gp_seq_endval()",
            "TPS(\"select\")"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"select\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_endval",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_endval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "37-40",
          "snippet": "static __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_exp_reset_tree",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "sync_exp_reset_tree_hotplug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "81-132",
          "snippet": "static void sync_exp_reset_tree_hotplug(void)\n{\n\tbool done;\n\tunsigned long flags;\n\tunsigned long mask;\n\tunsigned long oldmask;\n\tint ncpus = smp_load_acquire(&rcu_state.ncpus); /* Order vs. locking. */\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_up;\n\n\t/* If no new CPUs onlined since last time, nothing to do. */\n\tif (likely(ncpus == rcu_state.ncpus_snap))\n\t\treturn;\n\trcu_state.ncpus_snap = ncpus;\n\n\t/*\n\t * Each pass through the following loop propagates newly onlined\n\t * CPUs for the current rcu_node structure up the rcu_node tree.\n\t */\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmaskinit == rnp->expmaskinitnext) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;  /* No new CPUs, nothing to do. */\n\t\t}\n\n\t\t/* Update this node's mask, track old value for propagation. */\n\t\toldmask = rnp->expmaskinit;\n\t\trnp->expmaskinit = rnp->expmaskinitnext;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t\t/* If was already nonzero, nothing to propagate. */\n\t\tif (oldmask)\n\t\t\tcontinue;\n\n\t\t/* Propagate the new CPU up the tree. */\n\t\tmask = rnp->grpmask;\n\t\trnp_up = rnp->parent;\n\t\tdone = false;\n\t\twhile (rnp_up) {\n\t\t\traw_spin_lock_irqsave_rcu_node(rnp_up, flags);\n\t\t\tif (rnp_up->expmaskinit)\n\t\t\t\tdone = true;\n\t\t\trnp_up->expmaskinit |= mask;\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tmask = rnp_up->grpmask;\n\t\t\trnp_up = rnp_up->parent;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_exp_reset_tree_hotplug(void)\n{\n\tbool done;\n\tunsigned long flags;\n\tunsigned long mask;\n\tunsigned long oldmask;\n\tint ncpus = smp_load_acquire(&rcu_state.ncpus); /* Order vs. locking. */\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_up;\n\n\t/* If no new CPUs onlined since last time, nothing to do. */\n\tif (likely(ncpus == rcu_state.ncpus_snap))\n\t\treturn;\n\trcu_state.ncpus_snap = ncpus;\n\n\t/*\n\t * Each pass through the following loop propagates newly onlined\n\t * CPUs for the current rcu_node structure up the rcu_node tree.\n\t */\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmaskinit == rnp->expmaskinitnext) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;  /* No new CPUs, nothing to do. */\n\t\t}\n\n\t\t/* Update this node's mask, track old value for propagation. */\n\t\toldmask = rnp->expmaskinit;\n\t\trnp->expmaskinit = rnp->expmaskinitnext;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t\t/* If was already nonzero, nothing to propagate. */\n\t\tif (oldmask)\n\t\t\tcontinue;\n\n\t\t/* Propagate the new CPU up the tree. */\n\t\tmask = rnp->grpmask;\n\t\trnp_up = rnp->parent;\n\t\tdone = false;\n\t\twhile (rnp_up) {\n\t\t\traw_spin_lock_irqsave_rcu_node(rnp_up, flags);\n\t\t\tif (rnp_up->expmaskinit)\n\t\t\t\tdone = true;\n\t\t\trnp_up->expmaskinit |= mask;\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tmask = rnp_up->grpmask;\n\t\t\trnp_up = rnp_up->parent;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_exp_gp_seq_endval()",
            "TPS(\"reset\")"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"reset\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_rcu_exp_select_cpus(smp_call_func_t func)\n{\n\tint cpu;\n\tstruct rcu_node *rnp;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"reset\"));\n\tsync_exp_reset_tree();\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"select\"));\n\n\t/* Schedule work for each leaf rcu_node structure. */\n\trcu_for_each_leaf_node(rnp) {\n\t\trnp->exp_need_flush = false;\n\t\tif (!READ_ONCE(rnp->expmask))\n\t\t\tcontinue; /* Avoid early boot non-existent wq. */\n\t\trnp->rew.rew_func = func;\n\t\tif (!READ_ONCE(rcu_par_gp_wq) ||\n\t\t    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||\n\t\t    rcu_is_last_leaf_node(rnp)) {\n\t\t\t/* No workqueues yet or last leaf, do direct call. */\n\t\t\tsync_rcu_exp_select_node_cpus(&rnp->rew.rew_work);\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_WORK(&rnp->rew.rew_work, sync_rcu_exp_select_node_cpus);\n\t\tpreempt_disable();\n\t\tcpu = cpumask_next(rnp->grplo - 1, cpu_online_mask);\n\t\t/* If all offline, queue the work on an unbound CPU. */\n\t\tif (unlikely(cpu > rnp->grphi))\n\t\t\tcpu = WORK_CPU_UNBOUND;\n\t\tqueue_work_on(cpu, rcu_par_gp_wq, &rnp->rew.rew_work);\n\t\tpreempt_enable();\n\t\trnp->exp_need_flush = true;\n\t}\n\n\t/* Wait for workqueue jobs (if any) to complete. */\n\trcu_for_each_leaf_node(rnp)\n\t\tif (rnp->exp_need_flush)\n\t\t\tflush_work(&rnp->rew.rew_work);\n}"
  },
  {
    "function_name": "sync_rcu_exp_select_node_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "343-423",
    "snippet": "static void sync_rcu_exp_select_node_cpus(struct work_struct *wp)\n{\n\tint cpu;\n\tunsigned long flags;\n\tsmp_call_func_t func;\n\tunsigned long mask_ofl_test;\n\tunsigned long mask_ofl_ipi;\n\tint ret;\n\tstruct rcu_exp_work *rewp =\n\t\tcontainer_of(wp, struct rcu_exp_work, rew_work);\n\tstruct rcu_node *rnp = container_of(rewp, struct rcu_node, rew);\n\n\tfunc = rewp->rew_func;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/* Each pass checks a CPU for identity, offline, and idle. */\n\tmask_ofl_test = 0;\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tunsigned long mask = leaf_node_cpu_bit(rnp, cpu);\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tint snap;\n\n\t\tif (raw_smp_processor_id() == cpu ||\n\t\t    !(rnp->qsmaskinitnext & mask)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t} else {\n\t\t\tsnap = rcu_dynticks_snap(rdp);\n\t\t\tif (rcu_dynticks_in_eqs(snap))\n\t\t\t\tmask_ofl_test |= mask;\n\t\t\telse\n\t\t\t\trdp->exp_dynticks_snap = snap;\n\t\t}\n\t}\n\tmask_ofl_ipi = rnp->expmask & ~mask_ofl_test;\n\n\t/*\n\t * Need to wait for any blocked tasks as well.\tNote that\n\t * additional blocking tasks will also block the expedited GP\n\t * until such time as the ->expmask bits are cleared.\n\t */\n\tif (rcu_preempt_has_tasks(rnp))\n\t\trnp->exp_tasks = rnp->blkd_tasks.next;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t/* IPI the remaining CPUs for expedited quiescent state. */\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tunsigned long mask = leaf_node_cpu_bit(rnp, cpu);\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t\tif (!(mask_ofl_ipi & mask))\n\t\t\tcontinue;\nretry_ipi:\n\t\tif (rcu_dynticks_in_eqs_since(rdp, rdp->exp_dynticks_snap)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tcontinue;\n\t\t}\n\t\tret = smp_call_function_single(cpu, func, NULL, 0);\n\t\tif (!ret) {\n\t\t\tmask_ofl_ipi &= ~mask;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Failed, raced with CPU hotplug operation. */\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif ((rnp->qsmaskinitnext & mask) &&\n\t\t    (rnp->expmask & mask)) {\n\t\t\t/* Online, so delay for a bit and try again. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"selectofl\"));\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tgoto retry_ipi;\n\t\t}\n\t\t/* CPU really is offline, so we can ignore it. */\n\t\tif (!(rnp->expmask & mask))\n\t\t\tmask_ofl_ipi &= ~mask;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t/* Report quiescent states for those that went offline. */\n\tmask_ofl_test |= mask_ofl_ipi;\n\tif (mask_ofl_test)\n\t\trcu_report_exp_cpu_mult(rnp, mask_ofl_test, false);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_exp_cpu_mult",
          "args": [
            "rnp",
            "mask_ofl_test",
            "false"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_cpu_mult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "244-256",
          "snippet": "static void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\trnp->expmask &= ~mask;\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\trnp->expmask &= ~mask;\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1835-1839",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_exp_gp_seq_endval()",
            "TPS(\"selectofl\")"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"selectofl\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_endval",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_endval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "37-40",
          "snippet": "static __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "func",
            "NULL",
            "0"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "11-23",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs_since",
          "args": [
            "rdp",
            "rdp->exp_dynticks_snap"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs_since",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "320-323",
          "snippet": "static bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_cpu_mask",
          "args": [
            "rnp",
            "cpu",
            "rnp->expmask"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_has_tasks",
          "args": [
            "rnp"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_has_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1025-1028",
          "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs",
          "args": [
            "snap"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "310-313",
          "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "299-304",
          "snippet": "int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_cpu_mask",
          "args": [
            "rnp",
            "cpu",
            "rnp->expmask"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rewp",
            "structrcu_node",
            "rew"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wp",
            "structrcu_exp_work",
            "rew_work"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_rcu_exp_select_node_cpus(struct work_struct *wp)\n{\n\tint cpu;\n\tunsigned long flags;\n\tsmp_call_func_t func;\n\tunsigned long mask_ofl_test;\n\tunsigned long mask_ofl_ipi;\n\tint ret;\n\tstruct rcu_exp_work *rewp =\n\t\tcontainer_of(wp, struct rcu_exp_work, rew_work);\n\tstruct rcu_node *rnp = container_of(rewp, struct rcu_node, rew);\n\n\tfunc = rewp->rew_func;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/* Each pass checks a CPU for identity, offline, and idle. */\n\tmask_ofl_test = 0;\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tunsigned long mask = leaf_node_cpu_bit(rnp, cpu);\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tint snap;\n\n\t\tif (raw_smp_processor_id() == cpu ||\n\t\t    !(rnp->qsmaskinitnext & mask)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t} else {\n\t\t\tsnap = rcu_dynticks_snap(rdp);\n\t\t\tif (rcu_dynticks_in_eqs(snap))\n\t\t\t\tmask_ofl_test |= mask;\n\t\t\telse\n\t\t\t\trdp->exp_dynticks_snap = snap;\n\t\t}\n\t}\n\tmask_ofl_ipi = rnp->expmask & ~mask_ofl_test;\n\n\t/*\n\t * Need to wait for any blocked tasks as well.\tNote that\n\t * additional blocking tasks will also block the expedited GP\n\t * until such time as the ->expmask bits are cleared.\n\t */\n\tif (rcu_preempt_has_tasks(rnp))\n\t\trnp->exp_tasks = rnp->blkd_tasks.next;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t/* IPI the remaining CPUs for expedited quiescent state. */\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tunsigned long mask = leaf_node_cpu_bit(rnp, cpu);\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t\tif (!(mask_ofl_ipi & mask))\n\t\t\tcontinue;\nretry_ipi:\n\t\tif (rcu_dynticks_in_eqs_since(rdp, rdp->exp_dynticks_snap)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tcontinue;\n\t\t}\n\t\tret = smp_call_function_single(cpu, func, NULL, 0);\n\t\tif (!ret) {\n\t\t\tmask_ofl_ipi &= ~mask;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Failed, raced with CPU hotplug operation. */\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif ((rnp->qsmaskinitnext & mask) &&\n\t\t    (rnp->expmask & mask)) {\n\t\t\t/* Online, so delay for a bit and try again. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"selectofl\"));\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tgoto retry_ipi;\n\t\t}\n\t\t/* CPU really is offline, so we can ignore it. */\n\t\tif (!(rnp->expmask & mask))\n\t\t\tmask_ofl_ipi &= ~mask;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t/* Report quiescent states for those that went offline. */\n\tmask_ofl_test |= mask_ofl_ipi;\n\tif (mask_ofl_test)\n\t\trcu_report_exp_cpu_mult(rnp, mask_ofl_test, false);\n}"
  },
  {
    "function_name": "exp_funnel_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "286-337",
    "snippet": "static bool exp_funnel_lock(unsigned long s)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\t/* Low-contention fastpath. */\n\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s) &&\n\t    (rnp == rnp_root ||\n\t     ULONG_CMP_LT(READ_ONCE(rnp_root->exp_seq_rq), s)) &&\n\t    mutex_trylock(&rcu_state.exp_mutex))\n\t\tgoto fastpath;\n\n\t/*\n\t * Each pass through the following loop works its way up\n\t * the rcu_node tree, returning if others have done the work or\n\t * otherwise falls through to acquire ->exp_mutex.  The mapping\n\t * from CPU to rcu_node structure can be inexact, as it is just\n\t * promoting locality and is not strictly needed for correctness.\n\t */\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tif (sync_exp_work_done(s))\n\t\t\treturn true;\n\n\t\t/* Work not done, either wait here or go up. */\n\t\tspin_lock(&rnp->exp_lock);\n\t\tif (ULONG_CMP_GE(rnp->exp_seq_rq, s)) {\n\n\t\t\t/* Someone else doing GP, so wait for them. */\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t\t  rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t  TPS(\"wait\"));\n\t\t\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t\t\t   sync_exp_work_done(s));\n\t\t\treturn true;\n\t\t}\n\t\trnp->exp_seq_rq = s; /* Followers can wait on us. */\n\t\tspin_unlock(&rnp->exp_lock);\n\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t  rnp->grplo, rnp->grphi, TPS(\"nxtlvl\"));\n\t}\n\tmutex_lock(&rcu_state.exp_mutex);\nfastpath:\n\tif (sync_exp_work_done(s)) {\n\t\tmutex_unlock(&rcu_state.exp_mutex);\n\t\treturn true;\n\t}\n\trcu_exp_gp_seq_start();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"start\"));\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"start\")"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"start\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_start",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "28-31",
          "snippet": "static void rcu_exp_gp_seq_start(void)\n{\n\trcu_seq_start(&rcu_state.expedited_sequence);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_gp_seq_start(void)\n{\n\trcu_seq_start(&rcu_state.expedited_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.exp_mutex"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_exp_work_done",
          "args": [
            "s"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "sync_exp_work_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "268-277",
          "snippet": "static bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\t/* Ensure test happens before caller kfree(). */\n\t\tsmp_mb__before_atomic(); /* ^^^ */\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\t/* Ensure test happens before caller kfree(). */\n\t\tsmp_mb__before_atomic(); /* ^^^ */\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_state.exp_mutex"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_funnel_lock",
          "args": [
            "rcu_state.name",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "TPS(\"nxtlvl\")"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"nxtlvl\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "rnp->exp_wq[rcu_seq_ctr(s) & 0x3]",
            "sync_exp_work_done(s)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "s"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_funnel_lock",
          "args": [
            "rcu_state.name",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "TPS(\"wait\")"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"wait\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rnp->exp_seq_rq",
            "s"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&rcu_state.exp_mutex"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1582-1594",
          "snippet": "int __sched rt_mutex_trylock(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(in_irq() || in_nmi() || in_serving_softirq()))\n\t\treturn 0;\n\n\tret = rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);\n\tif (ret)\n\t\tmutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_trylock(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(in_irq() || in_nmi() || in_serving_softirq()))\n\t\treturn 0;\n\n\tret = rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);\n\tif (ret)\n\t\tmutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "READ_ONCE(rnp_root->exp_seq_rq)",
            "s"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->exp_seq_rq"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "READ_ONCE(rnp->exp_seq_rq)",
            "s"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_seq_rq"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "raw_smp_processor_id()"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool exp_funnel_lock(unsigned long s)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\t/* Low-contention fastpath. */\n\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s) &&\n\t    (rnp == rnp_root ||\n\t     ULONG_CMP_LT(READ_ONCE(rnp_root->exp_seq_rq), s)) &&\n\t    mutex_trylock(&rcu_state.exp_mutex))\n\t\tgoto fastpath;\n\n\t/*\n\t * Each pass through the following loop works its way up\n\t * the rcu_node tree, returning if others have done the work or\n\t * otherwise falls through to acquire ->exp_mutex.  The mapping\n\t * from CPU to rcu_node structure can be inexact, as it is just\n\t * promoting locality and is not strictly needed for correctness.\n\t */\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tif (sync_exp_work_done(s))\n\t\t\treturn true;\n\n\t\t/* Work not done, either wait here or go up. */\n\t\tspin_lock(&rnp->exp_lock);\n\t\tif (ULONG_CMP_GE(rnp->exp_seq_rq, s)) {\n\n\t\t\t/* Someone else doing GP, so wait for them. */\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t\t  rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t  TPS(\"wait\"));\n\t\t\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t\t\t   sync_exp_work_done(s));\n\t\t\treturn true;\n\t\t}\n\t\trnp->exp_seq_rq = s; /* Followers can wait on us. */\n\t\tspin_unlock(&rnp->exp_lock);\n\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t  rnp->grplo, rnp->grphi, TPS(\"nxtlvl\"));\n\t}\n\tmutex_lock(&rcu_state.exp_mutex);\nfastpath:\n\tif (sync_exp_work_done(s)) {\n\t\tmutex_unlock(&rcu_state.exp_mutex);\n\t\treturn true;\n\t}\n\trcu_exp_gp_seq_start();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"start\"));\n\treturn false;\n}"
  },
  {
    "function_name": "sync_exp_work_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "268-277",
    "snippet": "static bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\t/* Ensure test happens before caller kfree(). */\n\t\tsmp_mb__before_atomic(); /* ^^^ */\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"done\")"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"done\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_done",
          "args": [
            "s"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "69-72",
          "snippet": "static bool rcu_exp_gp_seq_done(unsigned long s)\n{\n\treturn rcu_seq_done(&rcu_state.expedited_sequence, s);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool rcu_exp_gp_seq_done(unsigned long s)\n{\n\treturn rcu_seq_done(&rcu_state.expedited_sequence, s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\t/* Ensure test happens before caller kfree(). */\n\t\tsmp_mb__before_atomic(); /* ^^^ */\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_report_exp_rdp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "261-265",
    "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_exp_cpu_mult",
          "args": [
            "rdp->mynode",
            "rdp->grpmask",
            "true"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_cpu_mult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "244-256",
          "snippet": "static void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\trnp->expmask &= ~mask;\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\trnp->expmask &= ~mask;\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->deferred_qs",
            "false"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
  },
  {
    "function_name": "rcu_report_exp_cpu_mult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "244-256",
    "snippet": "static void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\trnp->expmask &= ~mask;\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rcu_report_exp_rnp",
          "args": [
            "rnp",
            "wake",
            "flags"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_report_exp_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "197-226",
          "snippet": "static void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\tfor (;;) {\n\t\tif (!sync_rcu_preempt_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\trnp->expmask &= ~mask;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\tfor (;;) {\n\t\tif (!sync_rcu_preempt_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\trnp->expmask &= ~mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\trnp->expmask &= ~mask;\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}"
  },
  {
    "function_name": "rcu_report_exp_rnp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "232-238",
    "snippet": "static void __maybe_unused rcu_report_exp_rnp(struct rcu_node *rnp, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t__rcu_report_exp_rnp(rnp, wake, flags);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __maybe_unused"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rcu_report_exp_rnp",
          "args": [
            "rnp",
            "wake",
            "flags"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_report_exp_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "197-226",
          "snippet": "static void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\tfor (;;) {\n\t\tif (!sync_rcu_preempt_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\trnp->expmask &= ~mask;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\tfor (;;) {\n\t\tif (!sync_rcu_preempt_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\trnp->expmask &= ~mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic void __maybe_unused rcu_report_exp_rnp(struct rcu_node *rnp, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t__rcu_report_exp_rnp(rnp, wake, flags);\n}"
  },
  {
    "function_name": "__rcu_report_exp_rnp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "197-226",
    "snippet": "static void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\tfor (;;) {\n\t\tif (!sync_rcu_preempt_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\trnp->expmask &= ~mask;\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(rnp->expmask & mask)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rcu_state.expedited_wq"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "35-42",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_initiate_boost",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_initiate_boost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1484-1488",
          "snippet": "static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_rcu_preempt_exp_done",
          "args": [
            "rnp"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_preempt_exp_done_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "174-184",
          "snippet": "static bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\tfor (;;) {\n\t\tif (!sync_rcu_preempt_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\trnp->expmask &= ~mask;\n\t}\n}"
  },
  {
    "function_name": "sync_rcu_preempt_exp_done_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "174-184",
    "snippet": "static bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_rcu_preempt_exp_done",
          "args": [
            "rnp"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_preempt_exp_done_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "174-184",
          "snippet": "static bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sync_rcu_preempt_exp_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "161-167",
    "snippet": "static bool sync_rcu_preempt_exp_done(struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\treturn rnp->exp_tasks == NULL &&\n\t       READ_ONCE(rnp->expmask) == 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_rcu_preempt_exp_done(struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\treturn rnp->exp_tasks == NULL &&\n\t       READ_ONCE(rnp->expmask) == 0;\n}"
  },
  {
    "function_name": "sync_exp_reset_tree_hotplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "81-132",
    "snippet": "static void sync_exp_reset_tree_hotplug(void)\n{\n\tbool done;\n\tunsigned long flags;\n\tunsigned long mask;\n\tunsigned long oldmask;\n\tint ncpus = smp_load_acquire(&rcu_state.ncpus); /* Order vs. locking. */\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_up;\n\n\t/* If no new CPUs onlined since last time, nothing to do. */\n\tif (likely(ncpus == rcu_state.ncpus_snap))\n\t\treturn;\n\trcu_state.ncpus_snap = ncpus;\n\n\t/*\n\t * Each pass through the following loop propagates newly onlined\n\t * CPUs for the current rcu_node structure up the rcu_node tree.\n\t */\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmaskinit == rnp->expmaskinitnext) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;  /* No new CPUs, nothing to do. */\n\t\t}\n\n\t\t/* Update this node's mask, track old value for propagation. */\n\t\toldmask = rnp->expmaskinit;\n\t\trnp->expmaskinit = rnp->expmaskinitnext;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t\t/* If was already nonzero, nothing to propagate. */\n\t\tif (oldmask)\n\t\t\tcontinue;\n\n\t\t/* Propagate the new CPU up the tree. */\n\t\tmask = rnp->grpmask;\n\t\trnp_up = rnp->parent;\n\t\tdone = false;\n\t\twhile (rnp_up) {\n\t\t\traw_spin_lock_irqsave_rcu_node(rnp_up, flags);\n\t\t\tif (rnp_up->expmaskinit)\n\t\t\t\tdone = true;\n\t\t\trnp_up->expmaskinit |= mask;\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tmask = rnp_up->grpmask;\n\t\t\trnp_up = rnp_up->parent;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp_up",
            "flags"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp_up",
            "flags"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ncpus == rcu_state.ncpus_snap"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rcu_state.ncpus"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_exp_reset_tree_hotplug(void)\n{\n\tbool done;\n\tunsigned long flags;\n\tunsigned long mask;\n\tunsigned long oldmask;\n\tint ncpus = smp_load_acquire(&rcu_state.ncpus); /* Order vs. locking. */\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_up;\n\n\t/* If no new CPUs onlined since last time, nothing to do. */\n\tif (likely(ncpus == rcu_state.ncpus_snap))\n\t\treturn;\n\trcu_state.ncpus_snap = ncpus;\n\n\t/*\n\t * Each pass through the following loop propagates newly onlined\n\t * CPUs for the current rcu_node structure up the rcu_node tree.\n\t */\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmaskinit == rnp->expmaskinitnext) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;  /* No new CPUs, nothing to do. */\n\t\t}\n\n\t\t/* Update this node's mask, track old value for propagation. */\n\t\toldmask = rnp->expmaskinit;\n\t\trnp->expmaskinit = rnp->expmaskinitnext;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t\t/* If was already nonzero, nothing to propagate. */\n\t\tif (oldmask)\n\t\t\tcontinue;\n\n\t\t/* Propagate the new CPU up the tree. */\n\t\tmask = rnp->grpmask;\n\t\trnp_up = rnp->parent;\n\t\tdone = false;\n\t\twhile (rnp_up) {\n\t\t\traw_spin_lock_irqsave_rcu_node(rnp_up, flags);\n\t\t\tif (rnp_up->expmaskinit)\n\t\t\t\tdone = true;\n\t\t\trnp_up->expmaskinit |= mask;\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tmask = rnp_up->grpmask;\n\t\t\trnp_up = rnp_up->parent;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "69-72",
    "snippet": "static bool rcu_exp_gp_seq_done(unsigned long s)\n{\n\treturn rcu_seq_done(&rcu_state.expedited_sequence, s);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rcu_state.expedited_sequence",
            "s"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "133-136",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool rcu_exp_gp_seq_done(unsigned long s)\n{\n\treturn rcu_seq_done(&rcu_state.expedited_sequence, s);\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_snap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "54-62",
    "snippet": "static unsigned long rcu_exp_gp_seq_snap(void)\n{\n\tunsigned long s;\n\n\tsmp_mb(); /* Caller's modifications seen first by other CPUs. */\n\ts = rcu_seq_snap(&rcu_state.expedited_sequence);\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"snap\"));\n\treturn s;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"snap\")"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"snap\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.expedited_sequence"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic unsigned long rcu_exp_gp_seq_snap(void)\n{\n\tunsigned long s;\n\n\tsmp_mb(); /* Caller's modifications seen first by other CPUs. */\n\ts = rcu_seq_snap(&rcu_state.expedited_sequence);\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"snap\"));\n\treturn s;\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "45-49",
    "snippet": "static void rcu_exp_gp_seq_end(void)\n{\n\trcu_seq_end(&rcu_state.expedited_sequence);\n\tsmp_mb(); /* Ensure that consecutive grace periods serialize. */\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&rcu_state.expedited_sequence"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "87-92",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_gp_seq_end(void)\n{\n\trcu_seq_end(&rcu_state.expedited_sequence);\n\tsmp_mb(); /* Ensure that consecutive grace periods serialize. */\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_endval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "37-40",
    "snippet": "static __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __maybe_unused"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_endval",
          "args": [
            "&rcu_state.expedited_sequence"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_endval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "81-84",
          "snippet": "static inline unsigned long rcu_seq_endval(unsigned long *sp)\n{\n\treturn (*sp | RCU_SEQ_STATE_MASK) + 1;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_endval(unsigned long *sp)\n{\n\treturn (*sp | RCU_SEQ_STATE_MASK) + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
    "lines": "28-31",
    "snippet": "static void rcu_exp_gp_seq_start(void)\n{\n\trcu_seq_start(&rcu_state.expedited_sequence);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&rcu_state.expedited_sequence"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "73-78",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_gp_seq_start(void)\n{\n\trcu_seq_start(&rcu_state.expedited_sequence);\n}"
  }
]