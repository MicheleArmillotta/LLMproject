[
  {
    "function_name": "bpf_map_fd_sys_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
    "lines": "101-104",
    "snippet": "u32 bpf_map_fd_sys_lookup_elem(void *ptr)\n{\n\treturn ((struct bpf_map *)ptr)->id;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nu32 bpf_map_fd_sys_lookup_elem(void *ptr)\n{\n\treturn ((struct bpf_map *)ptr)->id;\n}"
  },
  {
    "function_name": "bpf_map_fd_put_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
    "lines": "93-99",
    "snippet": "void bpf_map_fd_put_ptr(void *ptr)\n{\n\t/* ptr->ops->map_free() has to go through one\n\t * rcu grace period by itself.\n\t */\n\tbpf_map_put(ptr);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "ptr"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "321-325",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nvoid bpf_map_fd_put_ptr(void *ptr)\n{\n\t/* ptr->ops->map_free() has to go through one\n\t * rcu grace period by itself.\n\t */\n\tbpf_map_put(ptr);\n}"
  },
  {
    "function_name": "bpf_map_fd_get_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
    "lines": "72-91",
    "snippet": "void *bpf_map_fd_get_ptr(struct bpf_map *map,\n\t\t\t struct file *map_file /* not used */,\n\t\t\t int ufd)\n{\n\tstruct bpf_map *inner_map;\n\tstruct fd f;\n\n\tf = fdget(ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\n\tif (bpf_map_meta_equal(map->inner_map_meta, inner_map))\n\t\tinner_map = bpf_map_inc(inner_map, false);\n\telse\n\t\tinner_map = ERR_PTR(-EINVAL);\n\n\tfdput(f);\n\treturn inner_map;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_inc",
          "args": [
            "inner_map",
            "false"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_inc_not_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "628-647",
          "snippet": "static struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map,\n\t\t\t\t\t    bool uref)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&map->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_map_put(map, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_MAX_REFCNT 32768"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstatic struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map,\n\t\t\t\t\t    bool uref)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&map->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_map_put(map, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_meta_equal",
          "args": [
            "map->inner_map_meta",
            "inner_map"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_meta_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
          "lines": "61-70",
          "snippet": "bool bpf_map_meta_equal(const struct bpf_map *meta0,\n\t\t\tconst struct bpf_map *meta1)\n{\n\t/* No need to compare ops because it is covered by map_type */\n\treturn meta0->map_type == meta1->map_type &&\n\t\tmeta0->key_size == meta1->key_size &&\n\t\tmeta0->value_size == meta1->value_size &&\n\t\tmeta0->map_flags == meta1->map_flags &&\n\t\tmeta0->max_entries == meta1->max_entries;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nbool bpf_map_meta_equal(const struct bpf_map *meta0,\n\t\t\tconst struct bpf_map *meta1)\n{\n\t/* No need to compare ops because it is covered by map_type */\n\treturn meta0->map_type == meta1->map_type &&\n\t\tmeta0->key_size == meta1->key_size &&\n\t\tmeta0->value_size == meta1->value_size &&\n\t\tmeta0->map_flags == meta1->map_flags &&\n\t\tmeta0->max_entries == meta1->max_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inner_map"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "585-595",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nvoid *bpf_map_fd_get_ptr(struct bpf_map *map,\n\t\t\t struct file *map_file /* not used */,\n\t\t\t int ufd)\n{\n\tstruct bpf_map *inner_map;\n\tstruct fd f;\n\n\tf = fdget(ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\n\tif (bpf_map_meta_equal(map->inner_map_meta, inner_map))\n\t\tinner_map = bpf_map_inc(inner_map, false);\n\telse\n\t\tinner_map = ERR_PTR(-EINVAL);\n\n\tfdput(f);\n\treturn inner_map;\n}"
  },
  {
    "function_name": "bpf_map_meta_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
    "lines": "61-70",
    "snippet": "bool bpf_map_meta_equal(const struct bpf_map *meta0,\n\t\t\tconst struct bpf_map *meta1)\n{\n\t/* No need to compare ops because it is covered by map_type */\n\treturn meta0->map_type == meta1->map_type &&\n\t\tmeta0->key_size == meta1->key_size &&\n\t\tmeta0->value_size == meta1->value_size &&\n\t\tmeta0->map_flags == meta1->map_flags &&\n\t\tmeta0->max_entries == meta1->max_entries;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nbool bpf_map_meta_equal(const struct bpf_map *meta0,\n\t\t\tconst struct bpf_map *meta1)\n{\n\t/* No need to compare ops because it is covered by map_type */\n\treturn meta0->map_type == meta1->map_type &&\n\t\tmeta0->key_size == meta1->key_size &&\n\t\tmeta0->value_size == meta1->value_size &&\n\t\tmeta0->map_flags == meta1->map_flags &&\n\t\tmeta0->max_entries == meta1->max_entries;\n}"
  },
  {
    "function_name": "bpf_map_meta_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
    "lines": "56-59",
    "snippet": "void bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tkfree(map_meta);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map_meta"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nvoid bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tkfree(map_meta);\n}"
  },
  {
    "function_name": "bpf_map_meta_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
    "lines": "12-54",
    "snippet": "struct bpf_map *bpf_map_meta_alloc(int inner_map_ufd)\n{\n\tstruct bpf_map *inner_map, *inner_map_meta;\n\tstruct fd f;\n\n\tf = fdget(inner_map_ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\n\t/* prog_array->owner_prog_type and owner_jited\n\t * is a runtime binding.  Doing static check alone\n\t * in the verifier is not enough.\n\t */\n\tif (inner_map->map_type == BPF_MAP_TYPE_PROG_ARRAY ||\n\t    inner_map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE ||\n\t    inner_map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\t/* Does not support >1 level map-in-map */\n\tif (inner_map->inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinner_map_meta = kzalloc(sizeof(*inner_map_meta), GFP_USER);\n\tif (!inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinner_map_meta->map_type = inner_map->map_type;\n\tinner_map_meta->key_size = inner_map->key_size;\n\tinner_map_meta->value_size = inner_map->value_size;\n\tinner_map_meta->map_flags = inner_map->map_flags;\n\tinner_map_meta->ops = inner_map->ops;\n\tinner_map_meta->max_entries = inner_map->max_entries;\n\n\tfdput(f);\n\treturn inner_map_meta;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/bpf.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*inner_map_meta)",
            "GFP_USER"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTSUPP"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inner_map"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "585-595",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "inner_map_ufd"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nstruct bpf_map *bpf_map_meta_alloc(int inner_map_ufd)\n{\n\tstruct bpf_map *inner_map, *inner_map_meta;\n\tstruct fd f;\n\n\tf = fdget(inner_map_ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\n\t/* prog_array->owner_prog_type and owner_jited\n\t * is a runtime binding.  Doing static check alone\n\t * in the verifier is not enough.\n\t */\n\tif (inner_map->map_type == BPF_MAP_TYPE_PROG_ARRAY ||\n\t    inner_map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE ||\n\t    inner_map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\t/* Does not support >1 level map-in-map */\n\tif (inner_map->inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinner_map_meta = kzalloc(sizeof(*inner_map_meta), GFP_USER);\n\tif (!inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinner_map_meta->map_type = inner_map->map_type;\n\tinner_map_meta->key_size = inner_map->key_size;\n\tinner_map_meta->value_size = inner_map->value_size;\n\tinner_map_meta->map_flags = inner_map->map_flags;\n\tinner_map_meta->ops = inner_map->ops;\n\tinner_map_meta->max_entries = inner_map->max_entries;\n\n\tfdput(f);\n\treturn inner_map_meta;\n}"
  }
]