[
  {
    "function_name": "sysctl_latencytop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "295-305",
    "snippet": "int sysctl_latencytop(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err;\n\n\terr = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (latencytop_enabled)\n\t\tforce_schedstat_enabled();\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int latencytop_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_schedstat_enabled",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2231-2237",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_ms_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3224-3228",
          "snippet": "int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nint latencytop_enabled;\n\nint sysctl_latencytop(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err;\n\n\terr = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (latencytop_enabled)\n\t\tforce_schedstat_enabled();\n\n\treturn err;\n}"
  },
  {
    "function_name": "init_lstats_procfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "289-293",
    "snippet": "static int __init init_lstats_procfs(void)\n{\n\tproc_create(\"latency_stats\", 0644, NULL, &lstats_fops);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations lstats_fops = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"latency_stats\"",
            "0644",
            "NULL",
            "&lstats_fops"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic const struct file_operations lstats_fops = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int __init init_lstats_procfs(void)\n{\n\tproc_create(\"latency_stats\", 0644, NULL, &lstats_fops);\n\treturn 0;\n}"
  },
  {
    "function_name": "lstats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "276-279",
    "snippet": "static int lstats_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, lstats_show, NULL);\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "filp",
            "lstats_show",
            "NULL"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int lstats_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, lstats_show, NULL);\n}"
  },
  {
    "function_name": "lstats_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "267-274",
    "snippet": "static ssize_t\nlstats_write(struct file *file, const char __user *buf, size_t count,\n\t     loff_t *offs)\n{\n\tclear_global_latency_tracing();\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_global_latency_tracing",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "clear_global_latency_tracing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
          "lines": "83-90",
          "snippet": "static void clear_global_latency_tracing(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\tmemset(&latency_record, 0, sizeof(latency_record));\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/list.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(latency_lock);",
            "static struct latency_record latency_record[MAXLR];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic DEFINE_RAW_SPINLOCK(latency_lock);\nstatic struct latency_record latency_record[MAXLR];\n\nstatic void clear_global_latency_tracing(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\tmemset(&latency_record, 0, sizeof(latency_record));\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic ssize_t\nlstats_write(struct file *file, const char __user *buf, size_t count,\n\t     loff_t *offs)\n{\n\tclear_global_latency_tracing();\n\n\treturn count;\n}"
  },
  {
    "function_name": "lstats_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "240-265",
    "snippet": "static int lstats_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\n\tfor (i = 0; i < MAXLR; i++) {\n\t\tstruct latency_record *lr = &latency_record[i];\n\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %lu %lu\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (bt == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [
      "#define MAXLR 128"
    ],
    "globals_used": [
      "static struct latency_record latency_record[MAXLR];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %ps\"",
            "(void *)bt"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\n#define MAXLR 128\n\nstatic struct latency_record latency_record[MAXLR];\n\nstatic int lstats_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\n\tfor (i = 0; i < MAXLR; i++) {\n\t\tstruct latency_record *lr = &latency_record[i];\n\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %lu %lu\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (bt == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__account_scheduler_latency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "174-238",
    "snippet": "void __sched\n__account_scheduler_latency(struct task_struct *tsk, int usecs, int inter)\n{\n\tunsigned long flags;\n\tint i, q;\n\tstruct latency_record lat;\n\n\t/* Long interruptible waits are generally user requested... */\n\tif (inter && usecs > 5000)\n\t\treturn;\n\n\t/* Negative sleeps are time going backwards */\n\t/* Zero-time sleeps are non-interesting */\n\tif (usecs <= 0)\n\t\treturn;\n\n\tmemset(&lat, 0, sizeof(lat));\n\tlat.count = 1;\n\tlat.time = usecs;\n\tlat.max = usecs;\n\tstore_stacktrace(tsk, &lat);\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\n\taccount_global_scheduler_latency(tsk, &lat);\n\n\tfor (i = 0; i < tsk->latency_record_count; i++) {\n\t\tstruct latency_record *mylat;\n\t\tint same = 1;\n\n\t\tmylat = &tsk->latency_record[i];\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat.backtrace[q];\n\n\t\t\tif (mylat->backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* 0 and ULONG_MAX entries mean end of backtrace: */\n\t\t\tif (record == 0 || record == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tmylat->count++;\n\t\t\tmylat->time += lat.time;\n\t\t\tif (lat.time > mylat->max)\n\t\t\t\tmylat->max = lat.time;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * short term hack; if we're > 32 we stop; future we recycle:\n\t */\n\tif (tsk->latency_record_count >= LT_SAVECOUNT)\n\t\tgoto out_unlock;\n\n\t/* Allocated a new one: */\n\ti = tsk->latency_record_count++;\n\tmemcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(latency_lock);",
      "static struct latency_record latency_record[MAXLR];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&latency_lock",
            "flags"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tsk->latency_record[i]",
            "&lat",
            "sizeof(struct latency_record)"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_global_scheduler_latency",
          "args": [
            "tsk",
            "&lat"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "account_global_scheduler_latency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
          "lines": "92-142",
          "snippet": "static void __sched\naccount_global_scheduler_latency(struct task_struct *tsk,\n\t\t\t\t struct latency_record *lat)\n{\n\tint firstnonnull = MAXLR + 1;\n\tint i;\n\n\tif (!latencytop_enabled)\n\t\treturn;\n\n\t/* skip kernel threads for now */\n\tif (!tsk->mm)\n\t\treturn;\n\n\tfor (i = 0; i < MAXLR; i++) {\n\t\tint q, same = 1;\n\n\t\t/* Nothing stored: */\n\t\tif (!latency_record[i].backtrace[0]) {\n\t\t\tif (firstnonnull > i)\n\t\t\t\tfirstnonnull = i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat->backtrace[q];\n\n\t\t\tif (latency_record[i].backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* 0 and ULONG_MAX entries mean end of backtrace: */\n\t\t\tif (record == 0 || record == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tlatency_record[i].count++;\n\t\t\tlatency_record[i].time += lat->time;\n\t\t\tif (lat->time > latency_record[i].max)\n\t\t\t\tlatency_record[i].max = lat->time;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ti = firstnonnull;\n\tif (i >= MAXLR - 1)\n\t\treturn;\n\n\t/* Allocted a new one: */\n\tmemcpy(&latency_record[i], lat, sizeof(struct latency_record));\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/list.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define MAXLR 128"
          ],
          "globals_used": [
            "static struct latency_record latency_record[MAXLR];",
            "int latencytop_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\n#define MAXLR 128\n\nstatic struct latency_record latency_record[MAXLR];\nint latencytop_enabled;\n\nstatic void __sched\naccount_global_scheduler_latency(struct task_struct *tsk,\n\t\t\t\t struct latency_record *lat)\n{\n\tint firstnonnull = MAXLR + 1;\n\tint i;\n\n\tif (!latencytop_enabled)\n\t\treturn;\n\n\t/* skip kernel threads for now */\n\tif (!tsk->mm)\n\t\treturn;\n\n\tfor (i = 0; i < MAXLR; i++) {\n\t\tint q, same = 1;\n\n\t\t/* Nothing stored: */\n\t\tif (!latency_record[i].backtrace[0]) {\n\t\t\tif (firstnonnull > i)\n\t\t\t\tfirstnonnull = i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat->backtrace[q];\n\n\t\t\tif (latency_record[i].backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* 0 and ULONG_MAX entries mean end of backtrace: */\n\t\t\tif (record == 0 || record == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tlatency_record[i].count++;\n\t\t\tlatency_record[i].time += lat->time;\n\t\t\tif (lat->time > latency_record[i].max)\n\t\t\t\tlatency_record[i].max = lat->time;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ti = firstnonnull;\n\tif (i >= MAXLR - 1)\n\t\treturn;\n\n\t/* Allocted a new one: */\n\tmemcpy(&latency_record[i], lat, sizeof(struct latency_record));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&latency_lock",
            "flags"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_stacktrace",
          "args": [
            "tsk",
            "&lat"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "store_stacktrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
          "lines": "147-156",
          "snippet": "static inline void store_stacktrace(struct task_struct *tsk,\n\t\t\t\t\tstruct latency_record *lat)\n{\n\tstruct stack_trace trace;\n\n\tmemset(&trace, 0, sizeof(trace));\n\ttrace.max_entries = LT_BACKTRACEDEPTH;\n\ttrace.entries = &lat->backtrace[0];\n\tsave_stack_trace_tsk(tsk, &trace);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/list.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct latency_record latency_record[MAXLR];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic struct latency_record latency_record[MAXLR];\n\nstatic inline void store_stacktrace(struct task_struct *tsk,\n\t\t\t\t\tstruct latency_record *lat)\n{\n\tstruct stack_trace trace;\n\n\tmemset(&trace, 0, sizeof(trace));\n\ttrace.max_entries = LT_BACKTRACEDEPTH;\n\ttrace.entries = &lat->backtrace[0];\n\tsave_stack_trace_tsk(tsk, &trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lat",
            "0",
            "sizeof(lat)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic DEFINE_RAW_SPINLOCK(latency_lock);\nstatic struct latency_record latency_record[MAXLR];\n\nvoid __sched\n__account_scheduler_latency(struct task_struct *tsk, int usecs, int inter)\n{\n\tunsigned long flags;\n\tint i, q;\n\tstruct latency_record lat;\n\n\t/* Long interruptible waits are generally user requested... */\n\tif (inter && usecs > 5000)\n\t\treturn;\n\n\t/* Negative sleeps are time going backwards */\n\t/* Zero-time sleeps are non-interesting */\n\tif (usecs <= 0)\n\t\treturn;\n\n\tmemset(&lat, 0, sizeof(lat));\n\tlat.count = 1;\n\tlat.time = usecs;\n\tlat.max = usecs;\n\tstore_stacktrace(tsk, &lat);\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\n\taccount_global_scheduler_latency(tsk, &lat);\n\n\tfor (i = 0; i < tsk->latency_record_count; i++) {\n\t\tstruct latency_record *mylat;\n\t\tint same = 1;\n\n\t\tmylat = &tsk->latency_record[i];\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat.backtrace[q];\n\n\t\t\tif (mylat->backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* 0 and ULONG_MAX entries mean end of backtrace: */\n\t\t\tif (record == 0 || record == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tmylat->count++;\n\t\t\tmylat->time += lat.time;\n\t\t\tif (lat.time > mylat->max)\n\t\t\t\tmylat->max = lat.time;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * short term hack; if we're > 32 we stop; future we recycle:\n\t */\n\tif (tsk->latency_record_count >= LT_SAVECOUNT)\n\t\tgoto out_unlock;\n\n\t/* Allocated a new one: */\n\ti = tsk->latency_record_count++;\n\tmemcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}"
  },
  {
    "function_name": "store_stacktrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "147-156",
    "snippet": "static inline void store_stacktrace(struct task_struct *tsk,\n\t\t\t\t\tstruct latency_record *lat)\n{\n\tstruct stack_trace trace;\n\n\tmemset(&trace, 0, sizeof(trace));\n\ttrace.max_entries = LT_BACKTRACEDEPTH;\n\ttrace.entries = &lat->backtrace[0];\n\tsave_stack_trace_tsk(tsk, &trace);\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct latency_record latency_record[MAXLR];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_stack_trace_tsk",
          "args": [
            "tsk",
            "&trace"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "save_stack_trace_tsk_reliable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stacktrace.c",
          "lines": "73-79",
          "snippet": "__weak int\nsave_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t      struct stack_trace *trace)\n{\n\tWARN_ONCE(1, KERN_INFO \"save_stack_tsk_reliable() not implemented yet.\\n\");\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\n__weak int\nsave_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t      struct stack_trace *trace)\n{\n\tWARN_ONCE(1, KERN_INFO \"save_stack_tsk_reliable() not implemented yet.\\n\");\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&trace",
            "0",
            "sizeof(trace)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic struct latency_record latency_record[MAXLR];\n\nstatic inline void store_stacktrace(struct task_struct *tsk,\n\t\t\t\t\tstruct latency_record *lat)\n{\n\tstruct stack_trace trace;\n\n\tmemset(&trace, 0, sizeof(trace));\n\ttrace.max_entries = LT_BACKTRACEDEPTH;\n\ttrace.entries = &lat->backtrace[0];\n\tsave_stack_trace_tsk(tsk, &trace);\n}"
  },
  {
    "function_name": "account_global_scheduler_latency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "92-142",
    "snippet": "static void __sched\naccount_global_scheduler_latency(struct task_struct *tsk,\n\t\t\t\t struct latency_record *lat)\n{\n\tint firstnonnull = MAXLR + 1;\n\tint i;\n\n\tif (!latencytop_enabled)\n\t\treturn;\n\n\t/* skip kernel threads for now */\n\tif (!tsk->mm)\n\t\treturn;\n\n\tfor (i = 0; i < MAXLR; i++) {\n\t\tint q, same = 1;\n\n\t\t/* Nothing stored: */\n\t\tif (!latency_record[i].backtrace[0]) {\n\t\t\tif (firstnonnull > i)\n\t\t\t\tfirstnonnull = i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat->backtrace[q];\n\n\t\t\tif (latency_record[i].backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* 0 and ULONG_MAX entries mean end of backtrace: */\n\t\t\tif (record == 0 || record == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tlatency_record[i].count++;\n\t\t\tlatency_record[i].time += lat->time;\n\t\t\tif (lat->time > latency_record[i].max)\n\t\t\t\tlatency_record[i].max = lat->time;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ti = firstnonnull;\n\tif (i >= MAXLR - 1)\n\t\treturn;\n\n\t/* Allocted a new one: */\n\tmemcpy(&latency_record[i], lat, sizeof(struct latency_record));\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [
      "#define MAXLR 128"
    ],
    "globals_used": [
      "static struct latency_record latency_record[MAXLR];",
      "int latencytop_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&latency_record[i]",
            "lat",
            "sizeof(struct latency_record)"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\n#define MAXLR 128\n\nstatic struct latency_record latency_record[MAXLR];\nint latencytop_enabled;\n\nstatic void __sched\naccount_global_scheduler_latency(struct task_struct *tsk,\n\t\t\t\t struct latency_record *lat)\n{\n\tint firstnonnull = MAXLR + 1;\n\tint i;\n\n\tif (!latencytop_enabled)\n\t\treturn;\n\n\t/* skip kernel threads for now */\n\tif (!tsk->mm)\n\t\treturn;\n\n\tfor (i = 0; i < MAXLR; i++) {\n\t\tint q, same = 1;\n\n\t\t/* Nothing stored: */\n\t\tif (!latency_record[i].backtrace[0]) {\n\t\t\tif (firstnonnull > i)\n\t\t\t\tfirstnonnull = i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat->backtrace[q];\n\n\t\t\tif (latency_record[i].backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* 0 and ULONG_MAX entries mean end of backtrace: */\n\t\t\tif (record == 0 || record == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tlatency_record[i].count++;\n\t\t\tlatency_record[i].time += lat->time;\n\t\t\tif (lat->time > latency_record[i].max)\n\t\t\t\tlatency_record[i].max = lat->time;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ti = firstnonnull;\n\tif (i >= MAXLR - 1)\n\t\treturn;\n\n\t/* Allocted a new one: */\n\tmemcpy(&latency_record[i], lat, sizeof(struct latency_record));\n}"
  },
  {
    "function_name": "clear_global_latency_tracing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "83-90",
    "snippet": "static void clear_global_latency_tracing(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\tmemset(&latency_record, 0, sizeof(latency_record));\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(latency_lock);",
      "static struct latency_record latency_record[MAXLR];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&latency_lock",
            "flags"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&latency_record",
            "0",
            "sizeof(latency_record)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&latency_lock",
            "flags"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic DEFINE_RAW_SPINLOCK(latency_lock);\nstatic struct latency_record latency_record[MAXLR];\n\nstatic void clear_global_latency_tracing(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\tmemset(&latency_record, 0, sizeof(latency_record));\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}"
  },
  {
    "function_name": "clear_all_latency_tracing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/latencytop.c",
    "lines": "70-81",
    "snippet": "void clear_all_latency_tracing(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tif (!latencytop_enabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\tmemset(&p->latency_record, 0, sizeof(p->latency_record));\n\tp->latency_record_count = 0;\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}",
    "includes": [
      "#include <linux/stacktrace.h>",
      "#include <linux/list.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/export.h>",
      "#include <linux/latencytop.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/notifier.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(latency_lock);",
      "static struct latency_record latency_record[MAXLR];",
      "int latencytop_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&latency_lock",
            "flags"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&p->latency_record",
            "0",
            "sizeof(p->latency_record)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&latency_lock",
            "flags"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic DEFINE_RAW_SPINLOCK(latency_lock);\nstatic struct latency_record latency_record[MAXLR];\nint latencytop_enabled;\n\nvoid clear_all_latency_tracing(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tif (!latencytop_enabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\tmemset(&p->latency_record, 0, sizeof(p->latency_record));\n\tp->latency_record_count = 0;\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}"
  }
]