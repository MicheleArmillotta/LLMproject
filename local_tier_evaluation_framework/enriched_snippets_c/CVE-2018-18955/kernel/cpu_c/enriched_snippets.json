[
  {
    "function_name": "boot_cpu_hotplug_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2300-2306",
    "snippet": "void __init boot_cpu_hotplug_init(void)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_write(cpuhp_state.booted_once, true);\n#endif\n\tthis_cpu_write(cpuhp_state.state, CPUHP_ONLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "cpuhp_state.state",
            "CPUHP_ONLINE"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "cpuhp_state.booted_once",
            "true"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid __init boot_cpu_hotplug_init(void)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_write(cpuhp_state.booted_once, true);\n#endif\n\tthis_cpu_write(cpuhp_state.state, CPUHP_ONLINE);\n}"
  },
  {
    "function_name": "boot_cpu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2282-2295",
    "snippet": "void __init boot_cpu_init(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/* Mark the boot cpu \"present\", \"online\" etc for SMP and UP case */\n\tset_cpu_online(cpu, true);\n\tset_cpu_active(cpu, true);\n\tset_cpu_present(cpu, true);\n\tset_cpu_possible(cpu, true);\n\n#ifdef CONFIG_SMP\n\t__boot_cpu_id = cpu;\n#endif\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpu_possible",
          "args": [
            "cpu",
            "true"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_present",
          "args": [
            "cpu",
            "true"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_active",
          "args": [
            "cpu",
            "true"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_online",
          "args": [
            "cpu",
            "true"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __init boot_cpu_init(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/* Mark the boot cpu \"present\", \"online\" etc for SMP and UP case */\n\tset_cpu_online(cpu, true);\n\tset_cpu_active(cpu, true);\n\tset_cpu_present(cpu, true);\n\tset_cpu_possible(cpu, true);\n\n#ifdef CONFIG_SMP\n\t__boot_cpu_id = cpu;\n#endif\n}"
  },
  {
    "function_name": "init_cpu_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2274-2277",
    "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask __cpu_online_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&__cpu_online_mask",
            "src"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
  },
  {
    "function_name": "init_cpu_possible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2269-2272",
    "snippet": "void init_cpu_possible(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_possible_mask, src);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&__cpu_possible_mask",
            "src"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid init_cpu_possible(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_possible_mask, src);\n}"
  },
  {
    "function_name": "init_cpu_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2264-2267",
    "snippet": "void init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask __cpu_present_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&__cpu_present_mask",
            "src"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_present_mask;\n\nvoid init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}"
  },
  {
    "function_name": "cpuhp_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2192-2215",
    "snippet": "static int __init cpuhp_sysfs_init(void)\n{\n\tint cpu, ret;\n\n\tret = cpu_smt_state_init();\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t &cpuhp_cpu_root_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = get_cpu_device(cpu);\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tret = sysfs_create_group(&dev->kobj, &cpuhp_cpu_attr_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&dev->kobj",
            "&cpuhp_cpu_attr_group"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&cpu_subsys.dev_root->kobj",
            "&cpuhp_cpu_root_attr_group"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_smt_state_init",
          "args": [],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_state_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2189-2189",
          "snippet": "static inline int cpu_smt_state_init(void) { return 0; }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline int cpu_smt_state_init(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int __init cpuhp_sysfs_init(void)\n{\n\tint cpu, ret;\n\n\tret = cpu_smt_state_init();\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t &cpuhp_cpu_root_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = get_cpu_device(cpu);\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tret = sysfs_create_group(&dev->kobj, &cpuhp_cpu_attr_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_smt_state_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2189-2189",
    "snippet": "static inline int cpu_smt_state_init(void) { return 0; }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline int cpu_smt_state_init(void) { return 0; }"
  },
  {
    "function_name": "cpu_smt_state_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2182-2186",
    "snippet": "static int __init cpu_smt_state_init(void)\n{\n\treturn sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t  &cpuhp_smt_attr_group);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&cpu_subsys.dev_root->kobj",
            "&cpuhp_smt_attr_group"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int __init cpu_smt_state_init(void)\n{\n\treturn sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t  &cpuhp_smt_attr_group);\n}"
  },
  {
    "function_name": "show_smt_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2161-2167",
    "snippet": "static ssize_t\nshow_smt_active(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tbool active = topology_max_smt_threads() > 1;\n\n\treturn snprintf(buf, PAGE_SIZE - 2, \"%d\\n\", active);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE - 2",
            "\"%d\\n\"",
            "active"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "topology_max_smt_threads",
          "args": [],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic ssize_t\nshow_smt_active(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tbool active = topology_max_smt_threads() > 1;\n\n\treturn snprintf(buf, PAGE_SIZE - 2, \"%d\\n\", active);\n}"
  },
  {
    "function_name": "store_smt_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2119-2158",
    "snippet": "static ssize_t\nstore_smt_control(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tint ctrlval, ret;\n\n\tif (sysfs_streq(buf, \"on\"))\n\t\tctrlval = CPU_SMT_ENABLED;\n\telse if (sysfs_streq(buf, \"off\"))\n\t\tctrlval = CPU_SMT_DISABLED;\n\telse if (sysfs_streq(buf, \"forceoff\"))\n\t\tctrlval = CPU_SMT_FORCE_DISABLED;\n\telse\n\t\treturn -EINVAL;\n\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED)\n\t\treturn -EPERM;\n\n\tif (cpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctrlval != cpu_smt_control) {\n\t\tswitch (ctrlval) {\n\t\tcase CPU_SMT_ENABLED:\n\t\t\tret = cpuhp_smt_enable();\n\t\t\tbreak;\n\t\tcase CPU_SMT_DISABLED:\n\t\tcase CPU_SMT_FORCE_DISABLED:\n\t\t\tret = cpuhp_smt_disable(ctrlval);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tunlock_device_hotplug();\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_smt_disable",
          "args": [
            "ctrlval"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_smt_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2064-2096",
          "snippet": "static int cpuhp_smt_disable(enum cpuhp_smt_control ctrlval)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tfor_each_online_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu))\n\t\t\tcontinue;\n\t\tret = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * As this needs to hold the cpu maps lock it's impossible\n\t\t * to call device_offline() because that ends up calling\n\t\t * cpu_down() which takes cpu maps lock. cpu maps lock\n\t\t * needs to be held as this might race against in kernel\n\t\t * abusers of the hotplug machinery (thermal management).\n\t\t *\n\t\t * So nothing would update device:offline state. That would\n\t\t * leave the sysfs entry stale and prevent onlining after\n\t\t * smt control has been changed to 'off' again. This is\n\t\t * called under the sysfs hotplug lock, so it is properly\n\t\t * serialized against the regular offline usage.\n\t\t */\n\t\tcpuhp_offline_cpu_device(cpu);\n\t}\n\tif (!ret) {\n\t\tcpu_smt_control = ctrlval;\n\t\tarch_smt_update();\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int cpuhp_smt_disable(enum cpuhp_smt_control ctrlval)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tfor_each_online_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu))\n\t\t\tcontinue;\n\t\tret = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * As this needs to hold the cpu maps lock it's impossible\n\t\t * to call device_offline() because that ends up calling\n\t\t * cpu_down() which takes cpu maps lock. cpu maps lock\n\t\t * needs to be held as this might race against in kernel\n\t\t * abusers of the hotplug machinery (thermal management).\n\t\t *\n\t\t * So nothing would update device:offline state. That would\n\t\t * leave the sysfs entry stale and prevent onlining after\n\t\t * smt control has been changed to 'off' again. This is\n\t\t * called under the sysfs hotplug lock, so it is properly\n\t\t * serialized against the regular offline usage.\n\t\t */\n\t\tcpuhp_offline_cpu_device(cpu);\n\t}\n\tif (!ret) {\n\t\tcpu_smt_control = ctrlval;\n\t\tarch_smt_update();\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_smt_enable",
          "args": [],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_smt_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2098-2117",
          "snippet": "static int cpuhp_smt_enable(void)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tcpu_smt_control = CPU_SMT_ENABLED;\n\tarch_smt_update();\n\tfor_each_present_cpu(cpu) {\n\t\t/* Skip online CPUs and CPUs on offline nodes */\n\t\tif (cpu_online(cpu) || !node_online(cpu_to_node(cpu)))\n\t\t\tcontinue;\n\t\tret = _cpu_up(cpu, 0, CPUHP_ONLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* See comment in cpuhp_smt_disable() */\n\t\tcpuhp_online_cpu_device(cpu);\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int cpuhp_smt_enable(void)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tcpu_smt_control = CPU_SMT_ENABLED;\n\tarch_smt_update();\n\tfor_each_present_cpu(cpu) {\n\t\t/* Skip online CPUs and CPUs on offline nodes */\n\t\tif (cpu_online(cpu) || !node_online(cpu_to_node(cpu)))\n\t\t\tcontinue;\n\t\tret = _cpu_up(cpu, 0, CPUHP_ONLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* See comment in cpuhp_smt_disable() */\n\t\tcpuhp_online_cpu_device(cpu);\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug_sysfs",
          "args": [],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "buf",
            "\"forceoff\""
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "buf",
            "\"off\""
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "buf",
            "\"on\""
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic ssize_t\nstore_smt_control(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tint ctrlval, ret;\n\n\tif (sysfs_streq(buf, \"on\"))\n\t\tctrlval = CPU_SMT_ENABLED;\n\telse if (sysfs_streq(buf, \"off\"))\n\t\tctrlval = CPU_SMT_DISABLED;\n\telse if (sysfs_streq(buf, \"forceoff\"))\n\t\tctrlval = CPU_SMT_FORCE_DISABLED;\n\telse\n\t\treturn -EINVAL;\n\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED)\n\t\treturn -EPERM;\n\n\tif (cpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctrlval != cpu_smt_control) {\n\t\tswitch (ctrlval) {\n\t\tcase CPU_SMT_ENABLED:\n\t\t\tret = cpuhp_smt_enable();\n\t\t\tbreak;\n\t\tcase CPU_SMT_DISABLED:\n\t\tcase CPU_SMT_FORCE_DISABLED:\n\t\t\tret = cpuhp_smt_disable(ctrlval);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tunlock_device_hotplug();\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "cpuhp_smt_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2098-2117",
    "snippet": "static int cpuhp_smt_enable(void)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tcpu_smt_control = CPU_SMT_ENABLED;\n\tarch_smt_update();\n\tfor_each_present_cpu(cpu) {\n\t\t/* Skip online CPUs and CPUs on offline nodes */\n\t\tif (cpu_online(cpu) || !node_online(cpu_to_node(cpu)))\n\t\t\tcontinue;\n\t\tret = _cpu_up(cpu, 0, CPUHP_ONLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* See comment in cpuhp_smt_disable() */\n\t\tcpuhp_online_cpu_device(cpu);\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "270-273",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_online_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_online_cpu_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2049-2056",
          "snippet": "static void cpuhp_online_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = false;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void cpuhp_online_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = false;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cpu_up",
          "args": [
            "cpu",
            "0",
            "CPUHP_ONLINE"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1087-1143",
          "snippet": "static int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of do_cpu_up might have raced with another\n\t * caller. Ignore it for now.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of do_cpu_up might have raced with another\n\t * caller. Ignore it for now.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "cpu_to_node(cpu)"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_smt_update",
          "args": [],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "arch_smt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2062-2062",
          "snippet": "void __weak arch_smt_update(void) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __weak arch_smt_update(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "265-268",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int cpuhp_smt_enable(void)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tcpu_smt_control = CPU_SMT_ENABLED;\n\tarch_smt_update();\n\tfor_each_present_cpu(cpu) {\n\t\t/* Skip online CPUs and CPUs on offline nodes */\n\t\tif (cpu_online(cpu) || !node_online(cpu_to_node(cpu)))\n\t\t\tcontinue;\n\t\tret = _cpu_up(cpu, 0, CPUHP_ONLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* See comment in cpuhp_smt_disable() */\n\t\tcpuhp_online_cpu_device(cpu);\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_smt_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2064-2096",
    "snippet": "static int cpuhp_smt_disable(enum cpuhp_smt_control ctrlval)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tfor_each_online_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu))\n\t\t\tcontinue;\n\t\tret = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * As this needs to hold the cpu maps lock it's impossible\n\t\t * to call device_offline() because that ends up calling\n\t\t * cpu_down() which takes cpu maps lock. cpu maps lock\n\t\t * needs to be held as this might race against in kernel\n\t\t * abusers of the hotplug machinery (thermal management).\n\t\t *\n\t\t * So nothing would update device:offline state. That would\n\t\t * leave the sysfs entry stale and prevent onlining after\n\t\t * smt control has been changed to 'off' again. This is\n\t\t * called under the sysfs hotplug lock, so it is properly\n\t\t * serialized against the regular offline usage.\n\t\t */\n\t\tcpuhp_offline_cpu_device(cpu);\n\t}\n\tif (!ret) {\n\t\tcpu_smt_control = ctrlval;\n\t\tarch_smt_update();\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "270-273",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_smt_update",
          "args": [],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "arch_smt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2062-2062",
          "snippet": "void __weak arch_smt_update(void) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __weak arch_smt_update(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_offline_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_offline_cpu_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2040-2047",
          "snippet": "static void cpuhp_offline_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = true;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void cpuhp_offline_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = true;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_down_maps_locked",
          "args": [
            "cpu",
            "CPUHP_OFFLINE"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_down_maps_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1017-1022",
          "snippet": "static int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "topology_is_primary_thread",
          "args": [
            "cpu"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "265-268",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int cpuhp_smt_disable(enum cpuhp_smt_control ctrlval)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tfor_each_online_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu))\n\t\t\tcontinue;\n\t\tret = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * As this needs to hold the cpu maps lock it's impossible\n\t\t * to call device_offline() because that ends up calling\n\t\t * cpu_down() which takes cpu maps lock. cpu maps lock\n\t\t * needs to be held as this might race against in kernel\n\t\t * abusers of the hotplug machinery (thermal management).\n\t\t *\n\t\t * So nothing would update device:offline state. That would\n\t\t * leave the sysfs entry stale and prevent onlining after\n\t\t * smt control has been changed to 'off' again. This is\n\t\t * called under the sysfs hotplug lock, so it is properly\n\t\t * serialized against the regular offline usage.\n\t\t */\n\t\tcpuhp_offline_cpu_device(cpu);\n\t}\n\tif (!ret) {\n\t\tcpu_smt_control = ctrlval;\n\t\tarch_smt_update();\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}"
  },
  {
    "function_name": "arch_smt_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2062-2062",
    "snippet": "void __weak arch_smt_update(void) { }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __weak arch_smt_update(void) { }"
  },
  {
    "function_name": "cpuhp_online_cpu_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2049-2056",
    "snippet": "static void cpuhp_online_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = false;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&dev->kobj",
            "KOBJ_ONLINE"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void cpuhp_online_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = false;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n}"
  },
  {
    "function_name": "cpuhp_offline_cpu_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2040-2047",
    "snippet": "static void cpuhp_offline_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = true;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&dev->kobj",
            "KOBJ_OFFLINE"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void cpuhp_offline_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = true;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n}"
  },
  {
    "function_name": "show_smt_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "2034-2038",
    "snippet": "static ssize_t\nshow_smt_control(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE - 2, \"%s\\n\", smt_states[cpu_smt_control]);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE - 2",
            "\"%s\\n\"",
            "smt_states[cpu_smt_control]"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic ssize_t\nshow_smt_control(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE - 2, \"%s\\n\", smt_states[cpu_smt_control]);\n}"
  },
  {
    "function_name": "show_cpuhp_states",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1993-2011",
    "snippet": "static ssize_t show_cpuhp_states(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tssize_t cur, res = 0;\n\tint i;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tfor (i = CPUHP_OFFLINE; i <= CPUHP_ONLINE; i++) {\n\t\tstruct cpuhp_step *sp = cpuhp_get_step(i);\n\n\t\tif (sp->name) {\n\t\t\tcur = sprintf(buf, \"%3d: %s\\n\", i, sp->name);\n\t\t\tbuf += cur;\n\t\t\tres += cur;\n\t\t}\n\t}\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn res;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%3d: %s\\n\"",
            "i",
            "sp->name"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "i"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nstatic ssize_t show_cpuhp_states(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tssize_t cur, res = 0;\n\tint i;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tfor (i = CPUHP_OFFLINE; i <= CPUHP_ONLINE; i++) {\n\t\tstruct cpuhp_step *sp = cpuhp_get_step(i);\n\n\t\tif (sp->name) {\n\t\t\tcur = sprintf(buf, \"%3d: %s\\n\", i, sp->name);\n\t\t\tbuf += cur;\n\t\t\tres += cur;\n\t\t}\n\t}\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn res;\n}"
  },
  {
    "function_name": "show_cpuhp_fail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1970-1976",
    "snippet": "static ssize_t show_cpuhp_fail(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->fail);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "st->fail"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic ssize_t show_cpuhp_fail(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->fail);\n}"
  },
  {
    "function_name": "write_cpuhp_fail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1936-1968",
    "snippet": "static ssize_t write_cpuhp_fail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\tstruct cpuhp_step *sp;\n\tint fail, ret;\n\n\tret = kstrtoint(buf, 10, &fail);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Cannot fail STARTING/DYING callbacks.\n\t */\n\tif (cpuhp_is_atomic_state(fail))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Cannot fail anything that doesn't have callbacks.\n\t */\n\tmutex_lock(&cpuhp_state_mutex);\n\tsp = cpuhp_get_step(fail);\n\tif (!sp->startup.single && !sp->teardown.single)\n\t\tret = -EINVAL;\n\tmutex_unlock(&cpuhp_state_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tst->fail = fail;\n\n\treturn count;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "fail"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_is_atomic_state",
          "args": [
            "fail"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_is_atomic_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "251-254",
          "snippet": "static bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "10",
            "&fail"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nstatic ssize_t write_cpuhp_fail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\tstruct cpuhp_step *sp;\n\tint fail, ret;\n\n\tret = kstrtoint(buf, 10, &fail);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Cannot fail STARTING/DYING callbacks.\n\t */\n\tif (cpuhp_is_atomic_state(fail))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Cannot fail anything that doesn't have callbacks.\n\t */\n\tmutex_lock(&cpuhp_state_mutex);\n\tsp = cpuhp_get_step(fail);\n\tif (!sp->startup.single && !sp->teardown.single)\n\t\tret = -EINVAL;\n\tmutex_unlock(&cpuhp_state_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tst->fail = fail;\n\n\treturn count;\n}"
  },
  {
    "function_name": "show_cpuhp_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1926-1932",
    "snippet": "static ssize_t show_cpuhp_target(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->target);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "st->target"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic ssize_t show_cpuhp_target(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->target);\n}"
  },
  {
    "function_name": "write_cpuhp_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1886-1924",
    "snippet": "static ssize_t write_cpuhp_target(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\tstruct cpuhp_step *sp;\n\tint target, ret;\n\n\tret = kstrtoint(buf, 10, &target);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_CPU_HOTPLUG_STATE_CONTROL\n\tif (target < CPUHP_OFFLINE || target > CPUHP_ONLINE)\n\t\treturn -EINVAL;\n#else\n\tif (target != CPUHP_OFFLINE && target != CPUHP_ONLINE)\n\t\treturn -EINVAL;\n#endif\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tsp = cpuhp_get_step(target);\n\tret = !sp->name || sp->cant_stop ? -EINVAL : 0;\n\tmutex_unlock(&cpuhp_state_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tif (st->state < target)\n\t\tret = do_cpu_up(dev->id, target);\n\telse\n\t\tret = do_cpu_down(dev->id, target);\nout:\n\tunlock_device_hotplug();\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_cpu_down",
          "args": [
            "dev->id",
            "target"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpu_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1024-1032",
          "snippet": "static int do_cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int do_cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cpu_up",
          "args": [
            "dev->id",
            "target"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1145-1177",
          "snippet": "static int do_cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int do_cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "target"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug_sysfs",
          "args": [],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "10",
            "&target"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nstatic ssize_t write_cpuhp_target(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\tstruct cpuhp_step *sp;\n\tint target, ret;\n\n\tret = kstrtoint(buf, 10, &target);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_CPU_HOTPLUG_STATE_CONTROL\n\tif (target < CPUHP_OFFLINE || target > CPUHP_ONLINE)\n\t\treturn -EINVAL;\n#else\n\tif (target != CPUHP_OFFLINE && target != CPUHP_ONLINE)\n\t\treturn -EINVAL;\n#endif\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tsp = cpuhp_get_step(target);\n\tret = !sp->name || sp->cant_stop ? -EINVAL : 0;\n\tmutex_unlock(&cpuhp_state_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tif (st->state < target)\n\t\tret = do_cpu_up(dev->id, target);\n\telse\n\t\tret = do_cpu_down(dev->id, target);\nout:\n\tunlock_device_hotplug();\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "show_cpuhp_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1877-1883",
    "snippet": "static ssize_t show_cpuhp_state(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->state);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "st->state"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic ssize_t show_cpuhp_state(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->state);\n}"
  },
  {
    "function_name": "__cpuhp_remove_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1868-1873",
    "snippet": "void __cpuhp_remove_state(enum cpuhp_state state, bool invoke)\n{\n\tcpus_read_lock();\n\t__cpuhp_remove_state_cpuslocked(state, invoke);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpuhp_remove_state_cpuslocked",
          "args": [
            "state",
            "invoke"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_remove_state_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1830-1865",
          "snippet": "void __cpuhp_remove_state_cpuslocked(enum cpuhp_state state, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tif (sp->multi_instance) {\n\t\tWARN(!hlist_empty(&sp->list),\n\t\t     \"Error: Removing state %d which has instances left.\\n\",\n\t\t     state);\n\t\tgoto remove;\n\t}\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, NULL);\n\t}\nremove:\n\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\tmutex_unlock(&cpuhp_state_mutex);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static DEFINE_MUTEX(cpuhp_state_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nvoid __cpuhp_remove_state_cpuslocked(enum cpuhp_state state, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tif (sp->multi_instance) {\n\t\tWARN(!hlist_empty(&sp->list),\n\t\t     \"Error: Removing state %d which has instances left.\\n\",\n\t\t     state);\n\t\tgoto remove;\n\t}\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, NULL);\n\t}\nremove:\n\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\tmutex_unlock(&cpuhp_state_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid __cpuhp_remove_state(enum cpuhp_state state, bool invoke)\n{\n\tcpus_read_lock();\n\t__cpuhp_remove_state_cpuslocked(state, invoke);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "__cpuhp_remove_state_cpuslocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1830-1865",
    "snippet": "void __cpuhp_remove_state_cpuslocked(enum cpuhp_state state, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tif (sp->multi_instance) {\n\t\tWARN(!hlist_empty(&sp->list),\n\t\t     \"Error: Removing state %d which has instances left.\\n\",\n\t\t     state);\n\t\tgoto remove;\n\t}\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, NULL);\n\t}\nremove:\n\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\tmutex_unlock(&cpuhp_state_mutex);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_store_callbacks",
          "args": [
            "state",
            "NULL",
            "NULL",
            "NULL",
            "false"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_store_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1534-1569",
          "snippet": "static int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "false",
            "NULL"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1580-1607",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_teardown_cb",
          "args": [
            "state"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_teardown_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1571-1574",
          "snippet": "static void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!hlist_empty(&sp->list)",
            "\"Error: Removing state %d which has instances left.\\n\"",
            "state"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&sp->list"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpuhp_cb_check(state)"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_cb_check",
          "args": [
            "state"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_cb_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1496-1501",
          "snippet": "static int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nvoid __cpuhp_remove_state_cpuslocked(enum cpuhp_state state, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tif (sp->multi_instance) {\n\t\tWARN(!hlist_empty(&sp->list),\n\t\t     \"Error: Removing state %d which has instances left.\\n\",\n\t\t     state);\n\t\tgoto remove;\n\t}\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, NULL);\n\t}\nremove:\n\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\tmutex_unlock(&cpuhp_state_mutex);\n}"
  },
  {
    "function_name": "__cpuhp_state_remove_instance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1782-1817",
    "snippet": "int __cpuhp_state_remove_instance(enum cpuhp_state state,\n\t\t\t\t  struct hlist_node *node, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tif (!sp->multi_instance)\n\t\treturn -EINVAL;\n\n\tcpus_read_lock();\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n\nremove:\n\thlist_del(node);\n\tmutex_unlock(&cpuhp_state_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "node"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "false",
            "node"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1580-1607",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_teardown_cb",
          "args": [
            "state"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_teardown_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1571-1574",
          "snippet": "static void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpuhp_cb_check(state)"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_cb_check",
          "args": [
            "state"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_cb_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1496-1501",
          "snippet": "static int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_state_remove_instance(enum cpuhp_state state,\n\t\t\t\t  struct hlist_node *node, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tif (!sp->multi_instance)\n\t\treturn -EINVAL;\n\n\tcpus_read_lock();\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n\nremove:\n\thlist_del(node);\n\tmutex_unlock(&cpuhp_state_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__cpuhp_setup_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1766-1779",
    "snippet": "int __cpuhp_setup_state(enum cpuhp_state state,\n\t\t\tconst char *name, bool invoke,\n\t\t\tint (*startup)(unsigned int cpu),\n\t\t\tint (*teardown)(unsigned int cpu),\n\t\t\tbool multi_instance)\n{\n\tint ret;\n\n\tcpus_read_lock();\n\tret = __cpuhp_setup_state_cpuslocked(state, name, invoke, startup,\n\t\t\t\t\t     teardown, multi_instance);\n\tcpus_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpuhp_setup_state_cpuslocked",
          "args": [
            "state",
            "name",
            "invoke",
            "startup",
            "teardown",
            "multi_instance"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_setup_state_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1707-1763",
          "snippet": "int __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,\n\t\t\t\t   const char *name, bool invoke,\n\t\t\t\t   int (*startup)(unsigned int cpu),\n\t\t\t\t   int (*teardown)(unsigned int cpu),\n\t\t\t\t   bool multi_instance)\n{\n\tint cpu, ret = 0;\n\tbool dynstate;\n\n\tlockdep_assert_cpus_held();\n\n\tif (cpuhp_cb_check(state) || !name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tret = cpuhp_store_callbacks(state, name, startup, teardown,\n\t\t\t\t    multi_instance);\n\n\tdynstate = state == CPUHP_AP_ONLINE_DYN;\n\tif (ret > 0 && dynstate) {\n\t\tstate = ret;\n\t\tret = 0;\n\t}\n\n\tif (ret || !invoke || !startup)\n\t\tgoto out;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, NULL);\n\t\tif (ret) {\n\t\t\tif (teardown)\n\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);\n\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&cpuhp_state_mutex);\n\t/*\n\t * If the requested state is CPUHP_AP_ONLINE_DYN, return the\n\t * dynamically allocated state in case of success.\n\t */\n\tif (!ret && dynstate)\n\t\treturn state;\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static DEFINE_MUTEX(cpuhp_state_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,\n\t\t\t\t   const char *name, bool invoke,\n\t\t\t\t   int (*startup)(unsigned int cpu),\n\t\t\t\t   int (*teardown)(unsigned int cpu),\n\t\t\t\t   bool multi_instance)\n{\n\tint cpu, ret = 0;\n\tbool dynstate;\n\n\tlockdep_assert_cpus_held();\n\n\tif (cpuhp_cb_check(state) || !name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tret = cpuhp_store_callbacks(state, name, startup, teardown,\n\t\t\t\t    multi_instance);\n\n\tdynstate = state == CPUHP_AP_ONLINE_DYN;\n\tif (ret > 0 && dynstate) {\n\t\tstate = ret;\n\t\tret = 0;\n\t}\n\n\tif (ret || !invoke || !startup)\n\t\tgoto out;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, NULL);\n\t\tif (ret) {\n\t\t\tif (teardown)\n\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);\n\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&cpuhp_state_mutex);\n\t/*\n\t * If the requested state is CPUHP_AP_ONLINE_DYN, return the\n\t * dynamically allocated state in case of success.\n\t */\n\tif (!ret && dynstate)\n\t\treturn state;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nint __cpuhp_setup_state(enum cpuhp_state state,\n\t\t\tconst char *name, bool invoke,\n\t\t\tint (*startup)(unsigned int cpu),\n\t\t\tint (*teardown)(unsigned int cpu),\n\t\t\tbool multi_instance)\n{\n\tint ret;\n\n\tcpus_read_lock();\n\tret = __cpuhp_setup_state_cpuslocked(state, name, invoke, startup,\n\t\t\t\t\t     teardown, multi_instance);\n\tcpus_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "__cpuhp_setup_state_cpuslocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1707-1763",
    "snippet": "int __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,\n\t\t\t\t   const char *name, bool invoke,\n\t\t\t\t   int (*startup)(unsigned int cpu),\n\t\t\t\t   int (*teardown)(unsigned int cpu),\n\t\t\t\t   bool multi_instance)\n{\n\tint cpu, ret = 0;\n\tbool dynstate;\n\n\tlockdep_assert_cpus_held();\n\n\tif (cpuhp_cb_check(state) || !name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tret = cpuhp_store_callbacks(state, name, startup, teardown,\n\t\t\t\t    multi_instance);\n\n\tdynstate = state == CPUHP_AP_ONLINE_DYN;\n\tif (ret > 0 && dynstate) {\n\t\tstate = ret;\n\t\tret = 0;\n\t}\n\n\tif (ret || !invoke || !startup)\n\t\tgoto out;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, NULL);\n\t\tif (ret) {\n\t\t\tif (teardown)\n\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);\n\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&cpuhp_state_mutex);\n\t/*\n\t * If the requested state is CPUHP_AP_ONLINE_DYN, return the\n\t * dynamically allocated state in case of success.\n\t */\n\tif (!ret && dynstate)\n\t\treturn state;\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_store_callbacks",
          "args": [
            "state",
            "NULL",
            "NULL",
            "NULL",
            "false"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_store_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1534-1569",
          "snippet": "static int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_rollback_install",
          "args": [
            "cpu",
            "state",
            "NULL"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_rollback_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1614-1631",
          "snippet": "static void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "true",
            "NULL"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1580-1607",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_cb_check",
          "args": [
            "state"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_cb_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1496-1501",
          "snippet": "static int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,\n\t\t\t\t   const char *name, bool invoke,\n\t\t\t\t   int (*startup)(unsigned int cpu),\n\t\t\t\t   int (*teardown)(unsigned int cpu),\n\t\t\t\t   bool multi_instance)\n{\n\tint cpu, ret = 0;\n\tbool dynstate;\n\n\tlockdep_assert_cpus_held();\n\n\tif (cpuhp_cb_check(state) || !name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tret = cpuhp_store_callbacks(state, name, startup, teardown,\n\t\t\t\t    multi_instance);\n\n\tdynstate = state == CPUHP_AP_ONLINE_DYN;\n\tif (ret > 0 && dynstate) {\n\t\tstate = ret;\n\t\tret = 0;\n\t}\n\n\tif (ret || !invoke || !startup)\n\t\tgoto out;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, NULL);\n\t\tif (ret) {\n\t\t\tif (teardown)\n\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);\n\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&cpuhp_state_mutex);\n\t/*\n\t * If the requested state is CPUHP_AP_ONLINE_DYN, return the\n\t * dynamically allocated state in case of success.\n\t */\n\tif (!ret && dynstate)\n\t\treturn state;\n\treturn ret;\n}"
  },
  {
    "function_name": "__cpuhp_state_add_instance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1678-1687",
    "snippet": "int __cpuhp_state_add_instance(enum cpuhp_state state, struct hlist_node *node,\n\t\t\t       bool invoke)\n{\n\tint ret;\n\n\tcpus_read_lock();\n\tret = __cpuhp_state_add_instance_cpuslocked(state, node, invoke);\n\tcpus_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpuhp_state_add_instance_cpuslocked",
          "args": [
            "state",
            "node",
            "invoke"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_state_add_instance_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1633-1676",
          "snippet": "int __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,\n\t\t\t\t\t  struct hlist_node *node,\n\t\t\t\t\t  bool invoke)\n{\n\tstruct cpuhp_step *sp;\n\tint cpu;\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tsp = cpuhp_get_step(state);\n\tif (sp->multi_instance == false)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !sp->startup.multi)\n\t\tgoto add_node;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, node);\n\t\tif (ret) {\n\t\t\tif (sp->teardown.multi)\n\t\t\t\tcpuhp_rollback_install(cpu, state, node);\n\t\t\tgoto unlock;\n\t\t}\n\t}\nadd_node:\n\tret = 0;\n\thlist_add_head(node, &sp->list);\nunlock:\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static DEFINE_MUTEX(cpuhp_state_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,\n\t\t\t\t\t  struct hlist_node *node,\n\t\t\t\t\t  bool invoke)\n{\n\tstruct cpuhp_step *sp;\n\tint cpu;\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tsp = cpuhp_get_step(state);\n\tif (sp->multi_instance == false)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !sp->startup.multi)\n\t\tgoto add_node;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, node);\n\t\tif (ret) {\n\t\t\tif (sp->teardown.multi)\n\t\t\t\tcpuhp_rollback_install(cpu, state, node);\n\t\t\tgoto unlock;\n\t\t}\n\t}\nadd_node:\n\tret = 0;\n\thlist_add_head(node, &sp->list);\nunlock:\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nint __cpuhp_state_add_instance(enum cpuhp_state state, struct hlist_node *node,\n\t\t\t       bool invoke)\n{\n\tint ret;\n\n\tcpus_read_lock();\n\tret = __cpuhp_state_add_instance_cpuslocked(state, node, invoke);\n\tcpus_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "__cpuhp_state_add_instance_cpuslocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1633-1676",
    "snippet": "int __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,\n\t\t\t\t\t  struct hlist_node *node,\n\t\t\t\t\t  bool invoke)\n{\n\tstruct cpuhp_step *sp;\n\tint cpu;\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tsp = cpuhp_get_step(state);\n\tif (sp->multi_instance == false)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !sp->startup.multi)\n\t\tgoto add_node;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, node);\n\t\tif (ret) {\n\t\t\tif (sp->teardown.multi)\n\t\t\t\tcpuhp_rollback_install(cpu, state, node);\n\t\t\tgoto unlock;\n\t\t}\n\t}\nadd_node:\n\tret = 0;\n\thlist_add_head(node, &sp->list);\nunlock:\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "node",
            "&sp->list"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_rollback_install",
          "args": [
            "cpu",
            "state",
            "node"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_rollback_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1614-1631",
          "snippet": "static void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "true",
            "node"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1580-1607",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,\n\t\t\t\t\t  struct hlist_node *node,\n\t\t\t\t\t  bool invoke)\n{\n\tstruct cpuhp_step *sp;\n\tint cpu;\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tsp = cpuhp_get_step(state);\n\tif (sp->multi_instance == false)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !sp->startup.multi)\n\t\tgoto add_node;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, node);\n\t\tif (ret) {\n\t\t\tif (sp->teardown.multi)\n\t\t\t\tcpuhp_rollback_install(cpu, state, node);\n\t\t\tgoto unlock;\n\t\t}\n\t}\nadd_node:\n\tret = 0;\n\thlist_add_head(node, &sp->list);\nunlock:\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_rollback_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1614-1631",
    "snippet": "static void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "false",
            "node"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1580-1607",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}"
  },
  {
    "function_name": "cpuhp_issue_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1580-1607",
    "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret && !bringup"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "node",
            "NULL"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_ap_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "node"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_ap_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "699-748",
          "snippet": "static int\ncpuhp_invoke_ap_callback(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t struct hlist_node *node)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint ret;\n\n\tif (!cpu_online(cpu))\n\t\treturn 0;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\t/*\n\t * If we are up and running, use the hotplug thread. For early calls\n\t * we invoke the thread function directly.\n\t */\n\tif (!st->thread)\n\t\treturn cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->node = node;\n\tst->bringup = bringup;\n\tst->cb_state = state;\n\tst->single = true;\n\n\t__cpuhp_kick_ap(st);\n\n\t/*\n\t * If we failed and did a partial, do a rollback.\n\t */\n\tif ((ret = st->result) && st->last) {\n\t\tst->rollback = true;\n\t\tst->bringup = !bringup;\n\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\t/*\n\t * Clean up the leftovers so the next hotplug operation wont use stale\n\t * data.\n\t */\n\tst->node = st->last = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int\ncpuhp_invoke_ap_callback(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t struct hlist_node *node)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint ret;\n\n\tif (!cpu_online(cpu))\n\t\treturn 0;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\t/*\n\t * If we are up and running, use the hotplug thread. For early calls\n\t * we invoke the thread function directly.\n\t */\n\tif (!st->thread)\n\t\treturn cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->node = node;\n\tst->bringup = bringup;\n\tst->cb_state = state;\n\tst->single = true;\n\n\t__cpuhp_kick_ap(st);\n\n\t/*\n\t * If we failed and did a partial, do a rollback.\n\t */\n\tif ((ret = st->result) && st->last) {\n\t\tst->rollback = true;\n\t\tst->bringup = !bringup;\n\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\t/*\n\t * Clean up the leftovers so the next hotplug operation wont use stale\n\t * data.\n\t */\n\tst->node = st->last = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_is_ap_state",
          "args": [
            "state"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_is_ap_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "227-234",
          "snippet": "static bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif ((bringup && !sp->startup.single) ||\n\t    (!bringup && !sp->teardown.single))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_get_teardown_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1571-1574",
    "snippet": "static void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}"
  },
  {
    "function_name": "cpuhp_store_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1534-1569",
    "snippet": "static int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&sp->list"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_reserve_state",
          "args": [
            "state"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_reserve_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1508-1532",
          "snippet": "static int cpuhp_reserve_state(enum cpuhp_state state)\n{\n\tenum cpuhp_state i, end;\n\tstruct cpuhp_step *step;\n\n\tswitch (state) {\n\tcase CPUHP_AP_ONLINE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;\n\t\tend = CPUHP_AP_ONLINE_DYN_END;\n\t\tbreak;\n\tcase CPUHP_BP_PREPARE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;\n\t\tend = CPUHP_BP_PREPARE_DYN_END;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = state; i <= end; i++, step++) {\n\t\tif (!step->name)\n\t\t\treturn i;\n\t}\n\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic int cpuhp_reserve_state(enum cpuhp_state state)\n{\n\tenum cpuhp_state i, end;\n\tstruct cpuhp_step *step;\n\n\tswitch (state) {\n\tcase CPUHP_AP_ONLINE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;\n\t\tend = CPUHP_AP_ONLINE_DYN_END;\n\t\tbreak;\n\tcase CPUHP_BP_PREPARE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;\n\t\tend = CPUHP_BP_PREPARE_DYN_END;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = state; i <= end; i++, step++) {\n\t\tif (!step->name)\n\t\t\treturn i;\n\t}\n\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_reserve_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1508-1532",
    "snippet": "static int cpuhp_reserve_state(enum cpuhp_state state)\n{\n\tenum cpuhp_state i, end;\n\tstruct cpuhp_step *step;\n\n\tswitch (state) {\n\tcase CPUHP_AP_ONLINE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;\n\t\tend = CPUHP_AP_ONLINE_DYN_END;\n\t\tbreak;\n\tcase CPUHP_BP_PREPARE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;\n\t\tend = CPUHP_BP_PREPARE_DYN_END;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = state; i <= end; i++, step++) {\n\t\tif (!step->name)\n\t\t\treturn i;\n\t}\n\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static struct cpuhp_step cpuhp_hp_states[];",
      "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"No more dynamic states available for CPU hotplug\\n\""
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic int cpuhp_reserve_state(enum cpuhp_state state)\n{\n\tenum cpuhp_state i, end;\n\tstruct cpuhp_step *step;\n\n\tswitch (state) {\n\tcase CPUHP_AP_ONLINE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;\n\t\tend = CPUHP_AP_ONLINE_DYN_END;\n\t\tbreak;\n\tcase CPUHP_BP_PREPARE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;\n\t\tend = CPUHP_BP_PREPARE_DYN_END;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = state; i <= end; i++, step++) {\n\t\tif (!step->name)\n\t\t\treturn i;\n\t}\n\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "cpuhp_cb_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1496-1501",
    "snippet": "static int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_hotplug_pm_sync_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1315-1324",
    "snippet": "static int __init cpu_hotplug_pm_sync_init(void)\n{\n\t/*\n\t * cpu_hotplug_pm_callback has higher priority than x86\n\t * bsp_pm_callback which depends on cpu_hotplug_pm_callback\n\t * to disable cpu hotplug to avoid cpu hotplug race.\n\t */\n\tpm_notifier(cpu_hotplug_pm_callback, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_notifier",
          "args": [
            "cpu_hotplug_pm_callback",
            "0"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int __init cpu_hotplug_pm_sync_init(void)\n{\n\t/*\n\t * cpu_hotplug_pm_callback has higher priority than x86\n\t * bsp_pm_callback which depends on cpu_hotplug_pm_callback\n\t * to disable cpu hotplug to avoid cpu hotplug race.\n\t */\n\tpm_notifier(cpu_hotplug_pm_callback, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_hotplug_pm_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1291-1312",
    "snippet": "static int\ncpu_hotplug_pm_callback(struct notifier_block *nb,\n\t\t\tunsigned long action, void *ptr)\n{\n\tswitch (action) {\n\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\t\tcpu_hotplug_disable();\n\t\tbreak;\n\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\t\tcpu_hotplug_enable();\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_hotplug_enable",
          "args": [],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_hotplug_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "350-355",
          "snippet": "void cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_hotplug_disable",
          "args": [],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_hotplug_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "335-340",
          "snippet": "void cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int\ncpu_hotplug_pm_callback(struct notifier_block *nb,\n\t\t\tunsigned long action, void *ptr)\n{\n\tswitch (action) {\n\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\t\tcpu_hotplug_disable();\n\t\tbreak;\n\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\t\tcpu_hotplug_enable();\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "alloc_frozen_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1272-1277",
    "snippet": "static int __init alloc_frozen_cpus(void)\n{\n\tif (!alloc_cpumask_var(&frozen_cpus, GFP_KERNEL|__GFP_ZERO))\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&frozen_cpus",
            "GFP_KERNEL|__GFP_ZERO"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int __init alloc_frozen_cpus(void)\n{\n\tif (!alloc_cpumask_var(&frozen_cpus, GFP_KERNEL|__GFP_ZERO))\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "enable_nonboot_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1240-1270",
    "snippet": "void enable_nonboot_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_enable_nonboot_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_enable_nonboot_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "270-273",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "frozen_cpus"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enable_nonboot_cpus_end",
          "args": [],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "arch_enable_nonboot_cpus_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1236-1238",
          "snippet": "void __weak arch_enable_nonboot_cpus_end(void)\n{\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __weak arch_enable_nonboot_cpus_end(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Error taking CPU%d up: %d\\n\"",
            "cpu",
            "error"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"CPU%d is up\\n\"",
            "cpu"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"CPU_ON\")",
            "cpu",
            "false"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CPU_ON\""
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cpu_up",
          "args": [
            "cpu",
            "1",
            "CPUHP_ONLINE"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1087-1143",
          "snippet": "static int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of do_cpu_up might have raced with another\n\t * caller. Ignore it for now.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of do_cpu_up might have raced with another\n\t * caller. Ignore it for now.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"CPU_ON\")",
            "cpu",
            "true"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CPU_ON\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "frozen_cpus"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enable_nonboot_cpus_begin",
          "args": [],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "arch_enable_nonboot_cpus_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1232-1234",
          "snippet": "void __weak arch_enable_nonboot_cpus_begin(void)\n{\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __weak arch_enable_nonboot_cpus_begin(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Enabling non-boot CPUs ...\\n\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "frozen_cpus"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpu_hotplug_enable",
          "args": [],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "__cpu_hotplug_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "343-348",
          "snippet": "static void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "265-268",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid enable_nonboot_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_enable_nonboot_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_enable_nonboot_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}"
  },
  {
    "function_name": "arch_enable_nonboot_cpus_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1236-1238",
    "snippet": "void __weak arch_enable_nonboot_cpus_end(void)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __weak arch_enable_nonboot_cpus_end(void)\n{\n}"
  },
  {
    "function_name": "arch_enable_nonboot_cpus_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1232-1234",
    "snippet": "void __weak arch_enable_nonboot_cpus_begin(void)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __weak arch_enable_nonboot_cpus_begin(void)\n{\n}"
  },
  {
    "function_name": "freeze_secondary_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1188-1230",
    "snippet": "int freeze_secondary_cpus(int primary)\n{\n\tint cpu, error = 0;\n\n\tcpu_maps_update_begin();\n\tif (!cpu_online(primary))\n\t\tprimary = cpumask_first(cpu_online_mask);\n\t/*\n\t * We take down all of the non-boot CPUs in one shot to avoid races\n\t * with the userspace trying to use the CPU hotplug at the same time\n\t */\n\tcpumask_clear(frozen_cpus);\n\n\tpr_info(\"Disabling non-boot CPUs ...\\n\");\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu == primary)\n\t\t\tcontinue;\n\t\ttrace_suspend_resume(TPS(\"CPU_OFF\"), cpu, true);\n\t\terror = _cpu_down(cpu, 1, CPUHP_OFFLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_OFF\"), cpu, false);\n\t\tif (!error)\n\t\t\tcpumask_set_cpu(cpu, frozen_cpus);\n\t\telse {\n\t\t\tpr_err(\"Error taking CPU%d down: %d\\n\", cpu, error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!error)\n\t\tBUG_ON(num_online_cpus() > 1);\n\telse\n\t\tpr_err(\"Non-boot CPUs are not disabled\\n\");\n\n\t/*\n\t * Make sure the CPUs won't be enabled by someone else. We need to do\n\t * this even in case of failure as all disable_nonboot_cpus() users are\n\t * supposed to do enable_nonboot_cpus() on the failure path.\n\t */\n\tcpu_hotplug_disabled++;\n\n\tcpu_maps_update_done();\n\treturn error;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "270-273",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Non-boot CPUs are not disabled\\n\""
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_online_cpus() > 1"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error taking CPU%d down: %d\\n\"",
            "cpu",
            "error"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "frozen_cpus"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"CPU_OFF\")",
            "cpu",
            "false"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CPU_OFF\""
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cpu_down",
          "args": [
            "cpu",
            "1",
            "CPUHP_OFFLINE"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "957-1015",
          "snippet": "static int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state == CPUHP_TEARDOWN_CPU && st->state < prev_state) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state == CPUHP_TEARDOWN_CPU && st->state < prev_state) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"CPU_OFF\")",
            "cpu",
            "true"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CPU_OFF\""
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Disabling non-boot CPUs ...\\n\""
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "frozen_cpus"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "primary"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "265-268",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nint freeze_secondary_cpus(int primary)\n{\n\tint cpu, error = 0;\n\n\tcpu_maps_update_begin();\n\tif (!cpu_online(primary))\n\t\tprimary = cpumask_first(cpu_online_mask);\n\t/*\n\t * We take down all of the non-boot CPUs in one shot to avoid races\n\t * with the userspace trying to use the CPU hotplug at the same time\n\t */\n\tcpumask_clear(frozen_cpus);\n\n\tpr_info(\"Disabling non-boot CPUs ...\\n\");\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu == primary)\n\t\t\tcontinue;\n\t\ttrace_suspend_resume(TPS(\"CPU_OFF\"), cpu, true);\n\t\terror = _cpu_down(cpu, 1, CPUHP_OFFLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_OFF\"), cpu, false);\n\t\tif (!error)\n\t\t\tcpumask_set_cpu(cpu, frozen_cpus);\n\t\telse {\n\t\t\tpr_err(\"Error taking CPU%d down: %d\\n\", cpu, error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!error)\n\t\tBUG_ON(num_online_cpus() > 1);\n\telse\n\t\tpr_err(\"Non-boot CPUs are not disabled\\n\");\n\n\t/*\n\t * Make sure the CPUs won't be enabled by someone else. We need to do\n\t * this even in case of failure as all disable_nonboot_cpus() users are\n\t * supposed to do enable_nonboot_cpus() on the failure path.\n\t */\n\tcpu_hotplug_disabled++;\n\n\tcpu_maps_update_done();\n\treturn error;\n}"
  },
  {
    "function_name": "cpu_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1179-1182",
    "snippet": "int cpu_up(unsigned int cpu)\n{\n\treturn do_cpu_up(cpu, CPUHP_ONLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_cpu_up",
          "args": [
            "cpu",
            "CPUHP_ONLINE"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1145-1177",
          "snippet": "static int do_cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int do_cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nint cpu_up(unsigned int cpu)\n{\n\treturn do_cpu_up(cpu, CPUHP_ONLINE);\n}"
  },
  {
    "function_name": "do_cpu_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1145-1177",
    "snippet": "static int do_cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "270-273",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cpu_up",
          "args": [
            "cpu",
            "0",
            "target"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1087-1143",
          "snippet": "static int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of do_cpu_up might have raced with another\n\t * caller. Ignore it for now.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of do_cpu_up might have raced with another\n\t * caller. Ignore it for now.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_smt_allowed",
          "args": [
            "cpu"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "447-447",
          "snippet": "static inline bool cpu_smt_allowed(unsigned int cpu) { return true; }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline bool cpu_smt_allowed(unsigned int cpu) { return true; }"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "265-268",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_online_node",
          "args": [
            "cpu_to_node(cpu)"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"please check additional_cpus= boot parameter\\n\""
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\"",
            "cpu"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_possible",
          "args": [
            "cpu"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2269-2272",
          "snippet": "void init_cpu_possible(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_possible_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid init_cpu_possible(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_possible_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int do_cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}"
  },
  {
    "function_name": "_cpu_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1087-1143",
    "snippet": "static int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of do_cpu_up might have raced with another\n\t * caller. Ignore it for now.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_write_unlock",
          "args": [],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "308-311",
          "snippet": "void cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_up_callbacks",
          "args": [
            "cpu",
            "st",
            "target"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_up_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "576-592",
          "snippet": "static int cpuhp_up_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t      enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\twhile (st->state < target) {\n\t\tst->state++;\n\t\tret = cpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n\t\tif (ret) {\n\t\t\tst->target = prev_state;\n\t\t\tundo_cpu_up(cpu, st);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_up_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t      enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\twhile (st->state < target) {\n\t\tst->state++;\n\t\tret = cpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n\t\tif (ret) {\n\t\t\tst->target = prev_state;\n\t\t\tundo_cpu_up(cpu, st);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(int)target",
            "CPUHP_BRINGUP_CPU"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_kick_ap_work",
          "args": [
            "cpu"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_kick_ap_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "750-767",
          "snippet": "static int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_set_state",
          "args": [
            "st",
            "target"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "450-463",
          "snippet": "static inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = st->state < target;\n\n\treturn prev_state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = st->state < target;\n\n\treturn prev_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "idle"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "idle"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_thread_get",
          "args": [
            "cpu"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "idle_thread_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smpboot.c",
          "lines": "29-37",
          "snippet": "struct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinit_idle(tsk, cpu);\n\treturn tsk;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinit_idle(tsk, cpu);\n\treturn tsk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_present",
          "args": [
            "cpu"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2264-2267",
          "snippet": "void init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_present_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_present_mask;\n\nvoid init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_write_lock",
          "args": [],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "303-306",
          "snippet": "void cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of do_cpu_up might have raced with another\n\t * caller. Ignore it for now.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_online_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1074-1084",
    "snippet": "void cpuhp_online_idle(enum cpuhp_state state)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\t/* Happens for the boot cpu */\n\tif (state != CPUHP_AP_ONLINE_IDLE)\n\t\treturn;\n\n\tst->state = CPUHP_AP_ONLINE_IDLE;\n\tcomplete_ap_thread(st, true);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_ap_thread",
          "args": [
            "st",
            "true"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "complete_ap_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "242-246",
          "snippet": "static inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid cpuhp_online_idle(enum cpuhp_state state)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\t/* Happens for the boot cpu */\n\tif (state != CPUHP_AP_ONLINE_IDLE)\n\t\treturn;\n\n\tst->state = CPUHP_AP_ONLINE_IDLE;\n\tcomplete_ap_thread(st, true);\n}"
  },
  {
    "function_name": "notify_cpu_starting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1051-1067",
    "snippet": "void notify_cpu_starting(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state target = min((int)st->target, CPUHP_AP_ONLINE);\n\tint ret;\n\n\trcu_cpu_starting(cpu);\t/* Enables RCU usage on this CPU. */\n\tst->booted_once = true;\n\twhile (st->state < target) {\n\t\tst->state++;\n\t\tret = cpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n\t\t/*\n\t\t * STARTING must not fail!\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "st->state",
            "true",
            "NULL",
            "NULL"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cpu_starting",
          "args": [
            "cpu"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_starting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3319-3354",
          "snippet": "void rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tint nbits;\n\tunsigned long oldmask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tif (per_cpu(rcu_cpu_started, cpu))\n\t\treturn;\n\n\tper_cpu(rcu_cpu_started, cpu) = 1;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->qsmaskinitnext |= mask;\n\toldmask = rnp->expmaskinitnext;\n\trnp->expmaskinitnext |= mask;\n\toldmask ^= rnp->expmaskinitnext;\n\tnbits = bitmap_weight(&oldmask, BITS_PER_LONG);\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + nbits); /* ^^^ */\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on incoming CPU? */\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static DEFINE_PER_CPU(int, rcu_cpu_started);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic DEFINE_PER_CPU(int, rcu_cpu_started);\n\nvoid rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tint nbits;\n\tunsigned long oldmask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tif (per_cpu(rcu_cpu_started, cpu))\n\t\treturn;\n\n\tper_cpu(rcu_cpu_started, cpu) = 1;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->qsmaskinitnext |= mask;\n\toldmask = rnp->expmaskinitnext;\n\trnp->expmaskinitnext |= mask;\n\toldmask ^= rnp->expmaskinitnext;\n\tnbits = bitmap_weight(&oldmask, BITS_PER_LONG);\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + nbits); /* ^^^ */\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on incoming CPU? */\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(int)st->target",
            "CPUHP_AP_ONLINE"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid notify_cpu_starting(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state target = min((int)st->target, CPUHP_AP_ONLINE);\n\tint ret;\n\n\trcu_cpu_starting(cpu);\t/* Enables RCU usage on this CPU. */\n\tst->booted_once = true;\n\twhile (st->state < target) {\n\t\tst->state++;\n\t\tret = cpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n\t\t/*\n\t\t * STARTING must not fail!\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n}"
  },
  {
    "function_name": "cpu_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1034-1037",
    "snippet": "int cpu_down(unsigned int cpu)\n{\n\treturn do_cpu_down(cpu, CPUHP_OFFLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_cpu_down",
          "args": [
            "cpu",
            "CPUHP_OFFLINE"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpu_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1024-1032",
          "snippet": "static int do_cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int do_cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nint cpu_down(unsigned int cpu)\n{\n\treturn do_cpu_down(cpu, CPUHP_OFFLINE);\n}"
  },
  {
    "function_name": "do_cpu_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1024-1032",
    "snippet": "static int do_cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "270-273",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_down_maps_locked",
          "args": [
            "cpu",
            "target"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_down_maps_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1017-1022",
          "snippet": "static int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "265-268",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int do_cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}"
  },
  {
    "function_name": "cpu_down_maps_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "1017-1022",
    "snippet": "static int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_cpu_down",
          "args": [
            "cpu",
            "0",
            "target"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "957-1015",
          "snippet": "static int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state == CPUHP_TEARDOWN_CPU && st->state < prev_state) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state == CPUHP_TEARDOWN_CPU && st->state < prev_state) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}"
  },
  {
    "function_name": "_cpu_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "957-1015",
    "snippet": "static int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state == CPUHP_TEARDOWN_CPU && st->state < prev_state) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockup_detector_cleanup",
          "args": [],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "631-636",
          "snippet": "void lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nvoid lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_write_unlock",
          "args": [],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "308-311",
          "snippet": "void cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpuhp_kick_ap",
          "args": [
            "st"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_kick_ap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "486-500",
          "snippet": "static void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_reset_state",
          "args": [
            "st",
            "prev_state"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_reset_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "465-483",
          "snippet": "static inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->target = prev_state;\n\tst->bringup = !st->bringup;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->target = prev_state;\n\tst->bringup = !st->bringup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_down_callbacks",
          "args": [
            "cpu",
            "st",
            "target"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_down_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "938-954",
          "snippet": "static int cpuhp_down_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t\tenum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tfor (; st->state > target; st->state--) {\n\t\tret = cpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n\t\tif (ret) {\n\t\t\tst->target = prev_state;\n\t\t\tif (st->state < prev_state)\n\t\t\t\tundo_cpu_down(cpu, st);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_down_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t\tenum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tfor (; st->state > target; st->state--) {\n\t\tret = cpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n\t\tif (ret) {\n\t\t\tst->target = prev_state;\n\t\t\tif (st->state < prev_state)\n\t\t\t\tundo_cpu_down(cpu, st);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_kick_ap_work",
          "args": [
            "cpu"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_kick_ap_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "750-767",
          "snippet": "static int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(int)target",
            "CPUHP_TEARDOWN_CPU"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_set_state",
          "args": [
            "st",
            "target"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "450-463",
          "snippet": "static inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = st->state < target;\n\n\treturn prev_state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = st->state < target;\n\n\treturn prev_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_write_lock",
          "args": [],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "303-306",
          "snippet": "void cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_present",
          "args": [
            "cpu"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2264-2267",
          "snippet": "void init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_present_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_present_mask;\n\nvoid init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state == CPUHP_TEARDOWN_CPU && st->state < prev_state) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_down_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "938-954",
    "snippet": "static int cpuhp_down_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t\tenum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tfor (; st->state > target; st->state--) {\n\t\tret = cpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n\t\tif (ret) {\n\t\t\tst->target = prev_state;\n\t\t\tif (st->state < prev_state)\n\t\t\t\tundo_cpu_down(cpu, st);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "undo_cpu_down",
          "args": [
            "cpu",
            "st"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "undo_cpu_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "932-936",
          "snippet": "static void undo_cpu_down(unsigned int cpu, struct cpuhp_cpu_state *st)\n{\n\tfor (st->state++; st->state < st->target; st->state++)\n\t\tcpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void undo_cpu_down(unsigned int cpu, struct cpuhp_cpu_state *st)\n{\n\tfor (st->state++; st->state < st->target; st->state++)\n\t\tcpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "st->state",
            "false",
            "NULL",
            "NULL"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_down_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t\tenum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tfor (; st->state > target; st->state--) {\n\t\tret = cpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n\t\tif (ret) {\n\t\t\tst->target = prev_state;\n\t\t\tif (st->state < prev_state)\n\t\t\t\tundo_cpu_down(cpu, st);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "undo_cpu_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "932-936",
    "snippet": "static void undo_cpu_down(unsigned int cpu, struct cpuhp_cpu_state *st)\n{\n\tfor (st->state++; st->state < st->target; st->state++)\n\t\tcpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "st->state",
            "true",
            "NULL",
            "NULL"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void undo_cpu_down(unsigned int cpu, struct cpuhp_cpu_state *st)\n{\n\tfor (st->state++; st->state < st->target; st->state++)\n\t\tcpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n}"
  },
  {
    "function_name": "cpuhp_report_idle_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "917-930",
    "snippet": "void cpuhp_report_idle_dead(void)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\tBUG_ON(st->state != CPUHP_AP_OFFLINE);\n\trcu_report_dead(smp_processor_id());\n\tst->state = CPUHP_AP_IDLE_DEAD;\n\t/*\n\t * We cannot call complete after rcu_report_dead() so we delegate it\n\t * to an online cpu.\n\t */\n\tsmp_call_function_single(cpumask_first(cpu_online_mask),\n\t\t\t\t cpuhp_complete_idle_dead, st, 0);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpumask_first(cpu_online_mask)",
            "cpuhp_complete_idle_dead",
            "st",
            "0"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "11-23",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_dead",
          "args": [
            "smp_processor_id()"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3365-3394",
          "snippet": "void rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t/* QS for any half-done expedited grace period. */\n\tpreempt_disable();\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\tpreempt_enable();\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\trnp->qsmaskinitnext &= ~mask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\n\tper_cpu(rcu_cpu_started, cpu) = 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static DEFINE_PER_CPU(int, rcu_cpu_started);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic DEFINE_PER_CPU(int, rcu_cpu_started);\n\nvoid rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t/* QS for any half-done expedited grace period. */\n\tpreempt_disable();\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\tpreempt_enable();\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\trnp->qsmaskinitnext &= ~mask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\n\tper_cpu(rcu_cpu_started, cpu) = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "st->state != CPUHP_AP_OFFLINE"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid cpuhp_report_idle_dead(void)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\tBUG_ON(st->state != CPUHP_AP_OFFLINE);\n\trcu_report_dead(smp_processor_id());\n\tst->state = CPUHP_AP_IDLE_DEAD;\n\t/*\n\t * We cannot call complete after rcu_report_dead() so we delegate it\n\t * to an online cpu.\n\t */\n\tsmp_call_function_single(cpumask_first(cpu_online_mask),\n\t\t\t\t cpuhp_complete_idle_dead, st, 0);\n}"
  },
  {
    "function_name": "cpuhp_complete_idle_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "910-915",
    "snippet": "static void cpuhp_complete_idle_dead(void *arg)\n{\n\tstruct cpuhp_cpu_state *st = arg;\n\n\tcomplete_ap_thread(st, false);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_ap_thread",
          "args": [
            "st",
            "false"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "complete_ap_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "242-246",
          "snippet": "static inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void cpuhp_complete_idle_dead(void *arg)\n{\n\tstruct cpuhp_cpu_state *st = arg;\n\n\tcomplete_ap_thread(st, false);\n}"
  },
  {
    "function_name": "takedown_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "861-908",
    "snippet": "static int takedown_cpu(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint err;\n\n\t/* Park the smpboot threads */\n\tkthread_park(per_cpu_ptr(&cpuhp_state, cpu)->thread);\n\n\t/*\n\t * Prevent irq alloc/free while the dying cpu reorganizes the\n\t * interrupt affinities.\n\t */\n\tirq_lock_sparse();\n\n\t/*\n\t * So now all preempt/rcu users must observe !cpu_active().\n\t */\n\terr = stop_machine_cpuslocked(take_cpu_down, NULL, cpumask_of(cpu));\n\tif (err) {\n\t\t/* CPU refused to die */\n\t\tirq_unlock_sparse();\n\t\t/* Unpark the hotplug thread so we can rollback there */\n\t\tkthread_unpark(per_cpu_ptr(&cpuhp_state, cpu)->thread);\n\t\treturn err;\n\t}\n\tBUG_ON(cpu_online(cpu));\n\n\t/*\n\t * The teardown callback for CPUHP_AP_SCHED_STARTING will have removed\n\t * all runnable tasks from the CPU, there's only the idle task left now\n\t * that the migration thread is done doing the stop_machine thing.\n\t *\n\t * Wait for the stop thread to go away.\n\t */\n\twait_for_ap_thread(st, false);\n\tBUG_ON(st->state != CPUHP_AP_IDLE_DEAD);\n\n\t/* Interrupts are moved away from the dying cpu, reenable alloc/free */\n\tirq_unlock_sparse();\n\n\thotplug_cpu__broadcast_tick_pull(cpu);\n\t/* This actually kills the CPU. */\n\t__cpu_die(cpu);\n\n\ttick_cleanup_dead_cpu(cpu);\n\trcutree_migrate_callbacks(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [
      "#define takedown_cpu\t\tNULL"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcutree_migrate_callbacks",
          "args": [
            "cpu"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_migrate_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3401-3433",
          "snippet": "void rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tbool needwake;\n\n\tif (rcu_is_nocb_cpu(cpu) || rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tif (rcu_nocb_adopt_orphan_cbs(my_rdp, rdp, flags)) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(rnp_root, rdp) ||\n\t\t   rcu_advance_cbs(rnp_root, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\traw_spin_unlock_irqrestore_rcu_node(rnp_root, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tbool needwake;\n\n\tif (rcu_is_nocb_cpu(cpu) || rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tif (rcu_nocb_adopt_orphan_cbs(my_rdp, rdp, flags)) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(rnp_root, rdp) ||\n\t\t   rcu_advance_cbs(rnp_root, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\traw_spin_unlock_irqrestore_rcu_node(rnp_root, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_cleanup_dead_cpu",
          "args": [
            "cpu"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "tick_cleanup_dead_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "627-655",
          "snippet": "void tick_cleanup_dead_cpu(int cpu)\n{\n\tstruct clock_event_device *dev, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\ttick_shutdown_broadcast_oneshot(cpu);\n\ttick_shutdown_broadcast(cpu);\n\ttick_shutdown(cpu);\n\t/*\n\t * Unregister the clock event devices which were\n\t * released from the users in the notify chain.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)\n\t\tlist_del(&dev->list);\n\t/*\n\t * Now check whether the CPU has left unused per cpu devices\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {\n\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&\n\t\t    cpumask_weight(dev->cpumask) == 1 &&\n\t\t    !tick_is_broadcast_device(dev)) {\n\t\t\tBUG_ON(!clockevent_state_detached(dev));\n\t\t\tlist_del(&dev->list);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);",
            "static LIST_HEAD(clockevents_released);",
            "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic LIST_HEAD(clockevents_released);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid tick_cleanup_dead_cpu(int cpu)\n{\n\tstruct clock_event_device *dev, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\ttick_shutdown_broadcast_oneshot(cpu);\n\ttick_shutdown_broadcast(cpu);\n\ttick_shutdown(cpu);\n\t/*\n\t * Unregister the clock event devices which were\n\t * released from the users in the notify chain.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)\n\t\tlist_del(&dev->list);\n\t/*\n\t * Now check whether the CPU has left unused per cpu devices\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {\n\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&\n\t\t    cpumask_weight(dev->cpumask) == 1 &&\n\t\t    !tick_is_broadcast_device(dev)) {\n\t\t\tBUG_ON(!clockevent_state_detached(dev));\n\t\t\tlist_del(&dev->list);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpu_die",
          "args": [
            "cpu"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hotplug_cpu__broadcast_tick_pull",
          "args": [
            "cpu"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "hotplug_cpu__broadcast_tick_pull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "940-953",
          "snippet": "void hotplug_cpu__broadcast_tick_pull(int deadcpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc && broadcast_needs_cpu(bc, deadcpu)) {\n\t\t/* This moves the broadcast assignment to this CPU: */\n\t\tclockevents_program_event(bc, bc->next_event, 1);\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid hotplug_cpu__broadcast_tick_pull(int deadcpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc && broadcast_needs_cpu(bc, deadcpu)) {\n\t\t/* This moves the broadcast assignment to this CPU: */\n\t\tclockevents_program_event(bc, bc->next_event, 1);\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_unlock_sparse",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "irq_unlock_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "367-370",
          "snippet": "void irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "st->state != CPUHP_AP_IDLE_DEAD"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_ap_thread",
          "args": [
            "st",
            "false"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_ap_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "236-240",
          "snippet": "static inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu_online(cpu)"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "per_cpu_ptr(&cpuhp_state, cpu)->thread"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_unpark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "463-479",
          "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_machine_cpuslocked",
          "args": [
            "take_cpu_down",
            "NULL",
            "cpumask_of(cpu)"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "583-617",
          "snippet": "int stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t    const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t\t.num_threads = num_online_cpus(),\n\t\t.active_cpus = cpus,\n\t};\n\n\tlockdep_assert_cpus_held();\n\n\tif (!stop_machine_initialized) {\n\t\t/*\n\t\t * Handle the case where stop_machine() is called\n\t\t * early in boot before stop_machine() has been\n\t\t * initialized.\n\t\t */\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(msdata.num_threads != 1);\n\n\t\tlocal_irq_save(flags);\n\t\thard_irq_disable();\n\t\tret = (*fn)(data);\n\t\tlocal_irq_restore(flags);\n\n\t\treturn ret;\n\t}\n\n\t/* Set the initial state and stop all online cpus. */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool stop_machine_initialized = false;",
            "extern void sched_set_stop_task(int cpu, struct task_struct *stop);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic bool stop_machine_initialized = false;\nextern void sched_set_stop_task(int cpu, struct task_struct *stop);\n\nint stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t    const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t\t.num_threads = num_online_cpus(),\n\t\t.active_cpus = cpus,\n\t};\n\n\tlockdep_assert_cpus_held();\n\n\tif (!stop_machine_initialized) {\n\t\t/*\n\t\t * Handle the case where stop_machine() is called\n\t\t * early in boot before stop_machine() has been\n\t\t * initialized.\n\t\t */\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(msdata.num_threads != 1);\n\n\t\tlocal_irq_save(flags);\n\t\thard_irq_disable();\n\t\tret = (*fn)(data);\n\t\tlocal_irq_restore(flags);\n\n\t\treturn ret;\n\t}\n\n\t/* Set the initial state and stop all online cpus. */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_lock_sparse",
          "args": [],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "irq_lock_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "362-365",
          "snippet": "void irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_park",
          "args": [
            "per_cpu_ptr(&cpuhp_state, cpu)->thread"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_park",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "494-520",
          "snippet": "int kthread_park(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\tif (WARN_ON(k->flags & PF_EXITING))\n\t\treturn -ENOSYS;\n\n\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))\n\t\treturn -EBUSY;\n\n\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\tif (k != current) {\n\t\twake_up_process(k);\n\t\t/*\n\t\t * Wait for __kthread_parkme() to complete(), this means we\n\t\t * _will_ have TASK_PARKED and are about to call schedule().\n\t\t */\n\t\twait_for_completion(&kthread->parked);\n\t\t/*\n\t\t * Now wait for that schedule() to complete and the task to\n\t\t * get scheduled out.\n\t\t */\n\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nint kthread_park(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\tif (WARN_ON(k->flags & PF_EXITING))\n\t\treturn -ENOSYS;\n\n\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))\n\t\treturn -EBUSY;\n\n\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\tif (k != current) {\n\t\twake_up_process(k);\n\t\t/*\n\t\t * Wait for __kthread_parkme() to complete(), this means we\n\t\t * _will_ have TASK_PARKED and are about to call schedule().\n\t\t */\n\t\twait_for_completion(&kthread->parked);\n\t\t/*\n\t\t * Now wait for that schedule() to complete and the task to\n\t\t * get scheduled out.\n\t\t */\n\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\n#define takedown_cpu\t\tNULL\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int takedown_cpu(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint err;\n\n\t/* Park the smpboot threads */\n\tkthread_park(per_cpu_ptr(&cpuhp_state, cpu)->thread);\n\n\t/*\n\t * Prevent irq alloc/free while the dying cpu reorganizes the\n\t * interrupt affinities.\n\t */\n\tirq_lock_sparse();\n\n\t/*\n\t * So now all preempt/rcu users must observe !cpu_active().\n\t */\n\terr = stop_machine_cpuslocked(take_cpu_down, NULL, cpumask_of(cpu));\n\tif (err) {\n\t\t/* CPU refused to die */\n\t\tirq_unlock_sparse();\n\t\t/* Unpark the hotplug thread so we can rollback there */\n\t\tkthread_unpark(per_cpu_ptr(&cpuhp_state, cpu)->thread);\n\t\treturn err;\n\t}\n\tBUG_ON(cpu_online(cpu));\n\n\t/*\n\t * The teardown callback for CPUHP_AP_SCHED_STARTING will have removed\n\t * all runnable tasks from the CPU, there's only the idle task left now\n\t * that the migration thread is done doing the stop_machine thing.\n\t *\n\t * Wait for the stop thread to go away.\n\t */\n\twait_for_ap_thread(st, false);\n\tBUG_ON(st->state != CPUHP_AP_IDLE_DEAD);\n\n\t/* Interrupts are moved away from the dying cpu, reenable alloc/free */\n\tirq_unlock_sparse();\n\n\thotplug_cpu__broadcast_tick_pull(cpu);\n\t/* This actually kills the CPU. */\n\t__cpu_die(cpu);\n\n\ttick_cleanup_dead_cpu(cpu);\n\trcutree_migrate_callbacks(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "take_cpu_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "827-859",
    "snippet": "static int take_cpu_down(void *_param)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\tenum cpuhp_state target = max((int)st->target, CPUHP_AP_OFFLINE);\n\tint err, cpu = smp_processor_id();\n\tint ret;\n\n\t/* Ensure this CPU doesn't handle any more interrupts. */\n\terr = __cpu_disable();\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * We get here while we are in CPUHP_TEARDOWN_CPU state and we must not\n\t * do this step again.\n\t */\n\tWARN_ON(st->state != CPUHP_TEARDOWN_CPU);\n\tst->state--;\n\t/* Invoke the former CPU_DYING callbacks */\n\tfor (; st->state > target; st->state--) {\n\t\tret = cpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n\t\t/*\n\t\t * DYING must not fail!\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\n\t/* Give up timekeeping duties */\n\ttick_handover_do_timer();\n\t/* Park the stopper thread */\n\tstop_machine_park(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_machine_park",
          "args": [
            "cpu"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_park",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "521-531",
          "snippet": "void stop_machine_park(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\t/*\n\t * Lockless. cpu_stopper_thread() will take stopper->lock and flush\n\t * the pending works before it parks, until then it is fine to queue\n\t * the new works.\n\t */\n\tstopper->enabled = false;\n\tkthread_park(stopper->thread);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nvoid stop_machine_park(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\t/*\n\t * Lockless. cpu_stopper_thread() will take stopper->lock and flush\n\t * the pending works before it parks, until then it is fine to queue\n\t * the new works.\n\t */\n\tstopper->enabled = false;\n\tkthread_park(stopper->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_handover_do_timer",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "tick_handover_do_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "372-380",
          "snippet": "void tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id()) {\n\t\tint cpu = cpumask_first(cpu_online_mask);\n\n\t\ttick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :\n\t\t\tTICK_DO_TIMER_NONE;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_do_timer_cpu;\n\nvoid tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id()) {\n\t\tint cpu = cpumask_first(cpu_online_mask);\n\n\t\ttick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :\n\t\t\tTICK_DO_TIMER_NONE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "st->state",
            "false",
            "NULL",
            "NULL"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "st->state != CPUHP_TEARDOWN_CPU"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpu_disable",
          "args": [],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(int)st->target",
            "CPUHP_AP_OFFLINE"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int take_cpu_down(void *_param)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\tenum cpuhp_state target = max((int)st->target, CPUHP_AP_OFFLINE);\n\tint err, cpu = smp_processor_id();\n\tint ret;\n\n\t/* Ensure this CPU doesn't handle any more interrupts. */\n\terr = __cpu_disable();\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * We get here while we are in CPUHP_TEARDOWN_CPU state and we must not\n\t * do this step again.\n\t */\n\tWARN_ON(st->state != CPUHP_TEARDOWN_CPU);\n\tst->state--;\n\t/* Invoke the former CPU_DYING callbacks */\n\tfor (; st->state > target; st->state--) {\n\t\tret = cpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n\t\t/*\n\t\t * DYING must not fail!\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\n\t/* Give up timekeeping duties */\n\ttick_handover_do_timer();\n\t/* Park the stopper thread */\n\tstop_machine_park(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_tasks_mm_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "797-824",
    "snippet": "void clear_tasks_mm_cpumask(int cpu)\n{\n\tstruct task_struct *p;\n\n\t/*\n\t * This function is called after the cpu is taken down and marked\n\t * offline, so its not like new tasks will ever get this cpu set in\n\t * their mm mask. -- Peter Zijlstra\n\t * Thus, we may use rcu_read_lock() here, instead of grabbing\n\t * full-fledged tasklist_lock.\n\t */\n\tWARN_ON(cpu_online(cpu));\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tstruct task_struct *t;\n\n\t\t/*\n\t\t * Main thread might exit, but other threads may still have\n\t\t * a valid mm. Find one.\n\t\t */\n\t\tt = find_lock_task_mm(p);\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(t->mm));\n\t\ttask_unlock(t);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "t"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "mm_cpumask(t->mm)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_cpumask",
          "args": [
            "t->mm"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "clear_tasks_mm_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "797-824",
          "snippet": "void clear_tasks_mm_cpumask(int cpu)\n{\n\tstruct task_struct *p;\n\n\t/*\n\t * This function is called after the cpu is taken down and marked\n\t * offline, so its not like new tasks will ever get this cpu set in\n\t * their mm mask. -- Peter Zijlstra\n\t * Thus, we may use rcu_read_lock() here, instead of grabbing\n\t * full-fledged tasklist_lock.\n\t */\n\tWARN_ON(cpu_online(cpu));\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tstruct task_struct *t;\n\n\t\t/*\n\t\t * Main thread might exit, but other threads may still have\n\t\t * a valid mm. Find one.\n\t\t */\n\t\tt = find_lock_task_mm(p);\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(t->mm));\n\t\ttask_unlock(t);\n\t}\n\trcu_read_unlock();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "find_lock_task_mm",
          "args": [
            "p"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpu_online(cpu)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid clear_tasks_mm_cpumask(int cpu)\n{\n\tstruct task_struct *p;\n\n\t/*\n\t * This function is called after the cpu is taken down and marked\n\t * offline, so its not like new tasks will ever get this cpu set in\n\t * their mm mask. -- Peter Zijlstra\n\t * Thus, we may use rcu_read_lock() here, instead of grabbing\n\t * full-fledged tasklist_lock.\n\t */\n\tWARN_ON(cpu_online(cpu));\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tstruct task_struct *t;\n\n\t\t/*\n\t\t * Main thread might exit, but other threads may still have\n\t\t * a valid mm. Find one.\n\t\t */\n\t\tt = find_lock_task_mm(p);\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(t->mm));\n\t\ttask_unlock(t);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cpuhp_threads_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "778-782",
    "snippet": "void __init cpuhp_threads_init(void)\n{\n\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));\n\tkthread_unpark(this_cpu_read(cpuhp_state.thread));\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "this_cpu_read(cpuhp_state.thread)"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_unpark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "463-479",
          "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "cpuhp_state.thread"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "smpboot_register_percpu_thread(&cpuhp_threads)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smpboot_register_percpu_thread",
          "args": [
            "&cpuhp_threads"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "smpboot_register_percpu_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smpboot.c",
          "lines": "288-308",
          "snippet": "int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tget_online_cpus();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tput_online_cpus();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(hotplug_threads);",
            "static DEFINE_MUTEX(smpboot_threads_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic LIST_HEAD(hotplug_threads);\nstatic DEFINE_MUTEX(smpboot_threads_lock);\n\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tget_online_cpus();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tput_online_cpus();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid __init cpuhp_threads_init(void)\n{\n\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));\n\tkthread_unpark(this_cpu_read(cpuhp_state.thread));\n}"
  },
  {
    "function_name": "cpuhp_kick_ap_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "750-767",
    "snippet": "static int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "prev_state",
            "ret"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_kick_ap",
          "args": [
            "st",
            "st->target"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_kick_ap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "502-515",
          "snippet": "static int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_enter",
          "args": [
            "cpu",
            "st->target",
            "prev_state",
            "cpuhp_kick_ap_work"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_release",
          "args": [
            "true"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "96-96",
          "snippet": "static inline void cpuhp_lock_release(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_release(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_acquire",
          "args": [
            "true"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "95-95",
          "snippet": "static inline void cpuhp_lock_acquire(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_invoke_ap_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "699-748",
    "snippet": "static int\ncpuhp_invoke_ap_callback(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t struct hlist_node *node)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint ret;\n\n\tif (!cpu_online(cpu))\n\t\treturn 0;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\t/*\n\t * If we are up and running, use the hotplug thread. For early calls\n\t * we invoke the thread function directly.\n\t */\n\tif (!st->thread)\n\t\treturn cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->node = node;\n\tst->bringup = bringup;\n\tst->cb_state = state;\n\tst->single = true;\n\n\t__cpuhp_kick_ap(st);\n\n\t/*\n\t * If we failed and did a partial, do a rollback.\n\t */\n\tif ((ret = st->result) && st->last) {\n\t\tst->rollback = true;\n\t\tst->bringup = !bringup;\n\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\t/*\n\t * Clean up the leftovers so the next hotplug operation wont use stale\n\t * data.\n\t */\n\tst->node = st->last = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuhp_kick_ap",
          "args": [
            "st"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_kick_ap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "486-500",
          "snippet": "static void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "node",
            "NULL"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_release",
          "args": [
            "true"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "96-96",
          "snippet": "static inline void cpuhp_lock_release(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_release(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_acquire",
          "args": [
            "true"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "95-95",
          "snippet": "static inline void cpuhp_lock_acquire(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int\ncpuhp_invoke_ap_callback(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t struct hlist_node *node)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint ret;\n\n\tif (!cpu_online(cpu))\n\t\treturn 0;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\t/*\n\t * If we are up and running, use the hotplug thread. For early calls\n\t * we invoke the thread function directly.\n\t */\n\tif (!st->thread)\n\t\treturn cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->node = node;\n\tst->bringup = bringup;\n\tst->cb_state = state;\n\tst->single = true;\n\n\t__cpuhp_kick_ap(st);\n\n\t/*\n\t * If we failed and did a partial, do a rollback.\n\t */\n\tif ((ret = st->result) && st->last) {\n\t\tst->rollback = true;\n\t\tst->bringup = !bringup;\n\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\t/*\n\t * Clean up the leftovers so the next hotplug operation wont use stale\n\t * data.\n\t */\n\tst->node = st->last = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_thread_fun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "626-696",
    "snippet": "static void cpuhp_thread_fun(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\tbool bringup = st->bringup;\n\tenum cpuhp_state state;\n\n\tif (WARN_ON_ONCE(!st->should_run))\n\t\treturn;\n\n\t/*\n\t * ACQUIRE for the cpuhp_should_run() load of ->should_run. Ensures\n\t * that if we see ->should_run we also see the rest of the state.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * The BP holds the hotplug lock, but we're now running on the AP,\n\t * ensure that anybody asserting the lock is held, will actually find\n\t * it so.\n\t */\n\tlockdep_acquire_cpus_lock();\n\tcpuhp_lock_acquire(bringup);\n\n\tif (st->single) {\n\t\tstate = st->cb_state;\n\t\tst->should_run = false;\n\t} else {\n\t\tif (bringup) {\n\t\t\tst->state++;\n\t\t\tstate = st->state;\n\t\t\tst->should_run = (st->state < st->target);\n\t\t\tWARN_ON_ONCE(st->state > st->target);\n\t\t} else {\n\t\t\tstate = st->state;\n\t\t\tst->state--;\n\t\t\tst->should_run = (st->state > st->target);\n\t\t\tWARN_ON_ONCE(st->state < st->target);\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(!cpuhp_is_ap_state(state));\n\n\tif (cpuhp_is_atomic_state(state)) {\n\t\tlocal_irq_disable();\n\t\tst->result = cpuhp_invoke_callback(cpu, state, bringup, st->node, &st->last);\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * STARTING/DYING must not fail!\n\t\t */\n\t\tWARN_ON_ONCE(st->result);\n\t} else {\n\t\tst->result = cpuhp_invoke_callback(cpu, state, bringup, st->node, &st->last);\n\t}\n\n\tif (st->result) {\n\t\t/*\n\t\t * If we fail on a rollback, we're up a creek without no\n\t\t * paddle, no way forward, no way back. We loose, thanks for\n\t\t * playing.\n\t\t */\n\t\tWARN_ON_ONCE(st->rollback);\n\t\tst->should_run = false;\n\t}\n\n\tcpuhp_lock_release(bringup);\n\tlockdep_release_cpus_lock();\n\n\tif (!st->should_run)\n\t\tcomplete_ap_thread(st, bringup);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_ap_thread",
          "args": [
            "st",
            "bringup"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "complete_ap_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "242-246",
          "snippet": "static inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_release_cpus_lock",
          "args": [],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_release_cpus_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "364-366",
          "snippet": "static void lockdep_release_cpus_lock(void)\n{\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void lockdep_release_cpus_lock(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_release",
          "args": [
            "bringup"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "96-96",
          "snippet": "static inline void cpuhp_lock_release(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_release(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "st->rollback"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "st->node",
            "&st->last"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "st->result"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_is_atomic_state",
          "args": [
            "state"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_is_atomic_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "251-254",
          "snippet": "static bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cpuhp_is_ap_state(state)"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_is_ap_state",
          "args": [
            "state"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_is_ap_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "227-234",
          "snippet": "static bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "st->state < st->target"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "st->state > st->target"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_acquire",
          "args": [
            "bringup"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "95-95",
          "snippet": "static inline void cpuhp_lock_acquire(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_acquire_cpus_lock",
          "args": [],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_acquire_cpus_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "360-362",
          "snippet": "static void lockdep_acquire_cpus_lock(void)\n{\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void lockdep_acquire_cpus_lock(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!st->should_run"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_thread_fun(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\tbool bringup = st->bringup;\n\tenum cpuhp_state state;\n\n\tif (WARN_ON_ONCE(!st->should_run))\n\t\treturn;\n\n\t/*\n\t * ACQUIRE for the cpuhp_should_run() load of ->should_run. Ensures\n\t * that if we see ->should_run we also see the rest of the state.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * The BP holds the hotplug lock, but we're now running on the AP,\n\t * ensure that anybody asserting the lock is held, will actually find\n\t * it so.\n\t */\n\tlockdep_acquire_cpus_lock();\n\tcpuhp_lock_acquire(bringup);\n\n\tif (st->single) {\n\t\tstate = st->cb_state;\n\t\tst->should_run = false;\n\t} else {\n\t\tif (bringup) {\n\t\t\tst->state++;\n\t\t\tstate = st->state;\n\t\t\tst->should_run = (st->state < st->target);\n\t\t\tWARN_ON_ONCE(st->state > st->target);\n\t\t} else {\n\t\t\tstate = st->state;\n\t\t\tst->state--;\n\t\t\tst->should_run = (st->state > st->target);\n\t\t\tWARN_ON_ONCE(st->state < st->target);\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(!cpuhp_is_ap_state(state));\n\n\tif (cpuhp_is_atomic_state(state)) {\n\t\tlocal_irq_disable();\n\t\tst->result = cpuhp_invoke_callback(cpu, state, bringup, st->node, &st->last);\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * STARTING/DYING must not fail!\n\t\t */\n\t\tWARN_ON_ONCE(st->result);\n\t} else {\n\t\tst->result = cpuhp_invoke_callback(cpu, state, bringup, st->node, &st->last);\n\t}\n\n\tif (st->result) {\n\t\t/*\n\t\t * If we fail on a rollback, we're up a creek without no\n\t\t * paddle, no way forward, no way back. We loose, thanks for\n\t\t * playing.\n\t\t */\n\t\tWARN_ON_ONCE(st->rollback);\n\t\tst->should_run = false;\n\t}\n\n\tcpuhp_lock_release(bringup);\n\tlockdep_release_cpus_lock();\n\n\tif (!st->should_run)\n\t\tcomplete_ap_thread(st, bringup);\n}"
  },
  {
    "function_name": "cpuhp_should_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "605-610",
    "snippet": "static int cpuhp_should_run(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\treturn st->should_run;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_should_run(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\treturn st->should_run;\n}"
  },
  {
    "function_name": "cpuhp_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "597-603",
    "snippet": "static void cpuhp_create(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\tinit_completion(&st->done_up);\n\tinit_completion(&st->done_down);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&st->done_down"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&st->done_up"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_create(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\tinit_completion(&st->done_up);\n\tinit_completion(&st->done_down);\n}"
  },
  {
    "function_name": "cpuhp_up_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "576-592",
    "snippet": "static int cpuhp_up_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t      enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\twhile (st->state < target) {\n\t\tst->state++;\n\t\tret = cpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n\t\tif (ret) {\n\t\t\tst->target = prev_state;\n\t\t\tundo_cpu_up(cpu, st);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "undo_cpu_up",
          "args": [
            "cpu",
            "st"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "undo_cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "570-574",
          "snippet": "static void undo_cpu_up(unsigned int cpu, struct cpuhp_cpu_state *st)\n{\n\tfor (st->state--; st->state > st->target; st->state--)\n\t\tcpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void undo_cpu_up(unsigned int cpu, struct cpuhp_cpu_state *st)\n{\n\tfor (st->state--; st->state > st->target; st->state--)\n\t\tcpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "st->state",
            "true",
            "NULL",
            "NULL"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_up_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t      enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\twhile (st->state < target) {\n\t\tst->state++;\n\t\tret = cpuhp_invoke_callback(cpu, st->state, true, NULL, NULL);\n\t\tif (ret) {\n\t\t\tst->target = prev_state;\n\t\t\tundo_cpu_up(cpu, st);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "undo_cpu_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "570-574",
    "snippet": "static void undo_cpu_up(unsigned int cpu, struct cpuhp_cpu_state *st)\n{\n\tfor (st->state--; st->state > st->target; st->state--)\n\t\tcpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "st->state",
            "false",
            "NULL",
            "NULL"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "142-224",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void undo_cpu_up(unsigned int cpu, struct cpuhp_cpu_state *st)\n{\n\tfor (st->state--; st->state > st->target; st->state--)\n\t\tcpuhp_invoke_callback(cpu, st->state, false, NULL, NULL);\n}"
  },
  {
    "function_name": "bringup_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "546-564",
    "snippet": "static int bringup_cpu(unsigned int cpu)\n{\n\tstruct task_struct *idle = idle_thread_get(cpu);\n\tint ret;\n\n\t/*\n\t * Some architectures have to walk the irq descriptors to\n\t * setup the vector space for the cpu which comes online.\n\t * Prevent irq alloc/free across the bringup.\n\t */\n\tirq_lock_sparse();\n\n\t/* Arch-specific enabling code. */\n\tret = __cpu_up(cpu, idle);\n\tirq_unlock_sparse();\n\tif (ret)\n\t\treturn ret;\n\treturn bringup_wait_for_ap(cpu);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bringup_wait_for_ap",
          "args": [
            "cpu"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "bringup_wait_for_ap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "517-544",
          "snippet": "static int bringup_wait_for_ap(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\t/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */\n\twait_for_ap_thread(st, true);\n\tif (WARN_ON_ONCE((!cpu_online(cpu))))\n\t\treturn -ECANCELED;\n\n\t/* Unpark the stopper thread and the hotplug thread of the target cpu */\n\tstop_machine_unpark(cpu);\n\tkthread_unpark(st->thread);\n\n\t/*\n\t * SMT soft disabling on X86 requires to bring the CPU out of the\n\t * BIOS 'wait for SIPI' state in order to set the CR4.MCE bit.  The\n\t * CPU marked itself as booted_once in cpu_notify_starting() so the\n\t * cpu_smt_allowed() check will now return false if this is not the\n\t * primary sibling.\n\t */\n\tif (!cpu_smt_allowed(cpu))\n\t\treturn -ECANCELED;\n\n\tif (st->target <= CPUHP_AP_ONLINE_IDLE)\n\t\treturn 0;\n\n\treturn cpuhp_kick_ap(st, st->target);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int bringup_wait_for_ap(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\t/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */\n\twait_for_ap_thread(st, true);\n\tif (WARN_ON_ONCE((!cpu_online(cpu))))\n\t\treturn -ECANCELED;\n\n\t/* Unpark the stopper thread and the hotplug thread of the target cpu */\n\tstop_machine_unpark(cpu);\n\tkthread_unpark(st->thread);\n\n\t/*\n\t * SMT soft disabling on X86 requires to bring the CPU out of the\n\t * BIOS 'wait for SIPI' state in order to set the CR4.MCE bit.  The\n\t * CPU marked itself as booted_once in cpu_notify_starting() so the\n\t * cpu_smt_allowed() check will now return false if this is not the\n\t * primary sibling.\n\t */\n\tif (!cpu_smt_allowed(cpu))\n\t\treturn -ECANCELED;\n\n\tif (st->target <= CPUHP_AP_ONLINE_IDLE)\n\t\treturn 0;\n\n\treturn cpuhp_kick_ap(st, st->target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_unlock_sparse",
          "args": [],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "irq_unlock_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "367-370",
          "snippet": "void irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpu_up",
          "args": [
            "cpu",
            "idle"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_lock_sparse",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "irq_lock_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "362-365",
          "snippet": "void irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_thread_get",
          "args": [
            "cpu"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "idle_thread_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smpboot.c",
          "lines": "29-37",
          "snippet": "struct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinit_idle(tsk, cpu);\n\treturn tsk;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinit_idle(tsk, cpu);\n\treturn tsk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int bringup_cpu(unsigned int cpu)\n{\n\tstruct task_struct *idle = idle_thread_get(cpu);\n\tint ret;\n\n\t/*\n\t * Some architectures have to walk the irq descriptors to\n\t * setup the vector space for the cpu which comes online.\n\t * Prevent irq alloc/free across the bringup.\n\t */\n\tirq_lock_sparse();\n\n\t/* Arch-specific enabling code. */\n\tret = __cpu_up(cpu, idle);\n\tirq_unlock_sparse();\n\tif (ret)\n\t\treturn ret;\n\treturn bringup_wait_for_ap(cpu);\n}"
  },
  {
    "function_name": "bringup_wait_for_ap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "517-544",
    "snippet": "static int bringup_wait_for_ap(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\t/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */\n\twait_for_ap_thread(st, true);\n\tif (WARN_ON_ONCE((!cpu_online(cpu))))\n\t\treturn -ECANCELED;\n\n\t/* Unpark the stopper thread and the hotplug thread of the target cpu */\n\tstop_machine_unpark(cpu);\n\tkthread_unpark(st->thread);\n\n\t/*\n\t * SMT soft disabling on X86 requires to bring the CPU out of the\n\t * BIOS 'wait for SIPI' state in order to set the CR4.MCE bit.  The\n\t * CPU marked itself as booted_once in cpu_notify_starting() so the\n\t * cpu_smt_allowed() check will now return false if this is not the\n\t * primary sibling.\n\t */\n\tif (!cpu_smt_allowed(cpu))\n\t\treturn -ECANCELED;\n\n\tif (st->target <= CPUHP_AP_ONLINE_IDLE)\n\t\treturn 0;\n\n\treturn cpuhp_kick_ap(st, st->target);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_kick_ap",
          "args": [
            "st",
            "st->target"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_kick_ap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "502-515",
          "snippet": "static int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_smt_allowed",
          "args": [
            "cpu"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "447-447",
          "snippet": "static inline bool cpu_smt_allowed(unsigned int cpu) { return true; }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline bool cpu_smt_allowed(unsigned int cpu) { return true; }"
        }
      },
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "st->thread"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_unpark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "463-479",
          "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_machine_unpark",
          "args": [
            "cpu"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_unpark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "547-553",
          "snippet": "void stop_machine_unpark(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tstopper->enabled = true;\n\tkthread_unpark(stopper->thread);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nvoid stop_machine_unpark(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tstopper->enabled = true;\n\tkthread_unpark(stopper->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(!cpu_online(cpu))"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_ap_thread",
          "args": [
            "st",
            "true"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_ap_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "236-240",
          "snippet": "static inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int bringup_wait_for_ap(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\t/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */\n\twait_for_ap_thread(st, true);\n\tif (WARN_ON_ONCE((!cpu_online(cpu))))\n\t\treturn -ECANCELED;\n\n\t/* Unpark the stopper thread and the hotplug thread of the target cpu */\n\tstop_machine_unpark(cpu);\n\tkthread_unpark(st->thread);\n\n\t/*\n\t * SMT soft disabling on X86 requires to bring the CPU out of the\n\t * BIOS 'wait for SIPI' state in order to set the CR4.MCE bit.  The\n\t * CPU marked itself as booted_once in cpu_notify_starting() so the\n\t * cpu_smt_allowed() check will now return false if this is not the\n\t * primary sibling.\n\t */\n\tif (!cpu_smt_allowed(cpu))\n\t\treturn -ECANCELED;\n\n\tif (st->target <= CPUHP_AP_ONLINE_IDLE)\n\t\treturn 0;\n\n\treturn cpuhp_kick_ap(st, st->target);\n}"
  },
  {
    "function_name": "cpuhp_kick_ap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "502-515",
    "snippet": "static int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuhp_kick_ap",
          "args": [
            "st"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_kick_ap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "486-500",
          "snippet": "static void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_reset_state",
          "args": [
            "st",
            "prev_state"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_reset_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "465-483",
          "snippet": "static inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->target = prev_state;\n\tst->bringup = !st->bringup;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->target = prev_state;\n\tst->bringup = !st->bringup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_set_state",
          "args": [
            "st",
            "target"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "450-463",
          "snippet": "static inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = st->state < target;\n\n\treturn prev_state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = st->state < target;\n\n\treturn prev_state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__cpuhp_kick_ap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "486-500",
    "snippet": "static void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_ap_thread",
          "args": [
            "st",
            "st->bringup"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_ap_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "236-240",
          "snippet": "static inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "st->thread"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}"
  },
  {
    "function_name": "cpuhp_reset_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "465-483",
    "snippet": "static inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->target = prev_state;\n\tst->bringup = !st->bringup;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->target = prev_state;\n\tst->bringup = !st->bringup;\n}"
  },
  {
    "function_name": "cpuhp_set_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "450-463",
    "snippet": "static inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = st->state < target;\n\n\treturn prev_state;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = st->state < target;\n\n\treturn prev_state;\n}"
  },
  {
    "function_name": "cpu_smt_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "447-447",
    "snippet": "static inline bool cpu_smt_allowed(unsigned int cpu) { return true; }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline bool cpu_smt_allowed(unsigned int cpu) { return true; }"
  },
  {
    "function_name": "cpu_smt_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "422-445",
    "snippet": "static inline bool cpu_smt_allowed(unsigned int cpu)\n{\n\tif (topology_is_primary_thread(cpu))\n\t\treturn true;\n\n\t/*\n\t * If the CPU is not a 'primary' thread and the booted_once bit is\n\t * set then the processor has SMT support. Store this information\n\t * for the late check of SMT support in cpu_smt_check_topology().\n\t */\n\tif (per_cpu(cpuhp_state, cpu).booted_once)\n\t\tcpu_smt_available = true;\n\n\tif (cpu_smt_control == CPU_SMT_ENABLED)\n\t\treturn true;\n\n\t/*\n\t * On x86 it's required to boot all logical CPUs at least once so\n\t * that the init code can get a chance to set CR4.MCE on each\n\t * CPU. Otherwise, a broadacasted MCE observing CR4.MCE=0b on any\n\t * core will shutdown the machine.\n\t */\n\treturn !per_cpu(cpuhp_state, cpu).booted_once;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpuhp_state",
            "cpu"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "topology_is_primary_thread",
          "args": [
            "cpu"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline bool cpu_smt_allowed(unsigned int cpu)\n{\n\tif (topology_is_primary_thread(cpu))\n\t\treturn true;\n\n\t/*\n\t * If the CPU is not a 'primary' thread and the booted_once bit is\n\t * set then the processor has SMT support. Store this information\n\t * for the late check of SMT support in cpu_smt_check_topology().\n\t */\n\tif (per_cpu(cpuhp_state, cpu).booted_once)\n\t\tcpu_smt_available = true;\n\n\tif (cpu_smt_control == CPU_SMT_ENABLED)\n\t\treturn true;\n\n\t/*\n\t * On x86 it's required to boot all logical CPUs at least once so\n\t * that the init code can get a chance to set CR4.MCE on each\n\t * CPU. Otherwise, a broadacasted MCE observing CR4.MCE=0b on any\n\t * core will shutdown the machine.\n\t */\n\treturn !per_cpu(cpuhp_state, cpu).booted_once;\n}"
  },
  {
    "function_name": "smt_cmdline_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "415-419",
    "snippet": "static int __init smt_cmdline_disable(char *str)\n{\n\tcpu_smt_disable(str && !strcmp(str, \"force\"));\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_smt_disable",
          "args": [
            "str && !strcmp(str, \"force\")"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "376-389",
          "snippet": "void __init cpu_smt_disable(bool force)\n{\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||\n\t\tcpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\treturn;\n\n\tif (force) {\n\t\tpr_info(\"SMT: Force disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_FORCE_DISABLED;\n\t} else {\n\t\tpr_info(\"SMT: disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_DISABLED;\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __init cpu_smt_disable(bool force)\n{\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||\n\t\tcpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\treturn;\n\n\tif (force) {\n\t\tpr_info(\"SMT: Force disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_FORCE_DISABLED;\n\t} else {\n\t\tpr_info(\"SMT: disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_DISABLED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"force\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic int __init smt_cmdline_disable(char *str)\n{\n\tcpu_smt_disable(str && !strcmp(str, \"force\"));\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_smt_check_topology",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "409-413",
    "snippet": "void __init cpu_smt_check_topology(void)\n{\n\tif (!cpu_smt_available)\n\t\tcpu_smt_control = CPU_SMT_NOT_SUPPORTED;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __init cpu_smt_check_topology(void)\n{\n\tif (!cpu_smt_available)\n\t\tcpu_smt_control = CPU_SMT_NOT_SUPPORTED;\n}"
  },
  {
    "function_name": "cpu_smt_check_topology_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "396-400",
    "snippet": "void __init cpu_smt_check_topology_early(void)\n{\n\tif (!topology_smt_supported())\n\t\tcpu_smt_control = CPU_SMT_NOT_SUPPORTED;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "topology_smt_supported",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __init cpu_smt_check_topology_early(void)\n{\n\tif (!topology_smt_supported())\n\t\tcpu_smt_control = CPU_SMT_NOT_SUPPORTED;\n}"
  },
  {
    "function_name": "cpu_smt_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "376-389",
    "snippet": "void __init cpu_smt_disable(bool force)\n{\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||\n\t\tcpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\treturn;\n\n\tif (force) {\n\t\tpr_info(\"SMT: Force disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_FORCE_DISABLED;\n\t} else {\n\t\tpr_info(\"SMT: disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_DISABLED;\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SMT: disabled\\n\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SMT: Force disabled\\n\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __init cpu_smt_disable(bool force)\n{\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||\n\t\tcpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\treturn;\n\n\tif (force) {\n\t\tpr_info(\"SMT: Force disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_FORCE_DISABLED;\n\t} else {\n\t\tpr_info(\"SMT: disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_DISABLED;\n\t}\n}"
  },
  {
    "function_name": "lockdep_release_cpus_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "364-366",
    "snippet": "static void lockdep_release_cpus_lock(void)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void lockdep_release_cpus_lock(void)\n{\n}"
  },
  {
    "function_name": "lockdep_acquire_cpus_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "360-362",
    "snippet": "static void lockdep_acquire_cpus_lock(void)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void lockdep_acquire_cpus_lock(void)\n{\n}"
  },
  {
    "function_name": "cpu_hotplug_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "350-355",
    "snippet": "void cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "270-273",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpu_hotplug_enable",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "__cpu_hotplug_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "343-348",
          "snippet": "static void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "265-268",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}"
  },
  {
    "function_name": "__cpu_hotplug_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "343-348",
    "snippet": "static void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!cpu_hotplug_disabled",
            "\"Unbalanced cpu hotplug enable\\n\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}"
  },
  {
    "function_name": "cpu_hotplug_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "335-340",
    "snippet": "void cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "270-273",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "265-268",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}"
  },
  {
    "function_name": "lockdep_release_cpus_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "323-326",
    "snippet": "static void lockdep_release_cpus_lock(void)\n{\n\trwsem_release(&cpu_hotplug_lock.rw_sem.dep_map, 1, _THIS_IP_);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&cpu_hotplug_lock.rw_sem.dep_map",
            "1",
            "_THIS_IP_"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void lockdep_release_cpus_lock(void)\n{\n\trwsem_release(&cpu_hotplug_lock.rw_sem.dep_map, 1, _THIS_IP_);\n}"
  },
  {
    "function_name": "lockdep_acquire_cpus_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "318-321",
    "snippet": "static void lockdep_acquire_cpus_lock(void)\n{\n\trwsem_acquire(&cpu_hotplug_lock.rw_sem.dep_map, 0, 0, _THIS_IP_);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwsem_acquire",
          "args": [
            "&cpu_hotplug_lock.rw_sem.dep_map",
            "0",
            "0",
            "_THIS_IP_"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void lockdep_acquire_cpus_lock(void)\n{\n\trwsem_acquire(&cpu_hotplug_lock.rw_sem.dep_map, 0, 0, _THIS_IP_);\n}"
  },
  {
    "function_name": "lockdep_assert_cpus_held",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "313-316",
    "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_rwsem_assert_held",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_write_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "308-311",
    "snippet": "void cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_write_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "303-306",
    "snippet": "void cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "297-300",
    "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_up_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "94-106",
          "snippet": "void __percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\tsmp_mb(); /* B matches C */\n\t/*\n\t * In other words, if they see our decrement (presumably to aggregate\n\t * zero, as that is the only time it matters) they will also see our\n\t * critical section.\n\t */\n\t__this_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to recheck readers_active */\n\trcuwait_wake_up(&sem->writer);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid __percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\tsmp_mb(); /* B matches C */\n\t/*\n\t * In other words, if they see our decrement (presumably to aggregate\n\t * zero, as that is the only time it matters) they will also see our\n\t * critical section.\n\t */\n\t__this_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to recheck readers_active */\n\trcuwait_wake_up(&sem->writer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_read_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "291-294",
    "snippet": "int cpus_read_trylock(void)\n{\n\treturn percpu_down_read_trylock(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read_trylock",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nint cpus_read_trylock(void)\n{\n\treturn percpu_down_read_trylock(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "285-288",
    "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpu_maps_update_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "270-273",
    "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpu_add_remove_lock"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
  },
  {
    "function_name": "cpu_maps_update_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "265-268",
    "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpu_add_remove_lock"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
  },
  {
    "function_name": "cpuhp_is_atomic_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "251-254",
    "snippet": "static bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}"
  },
  {
    "function_name": "complete_ap_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "242-246",
    "snippet": "static inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "done"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_complete_idle_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "910-915",
          "snippet": "static void cpuhp_complete_idle_dead(void *arg)\n{\n\tstruct cpuhp_cpu_state *st = arg;\n\n\tcomplete_ap_thread(st, false);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic void cpuhp_complete_idle_dead(void *arg)\n{\n\tstruct cpuhp_cpu_state *st = arg;\n\n\tcomplete_ap_thread(st, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}"
  },
  {
    "function_name": "wait_for_ap_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "236-240",
    "snippet": "static inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "done"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}"
  },
  {
    "function_name": "cpuhp_is_ap_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "227-234",
    "snippet": "static bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}"
  },
  {
    "function_name": "cpuhp_invoke_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "142-224",
    "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "state",
            "ret"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbm",
          "args": [
            "cpu",
            "node"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_multi_enter",
          "args": [
            "cpu",
            "st->target",
            "state",
            "cbm",
            "node"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each",
          "args": [
            "node",
            "&step->list"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "state",
            "ret"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbm",
          "args": [
            "cpu",
            "node"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_multi_enter",
          "args": [
            "cpu",
            "st->target",
            "state",
            "cbm",
            "node"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each",
          "args": [
            "node",
            "&step->list"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "state",
            "ret"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbm",
          "args": [
            "cpu",
            "node"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_multi_enter",
          "args": [
            "cpu",
            "st->target",
            "state",
            "cbm",
            "node"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lastp && *lastp"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "state",
            "ret"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "cpu"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_teardown_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1571-1574",
          "snippet": "static void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_enter",
          "args": [
            "cpu",
            "st->target",
            "state",
            "cb"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lastp && *lastp"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "127-130",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\n\t\tif (!(bringup ? step->startup.single : step->teardown.single))\n\t\t\treturn 0;\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\t\tif (!cb)\n\t\t\treturn 0;\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn 0;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_get_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "127-130",
    "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static struct cpuhp_step cpuhp_hp_states[];",
      "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on controll processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
  },
  {
    "function_name": "cpuhp_lock_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "96-96",
    "snippet": "static inline void cpuhp_lock_release(bool bringup) { }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_release(bool bringup) { }"
  },
  {
    "function_name": "cpuhp_lock_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "95-95",
    "snippet": "static inline void cpuhp_lock_acquire(bool bringup) { }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup) { }"
  },
  {
    "function_name": "cpuhp_lock_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "89-92",
    "snippet": "static inline void cpuhp_lock_release(bool bringup)\n{\n\tlock_map_release(bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_release(bool bringup)\n{\n\tlock_map_release(bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map);\n}"
  },
  {
    "function_name": "cpuhp_lock_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
    "lines": "84-87",
    "snippet": "static inline void cpuhp_lock_acquire(bool bringup)\n{\n\tlock_map_acquire(bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup)\n{\n\tlock_map_acquire(bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map);\n}"
  }
]