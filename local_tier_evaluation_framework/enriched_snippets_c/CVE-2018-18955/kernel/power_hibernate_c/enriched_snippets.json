[
  {
    "function_name": "nohibernate_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1221-1226",
    "snippet": "static int __init nohibernate_setup(char *str)\n{\n\tnoresume = 1;\n\tnohibernate = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "static int nohibernate;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nstatic int nohibernate;\n\nstatic int __init nohibernate_setup(char *str)\n{\n\tnoresume = 1;\n\tnohibernate = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "resumedelay_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1212-1219",
    "snippet": "static int __init resumedelay_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &resume_delay);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int resume_delay;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "str",
            "0",
            "&resume_delay"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic unsigned int resume_delay;\n\nstatic int __init resumedelay_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &resume_delay);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}"
  },
  {
    "function_name": "resumewait_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1206-1210",
    "snippet": "static int __init resumewait_setup(char *str)\n{\n\tresume_wait = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int resume_wait;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int resume_wait;\n\nstatic int __init resumewait_setup(char *str)\n{\n\tresume_wait = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "noresume_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1200-1204",
    "snippet": "static int __init noresume_setup(char *str)\n{\n\tnoresume = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\n\nstatic int __init noresume_setup(char *str)\n{\n\tnoresume = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "hibernate_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1184-1198",
    "snippet": "static int __init hibernate_setup(char *str)\n{\n\tif (!strncmp(str, \"noresume\", 8)) {\n\t\tnoresume = 1;\n\t} else if (!strncmp(str, \"nocompress\", 10)) {\n\t\tnocompress = 1;\n\t} else if (!strncmp(str, \"no\", 2)) {\n\t\tnoresume = 1;\n\t\tnohibernate = 1;\n\t} else if (IS_ENABLED(CONFIG_STRICT_KERNEL_RWX)\n\t\t   && !strncmp(str, \"protect_image\", 13)) {\n\t\tenable_restore_image_protection();\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nocompress;",
      "static int noresume;",
      "static int nohibernate;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_restore_image_protection",
          "args": [],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "enable_restore_image_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "69-69",
          "snippet": "static inline void enable_restore_image_protection(void) {}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void enable_restore_image_protection(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"protect_image\"",
            "13"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_STRICT_KERNEL_RWX"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"no\"",
            "2"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"nocompress\"",
            "10"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"noresume\"",
            "8"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nocompress;\nstatic int noresume;\nstatic int nohibernate;\n\nstatic int __init hibernate_setup(char *str)\n{\n\tif (!strncmp(str, \"noresume\", 8)) {\n\t\tnoresume = 1;\n\t} else if (!strncmp(str, \"nocompress\", 10)) {\n\t\tnocompress = 1;\n\t} else if (!strncmp(str, \"no\", 2)) {\n\t\tnoresume = 1;\n\t\tnohibernate = 1;\n\t} else if (IS_ENABLED(CONFIG_STRICT_KERNEL_RWX)\n\t\t   && !strncmp(str, \"protect_image\", 13)) {\n\t\tenable_restore_image_protection();\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "resume_offset_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1171-1182",
    "snippet": "static int __init resume_offset_setup(char *str)\n{\n\tunsigned long long offset;\n\n\tif (noresume)\n\t\treturn 1;\n\n\tif (sscanf(str, \"%llu\", &offset) == 1)\n\t\tswsusp_resume_block = offset;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "sector_t swsusp_resume_block;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%llu\"",
            "&offset"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nsector_t swsusp_resume_block;\n\nstatic int __init resume_offset_setup(char *str)\n{\n\tunsigned long long offset;\n\n\tif (noresume)\n\t\treturn 1;\n\n\tif (sscanf(str, \"%llu\", &offset) == 1)\n\t\tswsusp_resume_block = offset;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "resume_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1162-1169",
    "snippet": "static int __init resume_setup(char *str)\n{\n\tif (noresume)\n\t\treturn 1;\n\n\tstrncpy( resume_file, str, 255 );\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "static char resume_file[256] = CONFIG_PM_STD_PARTITION;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "resume_file",
            "str",
            "255"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nstatic char resume_file[256] = CONFIG_PM_STD_PARTITION;\n\nstatic int __init resume_setup(char *str)\n{\n\tif (noresume)\n\t\treturn 1;\n\n\tstrncpy( resume_file, str, 255 );\n\treturn 1;\n}"
  },
  {
    "function_name": "pm_disk_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1154-1157",
    "snippet": "static int __init pm_disk_init(void)\n{\n\treturn sysfs_create_group(power_kobj, &attr_group);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct attribute_group attr_group = {\n\t.attrs = g,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "power_kobj",
            "&attr_group"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\nstatic int __init pm_disk_init(void)\n{\n\treturn sysfs_create_group(power_kobj, &attr_group);\n}"
  },
  {
    "function_name": "reserved_size_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1123-1135",
    "snippet": "static ssize_t reserved_size_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\treserved_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%lu\"",
            "&size"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic ssize_t reserved_size_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\treserved_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "reserved_size_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1117-1121",
    "snippet": "static ssize_t reserved_size_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", reserved_size);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "reserved_size"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic ssize_t reserved_size_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", reserved_size);\n}"
  },
  {
    "function_name": "image_size_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1102-1113",
    "snippet": "static ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\timage_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%lu\"",
            "&size"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\timage_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "image_size_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1096-1100",
    "snippet": "static ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", image_size);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "image_size"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", image_size);\n}"
  },
  {
    "function_name": "resume_offset_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1079-1092",
    "snippet": "static ssize_t resume_offset_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, const char *buf,\n\t\t\t\t   size_t n)\n{\n\tunsigned long long offset;\n\tint rc;\n\n\trc = kstrtoull(buf, 0, &offset);\n\tif (rc)\n\t\treturn rc;\n\tswsusp_resume_block = offset;\n\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "sector_t swsusp_resume_block;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "buf",
            "0",
            "&offset"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nsector_t swsusp_resume_block;\n\nstatic ssize_t resume_offset_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, const char *buf,\n\t\t\t\t   size_t n)\n{\n\tunsigned long long offset;\n\tint rc;\n\n\trc = kstrtoull(buf, 0, &offset);\n\tif (rc)\n\t\treturn rc;\n\tswsusp_resume_block = offset;\n\n\treturn n;\n}"
  },
  {
    "function_name": "resume_offset_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1073-1077",
    "snippet": "static ssize_t resume_offset_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)swsusp_resume_block);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "sector_t swsusp_resume_block;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%llu\\n\"",
            "(unsigned long long)swsusp_resume_block"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nsector_t swsusp_resume_block;\n\nstatic ssize_t resume_offset_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)swsusp_resume_block);\n}"
  },
  {
    "function_name": "resume_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1044-1069",
    "snippet": "static ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t n)\n{\n\tdev_t res;\n\tint len = n;\n\tchar *name;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\tname = kstrndup(buf, len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tres = name_to_dev_t(name);\n\tkfree(name);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tlock_system_sleep();\n\tswsusp_resume_device = res;\n\tunlock_system_sleep();\n\tpm_pr_dbg(\"Configured resume from disk to %u\\n\", swsusp_resume_device);\n\tnoresume = 0;\n\tsoftware_resume();\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "dev_t swsusp_resume_device;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "software_resume",
          "args": [],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "software_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "796-910",
          "snippet": "static int software_resume(void)\n{\n\tint error, nr_calls = 0;\n\n\t/*\n\t * If the user said \"noresume\".. bail out early.\n\t */\n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\t/*\n\t * name_to_dev_t() below takes a sysfs buffer mutex when sysfs\n\t * is configured into the kernel. Since the regular hibernate\n\t * trigger path is via sysfs which takes a buffer mutex before\n\t * calling hibernate functions (which take system_transition_mutex)\n\t * this can cause lockdep to complain about a possible ABBA deadlock\n\t * which cannot happen since we're in the boot code here and\n\t * sysfs can't be invoked yet. Therefore, we use a subclass\n\t * here to avoid lockdep complaining.\n\t */\n\tmutex_lock_nested(&system_transition_mutex, SINGLE_DEPTH_NESTING);\n\n\tif (swsusp_resume_device)\n\t\tgoto Check_image;\n\n\tif (!strlen(resume_file)) {\n\t\terror = -ENOENT;\n\t\tgoto Unlock;\n\t}\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t/* Check if the device is there */\n\tswsusp_resume_device = name_to_dev_t(resume_file);\n\n\t/*\n\t * name_to_dev_t is ineffective to verify parition if resume_file is in\n\t * integer format. (e.g. major:minor)\n\t */\n\tif (isdigit(resume_file[0]) && resume_wait) {\n\t\tint partno;\n\t\twhile (!get_gendisk(swsusp_resume_device, &partno))\n\t\t\tmsleep(10);\n\t}\n\n\tif (!swsusp_resume_device) {\n\t\t/*\n\t\t * Some device discovery might still be in progress; we need\n\t\t * to wait for this to finish.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tif (resume_wait) {\n\t\t\twhile ((swsusp_resume_device = name_to_dev_t(resume_file)) == 0)\n\t\t\t\tmsleep(10);\n\t\t\tasync_synchronize_full();\n\t\t}\n\n\t\tswsusp_resume_device = name_to_dev_t(resume_file);\n\t\tif (!swsusp_resume_device) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto Unlock;\n\t\t}\n\t}\n\n Check_image:\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\terror = swsusp_check();\n\tif (error)\n\t\tgoto Unlock;\n\n\t/* The snapshot device should not be opened while we're running */\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(FMODE_READ);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = __pm_notifier_call_chain(PM_RESTORE_PREPARE, -1, &nr_calls);\n\tif (error) {\n\t\tnr_calls--;\n\t\tgoto Close_Finish;\n\t}\n\n\tpm_pr_dbg(\"Preparing processes for restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\terror = load_image_and_restore();\n\tthaw_processes();\n Finish:\n\t__pm_notifier_call_chain(PM_POST_RESTORE, nr_calls, NULL);\n\tpm_restore_console();\n\tpr_info(\"resume from hibernation failed (%d)\\n\", error);\n\tatomic_inc(&snapshot_device_available);\n\t/* For success case, the suspend path will release the lock */\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(FMODE_READ);\n\tgoto Finish;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int noresume;",
            "static int resume_wait;",
            "static unsigned int resume_delay;",
            "static char resume_file[256] = CONFIG_PM_STD_PARTITION;",
            "dev_t swsusp_resume_device;",
            "static struct attribute * g[] = {\n\t&disk_attr.attr,\n\t&resume_offset_attr.attr,\n\t&resume_attr.attr,\n\t&image_size_attr.attr,\n\t&reserved_size_attr.attr,\n\tNULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nstatic int resume_wait;\nstatic unsigned int resume_delay;\nstatic char resume_file[256] = CONFIG_PM_STD_PARTITION;\ndev_t swsusp_resume_device;\nstatic struct attribute * g[] = {\n\t&disk_attr.attr,\n\t&resume_offset_attr.attr,\n\t&resume_attr.attr,\n\t&image_size_attr.attr,\n\t&reserved_size_attr.attr,\n\tNULL,\n};\n\nstatic int software_resume(void)\n{\n\tint error, nr_calls = 0;\n\n\t/*\n\t * If the user said \"noresume\".. bail out early.\n\t */\n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\t/*\n\t * name_to_dev_t() below takes a sysfs buffer mutex when sysfs\n\t * is configured into the kernel. Since the regular hibernate\n\t * trigger path is via sysfs which takes a buffer mutex before\n\t * calling hibernate functions (which take system_transition_mutex)\n\t * this can cause lockdep to complain about a possible ABBA deadlock\n\t * which cannot happen since we're in the boot code here and\n\t * sysfs can't be invoked yet. Therefore, we use a subclass\n\t * here to avoid lockdep complaining.\n\t */\n\tmutex_lock_nested(&system_transition_mutex, SINGLE_DEPTH_NESTING);\n\n\tif (swsusp_resume_device)\n\t\tgoto Check_image;\n\n\tif (!strlen(resume_file)) {\n\t\terror = -ENOENT;\n\t\tgoto Unlock;\n\t}\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t/* Check if the device is there */\n\tswsusp_resume_device = name_to_dev_t(resume_file);\n\n\t/*\n\t * name_to_dev_t is ineffective to verify parition if resume_file is in\n\t * integer format. (e.g. major:minor)\n\t */\n\tif (isdigit(resume_file[0]) && resume_wait) {\n\t\tint partno;\n\t\twhile (!get_gendisk(swsusp_resume_device, &partno))\n\t\t\tmsleep(10);\n\t}\n\n\tif (!swsusp_resume_device) {\n\t\t/*\n\t\t * Some device discovery might still be in progress; we need\n\t\t * to wait for this to finish.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tif (resume_wait) {\n\t\t\twhile ((swsusp_resume_device = name_to_dev_t(resume_file)) == 0)\n\t\t\t\tmsleep(10);\n\t\t\tasync_synchronize_full();\n\t\t}\n\n\t\tswsusp_resume_device = name_to_dev_t(resume_file);\n\t\tif (!swsusp_resume_device) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto Unlock;\n\t\t}\n\t}\n\n Check_image:\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\terror = swsusp_check();\n\tif (error)\n\t\tgoto Unlock;\n\n\t/* The snapshot device should not be opened while we're running */\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(FMODE_READ);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = __pm_notifier_call_chain(PM_RESTORE_PREPARE, -1, &nr_calls);\n\tif (error) {\n\t\tnr_calls--;\n\t\tgoto Close_Finish;\n\t}\n\n\tpm_pr_dbg(\"Preparing processes for restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\terror = load_image_and_restore();\n\tthaw_processes();\n Finish:\n\t__pm_notifier_call_chain(PM_POST_RESTORE, nr_calls, NULL);\n\tpm_restore_console();\n\tpr_info(\"resume from hibernation failed (%d)\\n\", error);\n\tatomic_inc(&snapshot_device_available);\n\t/* For success case, the suspend path will release the lock */\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(FMODE_READ);\n\tgoto Finish;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Configured resume from disk to %u\\n\"",
            "swsusp_resume_device"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_pr_dbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "427-446",
          "snippet": "void __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_to_dev_t",
          "args": [
            "name"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "buf",
            "len",
            "GFP_KERNEL"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\ndev_t swsusp_resume_device;\n\nstatic ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t n)\n{\n\tdev_t res;\n\tint len = n;\n\tchar *name;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\tname = kstrndup(buf, len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tres = name_to_dev_t(name);\n\tkfree(name);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tlock_system_sleep();\n\tswsusp_resume_device = res;\n\tunlock_system_sleep();\n\tpm_pr_dbg(\"Configured resume from disk to %u\\n\", swsusp_resume_device);\n\tnoresume = 0;\n\tsoftware_resume();\n\treturn n;\n}"
  },
  {
    "function_name": "resume_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "1037-1042",
    "snippet": "static ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf,\"%d:%d\\n\", MAJOR(swsusp_resume_device),\n\t\t       MINOR(swsusp_resume_device));\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "dev_t swsusp_resume_device;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d:%d\\n\"",
            "MAJOR(swsusp_resume_device)",
            "MINOR(swsusp_resume_device)"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "swsusp_resume_device"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "swsusp_resume_device"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\ndev_t swsusp_resume_device;\n\nstatic ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf,\"%d:%d\\n\", MAJOR(swsusp_resume_device),\n\t\t       MINOR(swsusp_resume_device));\n}"
  },
  {
    "function_name": "disk_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "986-1033",
    "snippet": "static ssize_t disk_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t n)\n{\n\tint error = 0;\n\tint i;\n\tint len;\n\tchar *p;\n\tint mode = HIBERNATION_INVALID;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (len == strlen(hibernation_modes[i])\n\t\t    && !strncmp(buf, hibernation_modes[i], len)) {\n\t\t\tmode = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode != HIBERNATION_INVALID) {\n\t\tswitch (mode) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\thibernation_mode = mode;\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\thibernation_mode = mode;\n\t\t\telse\n\t\t\t\terror = -EINVAL;\n\t\t}\n\t} else\n\t\terror = -EINVAL;\n\n\tif (!error)\n\t\tpm_pr_dbg(\"Hibernation mode set to '%s'\\n\",\n\t\t\t       hibernation_modes[mode]);\n\tunlock_system_sleep();\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)",
      "#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)"
    ],
    "globals_used": [
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "static const struct platform_hibernation_ops *hibernation_ops;",
      "static const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation mode set to '%s'\\n\"",
            "hibernation_modes[mode]"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_pr_dbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "427-446",
          "snippet": "void __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "hibernation_modes[i]",
            "len"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hibernation_modes[i]"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "n"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "71-74",
          "snippet": "bool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\n#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)\n#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};\n\nstatic ssize_t disk_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t n)\n{\n\tint error = 0;\n\tint i;\n\tint len;\n\tchar *p;\n\tint mode = HIBERNATION_INVALID;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (len == strlen(hibernation_modes[i])\n\t\t    && !strncmp(buf, hibernation_modes[i], len)) {\n\t\t\tmode = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode != HIBERNATION_INVALID) {\n\t\tswitch (mode) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\thibernation_mode = mode;\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\thibernation_mode = mode;\n\t\t\telse\n\t\t\t\terror = -EINVAL;\n\t\t}\n\t} else\n\t\terror = -EINVAL;\n\n\tif (!error)\n\t\tpm_pr_dbg(\"Hibernation mode set to '%s'\\n\",\n\t\t\t       hibernation_modes[mode]);\n\tunlock_system_sleep();\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "disk_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "951-984",
    "snippet": "static ssize_t disk_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tint i;\n\tchar *start = buf;\n\n\tif (!hibernation_available())\n\t\treturn sprintf(buf, \"[disabled]\\n\");\n\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (!hibernation_modes[i])\n\t\t\tcontinue;\n\t\tswitch (i) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\tbreak;\n\t\t\t/* not a valid mode, continue with loop */\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == hibernation_mode)\n\t\t\tbuf += sprintf(buf, \"[%s] \", hibernation_modes[i]);\n\t\telse\n\t\t\tbuf += sprintf(buf, \"%s \", hibernation_modes[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf-start;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)",
      "#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)"
    ],
    "globals_used": [
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "static const struct platform_hibernation_ops *hibernation_ops;",
      "static const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s \"",
            "hibernation_modes[i]"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"[%s] \"",
            "hibernation_modes[i]"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"[disabled]\\n\""
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "71-74",
          "snippet": "bool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\n#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)\n#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};\n\nstatic ssize_t disk_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tint i;\n\tchar *start = buf;\n\n\tif (!hibernation_available())\n\t\treturn sprintf(buf, \"[disabled]\\n\");\n\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (!hibernation_modes[i])\n\t\t\tcontinue;\n\t\tswitch (i) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\tbreak;\n\t\t\t/* not a valid mode, continue with loop */\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == hibernation_mode)\n\t\t\tbuf += sprintf(buf, \"[%s] \", hibernation_modes[i]);\n\t\telse\n\t\t\tbuf += sprintf(buf, \"%s \", hibernation_modes[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf-start;\n}"
  },
  {
    "function_name": "software_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "796-910",
    "snippet": "static int software_resume(void)\n{\n\tint error, nr_calls = 0;\n\n\t/*\n\t * If the user said \"noresume\".. bail out early.\n\t */\n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\t/*\n\t * name_to_dev_t() below takes a sysfs buffer mutex when sysfs\n\t * is configured into the kernel. Since the regular hibernate\n\t * trigger path is via sysfs which takes a buffer mutex before\n\t * calling hibernate functions (which take system_transition_mutex)\n\t * this can cause lockdep to complain about a possible ABBA deadlock\n\t * which cannot happen since we're in the boot code here and\n\t * sysfs can't be invoked yet. Therefore, we use a subclass\n\t * here to avoid lockdep complaining.\n\t */\n\tmutex_lock_nested(&system_transition_mutex, SINGLE_DEPTH_NESTING);\n\n\tif (swsusp_resume_device)\n\t\tgoto Check_image;\n\n\tif (!strlen(resume_file)) {\n\t\terror = -ENOENT;\n\t\tgoto Unlock;\n\t}\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t/* Check if the device is there */\n\tswsusp_resume_device = name_to_dev_t(resume_file);\n\n\t/*\n\t * name_to_dev_t is ineffective to verify parition if resume_file is in\n\t * integer format. (e.g. major:minor)\n\t */\n\tif (isdigit(resume_file[0]) && resume_wait) {\n\t\tint partno;\n\t\twhile (!get_gendisk(swsusp_resume_device, &partno))\n\t\t\tmsleep(10);\n\t}\n\n\tif (!swsusp_resume_device) {\n\t\t/*\n\t\t * Some device discovery might still be in progress; we need\n\t\t * to wait for this to finish.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tif (resume_wait) {\n\t\t\twhile ((swsusp_resume_device = name_to_dev_t(resume_file)) == 0)\n\t\t\t\tmsleep(10);\n\t\t\tasync_synchronize_full();\n\t\t}\n\n\t\tswsusp_resume_device = name_to_dev_t(resume_file);\n\t\tif (!swsusp_resume_device) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto Unlock;\n\t\t}\n\t}\n\n Check_image:\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\terror = swsusp_check();\n\tif (error)\n\t\tgoto Unlock;\n\n\t/* The snapshot device should not be opened while we're running */\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(FMODE_READ);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = __pm_notifier_call_chain(PM_RESTORE_PREPARE, -1, &nr_calls);\n\tif (error) {\n\t\tnr_calls--;\n\t\tgoto Close_Finish;\n\t}\n\n\tpm_pr_dbg(\"Preparing processes for restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\terror = load_image_and_restore();\n\tthaw_processes();\n Finish:\n\t__pm_notifier_call_chain(PM_POST_RESTORE, nr_calls, NULL);\n\tpm_restore_console();\n\tpr_info(\"resume from hibernation failed (%d)\\n\", error);\n\tatomic_inc(&snapshot_device_available);\n\t/* For success case, the suspend path will release the lock */\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(FMODE_READ);\n\tgoto Finish;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "static int resume_wait;",
      "static unsigned int resume_delay;",
      "static char resume_file[256] = CONFIG_PM_STD_PARTITION;",
      "dev_t swsusp_resume_device;",
      "static struct attribute * g[] = {\n\t&disk_attr.attr,\n\t&resume_offset_attr.attr,\n\t&resume_attr.attr,\n\t&image_size_attr.attr,\n\t&reserved_size_attr.attr,\n\tNULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_close",
          "args": [
            "FMODE_READ"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1556-1564",
          "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation image not present or could not be loaded.\\n\""
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&snapshot_device_available"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"resume from hibernation failed (%d)\\n\"",
            "error"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restore_console",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "pm_restore_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/console.c",
          "lines": "143-152",
          "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_notifier_call_chain",
          "args": [
            "PM_POST_RESTORE",
            "nr_calls",
            "NULL"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "70-78",
          "snippet": "int __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_image_and_restore",
          "args": [],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "load_image_and_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "658-682",
          "snippet": "static int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ);\n\tif (!error)\n\t\thibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load hibernation image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ);\n\tif (!error)\n\t\thibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load hibernation image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_processes",
          "args": [],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_freeze_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "280-283",
          "snippet": "static inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Preparing processes for restore.\\n\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_prepare_console",
          "args": [],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "pm_prepare_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/console.c",
          "lines": "130-141",
          "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
          ],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"resume from hibernation\\n\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&snapshot_device_available",
            "-1",
            "0"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_check",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1512-1550",
          "snippet": "int swsusp_check(void)\n{\n\tint error;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ, NULL);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIBERNATE_SIG\t\"S1SUSPEND\""
          ],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;",
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\nstatic struct block_device *hib_resume_bdev;\n\nint swsusp_check(void)\n{\n\tint error;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ, NULL);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Looking for hibernation image.\\n\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation image partition %d:%d present\\n\"",
            "MAJOR(swsusp_resume_device)",
            "MINOR(swsusp_resume_device)"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_pr_dbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "427-446",
          "snippet": "void __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "swsusp_resume_device"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "swsusp_resume_device"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_to_dev_t",
          "args": [
            "resume_file"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "async_synchronize_full",
          "args": [],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "241-244",
          "snippet": "void async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nvoid async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "10"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_to_dev_t",
          "args": [
            "resume_file"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_device_probe",
          "args": [],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gendisk",
          "args": [
            "swsusp_resume_device",
            "&partno"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "resume_file[0]"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_to_dev_t",
          "args": [
            "resume_file"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "resume_delay"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Waiting %dsec before reading resume device ...\\n\"",
            "resume_delay"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "resume_file"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&system_transition_mutex",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1483-1486",
          "snippet": "void __sched rt_mutex_lock_nested(struct rt_mutex *lock, unsigned int subclass)\n{\n\t__rt_mutex_lock(lock, subclass);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_lock_nested(struct rt_mutex *lock, unsigned int subclass)\n{\n\t__rt_mutex_lock(lock, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "71-74",
          "snippet": "bool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nstatic int resume_wait;\nstatic unsigned int resume_delay;\nstatic char resume_file[256] = CONFIG_PM_STD_PARTITION;\ndev_t swsusp_resume_device;\nstatic struct attribute * g[] = {\n\t&disk_attr.attr,\n\t&resume_offset_attr.attr,\n\t&resume_attr.attr,\n\t&image_size_attr.attr,\n\t&reserved_size_attr.attr,\n\tNULL,\n};\n\nstatic int software_resume(void)\n{\n\tint error, nr_calls = 0;\n\n\t/*\n\t * If the user said \"noresume\".. bail out early.\n\t */\n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\t/*\n\t * name_to_dev_t() below takes a sysfs buffer mutex when sysfs\n\t * is configured into the kernel. Since the regular hibernate\n\t * trigger path is via sysfs which takes a buffer mutex before\n\t * calling hibernate functions (which take system_transition_mutex)\n\t * this can cause lockdep to complain about a possible ABBA deadlock\n\t * which cannot happen since we're in the boot code here and\n\t * sysfs can't be invoked yet. Therefore, we use a subclass\n\t * here to avoid lockdep complaining.\n\t */\n\tmutex_lock_nested(&system_transition_mutex, SINGLE_DEPTH_NESTING);\n\n\tif (swsusp_resume_device)\n\t\tgoto Check_image;\n\n\tif (!strlen(resume_file)) {\n\t\terror = -ENOENT;\n\t\tgoto Unlock;\n\t}\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t/* Check if the device is there */\n\tswsusp_resume_device = name_to_dev_t(resume_file);\n\n\t/*\n\t * name_to_dev_t is ineffective to verify parition if resume_file is in\n\t * integer format. (e.g. major:minor)\n\t */\n\tif (isdigit(resume_file[0]) && resume_wait) {\n\t\tint partno;\n\t\twhile (!get_gendisk(swsusp_resume_device, &partno))\n\t\t\tmsleep(10);\n\t}\n\n\tif (!swsusp_resume_device) {\n\t\t/*\n\t\t * Some device discovery might still be in progress; we need\n\t\t * to wait for this to finish.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tif (resume_wait) {\n\t\t\twhile ((swsusp_resume_device = name_to_dev_t(resume_file)) == 0)\n\t\t\t\tmsleep(10);\n\t\t\tasync_synchronize_full();\n\t\t}\n\n\t\tswsusp_resume_device = name_to_dev_t(resume_file);\n\t\tif (!swsusp_resume_device) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto Unlock;\n\t\t}\n\t}\n\n Check_image:\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\terror = swsusp_check();\n\tif (error)\n\t\tgoto Unlock;\n\n\t/* The snapshot device should not be opened while we're running */\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(FMODE_READ);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = __pm_notifier_call_chain(PM_RESTORE_PREPARE, -1, &nr_calls);\n\tif (error) {\n\t\tnr_calls--;\n\t\tgoto Close_Finish;\n\t}\n\n\tpm_pr_dbg(\"Preparing processes for restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\terror = load_image_and_restore();\n\tthaw_processes();\n Finish:\n\t__pm_notifier_call_chain(PM_POST_RESTORE, nr_calls, NULL);\n\tpm_restore_console();\n\tpr_info(\"resume from hibernation failed (%d)\\n\", error);\n\tatomic_inc(&snapshot_device_available);\n\t/* For success case, the suspend path will release the lock */\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(FMODE_READ);\n\tgoto Finish;\n}"
  },
  {
    "function_name": "hibernate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "687-778",
    "snippet": "int hibernate(void)\n{\n\tint error, nr_calls = 0;\n\tbool snapshot_test = false;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = __pm_notifier_call_chain(PM_HIBERNATION_PREPARE, -1, &nr_calls);\n\tif (error) {\n\t\tnr_calls--;\n\t\tgoto Exit;\n\t}\n\n\tpr_info(\"Syncing filesystems ... \\n\");\n\tksys_sync();\n\tpr_info(\"done.\\n\");\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\t__pm_notifier_call_chain(PM_POST_HIBERNATION, nr_calls, NULL);\n\tpm_restore_console();\n\tatomic_inc(&snapshot_device_available);\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nocompress;",
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "bool freezer_test_done;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"hibernation exit\\n\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&snapshot_device_available"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restore_console",
          "args": [],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "pm_restore_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/console.c",
          "lines": "143-152",
          "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_notifier_call_chain",
          "args": [
            "PM_POST_HIBERNATION",
            "nr_calls",
            "NULL"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "70-78",
          "snippet": "int __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_image_and_restore",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "load_image_and_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "658-682",
          "snippet": "static int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ);\n\tif (!error)\n\t\thibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load hibernation image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ);\n\tif (!error)\n\t\thibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load hibernation image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_check",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1512-1550",
          "snippet": "int swsusp_check(void)\n{\n\tint error;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ, NULL);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIBERNATE_SIG\t\"S1SUSPEND\""
          ],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;",
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\nstatic struct block_device *hib_resume_bdev;\n\nint swsusp_check(void)\n{\n\tint error;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ, NULL);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Checking hibernation image\\n\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_basic_memory_bitmaps",
          "args": [],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "free_basic_memory_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1121-1138",
          "snippet": "void free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nvoid free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Image restored successfully.\\n\""
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "power_down",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "power_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "614-656",
          "snippet": "static void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t/* Restore swap signature. */\n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\t/* Fall through */\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (pm_power_off)\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t/*\n\t * Valid image is on the disk, if we continue we risk serious data\n\t * corruption after resume.\n\t */\n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t/* Restore swap signature. */\n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\t/* Fall through */\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (pm_power_off)\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t/*\n\t * Valid image is on the disk, if we continue we risk serious data\n\t * corruption after resume.\n\t */\n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1451-1494",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_write",
          "args": [
            "flags"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "903-942",
          "snippet": "int swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Writing image.\\n\""
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_snapshot",
          "args": [
            "hibernation_mode == HIBERNATION_PLATFORM"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "343-416",
          "snippet": "int hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool freezer_test_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nbool freezer_test_done;\n\nint hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_basic_memory_bitmaps",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "create_basic_memory_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1071-1112",
          "snippet": "int create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n \tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n#define PG_ANY\t\t0\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nint create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n \tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_processes",
          "args": [],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_freeze_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "280-283",
          "snippet": "static inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"done.\\n\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksys_sync",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Syncing filesystems ... \\n\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_prepare_console",
          "args": [],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "pm_prepare_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/console.c",
          "lines": "130-141",
          "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
          ],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"hibernation entry\\n\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&snapshot_device_available",
            "-1",
            "0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation not available.\\n\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "71-74",
          "snippet": "bool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nocompress;\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nbool freezer_test_done;\n\nint hibernate(void)\n{\n\tint error, nr_calls = 0;\n\tbool snapshot_test = false;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = __pm_notifier_call_chain(PM_HIBERNATION_PREPARE, -1, &nr_calls);\n\tif (error) {\n\t\tnr_calls--;\n\t\tgoto Exit;\n\t}\n\n\tpr_info(\"Syncing filesystems ... \\n\");\n\tksys_sync();\n\tpr_info(\"done.\\n\");\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\t__pm_notifier_call_chain(PM_POST_HIBERNATION, nr_calls, NULL);\n\tpm_restore_console();\n\tatomic_inc(&snapshot_device_available);\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "load_image_and_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "658-682",
    "snippet": "static int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ);\n\tif (!error)\n\t\thibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load hibernation image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_basic_memory_bitmaps",
          "args": [],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "free_basic_memory_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1121-1138",
          "snippet": "void free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nvoid free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1451-1494",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to load hibernation image, recovering.\\n\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_restore",
          "args": [
            "flags & SF_PLATFORM_MODE"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "507-529",
          "snippet": "int hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_close",
          "args": [
            "FMODE_READ"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1556-1564",
          "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_read",
          "args": [
            "&flags"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1477-1506",
          "snippet": "int swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_basic_memory_bitmaps",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "create_basic_memory_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1071-1112",
          "snippet": "int create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n \tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n#define PG_ANY\t\t0\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nint create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n \tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Loading hibernation image.\\n\""
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ);\n\tif (!error)\n\t\thibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load hibernation image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}"
  },
  {
    "function_name": "power_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "614-656",
    "snippet": "static void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t/* Restore swap signature. */\n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\t/* Fall through */\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (pm_power_off)\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t/*\n\t * Valid image is on the disk, if we continue we risk serious data\n\t * corruption after resume.\n\t */\n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Power down manually\\n\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_halt",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_halt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/reboot.c",
          "lines": "269-277",
          "snippet": "void kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"System halted\\n\");\n\tkmsg_dump(KMSG_DUMP_HALT);\n\tmachine_halt();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n\nvoid kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"System halted\\n\");\n\tkmsg_dump(KMSG_DUMP_HALT);\n\tmachine_halt();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/reboot.c",
          "lines": "285-295",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_POWEROFF);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_POWEROFF);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_platform_enter",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_platform_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "534-605",
          "snippet": "int hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin();\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;",
            "static bool entering_platform_hibernation;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic bool entering_platform_hibernation;\n\nint hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin();\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_restart",
          "args": [
            "NULL"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/reboot.c",
          "lines": "242-253",
          "snippet": "void kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_RESTART);\n\tmachine_restart(cmd);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n\nvoid kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_RESTART);\n\tmachine_restart(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Swap will be unusable! Try swapon -a.\\n\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_unmark",
          "args": [],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_unmark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1571-1593",
          "snippet": "int swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t/*\n\t * We just returned from suspend, we don't need the image any more.\n\t */\n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIBERNATE_SIG\t\"S1SUSPEND\""
          ],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;",
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\nstatic unsigned short root_swap = 0xffff;\n\nint swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t/*\n\t * We just returned from suspend, we don't need the image any more.\n\t */\n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_devices_and_enter",
          "args": [
            "PM_SUSPEND_MEM"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_devices_and_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "198-201",
          "snippet": "static inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t/* Restore swap signature. */\n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\t/* Fall through */\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (pm_power_off)\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t/*\n\t * Valid image is on the disk, if we continue we risk serious data\n\t * corruption after resume.\n\t */\n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}"
  },
  {
    "function_name": "hibernation_platform_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "534-605",
    "snippet": "int hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin();\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;",
      "static bool entering_platform_hibernation;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->end",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_console",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "resume_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2189-2196",
          "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_resume_end",
          "args": [
            "PMSG_RESTORE"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_resume_start",
          "args": [
            "PMSG_RESTORE"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_ops->finish",
          "args": [],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_nonboot_cpus",
          "args": [],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "enable_nonboot_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1240-1270",
          "snippet": "void enable_nonboot_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_enable_nonboot_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_enable_nonboot_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid enable_nonboot_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_enable_nonboot_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_enable_nonboot_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_resume",
          "args": [],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_syscore_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/pm.c",
          "lines": "184-187",
          "snippet": "static void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_ops->enter",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_wakeup_pending",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_suspend",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_nonboot_cpus",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_ops->prepare",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_end",
          "args": [
            "PMSG_HIBERNATE"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_ops->recover",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_start",
          "args": [
            "PMSG_HIBERNATE"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_console",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2179-2187",
          "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_ops->begin",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic bool entering_platform_hibernation;\n\nint hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin();\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}"
  },
  {
    "function_name": "hibernation_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "507-529",
    "snippet": "int hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_restore_console",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "pm_restore_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/console.c",
          "lines": "143-152",
          "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resume_console",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "resume_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2189-2196",
          "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_resume_end",
          "args": [
            "PMSG_RECOVER"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!error"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_target_kernel",
          "args": [
            "platform_mode"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "resume_target_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "432-497",
          "snippet": "static int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t/*\n\t\t * The code below is only ever reached in case of a failure.\n\t\t * Otherwise, execution continues at the place where\n\t\t * swsusp_arch_suspend() was called.\n\t\t */\n\t\tBUG_ON(!error);\n\t\t/*\n\t\t * This call to restore_highmem() reverts the changes made by\n\t\t * the previous one.\n\t\t */\n\t\trestore_highmem();\n\t}\n\t/*\n\t * The only reason why swsusp_arch_resume() can fail is memory being\n\t * very tight, so we have to free it as soon as we can to avoid\n\t * subsequent failures.\n\t */\n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t/*\n\t\t * The code below is only ever reached in case of a failure.\n\t\t * Otherwise, execution continues at the place where\n\t\t * swsusp_arch_suspend() was called.\n\t\t */\n\t\tBUG_ON(!error);\n\t\t/*\n\t\t * This call to restore_highmem() reverts the changes made by\n\t\t * the previous one.\n\t\t */\n\t\trestore_highmem();\n\t}\n\t/*\n\t * The only reason why swsusp_arch_resume() can fail is memory being\n\t * very tight, so we have to free it as soon as we can to avoid\n\t * subsequent failures.\n\t */\n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_suspend_start",
          "args": [
            "PMSG_QUIESCE"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restrict_gfp_mask",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_console",
          "args": [],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2179-2187",
          "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_prepare_console",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "pm_prepare_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/console.c",
          "lines": "130-141",
          "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
          ],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}"
  },
  {
    "function_name": "resume_target_kernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "432-497",
    "snippet": "static int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t/*\n\t\t * The code below is only ever reached in case of a failure.\n\t\t * Otherwise, execution continues at the place where\n\t\t * swsusp_arch_suspend() was called.\n\t\t */\n\t\tBUG_ON(!error);\n\t\t/*\n\t\t * This call to restore_highmem() reverts the changes made by\n\t\t * the previous one.\n\t\t */\n\t\trestore_highmem();\n\t}\n\t/*\n\t * The only reason why swsusp_arch_resume() can fail is memory being\n\t * very tight, so we have to free it as soon as we can to avoid\n\t * subsequent failures.\n\t */\n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpm_resume_start",
          "args": [
            "PMSG_RECOVER"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_restore_cleanup",
          "args": [
            "platform_mode"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "platform_restore_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "217-221",
          "snippet": "static void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_nonboot_cpus",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "enable_nonboot_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1240-1270",
          "snippet": "void enable_nonboot_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_enable_nonboot_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_enable_nonboot_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid enable_nonboot_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_enable_nonboot_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_enable_nonboot_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_resume",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_syscore_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/pm.c",
          "lines": "184-187",
          "snippet": "static void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "298-302",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_processor_state",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1451-1494",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_highmem",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "restore_highmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "224-224",
          "snippet": "static inline int restore_highmem(void) { return 0; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int restore_highmem(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!error"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_arch_resume",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_processor_state",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_suspend",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernate_resume_nonboot_cpu_disable",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_resume_nonboot_cpu_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "418-421",
          "snippet": "int __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn disable_nonboot_cpus();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn disable_nonboot_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pre_restore",
          "args": [
            "platform_mode"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pre_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "200-204",
          "snippet": "static int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Some devices failed to power down, aborting resume\\n\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_end",
          "args": [
            "PMSG_QUIESCE"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t/*\n\t\t * The code below is only ever reached in case of a failure.\n\t\t * Otherwise, execution continues at the place where\n\t\t * swsusp_arch_suspend() was called.\n\t\t */\n\t\tBUG_ON(!error);\n\t\t/*\n\t\t * This call to restore_highmem() reverts the changes made by\n\t\t * the previous one.\n\t\t */\n\t\trestore_highmem();\n\t}\n\t/*\n\t * The only reason why swsusp_arch_resume() can fail is memory being\n\t * very tight, so we have to free it as soon as we can to avoid\n\t * subsequent failures.\n\t */\n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}"
  },
  {
    "function_name": "hibernate_resume_nonboot_cpu_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "418-421",
    "snippet": "int __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn disable_nonboot_cpus();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_nonboot_cpus",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn disable_nonboot_cpus();\n}"
  },
  {
    "function_name": "hibernation_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "343-416",
    "snippet": "int hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool freezer_test_done;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1451-1494",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_kernel_threads",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_kernel_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
          "lines": "227-245",
          "snippet": "void thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & (PF_KTHREAD | PF_WQ_WORKER))\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & (PF_KTHREAD | PF_WQ_WORKER))\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_end",
          "args": [
            "platform_mode"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "platform_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "140-144",
          "snippet": "static void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_complete",
          "args": [
            "msg"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_console",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "resume_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2189-2196",
          "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_resume",
          "args": [
            "msg"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_image",
          "args": [
            "platform_mode"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "create_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "270-335",
          "snippet": "static int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting hibernation\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting hibernation\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t/* Restore control flow magically appears here */\n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating hibernation image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting hibernation\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting hibernation\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t/* Restore control flow magically appears here */\n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating hibernation image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_recover",
          "args": [
            "platform_mode"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "platform_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "227-231",
          "snippet": "static void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_test",
          "args": [
            "TEST_DEVICES"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "123-123",
          "snippet": "static int hibernation_test(int level) { return 0; }",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_test(int level) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "dpm_suspend",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restrict_gfp_mask",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_console",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2179-2187",
          "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_complete",
          "args": [
            "PMSG_RECOVER"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_prepare",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_kernel_threads",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_kernel_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
          "lines": "170-187",
          "snippet": "int freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nint freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_preallocate_memory",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_preallocate_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1686-1834",
          "snippet": "int hibernate_preallocate_memory(void)\n{\n\tstruct zone *zone;\n\tunsigned long saveable, size, max_size, count, highmem, pages = 0;\n\tunsigned long alloc, save_highmem, pages_highmem, avail_normal;\n\tktime_t start, stop;\n\tint error;\n\n\tpr_info(\"Preallocating image memory... \");\n\tstart = ktime_get();\n\n\terror = memory_bm_create(&orig_bm, GFP_IMAGE, PG_ANY);\n\tif (error)\n\t\tgoto err_out;\n\n\terror = memory_bm_create(&copy_bm, GFP_IMAGE, PG_ANY);\n\tif (error)\n\t\tgoto err_out;\n\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\n\t/* Count the number of saveable data pages. */\n\tsave_highmem = count_highmem_pages();\n\tsaveable = count_data_pages();\n\n\t/*\n\t * Compute the total number of page frames we can use (count) and the\n\t * number of pages needed for image metadata (size).\n\t */\n\tcount = saveable;\n\tsaveable += save_highmem;\n\thighmem = save_highmem;\n\tsize = 0;\n\tfor_each_populated_zone(zone) {\n\t\tsize += snapshot_additional_pages(zone);\n\t\tif (is_highmem(zone))\n\t\t\thighmem += zone_page_state(zone, NR_FREE_PAGES);\n\t\telse\n\t\t\tcount += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\tavail_normal = count;\n\tcount += highmem;\n\tcount -= totalreserve_pages;\n\n\t/* Add number of pages required for page keys (s390 only). */\n\tsize += page_key_additional_pages(saveable);\n\n\t/* Compute the maximum number of saveable pages to leave in memory. */\n\tmax_size = (count - (size + PAGES_FOR_IO)) / 2\n\t\t\t- 2 * DIV_ROUND_UP(reserved_size, PAGE_SIZE);\n\t/* Compute the desired number of image pages specified by image_size. */\n\tsize = DIV_ROUND_UP(image_size, PAGE_SIZE);\n\tif (size > max_size)\n\t\tsize = max_size;\n\t/*\n\t * If the desired number of image pages is at least as large as the\n\t * current number of saveable pages in memory, allocate page frames for\n\t * the image and we're done.\n\t */\n\tif (size >= saveable) {\n\t\tpages = preallocate_image_highmem(save_highmem);\n\t\tpages += preallocate_image_memory(saveable - pages, avail_normal);\n\t\tgoto out;\n\t}\n\n\t/* Estimate the minimum size of the image. */\n\tpages = minimum_image_size(saveable);\n\t/*\n\t * To avoid excessive pressure on the normal zone, leave room in it to\n\t * accommodate an image of the minimum size (unless it's already too\n\t * small, in which case don't preallocate pages from it at all).\n\t */\n\tif (avail_normal > pages)\n\t\tavail_normal -= pages;\n\telse\n\t\tavail_normal = 0;\n\tif (size < pages)\n\t\tsize = min_t(unsigned long, pages, max_size);\n\n\t/*\n\t * Let the memory management subsystem know that we're going to need a\n\t * large number of page frames to allocate and make it free some memory.\n\t * NOTE: If this is not done, performance will be hurt badly in some\n\t * test cases.\n\t */\n\tshrink_all_memory(saveable - size);\n\n\t/*\n\t * The number of saveable pages in memory was too high, so apply some\n\t * pressure to decrease it.  First, make room for the largest possible\n\t * image and fail if that doesn't work.  Next, try to decrease the size\n\t * of the image as much as indicated by 'size' using allocations from\n\t * highmem and non-highmem zones separately.\n\t */\n\tpages_highmem = preallocate_image_highmem(highmem / 2);\n\talloc = count - max_size;\n\tif (alloc > pages_highmem)\n\t\talloc -= pages_highmem;\n\telse\n\t\talloc = 0;\n\tpages = preallocate_image_memory(alloc, avail_normal);\n\tif (pages < alloc) {\n\t\t/* We have exhausted non-highmem pages, try highmem. */\n\t\talloc -= pages;\n\t\tpages += pages_highmem;\n\t\tpages_highmem = preallocate_image_highmem(alloc);\n\t\tif (pages_highmem < alloc)\n\t\t\tgoto err_out;\n\t\tpages += pages_highmem;\n\t\t/*\n\t\t * size is the desired number of saveable pages to leave in\n\t\t * memory, so try to preallocate (all memory - size) pages.\n\t\t */\n\t\talloc = (count - pages) - size;\n\t\tpages += preallocate_image_highmem(alloc);\n\t} else {\n\t\t/*\n\t\t * There are approximately max_size saveable pages at this point\n\t\t * and we want to reduce this number down to size.\n\t\t */\n\t\talloc = max_size - size;\n\t\tsize = preallocate_highmem_fraction(alloc, highmem, count);\n\t\tpages_highmem += size;\n\t\talloc -= size;\n\t\tsize = preallocate_image_memory(alloc, avail_normal);\n\t\tpages_highmem += preallocate_image_highmem(alloc - size);\n\t\tpages += pages_highmem + size;\n\t}\n\n\t/*\n\t * We only need as many page frames for the image as there are saveable\n\t * pages in memory, but we have allocated more.  Release the excessive\n\t * ones now.\n\t */\n\tpages -= free_unnecessary_pages();\n\n out:\n\tstop = ktime_get();\n\tpr_cont(\"done (allocated %lu pages)\\n\", pages);\n\tswsusp_show_speed(start, stop, pages, \"Allocated\");\n\n\treturn 0;\n\n err_out:\n\tpr_cont(\"\\n\");\n\tswsusp_free();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define GFP_IMAGE\t(GFP_KERNEL | __GFP_NOWARN)",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "unsigned long reserved_size;",
            "unsigned long image_size;",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static unsigned int alloc_normal, alloc_highmem;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define GFP_IMAGE\t(GFP_KERNEL | __GFP_NOWARN)\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nunsigned long reserved_size;\nunsigned long image_size;\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic unsigned int alloc_normal, alloc_highmem;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint hibernate_preallocate_memory(void)\n{\n\tstruct zone *zone;\n\tunsigned long saveable, size, max_size, count, highmem, pages = 0;\n\tunsigned long alloc, save_highmem, pages_highmem, avail_normal;\n\tktime_t start, stop;\n\tint error;\n\n\tpr_info(\"Preallocating image memory... \");\n\tstart = ktime_get();\n\n\terror = memory_bm_create(&orig_bm, GFP_IMAGE, PG_ANY);\n\tif (error)\n\t\tgoto err_out;\n\n\terror = memory_bm_create(&copy_bm, GFP_IMAGE, PG_ANY);\n\tif (error)\n\t\tgoto err_out;\n\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\n\t/* Count the number of saveable data pages. */\n\tsave_highmem = count_highmem_pages();\n\tsaveable = count_data_pages();\n\n\t/*\n\t * Compute the total number of page frames we can use (count) and the\n\t * number of pages needed for image metadata (size).\n\t */\n\tcount = saveable;\n\tsaveable += save_highmem;\n\thighmem = save_highmem;\n\tsize = 0;\n\tfor_each_populated_zone(zone) {\n\t\tsize += snapshot_additional_pages(zone);\n\t\tif (is_highmem(zone))\n\t\t\thighmem += zone_page_state(zone, NR_FREE_PAGES);\n\t\telse\n\t\t\tcount += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\tavail_normal = count;\n\tcount += highmem;\n\tcount -= totalreserve_pages;\n\n\t/* Add number of pages required for page keys (s390 only). */\n\tsize += page_key_additional_pages(saveable);\n\n\t/* Compute the maximum number of saveable pages to leave in memory. */\n\tmax_size = (count - (size + PAGES_FOR_IO)) / 2\n\t\t\t- 2 * DIV_ROUND_UP(reserved_size, PAGE_SIZE);\n\t/* Compute the desired number of image pages specified by image_size. */\n\tsize = DIV_ROUND_UP(image_size, PAGE_SIZE);\n\tif (size > max_size)\n\t\tsize = max_size;\n\t/*\n\t * If the desired number of image pages is at least as large as the\n\t * current number of saveable pages in memory, allocate page frames for\n\t * the image and we're done.\n\t */\n\tif (size >= saveable) {\n\t\tpages = preallocate_image_highmem(save_highmem);\n\t\tpages += preallocate_image_memory(saveable - pages, avail_normal);\n\t\tgoto out;\n\t}\n\n\t/* Estimate the minimum size of the image. */\n\tpages = minimum_image_size(saveable);\n\t/*\n\t * To avoid excessive pressure on the normal zone, leave room in it to\n\t * accommodate an image of the minimum size (unless it's already too\n\t * small, in which case don't preallocate pages from it at all).\n\t */\n\tif (avail_normal > pages)\n\t\tavail_normal -= pages;\n\telse\n\t\tavail_normal = 0;\n\tif (size < pages)\n\t\tsize = min_t(unsigned long, pages, max_size);\n\n\t/*\n\t * Let the memory management subsystem know that we're going to need a\n\t * large number of page frames to allocate and make it free some memory.\n\t * NOTE: If this is not done, performance will be hurt badly in some\n\t * test cases.\n\t */\n\tshrink_all_memory(saveable - size);\n\n\t/*\n\t * The number of saveable pages in memory was too high, so apply some\n\t * pressure to decrease it.  First, make room for the largest possible\n\t * image and fail if that doesn't work.  Next, try to decrease the size\n\t * of the image as much as indicated by 'size' using allocations from\n\t * highmem and non-highmem zones separately.\n\t */\n\tpages_highmem = preallocate_image_highmem(highmem / 2);\n\talloc = count - max_size;\n\tif (alloc > pages_highmem)\n\t\talloc -= pages_highmem;\n\telse\n\t\talloc = 0;\n\tpages = preallocate_image_memory(alloc, avail_normal);\n\tif (pages < alloc) {\n\t\t/* We have exhausted non-highmem pages, try highmem. */\n\t\talloc -= pages;\n\t\tpages += pages_highmem;\n\t\tpages_highmem = preallocate_image_highmem(alloc);\n\t\tif (pages_highmem < alloc)\n\t\t\tgoto err_out;\n\t\tpages += pages_highmem;\n\t\t/*\n\t\t * size is the desired number of saveable pages to leave in\n\t\t * memory, so try to preallocate (all memory - size) pages.\n\t\t */\n\t\talloc = (count - pages) - size;\n\t\tpages += preallocate_image_highmem(alloc);\n\t} else {\n\t\t/*\n\t\t * There are approximately max_size saveable pages at this point\n\t\t * and we want to reduce this number down to size.\n\t\t */\n\t\talloc = max_size - size;\n\t\tsize = preallocate_highmem_fraction(alloc, highmem, count);\n\t\tpages_highmem += size;\n\t\talloc -= size;\n\t\tsize = preallocate_image_memory(alloc, avail_normal);\n\t\tpages_highmem += preallocate_image_highmem(alloc - size);\n\t\tpages += pages_highmem + size;\n\t}\n\n\t/*\n\t * We only need as many page frames for the image as there are saveable\n\t * pages in memory, but we have allocated more.  Release the excessive\n\t * ones now.\n\t */\n\tpages -= free_unnecessary_pages();\n\n out:\n\tstop = ktime_get();\n\tpr_cont(\"done (allocated %lu pages)\\n\", pages);\n\tswsusp_show_speed(start, stop, pages, \"Allocated\");\n\n\treturn 0;\n\n err_out:\n\tpr_cont(\"\\n\");\n\tswsusp_free();\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_begin",
          "args": [
            "platform_mode"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "platform_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "130-134",
          "snippet": "static int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin() : 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin() : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_suspend_clear_flags",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nbool freezer_test_done;\n\nint hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}"
  },
  {
    "function_name": "create_image",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "270-335",
    "snippet": "static int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting hibernation\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting hibernation\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t/* Restore control flow magically appears here */\n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating hibernation image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpm_resume_start",
          "args": [
            "in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_finish",
          "args": [
            "platform_mode"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "platform_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "184-188",
          "snippet": "static void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_nonboot_cpus",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "enable_nonboot_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1240-1270",
          "snippet": "void enable_nonboot_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_enable_nonboot_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_enable_nonboot_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid enable_nonboot_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_enable_nonboot_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_enable_nonboot_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_resume",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_syscore_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/pm.c",
          "lines": "184-187",
          "snippet": "static void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_leave",
          "args": [
            "platform_mode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "platform_leave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "169-173",
          "snippet": "static void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_free_pages",
          "args": [],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "clear_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1140-1160",
          "snippet": "void clear_free_pages(void)\n{\n#ifdef CONFIG_PAGE_POISONING_ZERO\n\tstruct memory_bitmap *bm = free_pages_map;\n\tunsigned long pfn;\n\n\tif (WARN_ON(!(free_pages_map)))\n\t\treturn;\n\n\tmemory_bm_position_reset(bm);\n\tpfn = memory_bm_next_pfn(bm);\n\twhile (pfn != BM_END_OF_MAP) {\n\t\tif (pfn_valid(pfn))\n\t\t\tclear_highpage(pfn_to_page(pfn));\n\n\t\tpfn = memory_bm_next_pfn(bm);\n\t}\n\tmemory_bm_position_reset(bm);\n\tpr_info(\"free pages cleared after restore\\n\");\n#endif /* PAGE_POISONING_ZERO */\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic struct memory_bitmap *free_pages_map;\n\nvoid clear_free_pages(void)\n{\n#ifdef CONFIG_PAGE_POISONING_ZERO\n\tstruct memory_bitmap *bm = free_pages_map;\n\tunsigned long pfn;\n\n\tif (WARN_ON(!(free_pages_map)))\n\t\treturn;\n\n\tmemory_bm_position_reset(bm);\n\tpfn = memory_bm_next_pfn(bm);\n\twhile (pfn != BM_END_OF_MAP) {\n\t\tif (pfn_valid(pfn))\n\t\t\tclear_highpage(pfn_to_page(pfn));\n\n\t\tpfn = memory_bm_next_pfn(bm);\n\t}\n\tmemory_bm_position_reset(bm);\n\tpr_info(\"free pages cleared after restore\\n\");\n#endif /* PAGE_POISONING_ZERO */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error %d creating hibernation image\\n\"",
            "error"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"machine_suspend\")",
            "PM_EVENT_HIBERNATE",
            "false"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"machine_suspend\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_processor_state",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_arch_suspend",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"machine_suspend\")",
            "PM_EVENT_HIBERNATE",
            "true"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"machine_suspend\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_processor_state",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_wakeup_pending",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_test",
          "args": [
            "TEST_CORE"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "123-123",
          "snippet": "static int hibernation_test(int level) { return 0; }",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_test(int level) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Some system devices failed to power down, aborting hibernation\\n\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_suspend",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_nonboot_cpus",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_pre_snapshot",
          "args": [
            "platform_mode"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pre_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "154-158",
          "snippet": "static int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Some devices failed to power down, aborting hibernation\\n\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_end",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting hibernation\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting hibernation\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t/* Restore control flow magically appears here */\n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating hibernation image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}"
  },
  {
    "function_name": "swsusp_show_speed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "240-259",
    "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\"",
            "msg",
            "k",
            "centisecs / 100",
            "centisecs % 100",
            "kps / 1000",
            "(kps % 1000) / 10"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_divns",
          "args": [
            "diff",
            "10*NSEC_PER_MSEC"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_divns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "299-316",
          "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "stop",
            "start"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
  },
  {
    "function_name": "platform_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "227-231",
    "snippet": "static void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->recover",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}"
  },
  {
    "function_name": "platform_restore_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "217-221",
    "snippet": "static void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->restore_cleanup",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}"
  },
  {
    "function_name": "platform_pre_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "200-204",
    "snippet": "static int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->pre_restore",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}"
  },
  {
    "function_name": "platform_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "184-188",
    "snippet": "static void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->finish",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}"
  },
  {
    "function_name": "platform_leave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "169-173",
    "snippet": "static void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->leave",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}"
  },
  {
    "function_name": "platform_pre_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "154-158",
    "snippet": "static int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->pre_snapshot",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}"
  },
  {
    "function_name": "platform_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "140-144",
    "snippet": "static void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->end",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}"
  },
  {
    "function_name": "platform_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "130-134",
    "snippet": "static int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin() : 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->begin",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin() : 0;\n}"
  },
  {
    "function_name": "hibernation_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "123-123",
    "snippet": "static int hibernation_test(int level) { return 0; }",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_test(int level) { return 0; }"
  },
  {
    "function_name": "hibernation_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "114-121",
    "snippet": "static int hibernation_test(int level)\n{\n\tif (pm_test_level == level) {\n\t\thibernation_debug_sleep();\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_debug_sleep",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_debug_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "108-112",
          "snippet": "static void hibernation_debug_sleep(void)\n{\n\tpr_info(\"hibernation debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic void hibernation_debug_sleep(void)\n{\n\tpr_info(\"hibernation debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_test(int level)\n{\n\tif (pm_test_level == level) {\n\t\thibernation_debug_sleep();\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hibernation_debug_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "108-112",
    "snippet": "static void hibernation_debug_sleep(void)\n{\n\tpr_info(\"hibernation debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "5000"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"hibernation debug: Waiting for 5 seconds.\\n\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic void hibernation_debug_sleep(void)\n{\n\tpr_info(\"hibernation debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}"
  },
  {
    "function_name": "system_entering_hibernation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "101-104",
    "snippet": "bool system_entering_hibernation(void)\n{\n\treturn entering_platform_hibernation;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool entering_platform_hibernation;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic bool entering_platform_hibernation;\n\nbool system_entering_hibernation(void)\n{\n\treturn entering_platform_hibernation;\n}"
  },
  {
    "function_name": "hibernation_set_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "80-96",
    "snippet": "void hibernation_set_ops(const struct platform_hibernation_ops *ops)\n{\n\tif (ops && !(ops->begin && ops->end &&  ops->pre_snapshot\n\t    && ops->prepare && ops->finish && ops->enter && ops->pre_restore\n\t    && ops->restore_cleanup && ops->leave)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tlock_system_sleep();\n\thibernation_ops = ops;\n\tif (ops)\n\t\thibernation_mode = HIBERNATION_PLATFORM;\n\telse if (hibernation_mode == HIBERNATION_PLATFORM)\n\t\thibernation_mode = HIBERNATION_SHUTDOWN;\n\n\tunlock_system_sleep();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nvoid hibernation_set_ops(const struct platform_hibernation_ops *ops)\n{\n\tif (ops && !(ops->begin && ops->end &&  ops->pre_snapshot\n\t    && ops->prepare && ops->finish && ops->enter && ops->pre_restore\n\t    && ops->restore_cleanup && ops->leave)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tlock_system_sleep();\n\thibernation_ops = ops;\n\tif (ops)\n\t\thibernation_mode = HIBERNATION_PLATFORM;\n\telse if (hibernation_mode == HIBERNATION_PLATFORM)\n\t\thibernation_mode = HIBERNATION_SHUTDOWN;\n\n\tunlock_system_sleep();\n}"
  },
  {
    "function_name": "hibernation_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
    "lines": "71-74",
    "snippet": "bool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nohibernate;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}"
  }
]