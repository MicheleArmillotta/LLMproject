[
  {
    "function_name": "tick_check_oneshot_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1371-1389",
    "snippet": "int tick_check_oneshot_change(int allow_nohz)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (!test_and_clear_bit(0, &ts->check_clocks))\n\t\treturn 0;\n\n\tif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\n\t\treturn 0;\n\n\tif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\n\t\treturn 0;\n\n\tif (!allow_nohz)\n\t\treturn 1;\n\n\ttick_nohz_switch_to_nohz();\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_switch_to_nohz",
          "args": [],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_switch_to_nohz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1237-1237",
          "snippet": "static inline void tick_nohz_switch_to_nohz(void) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_switch_to_nohz(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_is_oneshot_available",
          "args": [],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "tick_is_oneshot_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "65-74",
          "snippet": "int tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_valid_for_hres",
          "args": [],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_valid_for_hres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1434-1448",
          "snippet": "int timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "0",
            "&ts->check_clocks"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nint tick_check_oneshot_change(int allow_nohz)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (!test_and_clear_bit(0, &ts->check_clocks))\n\t\treturn 0;\n\n\tif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\n\t\treturn 0;\n\n\tif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\n\t\treturn 0;\n\n\tif (!allow_nohz)\n\t\treturn 1;\n\n\ttick_nohz_switch_to_nohz();\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_oneshot_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1356-1361",
    "snippet": "void tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "&ts->check_clocks"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}"
  },
  {
    "function_name": "tick_clock_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1345-1351",
    "snippet": "void tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}"
  },
  {
    "function_name": "tick_cancel_sched_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1329-1339",
    "snippet": "void tick_cancel_sched_timer(int cpu)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\n# ifdef CONFIG_HIGH_RES_TIMERS\n\tif (ts->sched_timer.base)\n\t\thrtimer_cancel(&ts->sched_timer);\n# endif\n\n\tmemset(ts, 0, sizeof(*ts));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ts",
            "0",
            "sizeof(*ts)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_cancel_sched_timer(int cpu)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\n# ifdef CONFIG_HIGH_RES_TIMERS\n\tif (ts->sched_timer.base)\n\t\thrtimer_cancel(&ts->sched_timer);\n# endif\n\n\tmemset(ts, 0, sizeof(*ts));\n}"
  },
  {
    "function_name": "tick_setup_sched_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1300-1325",
    "snippet": "void tick_setup_sched_timer(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now = ktime_get();\n\n\t/*\n\t * Emulate tick processing via per-CPU hrtimers:\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tts->sched_timer.function = tick_sched_timer;\n\n\t/* Get the next period (per-CPU) */\n\thrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\n\n\t/* Offset the tick to avert jiffies_lock contention. */\n\tif (sched_skew_tick) {\n\t\tu64 offset = ktime_to_ns(tick_period) >> 1;\n\t\tdo_div(offset, num_possible_cpus());\n\t\toffset *= smp_processor_id();\n\t\thrtimer_add_expires_ns(&ts->sched_timer, offset);\n\t}\n\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);\n\ttick_nohz_activate(ts, NOHZ_MODE_HIGHRES);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_activate",
          "args": [
            "ts",
            "NOHZ_MODE_HIGHRES"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1239-1239",
          "snippet": "static inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&ts->sched_timer",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "&ts->sched_timer",
            "now",
            "tick_period"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "907-939",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_add_expires_ns",
          "args": [
            "&ts->sched_timer",
            "offset"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "offset",
            "num_possible_cpus()"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tick_period"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&ts->sched_timer",
            "tick_init_jiffy_update()"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_init_jiffy_update",
          "args": [],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "tick_init_jiffy_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "103-114",
          "snippet": "static ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\twrite_seqlock(&jiffies_lock);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_sequnlock(&jiffies_lock);\n\treturn period;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\twrite_seqlock(&jiffies_lock);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_sequnlock(&jiffies_lock);\n\treturn period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&ts->sched_timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_setup_sched_timer(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now = ktime_get();\n\n\t/*\n\t * Emulate tick processing via per-CPU hrtimers:\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tts->sched_timer.function = tick_sched_timer;\n\n\t/* Get the next period (per-CPU) */\n\thrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\n\n\t/* Offset the tick to avert jiffies_lock contention. */\n\tif (sched_skew_tick) {\n\t\tu64 offset = ktime_to_ns(tick_period) >> 1;\n\t\tdo_div(offset, num_possible_cpus());\n\t\toffset *= smp_processor_id();\n\t\thrtimer_add_expires_ns(&ts->sched_timer, offset);\n\t}\n\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);\n\ttick_nohz_activate(ts, NOHZ_MODE_HIGHRES);\n}"
  },
  {
    "function_name": "skew_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1289-1294",
    "snippet": "static int __init skew_tick(char *str)\n{\n\tget_option(&str, &sched_skew_tick);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&sched_skew_tick"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int __init skew_tick(char *str)\n{\n\tget_option(&str, &sched_skew_tick);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_sched_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1260-1285",
    "snippet": "static enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)\n{\n\tstruct tick_sched *ts =\n\t\tcontainer_of(timer, struct tick_sched, sched_timer);\n\tstruct pt_regs *regs = get_irq_regs();\n\tktime_t now = ktime_get();\n\n\ttick_sched_do_timer(ts, now);\n\n\t/*\n\t * Do not call, when we are not in irq context and have\n\t * no valid regs pointer\n\t */\n\tif (regs)\n\t\ttick_sched_handle(ts, regs);\n\telse\n\t\tts->next_tick = 0;\n\n\t/* No need to reprogram if we are in idle or full dynticks mode */\n\tif (unlikely(ts->tick_stopped))\n\t\treturn HRTIMER_NORESTART;\n\n\thrtimer_forward(timer, now, tick_period);\n\n\treturn HRTIMER_RESTART;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "timer",
            "now",
            "tick_period"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "907-939",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->tick_stopped"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_sched_handle",
          "args": [
            "ts",
            "regs"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "tick_sched_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "141-166",
          "snippet": "static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_sched_do_timer",
          "args": [
            "ts",
            "now"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "tick_sched_do_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "116-139",
          "snippet": "static void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t    && !tick_nohz_full_cpu(cpu))\n\t\ttick_do_timer_cpu = cpu;\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t    && !tick_nohz_full_cpu(cpu))\n\t\ttick_do_timer_cpu = cpu;\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structtick_sched",
            "sched_timer"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)\n{\n\tstruct tick_sched *ts =\n\t\tcontainer_of(timer, struct tick_sched, sched_timer);\n\tstruct pt_regs *regs = get_irq_regs();\n\tktime_t now = ktime_get();\n\n\ttick_sched_do_timer(ts, now);\n\n\t/*\n\t * Do not call, when we are not in irq context and have\n\t * no valid regs pointer\n\t */\n\tif (regs)\n\t\ttick_sched_handle(ts, regs);\n\telse\n\t\tts->next_tick = 0;\n\n\t/* No need to reprogram if we are in idle or full dynticks mode */\n\tif (unlikely(ts->tick_stopped))\n\t\treturn HRTIMER_NORESTART;\n\n\thrtimer_forward(timer, now, tick_period);\n\n\treturn HRTIMER_RESTART;\n}"
  },
  {
    "function_name": "tick_irq_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1246-1250",
    "snippet": "void tick_irq_enter(void)\n{\n\ttick_check_oneshot_broadcast_this_cpu();\n\ttick_nohz_irq_enter();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_irq_enter",
          "args": [],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_irq_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1238-1238",
          "snippet": "static inline void tick_nohz_irq_enter(void) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_irq_enter(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_oneshot_broadcast_this_cpu",
          "args": [],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_oneshot_broadcast_this_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "579-594",
          "snippet": "void tick_check_oneshot_broadcast_this_cpu(void)\n{\n\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {\n\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\t\t/*\n\t\t * We might be in the middle of switching over from\n\t\t * periodic to oneshot. If the CPU has not yet\n\t\t * switched over, leave the device alone.\n\t\t */\n\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {\n\t\t\tclockevents_switch_state(td->evtdev,\n\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_oneshot_broadcast_this_cpu(void)\n{\n\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {\n\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\t\t/*\n\t\t * We might be in the middle of switching over from\n\t\t * periodic to oneshot. If the CPU has not yet\n\t\t * switched over, leave the device alone.\n\t\t */\n\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {\n\t\t\tclockevents_switch_state(td->evtdev,\n\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_irq_enter(void)\n{\n\ttick_check_oneshot_broadcast_this_cpu();\n\ttick_nohz_irq_enter();\n}"
  },
  {
    "function_name": "tick_nohz_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1239-1239",
    "snippet": "static inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }"
  },
  {
    "function_name": "tick_nohz_irq_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1238-1238",
    "snippet": "static inline void tick_nohz_irq_enter(void) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_irq_enter(void) { }"
  },
  {
    "function_name": "tick_nohz_switch_to_nohz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1237-1237",
    "snippet": "static inline void tick_nohz_switch_to_nohz(void) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_switch_to_nohz(void) { }"
  },
  {
    "function_name": "tick_nohz_irq_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1221-1233",
    "snippet": "static inline void tick_nohz_irq_enter(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tif (!ts->idle_active && !ts->tick_stopped)\n\t\treturn;\n\tnow = ktime_get();\n\tif (ts->idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\tif (ts->tick_stopped)\n\t\ttick_nohz_update_jiffies(now);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_update_jiffies",
          "args": [
            "now"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_update_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "492-503",
          "snippet": "static void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog_sched();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog_sched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_idle",
          "args": [
            "ts",
            "now"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "527-533",
          "snippet": "static void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic inline void tick_nohz_irq_enter(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tif (!ts->idle_active && !ts->tick_stopped)\n\t\treturn;\n\tnow = ktime_get();\n\tif (ts->idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\tif (ts->tick_stopped)\n\t\ttick_nohz_update_jiffies(now);\n}"
  },
  {
    "function_name": "tick_nohz_switch_to_nohz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1196-1219",
    "snippet": "static void tick_nohz_switch_to_nohz(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t next;\n\n\tif (!tick_nohz_enabled)\n\t\treturn;\n\n\tif (tick_switch_to_oneshot(tick_nohz_handler))\n\t\treturn;\n\n\t/*\n\t * Recycle the hrtimer in ts, so we can share the\n\t * hrtimer_forward with the highres code.\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t/* Get the next period */\n\tnext = tick_init_jiffy_update();\n\n\thrtimer_set_expires(&ts->sched_timer, next);\n\thrtimer_forward_now(&ts->sched_timer, tick_period);\n\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n\ttick_nohz_activate(ts, NOHZ_MODE_LOWRES);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_activate",
          "args": [
            "ts",
            "NOHZ_MODE_LOWRES"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1239-1239",
          "snippet": "static inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "hrtimer_get_expires(&ts->sched_timer)",
            "1"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "27-49",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward_now",
          "args": [
            "&ts->sched_timer",
            "tick_period"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&ts->sched_timer",
            "next"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_init_jiffy_update",
          "args": [],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "tick_init_jiffy_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "103-114",
          "snippet": "static ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\twrite_seqlock(&jiffies_lock);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_sequnlock(&jiffies_lock);\n\treturn period;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\twrite_seqlock(&jiffies_lock);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_sequnlock(&jiffies_lock);\n\treturn period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&ts->sched_timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_switch_to_oneshot",
          "args": [
            "tick_nohz_handler"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "tick_switch_to_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "77-103",
          "snippet": "int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||\n\t\t    !tick_device_is_functional(dev)) {\n\n\t\tpr_info(\"Clockevents: could not switch to one-shot mode:\");\n\t\tif (!dev) {\n\t\t\tpr_cont(\" no tick device\\n\");\n\t\t} else {\n\t\t\tif (!tick_device_is_functional(dev))\n\t\t\t\tpr_cont(\" %s is not functional.\\n\", dev->name);\n\t\t\telse\n\t\t\t\tpr_cont(\" %s does not support one-shot mode.\\n\",\n\t\t\t\t\tdev->name);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\ttd->mode = TICKDEV_MODE_ONESHOT;\n\tdev->event_handler = handler;\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\ttick_broadcast_switch_to_oneshot();\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||\n\t\t    !tick_device_is_functional(dev)) {\n\n\t\tpr_info(\"Clockevents: could not switch to one-shot mode:\");\n\t\tif (!dev) {\n\t\t\tpr_cont(\" no tick device\\n\");\n\t\t} else {\n\t\t\tif (!tick_device_is_functional(dev))\n\t\t\t\tpr_cont(\" %s is not functional.\\n\", dev->name);\n\t\t\telse\n\t\t\t\tpr_cont(\" %s does not support one-shot mode.\\n\",\n\t\t\t\t\tdev->name);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\ttd->mode = TICKDEV_MODE_ONESHOT;\n\tdev->event_handler = handler;\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\ttick_broadcast_switch_to_oneshot();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic void tick_nohz_switch_to_nohz(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t next;\n\n\tif (!tick_nohz_enabled)\n\t\treturn;\n\n\tif (tick_switch_to_oneshot(tick_nohz_handler))\n\t\treturn;\n\n\t/*\n\t * Recycle the hrtimer in ts, so we can share the\n\t * hrtimer_forward with the highres code.\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t/* Get the next period */\n\tnext = tick_init_jiffy_update();\n\n\thrtimer_set_expires(&ts->sched_timer, next);\n\thrtimer_forward_now(&ts->sched_timer, tick_period);\n\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n\ttick_nohz_activate(ts, NOHZ_MODE_LOWRES);\n}"
  },
  {
    "function_name": "tick_nohz_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1183-1191",
    "snippet": "static inline void tick_nohz_activate(struct tick_sched *ts, int mode)\n{\n\tif (!tick_nohz_enabled)\n\t\treturn;\n\tts->nohz_mode = mode;\n\t/* One update is enough */\n\tif (!test_and_set_bit(0, &tick_nohz_active))\n\t\ttimers_update_nohz();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timers_update_nohz",
          "args": [],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "timers_update_nohz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "243-246",
          "snippet": "void timers_update_nohz(void)\n{\n\tschedule_work(&timer_update_work);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid timers_update_nohz(void)\n{\n\tschedule_work(&timer_update_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&tick_nohz_active"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_activate(struct tick_sched *ts, int mode)\n{\n\tif (!tick_nohz_enabled)\n\t\treturn;\n\tts->nohz_mode = mode;\n\t/* One update is enough */\n\tif (!test_and_set_bit(0, &tick_nohz_active))\n\t\ttimers_update_nohz();\n}"
  },
  {
    "function_name": "tick_nohz_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1164-1181",
    "snippet": "static void tick_nohz_handler(struct clock_event_device *dev)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tstruct pt_regs *regs = get_irq_regs();\n\tktime_t now = ktime_get();\n\n\tdev->next_event = KTIME_MAX;\n\n\ttick_sched_do_timer(ts, now);\n\ttick_sched_handle(ts, regs);\n\n\t/* No need to reprogram if we are running tickless  */\n\tif (unlikely(ts->tick_stopped))\n\t\treturn;\n\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "hrtimer_get_expires(&ts->sched_timer)",
            "1"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "27-49",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "&ts->sched_timer",
            "now",
            "tick_period"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "907-939",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->tick_stopped"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_sched_handle",
          "args": [
            "ts",
            "regs"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "tick_sched_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "141-166",
          "snippet": "static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_sched_do_timer",
          "args": [
            "ts",
            "now"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "tick_sched_do_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "116-139",
          "snippet": "static void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t    && !tick_nohz_full_cpu(cpu))\n\t\ttick_do_timer_cpu = cpu;\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t    && !tick_nohz_full_cpu(cpu))\n\t\ttick_do_timer_cpu = cpu;\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic void tick_nohz_handler(struct clock_event_device *dev)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tstruct pt_regs *regs = get_irq_regs();\n\tktime_t now = ktime_get();\n\n\tdev->next_event = KTIME_MAX;\n\n\ttick_sched_do_timer(ts, now);\n\ttick_sched_handle(ts, regs);\n\n\t/* No need to reprogram if we are running tickless  */\n\tif (unlikely(ts->tick_stopped))\n\t\treturn;\n\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n}"
  },
  {
    "function_name": "tick_nohz_idle_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1134-1159",
    "snippet": "void tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tbool idle_active, tick_stopped;\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 0;\n\tidle_active = ts->idle_active;\n\ttick_stopped = ts->tick_stopped;\n\n\tif (idle_active || tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (tick_stopped)\n\t\t__tick_nohz_idle_restart_tick(ts, now);\n\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tick_nohz_idle_restart_tick",
          "args": [
            "ts",
            "now"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_nohz_idle_restart_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1113-1117",
          "snippet": "static void __tick_nohz_idle_restart_tick(struct tick_sched *ts, ktime_t now)\n{\n\ttick_nohz_restart_sched_tick(ts, now);\n\ttick_nohz_account_idle_ticks(ts);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_idle_restart_tick(struct tick_sched *ts, ktime_t now)\n{\n\ttick_nohz_restart_sched_tick(ts, now);\n\ttick_nohz_account_idle_ticks(ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_idle",
          "args": [
            "ts",
            "now"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "527-533",
          "snippet": "static void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ts->timer_expires_base"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ts->inidle"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tbool idle_active, tick_stopped;\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 0;\n\tidle_active = ts->idle_active;\n\ttick_stopped = ts->tick_stopped;\n\n\tif (idle_active || tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (tick_stopped)\n\t\t__tick_nohz_idle_restart_tick(ts, now);\n\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "tick_nohz_idle_restart_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1119-1125",
    "snippet": "void tick_nohz_idle_restart_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped)\n\t\t__tick_nohz_idle_restart_tick(ts, ktime_get());\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tick_nohz_idle_restart_tick",
          "args": [
            "ts",
            "ktime_get()"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_nohz_idle_restart_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1113-1117",
          "snippet": "static void __tick_nohz_idle_restart_tick(struct tick_sched *ts, ktime_t now)\n{\n\ttick_nohz_restart_sched_tick(ts, now);\n\ttick_nohz_account_idle_ticks(ts);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_idle_restart_tick(struct tick_sched *ts, ktime_t now)\n{\n\ttick_nohz_restart_sched_tick(ts, now);\n\ttick_nohz_account_idle_ticks(ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_restart_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped)\n\t\t__tick_nohz_idle_restart_tick(ts, ktime_get());\n}"
  },
  {
    "function_name": "__tick_nohz_idle_restart_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1113-1117",
    "snippet": "static void __tick_nohz_idle_restart_tick(struct tick_sched *ts, ktime_t now)\n{\n\ttick_nohz_restart_sched_tick(ts, now);\n\ttick_nohz_account_idle_ticks(ts);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_account_idle_ticks",
          "args": [
            "ts"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_account_idle_ticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1092-1111",
          "snippet": "static void tick_nohz_account_idle_ticks(struct tick_sched *ts)\n{\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE\n\tunsigned long ticks;\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n#endif\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_account_idle_ticks(struct tick_sched *ts)\n{\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE\n\tunsigned long ticks;\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_restart_sched_tick",
          "args": [
            "ts",
            "now"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_restart_sched_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "821-842",
          "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\tcpu_load_update_nohz_stop();\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\tts->idle_exittime = now;\n\n\ttick_nohz_restart(ts, now);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\tcpu_load_update_nohz_stop();\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\tts->idle_exittime = now;\n\n\ttick_nohz_restart(ts, now);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_idle_restart_tick(struct tick_sched *ts, ktime_t now)\n{\n\ttick_nohz_restart_sched_tick(ts, now);\n\ttick_nohz_account_idle_ticks(ts);\n}"
  },
  {
    "function_name": "tick_nohz_account_idle_ticks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1092-1111",
    "snippet": "static void tick_nohz_account_idle_ticks(struct tick_sched *ts)\n{\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE\n\tunsigned long ticks;\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n#endif\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_idle_ticks",
          "args": [
            "ticks"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_account_idle_ticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1092-1111",
          "snippet": "static void tick_nohz_account_idle_ticks(struct tick_sched *ts)\n{\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE\n\tunsigned long ticks;\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "vtime_accounting_cpu_enabled",
          "args": [],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_account_idle_ticks(struct tick_sched *ts)\n{\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE\n\tunsigned long ticks;\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n#endif\n}"
  },
  {
    "function_name": "tick_nohz_get_idle_calls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1085-1090",
    "snippet": "unsigned long tick_nohz_get_idle_calls(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->idle_calls;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nunsigned long tick_nohz_get_idle_calls(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->idle_calls;\n}"
  },
  {
    "function_name": "tick_nohz_get_idle_calls_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1073-1078",
    "snippet": "unsigned long tick_nohz_get_idle_calls_cpu(int cpu)\n{\n\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\n\treturn ts->idle_calls;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_get_tick_sched",
          "args": [
            "cpu"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_tick_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "43-46",
          "snippet": "struct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstruct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nunsigned long tick_nohz_get_idle_calls_cpu(int cpu)\n{\n\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\n\treturn ts->idle_calls;\n}"
  },
  {
    "function_name": "tick_nohz_get_sleep_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1034-1065",
    "snippet": "ktime_t tick_nohz_get_sleep_length(ktime_t *delta_next)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tint cpu = smp_processor_id();\n\t/*\n\t * The idle entry time is expected to be a sufficient approximation of\n\t * the current time at this point.\n\t */\n\tktime_t now = ts->idle_entrytime;\n\tktime_t next_event;\n\n\tWARN_ON_ONCE(!ts->inidle);\n\n\t*delta_next = ktime_sub(dev->next_event, now);\n\n\tif (!can_stop_idle_tick(cpu, ts))\n\t\treturn *delta_next;\n\n\tnext_event = tick_nohz_next_event(ts, cpu);\n\tif (!next_event)\n\t\treturn *delta_next;\n\n\t/*\n\t * If the next highres timer to expire is earlier than next_event, the\n\t * idle governor needs to know that.\n\t */\n\tnext_event = min_t(u64, next_event,\n\t\t\t   hrtimer_next_event_without(&ts->sched_timer));\n\n\treturn ktime_sub(next_event, now);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "next_event",
            "now"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "next_event",
            "hrtimer_next_event_without(&ts->sched_timer)"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_next_event_without",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_next_event_without",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1229-1253",
          "snippet": "u64 hrtimer_next_event_without(const struct hrtimer *exclude)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (__hrtimer_hres_active(cpu_base)) {\n\t\tunsigned int active;\n\n\t\tif (!cpu_base->softirq_activated) {\n\t\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\t\texpires = __hrtimer_next_event_base(cpu_base, exclude,\n\t\t\t\t\t\t\t    active, KTIME_MAX);\n\t\t}\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\texpires = __hrtimer_next_event_base(cpu_base, exclude, active,\n\t\t\t\t\t\t    expires);\n\t}\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nu64 hrtimer_next_event_without(const struct hrtimer *exclude)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (__hrtimer_hres_active(cpu_base)) {\n\t\tunsigned int active;\n\n\t\tif (!cpu_base->softirq_activated) {\n\t\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\t\texpires = __hrtimer_next_event_base(cpu_base, exclude,\n\t\t\t\t\t\t\t    active, KTIME_MAX);\n\t\t}\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\texpires = __hrtimer_next_event_base(cpu_base, exclude, active,\n\t\t\t\t\t\t    expires);\n\t}\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_next_event",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "648-730",
          "snippet": "static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long seq, basejiff;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long seq, basejiff;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_stop_idle_tick",
          "args": [
            "cpu",
            "ts"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "can_stop_idle_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "862-916",
          "snippet": "static bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ: local_softirq_pending %02x\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\t\t/*\n\t\t * Boot safety: make sure the timekeeping duty has been\n\t\t * assigned before entering dyntick-idle mode,\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ: local_softirq_pending %02x\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\t\t/*\n\t\t * Boot safety: make sure the timekeeping duty has been\n\t\t * assigned before entering dyntick-idle mode,\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "dev->next_event",
            "now"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ts->inidle"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tick_cpu_device.evtdev"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nktime_t tick_nohz_get_sleep_length(ktime_t *delta_next)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tint cpu = smp_processor_id();\n\t/*\n\t * The idle entry time is expected to be a sufficient approximation of\n\t * the current time at this point.\n\t */\n\tktime_t now = ts->idle_entrytime;\n\tktime_t next_event;\n\n\tWARN_ON_ONCE(!ts->inidle);\n\n\t*delta_next = ktime_sub(dev->next_event, now);\n\n\tif (!can_stop_idle_tick(cpu, ts))\n\t\treturn *delta_next;\n\n\tnext_event = tick_nohz_next_event(ts, cpu);\n\tif (!next_event)\n\t\treturn *delta_next;\n\n\t/*\n\t * If the next highres timer to expire is earlier than next_event, the\n\t * idle governor needs to know that.\n\t */\n\tnext_event = min_t(u64, next_event,\n\t\t\t   hrtimer_next_event_without(&ts->sched_timer));\n\n\treturn ktime_sub(next_event, now);\n}"
  },
  {
    "function_name": "tick_nohz_idle_got_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1017-1026",
    "snippet": "bool tick_nohz_idle_got_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->got_idle_tick) {\n\t\tts->got_idle_tick = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_idle_got_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->got_idle_tick) {\n\t\tts->got_idle_tick = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "tick_nohz_irq_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "1004-1012",
    "snippet": "void tick_nohz_irq_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->inidle)\n\t\ttick_nohz_start_idle(ts);\n\telse\n\t\ttick_nohz_full_update_tick(ts);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_full_update_tick",
          "args": [
            "ts"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_update_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "844-860",
          "snippet": "static void tick_nohz_full_update_tick(struct tick_sched *ts)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tif (!ts->tick_stopped && ts->nohz_mode == NOHZ_MODE_INACTIVE)\n\t\treturn;\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, ktime_get());\n#endif\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_update_tick(struct tick_sched *ts)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tif (!ts->tick_stopped && ts->nohz_mode == NOHZ_MODE_INACTIVE)\n\t\treturn;\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, ktime_get());\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_start_idle",
          "args": [
            "ts"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_start_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "535-540",
          "snippet": "static void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_irq_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->inidle)\n\t\ttick_nohz_start_idle(ts);\n\telse\n\t\ttick_nohz_full_update_tick(ts);\n}"
  },
  {
    "function_name": "tick_nohz_idle_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "978-994",
    "snippet": "void tick_nohz_idle_enter(void)\n{\n\tstruct tick_sched *ts;\n\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_disable();\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 1;\n\ttick_nohz_start_idle(ts);\n\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_start_idle",
          "args": [
            "ts"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_start_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "535-540",
          "snippet": "static void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ts->timer_expires_base"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_enter(void)\n{\n\tstruct tick_sched *ts;\n\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_disable();\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 1;\n\ttick_nohz_start_idle(ts);\n\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "tick_nohz_idle_retain_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "963-971",
    "snippet": "void tick_nohz_idle_retain_tick(void)\n{\n\ttick_nohz_retain_tick(this_cpu_ptr(&tick_cpu_sched));\n\t/*\n\t * Undo the effect of get_next_timer_interrupt() called from\n\t * tick_nohz_next_event().\n\t */\n\ttimer_clear_idle();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_clear_idle",
          "args": [],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "timer_clear_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1577-1588",
          "snippet": "void timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_retain_tick",
          "args": [
            "this_cpu_ptr(&tick_cpu_sched)"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_retain_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "806-809",
          "snippet": "static void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_retain_tick(void)\n{\n\ttick_nohz_retain_tick(this_cpu_ptr(&tick_cpu_sched));\n\t/*\n\t * Undo the effect of get_next_timer_interrupt() called from\n\t * tick_nohz_next_event().\n\t */\n\ttimer_clear_idle();\n}"
  },
  {
    "function_name": "tick_nohz_idle_stop_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "958-961",
    "snippet": "void tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tick_nohz_idle_stop_tick",
          "args": [
            "this_cpu_ptr(&tick_cpu_sched)"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_nohz_idle_stop_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "918-951",
          "snippet": "static void __tick_nohz_idle_stop_tick(struct tick_sched *ts)\n{\n\tktime_t expires;\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the\n\t * tick timer expiration time is known already.\n\t */\n\tif (ts->timer_expires_base)\n\t\texpires = ts->timer_expires;\n\telse if (can_stop_idle_tick(cpu, ts))\n\t\texpires = tick_nohz_next_event(ts, cpu);\n\telse\n\t\treturn;\n\n\tts->idle_calls++;\n\n\tif (expires > 0LL) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\ttick_nohz_stop_tick(ts, cpu);\n\n\t\tts->idle_sleeps++;\n\t\tts->idle_expires = expires;\n\n\t\tif (!was_stopped && ts->tick_stopped) {\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t\t\tnohz_balance_enter_idle(cpu);\n\t\t}\n\t} else {\n\t\ttick_nohz_retain_tick(ts);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_idle_stop_tick(struct tick_sched *ts)\n{\n\tktime_t expires;\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the\n\t * tick timer expiration time is known already.\n\t */\n\tif (ts->timer_expires_base)\n\t\texpires = ts->timer_expires;\n\telse if (can_stop_idle_tick(cpu, ts))\n\t\texpires = tick_nohz_next_event(ts, cpu);\n\telse\n\t\treturn;\n\n\tts->idle_calls++;\n\n\tif (expires > 0LL) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\ttick_nohz_stop_tick(ts, cpu);\n\n\t\tts->idle_sleeps++;\n\t\tts->idle_expires = expires;\n\n\t\tif (!was_stopped && ts->tick_stopped) {\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t\t\tnohz_balance_enter_idle(cpu);\n\t\t}\n\t} else {\n\t\ttick_nohz_retain_tick(ts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}"
  },
  {
    "function_name": "__tick_nohz_idle_stop_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "918-951",
    "snippet": "static void __tick_nohz_idle_stop_tick(struct tick_sched *ts)\n{\n\tktime_t expires;\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the\n\t * tick timer expiration time is known already.\n\t */\n\tif (ts->timer_expires_base)\n\t\texpires = ts->timer_expires;\n\telse if (can_stop_idle_tick(cpu, ts))\n\t\texpires = tick_nohz_next_event(ts, cpu);\n\telse\n\t\treturn;\n\n\tts->idle_calls++;\n\n\tif (expires > 0LL) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\ttick_nohz_stop_tick(ts, cpu);\n\n\t\tts->idle_sleeps++;\n\t\tts->idle_expires = expires;\n\n\t\tif (!was_stopped && ts->tick_stopped) {\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t\t\tnohz_balance_enter_idle(cpu);\n\t\t}\n\t} else {\n\t\ttick_nohz_retain_tick(ts);\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_retain_tick",
          "args": [
            "ts"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_retain_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "806-809",
          "snippet": "static void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nohz_balance_enter_idle",
          "args": [
            "cpu"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_tick",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "732-804",
          "snippet": "static void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tcpu_load_update_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tcpu_load_update_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_next_event",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "648-730",
          "snippet": "static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long seq, basejiff;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long seq, basejiff;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_stop_idle_tick",
          "args": [
            "cpu",
            "ts"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "can_stop_idle_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "862-916",
          "snippet": "static bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ: local_softirq_pending %02x\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\t\t/*\n\t\t * Boot safety: make sure the timekeeping duty has been\n\t\t * assigned before entering dyntick-idle mode,\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ: local_softirq_pending %02x\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\t\t/*\n\t\t * Boot safety: make sure the timekeeping duty has been\n\t\t * assigned before entering dyntick-idle mode,\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_idle_stop_tick(struct tick_sched *ts)\n{\n\tktime_t expires;\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the\n\t * tick timer expiration time is known already.\n\t */\n\tif (ts->timer_expires_base)\n\t\texpires = ts->timer_expires;\n\telse if (can_stop_idle_tick(cpu, ts))\n\t\texpires = tick_nohz_next_event(ts, cpu);\n\telse\n\t\treturn;\n\n\tts->idle_calls++;\n\n\tif (expires > 0LL) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\ttick_nohz_stop_tick(ts, cpu);\n\n\t\tts->idle_sleeps++;\n\t\tts->idle_expires = expires;\n\n\t\tif (!was_stopped && ts->tick_stopped) {\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t\t\tnohz_balance_enter_idle(cpu);\n\t\t}\n\t} else {\n\t\ttick_nohz_retain_tick(ts);\n\t}\n}"
  },
  {
    "function_name": "can_stop_idle_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "862-916",
    "snippet": "static bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ: local_softirq_pending %02x\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\t\t/*\n\t\t * Boot safety: make sure the timekeeping duty has been\n\t\t * assigned before entering dyntick-idle mode,\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_full_enabled",
          "args": [],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NOHZ: local_softirq_pending %02x\\n\"",
            "(unsigned int) local_softirq_pending()"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "local_softirq_pending()"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->nohz_mode == NOHZ_MODE_INACTIVE"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cpu_online(cpu)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ: local_softirq_pending %02x\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\t\t/*\n\t\t * Boot safety: make sure the timekeeping duty has been\n\t\t * assigned before entering dyntick-idle mode,\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "tick_nohz_full_update_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "844-860",
    "snippet": "static void tick_nohz_full_update_tick(struct tick_sched *ts)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tif (!ts->tick_stopped && ts->nohz_mode == NOHZ_MODE_INACTIVE)\n\t\treturn;\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, ktime_get());\n#endif\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_restart_sched_tick",
          "args": [
            "ts",
            "ktime_get()"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_restart_sched_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "821-842",
          "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\tcpu_load_update_nohz_stop();\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\tts->idle_exittime = now;\n\n\ttick_nohz_restart(ts, now);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\tcpu_load_update_nohz_stop();\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\tts->idle_exittime = now;\n\n\ttick_nohz_restart(ts, now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_sched_tick",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_sched_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "812-818",
          "snippet": "static void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)\n{\n\tif (tick_nohz_next_event(ts, cpu))\n\t\ttick_nohz_stop_tick(ts, cpu);\n\telse\n\t\ttick_nohz_retain_tick(ts);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)\n{\n\tif (tick_nohz_next_event(ts, cpu))\n\t\ttick_nohz_stop_tick(ts, cpu);\n\telse\n\t\ttick_nohz_retain_tick(ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_stop_full_tick",
          "args": [
            "cpu",
            "ts"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "can_stop_full_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "201-221",
          "snippet": "static bool can_stop_full_tick(int cpu, struct tick_sched *ts)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (unlikely(!cpu_online(cpu)))\n\t\treturn false;\n\n\tif (check_tick_dependency(&tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&ts->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->signal->tick_dep_mask))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_full_tick(int cpu, struct tick_sched *ts)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (unlikely(!cpu_online(cpu)))\n\t\treturn false;\n\n\tif (check_tick_dependency(&tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&ts->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->signal->tick_dep_mask))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_update_tick(struct tick_sched *ts)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tif (!ts->tick_stopped && ts->nohz_mode == NOHZ_MODE_INACTIVE)\n\t\treturn;\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, ktime_get());\n#endif\n}"
  },
  {
    "function_name": "tick_nohz_restart_sched_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "821-842",
    "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\tcpu_load_update_nohz_stop();\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\tts->idle_exittime = now;\n\n\ttick_nohz_restart(ts, now);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_restart",
          "args": [
            "ts",
            "now"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_restart_sched_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "821-842",
          "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\tcpu_load_update_nohz_stop();\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\tts->idle_exittime = now;\n\n\ttick_nohz_restart(ts, now);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sched",
          "args": [],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "264-271",
          "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_load_nohz_stop",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_nohz_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/loadavg.c",
          "lines": "251-269",
          "snippet": "void calc_load_nohz_stop(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * If we're still before the pending sample window, we're done.\n\t */\n\tthis_rq->calc_load_update = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\t/*\n\t * We woke inside or after the sample window, this means we're already\n\t * accounted through the nohz accounting, so skip the entire deal and\n\t * sync up for the next window.\n\t */\n\tif (time_before(jiffies, this_rq->calc_load_update + 10))\n\t\tthis_rq->calc_load_update += LOAD_FREQ;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long calc_load_update;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nunsigned long calc_load_update;\n\nvoid calc_load_nohz_stop(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * If we're still before the pending sample window, we're done.\n\t */\n\tthis_rq->calc_load_update = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\t/*\n\t * We woke inside or after the sample window, this means we're already\n\t * accounted through the nohz accounting, so skip the entire deal and\n\t * sync up for the next window.\n\t */\n\tif (time_before(jiffies, this_rq->calc_load_update + 10))\n\t\tthis_rq->calc_load_update += LOAD_FREQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_clear_idle",
          "args": [],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "timer_clear_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1577-1588",
          "snippet": "void timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_load_update_nohz_stop",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_load_update_nohz_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "5432-5447",
          "snippet": "void cpu_load_update_nohz_stop(void)\n{\n\tunsigned long curr_jiffies = READ_ONCE(jiffies);\n\tstruct rq *this_rq = this_rq();\n\tunsigned long load;\n\tstruct rq_flags rf;\n\n\tif (curr_jiffies == this_rq->last_load_update_tick)\n\t\treturn;\n\n\tload = weighted_cpuload(this_rq);\n\trq_lock(this_rq, &rf);\n\tupdate_rq_clock(this_rq);\n\tcpu_load_update_nohz(this_rq, curr_jiffies, load);\n\trq_unlock(this_rq, &rf);\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid cpu_load_update_nohz_stop(void)\n{\n\tunsigned long curr_jiffies = READ_ONCE(jiffies);\n\tstruct rq *this_rq = this_rq();\n\tunsigned long load;\n\tstruct rq_flags rf;\n\n\tif (curr_jiffies == this_rq->last_load_update_tick)\n\t\treturn;\n\n\tload = weighted_cpuload(this_rq);\n\trq_lock(this_rq, &rf);\n\tupdate_rq_clock(this_rq);\n\tcpu_load_update_nohz(this_rq, curr_jiffies, load);\n\trq_unlock(this_rq, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_do_update_jiffies64",
          "args": [
            "now"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_update_jiffies64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "57-98",
          "snippet": "static void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 0;\n\tktime_t delta;\n\n\t/*\n\t * Do a quick check without holding jiffies_lock:\n\t */\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta < tick_period)\n\t\treturn;\n\n\t/* Reevaluate with jiffies_lock held */\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta >= tick_period) {\n\n\t\tdelta = ktime_sub(delta, tick_period);\n\t\tlast_jiffies_update = ktime_add(last_jiffies_update,\n\t\t\t\t\t\ttick_period);\n\n\t\t/* Slow path for long timeouts */\n\t\tif (unlikely(delta >= tick_period)) {\n\t\t\ts64 incr = ktime_to_ns(tick_period);\n\n\t\t\tticks = ktime_divns(delta, incr);\n\n\t\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t\t   incr * ticks);\n\t\t}\n\t\tdo_timer(++ticks);\n\n\t\t/* Keep the tick_next_period variable up to date */\n\t\ttick_next_period = ktime_add(last_jiffies_update, tick_period);\n\t} else {\n\t\twrite_sequnlock(&jiffies_lock);\n\t\treturn;\n\t}\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 0;\n\tktime_t delta;\n\n\t/*\n\t * Do a quick check without holding jiffies_lock:\n\t */\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta < tick_period)\n\t\treturn;\n\n\t/* Reevaluate with jiffies_lock held */\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta >= tick_period) {\n\n\t\tdelta = ktime_sub(delta, tick_period);\n\t\tlast_jiffies_update = ktime_add(last_jiffies_update,\n\t\t\t\t\t\ttick_period);\n\n\t\t/* Slow path for long timeouts */\n\t\tif (unlikely(delta >= tick_period)) {\n\t\t\ts64 incr = ktime_to_ns(tick_period);\n\n\t\t\tticks = ktime_divns(delta, incr);\n\n\t\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t\t   incr * ticks);\n\t\t}\n\t\tdo_timer(++ticks);\n\n\t\t/* Keep the tick_next_period variable up to date */\n\t\ttick_next_period = ktime_add(last_jiffies_update, tick_period);\n\t} else {\n\t\twrite_sequnlock(&jiffies_lock);\n\t\treturn;\n\t}\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\tcpu_load_update_nohz_stop();\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\tts->idle_exittime = now;\n\n\ttick_nohz_restart(ts, now);\n}"
  },
  {
    "function_name": "tick_nohz_stop_sched_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "812-818",
    "snippet": "static void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)\n{\n\tif (tick_nohz_next_event(ts, cpu))\n\t\ttick_nohz_stop_tick(ts, cpu);\n\telse\n\t\ttick_nohz_retain_tick(ts);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_retain_tick",
          "args": [
            "ts"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_retain_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "806-809",
          "snippet": "static void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_tick",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "732-804",
          "snippet": "static void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tcpu_load_update_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tcpu_load_update_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_next_event",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "648-730",
          "snippet": "static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long seq, basejiff;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long seq, basejiff;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)\n{\n\tif (tick_nohz_next_event(ts, cpu))\n\t\ttick_nohz_stop_tick(ts, cpu);\n\telse\n\t\ttick_nohz_retain_tick(ts);\n}"
  },
  {
    "function_name": "tick_nohz_retain_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "806-809",
    "snippet": "static void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}"
  },
  {
    "function_name": "tick_nohz_stop_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "732-804",
    "snippet": "static void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tcpu_load_update_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "tick",
            "1"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "27-49",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&ts->sched_timer",
            "tick"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&ts->sched_timer",
            "tick",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "expires == KTIME_MAX"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "1",
            "TICK_DEP_MASK_NONE"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quiet_vmstat",
          "args": [],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_load_update_nohz_start",
          "args": [],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_load_update_nohz_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "5417-5427",
          "snippet": "void cpu_load_update_nohz_start(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * This is all lockless but should be fine. If weighted_cpuload changes\n\t * concurrently we'll exit nohz. And cpu_load write can race with\n\t * cpu_load_update_idle() but both updater would be writing the same.\n\t */\n\tthis_rq->cpu_load[0] = weighted_cpuload(this_rq);\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid cpu_load_update_nohz_start(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * This is all lockless but should be fine. If weighted_cpuload changes\n\t * concurrently we'll exit nohz. And cpu_load write can race with\n\t * cpu_load_update_idle() but both updater would be writing the same.\n\t */\n\tthis_rq->cpu_load[0] = weighted_cpuload(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_load_nohz_start",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_nohz_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/loadavg.c",
          "lines": "234-249",
          "snippet": "void calc_load_nohz_start(void)\n{\n\tstruct rq *this_rq = this_rq();\n\tlong delta;\n\n\t/*\n\t * We're going into NO_HZ mode, if there's any pending delta, fold it\n\t * into the pending NO_HZ delta.\n\t */\n\tdelta = calc_load_fold_active(this_rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid calc_load_nohz_start(void)\n{\n\tstruct rq *this_rq = this_rq();\n\tlong delta;\n\n\t/*\n\t * We're going into NO_HZ mode, if there's any pending delta, fold it\n\t * into the pending NO_HZ delta.\n\t */\n\tdelta = calc_load_fold_active(this_rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\"",
            "basemono",
            "ts->next_tick",
            "dev->next_event",
            "hrtimer_active(&ts->sched_timer)",
            "hrtimer_get_expires(&ts->sched_timer)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1320-1337",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tick_cpu_device.evtdev"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tcpu_load_update_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}"
  },
  {
    "function_name": "tick_nohz_next_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "648-730",
    "snippet": "static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long seq, basejiff;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "expires",
            "next_tick"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_max_deferment",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_max_deferment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1453-1467",
          "snippet": "u64 timekeeping_max_deferment(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->max_idle_ns;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 timekeeping_max_deferment(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->max_idle_ns;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_clear_idle",
          "args": [],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "timer_clear_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1577-1588",
          "snippet": "void timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_timer_interrupt",
          "args": [
            "basejiff",
            "basemono"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_timer_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1519-1570",
          "snippet": "u64 get_next_timer_interrupt(unsigned long basej, u64 basem)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\tu64 expires = KTIME_MAX;\n\tunsigned long nextevt;\n\tbool is_max_delta;\n\n\t/*\n\t * Pretend that there is no timer pending if the cpu is offline.\n\t * Possible pending timers will be migrated later to an active cpu.\n\t */\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn expires;\n\n\traw_spin_lock(&base->lock);\n\tnextevt = __next_timer_interrupt(base);\n\tis_max_delta = (nextevt == base->clk + NEXT_TIMER_MAX_DELTA);\n\tbase->next_expiry = nextevt;\n\t/*\n\t * We have a fresh next event. Check whether we can forward the\n\t * base. We can only do that when @basej is past base->clk\n\t * otherwise we might rewind base->clk.\n\t */\n\tif (time_after(basej, base->clk)) {\n\t\tif (time_after(nextevt, basej))\n\t\t\tbase->clk = basej;\n\t\telse if (time_after(nextevt, base->clk))\n\t\t\tbase->clk = nextevt;\n\t}\n\n\tif (time_before_eq(nextevt, basej)) {\n\t\texpires = basem;\n\t\tbase->is_idle = false;\n\t} else {\n\t\tif (!is_max_delta)\n\t\t\texpires = basem + (u64)(nextevt - basej) * TICK_NSEC;\n\t\t/*\n\t\t * If we expect to sleep more than a tick, mark the base idle.\n\t\t * Also the tick is stopped so any added timer must forward\n\t\t * the base clk itself to keep granularity small. This idle\n\t\t * logic is only maintained for the BASE_STD base, deferrable\n\t\t * timers may still see large granularity skew (by design).\n\t\t */\n\t\tif ((expires - basem) > TICK_NSEC) {\n\t\t\tbase->must_forward_clk = true;\n\t\t\tbase->is_idle = true;\n\t\t}\n\t}\n\traw_spin_unlock(&base->lock);\n\n\treturn cmp_next_hrtimer_event(basem, expires);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible u64",
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n__visible u64;\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nu64 get_next_timer_interrupt(unsigned long basej, u64 basem)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\tu64 expires = KTIME_MAX;\n\tunsigned long nextevt;\n\tbool is_max_delta;\n\n\t/*\n\t * Pretend that there is no timer pending if the cpu is offline.\n\t * Possible pending timers will be migrated later to an active cpu.\n\t */\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn expires;\n\n\traw_spin_lock(&base->lock);\n\tnextevt = __next_timer_interrupt(base);\n\tis_max_delta = (nextevt == base->clk + NEXT_TIMER_MAX_DELTA);\n\tbase->next_expiry = nextevt;\n\t/*\n\t * We have a fresh next event. Check whether we can forward the\n\t * base. We can only do that when @basej is past base->clk\n\t * otherwise we might rewind base->clk.\n\t */\n\tif (time_after(basej, base->clk)) {\n\t\tif (time_after(nextevt, basej))\n\t\t\tbase->clk = basej;\n\t\telse if (time_after(nextevt, base->clk))\n\t\t\tbase->clk = nextevt;\n\t}\n\n\tif (time_before_eq(nextevt, basej)) {\n\t\texpires = basem;\n\t\tbase->is_idle = false;\n\t} else {\n\t\tif (!is_max_delta)\n\t\t\texpires = basem + (u64)(nextevt - basej) * TICK_NSEC;\n\t\t/*\n\t\t * If we expect to sleep more than a tick, mark the base idle.\n\t\t * Also the tick is stopped so any added timer must forward\n\t\t * the base clk itself to keep granularity small. This idle\n\t\t * logic is only maintained for the BASE_STD base, deferrable\n\t\t * timers may still see large granularity skew (by design).\n\t\t */\n\t\tif ((expires - basem) > TICK_NSEC) {\n\t\t\tbase->must_forward_clk = true;\n\t\t\tbase->is_idle = true;\n\t\t}\n\t}\n\traw_spin_unlock(&base->lock);\n\n\treturn cmp_next_hrtimer_event(basem, expires);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_timer_softirq_pending",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "local_timer_softirq_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "643-646",
          "snippet": "static inline bool local_timer_softirq_pending(void)\n{\n\treturn local_softirq_pending() & BIT(TIMER_SOFTIRQ);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline bool local_timer_softirq_pending(void)\n{\n\treturn local_softirq_pending() & BIT(TIMER_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_needs_cpu",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_needs_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "115-130",
          "snippet": "bool irq_work_needs_cpu(void)\n{\n\tstruct llist_head *raised, *lazy;\n\n\traised = this_cpu_ptr(&raised_list);\n\tlazy = this_cpu_ptr(&lazy_list);\n\n\tif (llist_empty(raised) || arch_irq_work_has_interrupt())\n\t\tif (llist_empty(lazy))\n\t\t\treturn false;\n\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_needs_cpu(void)\n{\n\tstruct llist_head *raised, *lazy;\n\n\traised = this_cpu_ptr(&raised_list);\n\tlazy = this_cpu_ptr(&lazy_list);\n\n\tif (llist_empty(raised) || arch_irq_work_has_interrupt())\n\t\tif (llist_empty(lazy))\n\t\t\treturn false;\n\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_needs_cpu",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_needs_cpu",
          "args": [
            "basemono",
            "&next_rcu"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_needs_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1634-1667",
          "snippet": "int rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tunsigned long dj;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Snapshot to detect later posting of non-lazy callback. */\n\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\n\t/* If no callbacks, RCU doesn't need the CPU. */\n\tif (!rcu_cpu_has_callbacks(&rdp->all_lazy)) {\n\t\t*nextevt = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\t/* Attempt to advance callbacks. */\n\tif (rcu_try_advance_all_cbs()) {\n\t\t/* Some ready to invoke, so initiate later invocation. */\n\t\tinvoke_rcu_core();\n\t\treturn 1;\n\t}\n\trdp->last_accelerate = jiffies;\n\n\t/* Request timer delay depending on laziness, and round. */\n\tif (!rdp->all_lazy) {\n\t\tdj = round_up(rcu_idle_gp_delay + jiffies,\n\t\t\t       rcu_idle_gp_delay) - jiffies;\n\t} else {\n\t\tdj = round_jiffies(rcu_idle_lazy_gp_delay + jiffies) - jiffies;\n\t}\n\t*nextevt = basemono + dj * TICK_NSEC;\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nint rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tunsigned long dj;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Snapshot to detect later posting of non-lazy callback. */\n\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\n\t/* If no callbacks, RCU doesn't need the CPU. */\n\tif (!rcu_cpu_has_callbacks(&rdp->all_lazy)) {\n\t\t*nextevt = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\t/* Attempt to advance callbacks. */\n\tif (rcu_try_advance_all_cbs()) {\n\t\t/* Some ready to invoke, so initiate later invocation. */\n\t\tinvoke_rcu_core();\n\t\treturn 1;\n\t}\n\trdp->last_accelerate = jiffies;\n\n\t/* Request timer delay depending on laziness, and round. */\n\tif (!rdp->all_lazy) {\n\t\tdj = round_up(rcu_idle_gp_delay + jiffies,\n\t\t\t       rcu_idle_gp_delay) - jiffies;\n\t} else {\n\t\tdj = round_jiffies(rcu_idle_lazy_gp_delay + jiffies) - jiffies;\n\t}\n\t*nextevt = basemono + dj * TICK_NSEC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&jiffies_lock",
            "seq"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&jiffies_lock"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long seq, basejiff;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immeditate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}"
  },
  {
    "function_name": "local_timer_softirq_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "643-646",
    "snippet": "static inline bool local_timer_softirq_pending(void)\n{\n\treturn local_softirq_pending() & BIT(TIMER_SOFTIRQ);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "TIMER_SOFTIRQ"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline bool local_timer_softirq_pending(void)\n{\n\treturn local_softirq_pending() & BIT(TIMER_SOFTIRQ);\n}"
  },
  {
    "function_name": "tick_nohz_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "623-641",
    "snippet": "static void tick_nohz_restart(struct tick_sched *ts, ktime_t now)\n{\n\thrtimer_cancel(&ts->sched_timer);\n\thrtimer_set_expires(&ts->sched_timer, ts->last_tick);\n\n\t/* Forward the time to expire in the future */\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);\n\telse\n\t\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n\n\t/*\n\t * Reset to make sure next tick stop doesn't get fooled by past\n\t * cached clock deadline.\n\t */\n\tts->next_tick = 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "hrtimer_get_expires(&ts->sched_timer)",
            "1"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "27-49",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&ts->sched_timer",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "&ts->sched_timer",
            "now",
            "tick_period"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "907-939",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&ts->sched_timer",
            "ts->last_tick"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart(struct tick_sched *ts, ktime_t now)\n{\n\thrtimer_cancel(&ts->sched_timer);\n\thrtimer_set_expires(&ts->sched_timer, ts->last_tick);\n\n\t/* Forward the time to expire in the future */\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);\n\telse\n\t\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n\n\t/*\n\t * Reset to make sure next tick stop doesn't get fooled by past\n\t * cached clock deadline.\n\t */\n\tts->next_tick = 0;\n}"
  },
  {
    "function_name": "get_cpu_iowait_time_us",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "597-620",
    "snippet": "u64 get_cpu_iowait_time_us(int cpu, u64 *last_update_time)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\tktime_t now, iowait;\n\n\tif (!tick_nohz_active)\n\t\treturn -1;\n\n\tnow = ktime_get();\n\tif (last_update_time) {\n\t\tupdate_ts_time_stats(cpu, ts, now, last_update_time);\n\t\tiowait = ts->iowait_sleeptime;\n\t} else {\n\t\tif (ts->idle_active && nr_iowait_cpu(cpu) > 0) {\n\t\t\tktime_t delta = ktime_sub(now, ts->idle_entrytime);\n\n\t\t\tiowait = ktime_add(ts->iowait_sleeptime, delta);\n\t\t} else {\n\t\t\tiowait = ts->iowait_sleeptime;\n\t\t}\n\t}\n\n\treturn ktime_to_us(iowait);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "iowait"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "ts->iowait_sleeptime",
            "delta"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "ts->idle_entrytime"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_iowait_cpu",
          "args": [
            "cpu"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ts_time_stats",
          "args": [
            "cpu",
            "ts",
            "now",
            "last_update_time"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "update_ts_time_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "508-525",
          "snippet": "static void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nu64 get_cpu_iowait_time_us(int cpu, u64 *last_update_time)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\tktime_t now, iowait;\n\n\tif (!tick_nohz_active)\n\t\treturn -1;\n\n\tnow = ktime_get();\n\tif (last_update_time) {\n\t\tupdate_ts_time_stats(cpu, ts, now, last_update_time);\n\t\tiowait = ts->iowait_sleeptime;\n\t} else {\n\t\tif (ts->idle_active && nr_iowait_cpu(cpu) > 0) {\n\t\t\tktime_t delta = ktime_sub(now, ts->idle_entrytime);\n\n\t\t\tiowait = ktime_add(ts->iowait_sleeptime, delta);\n\t\t} else {\n\t\t\tiowait = ts->iowait_sleeptime;\n\t\t}\n\t}\n\n\treturn ktime_to_us(iowait);\n}"
  },
  {
    "function_name": "get_cpu_idle_time_us",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "556-580",
    "snippet": "u64 get_cpu_idle_time_us(int cpu, u64 *last_update_time)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\tktime_t now, idle;\n\n\tif (!tick_nohz_active)\n\t\treturn -1;\n\n\tnow = ktime_get();\n\tif (last_update_time) {\n\t\tupdate_ts_time_stats(cpu, ts, now, last_update_time);\n\t\tidle = ts->idle_sleeptime;\n\t} else {\n\t\tif (ts->idle_active && !nr_iowait_cpu(cpu)) {\n\t\t\tktime_t delta = ktime_sub(now, ts->idle_entrytime);\n\n\t\t\tidle = ktime_add(ts->idle_sleeptime, delta);\n\t\t} else {\n\t\t\tidle = ts->idle_sleeptime;\n\t\t}\n\t}\n\n\treturn ktime_to_us(idle);\n\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "idle"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "ts->idle_sleeptime",
            "delta"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "ts->idle_entrytime"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_iowait_cpu",
          "args": [
            "cpu"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ts_time_stats",
          "args": [
            "cpu",
            "ts",
            "now",
            "last_update_time"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "update_ts_time_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "508-525",
          "snippet": "static void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nu64 get_cpu_idle_time_us(int cpu, u64 *last_update_time)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\tktime_t now, idle;\n\n\tif (!tick_nohz_active)\n\t\treturn -1;\n\n\tnow = ktime_get();\n\tif (last_update_time) {\n\t\tupdate_ts_time_stats(cpu, ts, now, last_update_time);\n\t\tidle = ts->idle_sleeptime;\n\t} else {\n\t\tif (ts->idle_active && !nr_iowait_cpu(cpu)) {\n\t\t\tktime_t delta = ktime_sub(now, ts->idle_entrytime);\n\n\t\t\tidle = ktime_add(ts->idle_sleeptime, delta);\n\t\t} else {\n\t\t\tidle = ts->idle_sleeptime;\n\t\t}\n\t}\n\n\treturn ktime_to_us(idle);\n\n}"
  },
  {
    "function_name": "tick_nohz_start_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "535-540",
    "snippet": "static void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_idle_sleep_event",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_idle_sleep_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "425-428",
          "snippet": "void sched_clock_idle_sleep_event(void)\n{\n\tsched_clock_cpu(smp_processor_id());\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_idle_sleep_event(void)\n{\n\tsched_clock_cpu(smp_processor_id());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}"
  },
  {
    "function_name": "tick_nohz_stop_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "527-533",
    "snippet": "static void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_idle_wakeup_event",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_idle_wakeup_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "434-447",
          "snippet": "void sched_clock_idle_wakeup_event(void)\n{\n\tunsigned long flags;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (unlikely(timekeeping_suspended))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tsched_clock_tick();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_idle_wakeup_event(void)\n{\n\tunsigned long flags;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (unlikely(timekeeping_suspended))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tsched_clock_tick();\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ts_time_stats",
          "args": [
            "smp_processor_id()",
            "ts",
            "now",
            "NULL"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "update_ts_time_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "508-525",
          "snippet": "static void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}"
  },
  {
    "function_name": "update_ts_time_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "508-525",
    "snippet": "static void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "now"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "ts->idle_sleeptime",
            "delta"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_iowait_cpu",
          "args": [
            "cpu"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "ts->idle_entrytime"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}"
  },
  {
    "function_name": "tick_nohz_update_jiffies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "492-503",
    "snippet": "static void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog_sched();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sched",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "264-271",
          "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_do_update_jiffies64",
          "args": [
            "now"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_update_jiffies64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "57-98",
          "snippet": "static void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 0;\n\tktime_t delta;\n\n\t/*\n\t * Do a quick check without holding jiffies_lock:\n\t */\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta < tick_period)\n\t\treturn;\n\n\t/* Reevaluate with jiffies_lock held */\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta >= tick_period) {\n\n\t\tdelta = ktime_sub(delta, tick_period);\n\t\tlast_jiffies_update = ktime_add(last_jiffies_update,\n\t\t\t\t\t\ttick_period);\n\n\t\t/* Slow path for long timeouts */\n\t\tif (unlikely(delta >= tick_period)) {\n\t\t\ts64 incr = ktime_to_ns(tick_period);\n\n\t\t\tticks = ktime_divns(delta, incr);\n\n\t\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t\t   incr * ticks);\n\t\t}\n\t\tdo_timer(++ticks);\n\n\t\t/* Keep the tick_next_period variable up to date */\n\t\ttick_next_period = ktime_add(last_jiffies_update, tick_period);\n\t} else {\n\t\twrite_sequnlock(&jiffies_lock);\n\t\treturn;\n\t}\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 0;\n\tktime_t delta;\n\n\t/*\n\t * Do a quick check without holding jiffies_lock:\n\t */\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta < tick_period)\n\t\treturn;\n\n\t/* Reevaluate with jiffies_lock held */\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta >= tick_period) {\n\n\t\tdelta = ktime_sub(delta, tick_period);\n\t\tlast_jiffies_update = ktime_add(last_jiffies_update,\n\t\t\t\t\t\ttick_period);\n\n\t\t/* Slow path for long timeouts */\n\t\tif (unlikely(delta >= tick_period)) {\n\t\t\ts64 incr = ktime_to_ns(tick_period);\n\n\t\t\tticks = ktime_divns(delta, incr);\n\n\t\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t\t   incr * ticks);\n\t\t}\n\t\tdo_timer(++ticks);\n\n\t\t/* Keep the tick_next_period variable up to date */\n\t\ttick_next_period = ktime_add(last_jiffies_update, tick_period);\n\t} else {\n\t\twrite_sequnlock(&jiffies_lock);\n\t\treturn;\n\t}\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "tick_cpu_sched.idle_waketime",
            "now"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog_sched();\n}"
  },
  {
    "function_name": "tick_nohz_tick_stopped_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "475-480",
    "snippet": "bool tick_nohz_tick_stopped_cpu(int cpu)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\treturn ts->tick_stopped;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&tick_cpu_sched",
            "cpu"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped_cpu(int cpu)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\treturn ts->tick_stopped;\n}"
  },
  {
    "function_name": "tick_nohz_tick_stopped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "468-473",
    "snippet": "bool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}"
  },
  {
    "function_name": "setup_tick_nohz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "461-464",
    "snippet": "static int __init setup_tick_nohz(char *str)\n{\n\treturn (kstrtobool(str, &tick_nohz_enabled) == 0);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "str",
            "&tick_nohz_enabled"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int __init setup_tick_nohz(char *str)\n{\n\treturn (kstrtobool(str, &tick_nohz_enabled) == 0);\n}"
  },
  {
    "function_name": "tick_nohz_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "410-446",
    "snippet": "void __init tick_nohz_init(void)\n{\n\tint cpu, ret;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\t/*\n\t * Full dynticks uses irq work to drive the tick rescheduling on safe\n\t * locking contexts. But then we need irq work to raise its own\n\t * interrupts to avoid circular dependency on the tick\n\t */\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warn(\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tcpu = smp_processor_id();\n\n\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\tpr_warn(\"NO_HZ: Clearing %d from nohz_full range for timekeeping\\n\",\n\t\t\tcpu);\n\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t}\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"kernel/nohz:predown\", NULL,\n\t\t\t\t\ttick_nohz_cpu_down);\n\tWARN_ON(ret < 0);\n\tpr_info(\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\"",
            "cpumask_pr_args(tick_nohz_full_mask)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "tick_nohz_full_mask"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"kernel/nohz:predown\"",
            "NULL",
            "tick_nohz_cpu_down"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_tracking_cpu_set",
          "args": [
            "cpu"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_cpu_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "188-208",
          "snippet": "void __init context_tracking_cpu_set(int cpu)\n{\n\tstatic __initdata bool initialized = false;\n\n\tif (!per_cpu(context_tracking.active, cpu)) {\n\t\tper_cpu(context_tracking.active, cpu) = true;\n\t\tstatic_branch_inc(&context_tracking_enabled);\n\t}\n\n\tif (initialized)\n\t\treturn;\n\n\t/*\n\t * Set TIF_NOHZ to init/0 and let it propagate to all tasks through fork\n\t * This assumes that init is the only task at this early boot stage.\n\t */\n\tset_tsk_thread_flag(&init_task, TIF_NOHZ);\n\tWARN_ON_ONCE(!tasklist_empty());\n\n\tinitialized = true;\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __init context_tracking_cpu_set(int cpu)\n{\n\tstatic __initdata bool initialized = false;\n\n\tif (!per_cpu(context_tracking.active, cpu)) {\n\t\tper_cpu(context_tracking.active, cpu) = true;\n\t\tstatic_branch_inc(&context_tracking_enabled);\n\t}\n\n\tif (initialized)\n\t\treturn;\n\n\t/*\n\t * Set TIF_NOHZ to init/0 and let it propagate to all tasks through fork\n\t * This assumes that init is the only task at this early boot stage.\n\t */\n\tset_tsk_thread_flag(&init_task, TIF_NOHZ);\n\tWARN_ON_ONCE(!tasklist_empty());\n\n\tinitialized = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "tick_nohz_full_mask"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_nohz_full_mask"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NO_HZ: Clearing %d from nohz_full range for timekeeping\\n\"",
            "cpu"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_nohz_full_mask"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "tick_nohz_full_mask"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_work_has_interrupt",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init tick_nohz_init(void)\n{\n\tint cpu, ret;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\t/*\n\t * Full dynticks uses irq work to drive the tick rescheduling on safe\n\t * locking contexts. But then we need irq work to raise its own\n\t * interrupts to avoid circular dependency on the tick\n\t */\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warn(\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tcpu = smp_processor_id();\n\n\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\tpr_warn(\"NO_HZ: Clearing %d from nohz_full range for timekeeping\\n\",\n\t\t\tcpu);\n\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t}\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"kernel/nohz:predown\", NULL,\n\t\t\t\t\ttick_nohz_cpu_down);\n\tWARN_ON(ret < 0);\n\tpr_info(\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}"
  },
  {
    "function_name": "tick_nohz_cpu_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "398-408",
    "snippet": "static int tick_nohz_cpu_down(unsigned int cpu)\n{\n\t/*\n\t * The boot CPU handles housekeeping duty (unbound timers,\n\t * workqueues, timekeeping, ...) on behalf of full dynticks\n\t * CPUs. It must remain online when nohz full is enabled.\n\t */\n\tif (tick_nohz_full_running && tick_do_timer_cpu == cpu)\n\t\treturn -EBUSY;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int tick_nohz_cpu_down(unsigned int cpu)\n{\n\t/*\n\t * The boot CPU handles housekeeping duty (unbound timers,\n\t * workqueues, timekeeping, ...) on behalf of full dynticks\n\t * CPUs. It must remain online when nohz full is enabled.\n\t */\n\tif (tick_nohz_full_running && tick_do_timer_cpu == cpu)\n\t\treturn -EBUSY;\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_nohz_full_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "391-396",
    "snippet": "void __init tick_nohz_full_setup(cpumask_var_t cpumask)\n{\n\talloc_bootmem_cpumask_var(&tick_nohz_full_mask);\n\tcpumask_copy(tick_nohz_full_mask, cpumask);\n\ttick_nohz_full_running = true;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "tick_nohz_full_mask",
            "cpumask"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_bootmem_cpumask_var",
          "args": [
            "&tick_nohz_full_mask"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init tick_nohz_full_setup(cpumask_var_t cpumask)\n{\n\talloc_bootmem_cpumask_var(&tick_nohz_full_mask);\n\tcpumask_copy(tick_nohz_full_mask, cpumask);\n\ttick_nohz_full_running = true;\n}"
  },
  {
    "function_name": "__tick_nohz_task_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "369-388",
    "snippet": "void __tick_nohz_task_switch(void)\n{\n\tunsigned long flags;\n\tstruct tick_sched *ts;\n\n\tlocal_irq_save(flags);\n\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\tgoto out;\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tif (atomic_read(&current->tick_dep_mask) ||\n\t\t    atomic_read(&current->signal->tick_dep_mask))\n\t\t\ttick_nohz_full_kick();\n\t}\nout:\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_kick",
          "args": [],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "262-273",
          "snippet": "static void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->signal->tick_dep_mask"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->tick_dep_mask"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid __tick_nohz_task_switch(void)\n{\n\tunsigned long flags;\n\tstruct tick_sched *ts;\n\n\tlocal_irq_save(flags);\n\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\tgoto out;\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tif (atomic_read(&current->tick_dep_mask) ||\n\t\t    atomic_read(&current->signal->tick_dep_mask))\n\t\t\ttick_nohz_full_kick();\n\t}\nout:\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "tick_nohz_dep_clear_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "359-362",
    "snippet": "void tick_nohz_dep_clear_signal(struct signal_struct *sig, enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &sig->tick_dep_mask);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "BIT(bit)",
            "&sig->tick_dep_mask"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_clear_signal(struct signal_struct *sig, enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &sig->tick_dep_mask);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "354-357",
    "snippet": "void tick_nohz_dep_set_signal(struct signal_struct *sig, enum tick_dep_bits bit)\n{\n\ttick_nohz_dep_set_all(&sig->tick_dep_mask, bit);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_dep_set_all",
          "args": [
            "&sig->tick_dep_mask",
            "bit"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_dep_set_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "275-283",
          "snippet": "static void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_set_signal(struct signal_struct *sig, enum tick_dep_bits bit)\n{\n\ttick_nohz_dep_set_all(&sig->tick_dep_mask, bit);\n}"
  },
  {
    "function_name": "tick_nohz_dep_clear_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "345-348",
    "snippet": "void tick_nohz_dep_clear_task(struct task_struct *tsk, enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &tsk->tick_dep_mask);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "BIT(bit)",
            "&tsk->tick_dep_mask"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_clear_task(struct task_struct *tsk, enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &tsk->tick_dep_mask);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "336-343",
    "snippet": "void tick_nohz_dep_set_task(struct task_struct *tsk, enum tick_dep_bits bit)\n{\n\t/*\n\t * We could optimize this with just kicking the target running the task\n\t * if that noise matters for nohz full users.\n\t */\n\ttick_nohz_dep_set_all(&tsk->tick_dep_mask, bit);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_dep_set_all",
          "args": [
            "&tsk->tick_dep_mask",
            "bit"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_dep_set_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "275-283",
          "snippet": "static void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_set_task(struct task_struct *tsk, enum tick_dep_bits bit)\n{\n\t/*\n\t * We could optimize this with just kicking the target running the task\n\t * if that noise matters for nohz full users.\n\t */\n\ttick_nohz_dep_set_all(&tsk->tick_dep_mask, bit);\n}"
  },
  {
    "function_name": "tick_nohz_dep_clear_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "325-330",
    "snippet": "void tick_nohz_dep_clear_cpu(int cpu, enum tick_dep_bits bit)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\tatomic_andnot(BIT(bit), &ts->tick_dep_mask);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "BIT(bit)",
            "&ts->tick_dep_mask"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&tick_cpu_sched",
            "cpu"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_dep_clear_cpu(int cpu, enum tick_dep_bits bit)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\tatomic_andnot(BIT(bit), &ts->tick_dep_mask);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "303-323",
    "snippet": "void tick_nohz_dep_set_cpu(int cpu, enum tick_dep_bits bit)\n{\n\tint prev;\n\tstruct tick_sched *ts;\n\n\tts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\tprev = atomic_fetch_or(BIT(bit), &ts->tick_dep_mask);\n\tif (!prev) {\n\t\tpreempt_disable();\n\t\t/* Perf needs local kick that is NMI safe */\n\t\tif (cpu == smp_processor_id()) {\n\t\t\ttick_nohz_full_kick();\n\t\t} else {\n\t\t\t/* Remote irq work not NMI-safe */\n\t\t\tif (!WARN_ON_ONCE(in_nmi()))\n\t\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_kick_cpu",
          "args": [
            "cpu"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "250-256",
          "snippet": "void tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_nmi()"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_kick",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "262-273",
          "snippet": "static void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_fetch_or",
          "args": [
            "BIT(bit)",
            "&ts->tick_dep_mask"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&tick_cpu_sched",
            "cpu"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_dep_set_cpu(int cpu, enum tick_dep_bits bit)\n{\n\tint prev;\n\tstruct tick_sched *ts;\n\n\tts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\tprev = atomic_fetch_or(BIT(bit), &ts->tick_dep_mask);\n\tif (!prev) {\n\t\tpreempt_disable();\n\t\t/* Perf needs local kick that is NMI safe */\n\t\tif (cpu == smp_processor_id()) {\n\t\t\ttick_nohz_full_kick();\n\t\t} else {\n\t\t\t/* Remote irq work not NMI-safe */\n\t\t\tif (!WARN_ON_ONCE(in_nmi()))\n\t\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "tick_nohz_dep_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "294-297",
    "snippet": "void tick_nohz_dep_clear(enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &tick_dep_mask);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "BIT(bit)",
            "&tick_dep_mask"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_clear(enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &tick_dep_mask);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "289-292",
    "snippet": "void tick_nohz_dep_set(enum tick_dep_bits bit)\n{\n\ttick_nohz_dep_set_all(&tick_dep_mask, bit);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_dep_set_all",
          "args": [
            "&tick_dep_mask",
            "bit"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_dep_set_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "275-283",
          "snippet": "static void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_set(enum tick_dep_bits bit)\n{\n\ttick_nohz_dep_set_all(&tick_dep_mask, bit);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "275-283",
    "snippet": "static void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_full_kick_all",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "262-273",
          "snippet": "static void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_fetch_or",
          "args": [
            "BIT(bit)",
            "dep"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}"
  },
  {
    "function_name": "tick_nohz_full_kick_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "262-273",
    "snippet": "static void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_kick_cpu",
          "args": [
            "cpu"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "250-256",
          "snippet": "void tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_and",
          "args": [
            "cpu",
            "tick_nohz_full_mask",
            "cpu_online_mask"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "tick_nohz_full_kick_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "250-256",
    "snippet": "void tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue_on",
          "args": [
            "&per_cpu(nohz_full_kick_work, cpu)",
            "cpu"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "65-87",
          "snippet": "bool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n#ifdef CONFIG_SMP\n\n\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\tWARN_ON_ONCE(in_nmi());\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tif (llist_add(&work->llnode, &per_cpu(raised_list, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n#else /* #ifdef CONFIG_SMP */\n\tirq_work_queue(work);\n#endif /* #else #ifdef CONFIG_SMP */\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\n\nbool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n#ifdef CONFIG_SMP\n\n\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\tWARN_ON_ONCE(in_nmi());\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tif (llist_add(&work->llnode, &per_cpu(raised_list, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n#else /* #ifdef CONFIG_SMP */\n\tirq_work_queue(work);\n#endif /* #else #ifdef CONFIG_SMP */\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "nohz_full_kick_work",
            "cpu"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}"
  },
  {
    "function_name": "tick_nohz_full_kick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "238-244",
    "snippet": "static void tick_nohz_full_kick(void)\n{\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tirq_work_queue(this_cpu_ptr(&nohz_full_kick_work));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "this_cpu_ptr(&nohz_full_kick_work)"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&nohz_full_kick_work"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick(void)\n{\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tirq_work_queue(this_cpu_ptr(&nohz_full_kick_work));\n}"
  },
  {
    "function_name": "nohz_full_kick_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "223-226",
    "snippet": "static void nohz_full_kick_func(struct irq_work *work)\n{\n\t/* Empty, the tick restart happens on tick_nohz_irq_exit() */\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void nohz_full_kick_func(struct irq_work *work)\n{\n\t/* Empty, the tick restart happens on tick_nohz_irq_exit() */\n}"
  },
  {
    "function_name": "can_stop_full_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "201-221",
    "snippet": "static bool can_stop_full_tick(int cpu, struct tick_sched *ts)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (unlikely(!cpu_online(cpu)))\n\t\treturn false;\n\n\tif (check_tick_dependency(&tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&ts->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->signal->tick_dep_mask))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_tick_dependency",
          "args": [
            "&current->signal->tick_dep_mask"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "check_tick_dependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "174-199",
          "snippet": "static bool check_tick_dependency(atomic_t *dep)\n{\n\tint val = atomic_read(dep);\n\n\tif (val & TICK_DEP_MASK_POSIX_TIMER) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_POSIX_TIMER);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_PERF_EVENTS) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_PERF_EVENTS);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_SCHED) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_SCHED);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_CLOCK_UNSTABLE) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_CLOCK_UNSTABLE);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool check_tick_dependency(atomic_t *dep)\n{\n\tint val = atomic_read(dep);\n\n\tif (val & TICK_DEP_MASK_POSIX_TIMER) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_POSIX_TIMER);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_PERF_EVENTS) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_PERF_EVENTS);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_SCHED) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_SCHED);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_CLOCK_UNSTABLE) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_CLOCK_UNSTABLE);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cpu_online(cpu)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_full_tick(int cpu, struct tick_sched *ts)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (unlikely(!cpu_online(cpu)))\n\t\treturn false;\n\n\tif (check_tick_dependency(&tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&ts->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->signal->tick_dep_mask))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "check_tick_dependency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "174-199",
    "snippet": "static bool check_tick_dependency(atomic_t *dep)\n{\n\tint val = atomic_read(dep);\n\n\tif (val & TICK_DEP_MASK_POSIX_TIMER) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_POSIX_TIMER);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_PERF_EVENTS) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_PERF_EVENTS);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_SCHED) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_SCHED);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_CLOCK_UNSTABLE) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_CLOCK_UNSTABLE);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_CLOCK_UNSTABLE"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_SCHED"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_PERF_EVENTS"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_POSIX_TIMER"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "dep"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool check_tick_dependency(atomic_t *dep)\n{\n\tint val = atomic_read(dep);\n\n\tif (val & TICK_DEP_MASK_POSIX_TIMER) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_POSIX_TIMER);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_PERF_EVENTS) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_PERF_EVENTS);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_SCHED) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_SCHED);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_CLOCK_UNSTABLE) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_CLOCK_UNSTABLE);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "tick_sched_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "141-166",
    "snippet": "static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_tick",
          "args": [
            "CPU_PROFILING"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "profile_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
          "lines": "401-408",
          "snippet": "void profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && prof_cpu_mask != NULL &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t prof_cpu_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nvoid profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && prof_cpu_mask != NULL &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_process_times",
          "args": [
            "user_mode(regs)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "update_process_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1629-1644",
          "snippet": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_check_callbacks(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers(p);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_check_callbacks(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sched",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "264-271",
          "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}"
  },
  {
    "function_name": "tick_sched_do_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "116-139",
    "snippet": "static void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t    && !tick_nohz_full_cpu(cpu))\n\t\ttick_do_timer_cpu = cpu;\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_do_update_jiffies64",
          "args": [
            "now"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_update_jiffies64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "57-98",
          "snippet": "static void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 0;\n\tktime_t delta;\n\n\t/*\n\t * Do a quick check without holding jiffies_lock:\n\t */\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta < tick_period)\n\t\treturn;\n\n\t/* Reevaluate with jiffies_lock held */\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta >= tick_period) {\n\n\t\tdelta = ktime_sub(delta, tick_period);\n\t\tlast_jiffies_update = ktime_add(last_jiffies_update,\n\t\t\t\t\t\ttick_period);\n\n\t\t/* Slow path for long timeouts */\n\t\tif (unlikely(delta >= tick_period)) {\n\t\t\ts64 incr = ktime_to_ns(tick_period);\n\n\t\t\tticks = ktime_divns(delta, incr);\n\n\t\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t\t   incr * ticks);\n\t\t}\n\t\tdo_timer(++ticks);\n\n\t\t/* Keep the tick_next_period variable up to date */\n\t\ttick_next_period = ktime_add(last_jiffies_update, tick_period);\n\t} else {\n\t\twrite_sequnlock(&jiffies_lock);\n\t\treturn;\n\t}\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 0;\n\tktime_t delta;\n\n\t/*\n\t * Do a quick check without holding jiffies_lock:\n\t */\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta < tick_period)\n\t\treturn;\n\n\t/* Reevaluate with jiffies_lock held */\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta >= tick_period) {\n\n\t\tdelta = ktime_sub(delta, tick_period);\n\t\tlast_jiffies_update = ktime_add(last_jiffies_update,\n\t\t\t\t\t\ttick_period);\n\n\t\t/* Slow path for long timeouts */\n\t\tif (unlikely(delta >= tick_period)) {\n\t\t\ts64 incr = ktime_to_ns(tick_period);\n\n\t\t\tticks = ktime_divns(delta, incr);\n\n\t\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t\t   incr * ticks);\n\t\t}\n\t\tdo_timer(++ticks);\n\n\t\t/* Keep the tick_next_period variable up to date */\n\t\ttick_next_period = ktime_add(last_jiffies_update, tick_period);\n\t} else {\n\t\twrite_sequnlock(&jiffies_lock);\n\t\treturn;\n\t}\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tick_do_timer_cpu == TICK_DO_TIMER_NONE"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)\n\t    && !tick_nohz_full_cpu(cpu))\n\t\ttick_do_timer_cpu = cpu;\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}"
  },
  {
    "function_name": "tick_init_jiffy_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "103-114",
    "snippet": "static ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\twrite_seqlock(&jiffies_lock);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_sequnlock(&jiffies_lock);\n\treturn period;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\twrite_seqlock(&jiffies_lock);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_sequnlock(&jiffies_lock);\n\treturn period;\n}"
  },
  {
    "function_name": "tick_do_update_jiffies64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "57-98",
    "snippet": "static void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 0;\n\tktime_t delta;\n\n\t/*\n\t * Do a quick check without holding jiffies_lock:\n\t */\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta < tick_period)\n\t\treturn;\n\n\t/* Reevaluate with jiffies_lock held */\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta >= tick_period) {\n\n\t\tdelta = ktime_sub(delta, tick_period);\n\t\tlast_jiffies_update = ktime_add(last_jiffies_update,\n\t\t\t\t\t\ttick_period);\n\n\t\t/* Slow path for long timeouts */\n\t\tif (unlikely(delta >= tick_period)) {\n\t\t\ts64 incr = ktime_to_ns(tick_period);\n\n\t\t\tticks = ktime_divns(delta, incr);\n\n\t\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t\t   incr * ticks);\n\t\t}\n\t\tdo_timer(++ticks);\n\n\t\t/* Keep the tick_next_period variable up to date */\n\t\ttick_next_period = ktime_add(last_jiffies_update, tick_period);\n\t} else {\n\t\twrite_sequnlock(&jiffies_lock);\n\t\treturn;\n\t}\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_wall_time",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "update_wall_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2136-2139",
          "snippet": "void update_wall_time(void)\n{\n\ttimekeeping_advance(TK_ADV_TICK);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid update_wall_time(void)\n{\n\ttimekeeping_advance(TK_ADV_TICK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "last_jiffies_update",
            "tick_period"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_timer",
          "args": [
            "++ticks"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "do_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2195-2199",
          "snippet": "void do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load(ticks);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "last_jiffies_update",
            "incr * ticks"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_divns",
          "args": [
            "delta",
            "incr"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_divns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "299-316",
          "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tick_period"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta >= tick_period"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "delta",
            "tick_period"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "last_jiffies_update"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "last_jiffies_update"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 0;\n\tktime_t delta;\n\n\t/*\n\t * Do a quick check without holding jiffies_lock:\n\t */\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta < tick_period)\n\t\treturn;\n\n\t/* Reevaluate with jiffies_lock held */\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta >= tick_period) {\n\n\t\tdelta = ktime_sub(delta, tick_period);\n\t\tlast_jiffies_update = ktime_add(last_jiffies_update,\n\t\t\t\t\t\ttick_period);\n\n\t\t/* Slow path for long timeouts */\n\t\tif (unlikely(delta >= tick_period)) {\n\t\t\ts64 incr = ktime_to_ns(tick_period);\n\n\t\t\tticks = ktime_divns(delta, incr);\n\n\t\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t\t   incr * ticks);\n\t\t}\n\t\tdo_timer(++ticks);\n\n\t\t/* Keep the tick_next_period variable up to date */\n\t\ttick_next_period = ktime_add(last_jiffies_update, tick_period);\n\t} else {\n\t\twrite_sequnlock(&jiffies_lock);\n\t\treturn;\n\t}\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
  },
  {
    "function_name": "tick_get_tick_sched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
    "lines": "43-46",
    "snippet": "struct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstruct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}"
  }
]