[
  {
    "function_name": "mmio_trace_printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "359-362",
    "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_vprintk",
          "args": [
            "0",
            "fmt",
            "args"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "trace_vprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3059-3062",
          "snippet": "int trace_vprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\treturn trace_array_vprintk(&global_trace, ip, fmt, args);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint trace_vprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\treturn trace_array_vprintk(&global_trace, ip, fmt, args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
  },
  {
    "function_name": "mmio_trace_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "348-357",
    "snippet": "void mmio_trace_mapping(struct mmiotrace_map *map)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data;\n\n\tpreempt_disable();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_map(tr, data, map);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *mmio_trace_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_mmiotrace_map",
          "args": [
            "tr",
            "data",
            "map"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_mmiotrace_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "325-346",
          "snippet": "static void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tint pc = preempt_count();\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), 0, pc);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, 0, pc);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t dropped_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic atomic_t dropped_count;\n\nstatic void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tint pc = preempt_count();\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), 0, pc);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, 0, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->trace_buffer.data",
            "smp_processor_id()"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic struct trace_array *mmio_trace_array;\n\nvoid mmio_trace_mapping(struct mmiotrace_map *map)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data;\n\n\tpreempt_disable();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_map(tr, data, map);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "__trace_mmiotrace_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "325-346",
    "snippet": "static void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tint pc = preempt_count();\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), 0, pc);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, 0, pc);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t dropped_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "tr",
            "buffer",
            "event",
            "0",
            "pc"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1250-1256",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "305-316",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dropped_count"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_MMIO_MAP",
            "sizeof(*entry)",
            "0",
            "pc"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic atomic_t dropped_count;\n\nstatic void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tint pc = preempt_count();\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), 0, pc);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, 0, pc);\n}"
  },
  {
    "function_name": "mmio_trace_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "318-323",
    "snippet": "void mmio_trace_rw(struct mmiotrace_rw *rw)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data = per_cpu_ptr(tr->trace_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_rw(tr, data, rw);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *mmio_trace_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_mmiotrace_rw",
          "args": [
            "tr",
            "data",
            "rw"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_mmiotrace_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "295-316",
          "snippet": "static void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tint pc = preempt_count();\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), 0, pc);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, 0, pc);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t dropped_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic atomic_t dropped_count;\n\nstatic void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tint pc = preempt_count();\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), 0, pc);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, 0, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->trace_buffer.data",
            "smp_processor_id()"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic struct trace_array *mmio_trace_array;\n\nvoid mmio_trace_rw(struct mmiotrace_rw *rw)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data = per_cpu_ptr(tr->trace_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_rw(tr, data, rw);\n}"
  },
  {
    "function_name": "__trace_mmiotrace_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "295-316",
    "snippet": "static void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tint pc = preempt_count();\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), 0, pc);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, 0, pc);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t dropped_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "tr",
            "buffer",
            "event",
            "0",
            "pc"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1250-1256",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "305-316",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dropped_count"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_MMIO_RW",
            "sizeof(*entry)",
            "0",
            "pc"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic atomic_t dropped_count;\n\nstatic void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tint pc = preempt_count();\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), 0, pc);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, 0, pc);\n}"
  },
  {
    "function_name": "init_mmio_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "289-292",
    "snippet": "__init static int init_mmio_trace(void)\n{\n\treturn register_tracer(&mmio_tracer);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&mmio_tracer"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1591-1672",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\n__init static int init_mmio_trace(void)\n{\n\treturn register_tracer(&mmio_tracer);\n}"
  },
  {
    "function_name": "mmio_print_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "262-274",
    "snippet": "static enum print_line_t mmio_print_line(struct trace_iterator *iter)\n{\n\tswitch (iter->ent->type) {\n\tcase TRACE_MMIO_RW:\n\t\treturn mmio_print_rw(iter);\n\tcase TRACE_MMIO_MAP:\n\t\treturn mmio_print_map(iter);\n\tcase TRACE_PRINT:\n\t\treturn mmio_print_mark(iter);\n\tdefault:\n\t\treturn TRACE_TYPE_HANDLED; /* ignore unknown entries */\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmio_print_mark",
          "args": [
            "iter"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_print_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "246-260",
          "snippet": "static enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t/* The trailing newline must be in the message. */\n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t/* The trailing newline must be in the message. */\n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmio_print_map",
          "args": [
            "iter"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_print_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "212-244",
          "snippet": "static enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmio_print_rw",
          "args": [
            "iter"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_print_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "167-210",
          "snippet": "static enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_line(struct trace_iterator *iter)\n{\n\tswitch (iter->ent->type) {\n\tcase TRACE_MMIO_RW:\n\t\treturn mmio_print_rw(iter);\n\tcase TRACE_MMIO_MAP:\n\t\treturn mmio_print_map(iter);\n\tcase TRACE_PRINT:\n\t\treturn mmio_print_mark(iter);\n\tdefault:\n\t\treturn TRACE_TYPE_HANDLED; /* ignore unknown entries */\n\t}\n}"
  },
  {
    "function_name": "mmio_print_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "246-260",
    "snippet": "static enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t/* The trailing newline must be in the message. */\n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"MARK %u.%06lu %s\"",
            "secs",
            "usec_rem",
            "msg"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "USEC_PER_SEC"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "iter->ts"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "241-246",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t/* The trailing newline must be in the message. */\n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "mmio_print_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "212-244",
    "snippet": "static enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"map what?\\n\""
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"UNMAP %u.%06lu %d 0x%lx %d\\n\"",
            "secs",
            "usec_rem",
            "m->map_id",
            "0UL",
            "0"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "USEC_PER_SEC"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "iter->ts"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "241-246",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "mmio_print_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "167-210",
    "snippet": "static enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"rw what?\\n\""
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\"",
            "secs",
            "usec_rem",
            "rw->map_id",
            "(unsigned long long)rw->phys",
            "(rw->value >> 16) & 0xff",
            "(rw->value >> 8) & 0xff",
            "(rw->value >> 0) & 0xff",
            "rw->pc",
            "0"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "USEC_PER_SEC"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "iter->ts"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "241-246",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "mmio_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "133-165",
    "snippet": "static ssize_t mmio_read(struct trace_iterator *iter, struct file *filp,\n\t\t\t\tchar __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tssize_t ret;\n\tstruct header_iter *hiter = iter->private;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long n;\n\n\tn = count_overruns(iter);\n\tif (n) {\n\t\t/* XXX: This is later than where events were lost. */\n\t\ttrace_seq_printf(s, \"MARK 0.000000 Lost %lu events.\\n\", n);\n\t\tif (!overrun_detected)\n\t\t\tpr_warn(\"mmiotrace has lost events\\n\");\n\t\toverrun_detected = true;\n\t\tgoto print_out;\n\t}\n\n\tif (!hiter)\n\t\treturn 0;\n\n\tmmio_print_pcidev(s, hiter->dev);\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, hiter->dev);\n\n\tif (!hiter->dev) {\n\t\tdestroy_header_iter(hiter);\n\t\titer->private = NULL;\n\t}\n\nprint_out:\n\tret = trace_seq_to_user(s, ubuf, cnt);\n\treturn (ret == -EBUSY) ? 0 : ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool overrun_detected;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_to_user",
          "args": [
            "s",
            "ubuf",
            "cnt"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "373-377",
          "snippet": "int trace_seq_to_user(struct trace_seq *s, char __user *ubuf, int cnt)\n{\n\t__trace_seq_init(s);\n\treturn seq_buf_to_user(&s->seq, ubuf, cnt);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nint trace_seq_to_user(struct trace_seq *s, char __user *ubuf, int cnt)\n{\n\t__trace_seq_init(s);\n\treturn seq_buf_to_user(&s->seq, ubuf, cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_header_iter",
          "args": [
            "hiter"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_header_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "91-97",
          "snippet": "static void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_device",
          "args": [
            "PCI_ANY_ID",
            "PCI_ANY_ID",
            "hiter->dev"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmio_print_pcidev",
          "args": [
            "s",
            "hiter->dev"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_print_pcidev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "63-89",
          "snippet": "static void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"mmiotrace has lost events\\n\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"MARK 0.000000 Lost %lu events.\\n\"",
            "n"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_overruns",
          "args": [
            "iter"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "count_overruns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "122-131",
          "snippet": "static unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->trace_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long prev_overruns;",
            "static atomic_t dropped_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic unsigned long prev_overruns;\nstatic atomic_t dropped_count;\n\nstatic unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->trace_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\n\nstatic ssize_t mmio_read(struct trace_iterator *iter, struct file *filp,\n\t\t\t\tchar __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tssize_t ret;\n\tstruct header_iter *hiter = iter->private;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long n;\n\n\tn = count_overruns(iter);\n\tif (n) {\n\t\t/* XXX: This is later than where events were lost. */\n\t\ttrace_seq_printf(s, \"MARK 0.000000 Lost %lu events.\\n\", n);\n\t\tif (!overrun_detected)\n\t\t\tpr_warn(\"mmiotrace has lost events\\n\");\n\t\toverrun_detected = true;\n\t\tgoto print_out;\n\t}\n\n\tif (!hiter)\n\t\treturn 0;\n\n\tmmio_print_pcidev(s, hiter->dev);\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, hiter->dev);\n\n\tif (!hiter->dev) {\n\t\tdestroy_header_iter(hiter);\n\t\titer->private = NULL;\n\t}\n\nprint_out:\n\tret = trace_seq_to_user(s, ubuf, cnt);\n\treturn (ret == -EBUSY) ? 0 : ret;\n}"
  },
  {
    "function_name": "count_overruns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "122-131",
    "snippet": "static unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->trace_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long prev_overruns;",
      "static atomic_t dropped_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_overruns",
          "args": [
            "iter->trace_buffer->buffer"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_overruns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "3488-3501",
          "snippet": "unsigned long ring_buffer_overruns(struct ring_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long overruns = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\toverruns += local_read(&cpu_buffer->overrun);\n\t}\n\n\treturn overruns;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nunsigned long ring_buffer_overruns(struct ring_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long overruns = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\toverruns += local_read(&cpu_buffer->overrun);\n\t}\n\n\treturn overruns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&dropped_count",
            "0"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic unsigned long prev_overruns;\nstatic atomic_t dropped_count;\n\nstatic unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->trace_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}"
  },
  {
    "function_name": "mmio_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "115-120",
    "snippet": "static void mmio_close(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter = iter->private;\n\tdestroy_header_iter(hiter);\n\titer->private = NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_header_iter",
          "args": [
            "hiter"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_header_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "91-97",
          "snippet": "static void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_close(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter = iter->private;\n\tdestroy_header_iter(hiter);\n\titer->private = NULL;\n}"
  },
  {
    "function_name": "mmio_pipe_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "99-112",
    "snippet": "static void mmio_pipe_open(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_puts(s, \"VERSION 20070824\\n\");\n\n\thiter = kzalloc(sizeof(*hiter), GFP_KERNEL);\n\tif (!hiter)\n\t\treturn;\n\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);\n\titer->private = hiter;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_get_device",
          "args": [
            "PCI_ANY_ID",
            "PCI_ANY_ID",
            "NULL"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*hiter)",
            "GFP_KERNEL"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"VERSION 20070824\\n\""
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_pipe_open(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_puts(s, \"VERSION 20070824\\n\");\n\n\thiter = kzalloc(sizeof(*hiter), GFP_KERNEL);\n\tif (!hiter)\n\t\treturn;\n\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);\n\titer->private = hiter;\n}"
  },
  {
    "function_name": "destroy_header_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "91-97",
    "snippet": "static void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hiter"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "hiter->dev"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}"
  },
  {
    "function_name": "mmio_print_pcidev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "63-89",
    "snippet": "static void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" \\n\""
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" %s\\n\"",
            "drv->name"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_driver",
          "args": [
            "dev"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}"
  },
  {
    "function_name": "mmio_trace_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "57-61",
    "snippet": "static void mmio_trace_start(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_reset_data(tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmio_reset_data",
          "args": [
            "tr"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_reset_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "30-36",
          "snippet": "static void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool overrun_detected;",
            "static unsigned long prev_overruns;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"in %s\\n\"",
            "__func__"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_trace_start(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_reset_data(tr);\n}"
  },
  {
    "function_name": "mmio_trace_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "48-55",
    "snippet": "static void mmio_trace_reset(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\n\tdisable_mmiotrace();\n\tmmio_reset_data(tr);\n\tmmio_trace_array = NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *mmio_trace_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmio_reset_data",
          "args": [
            "tr"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_reset_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "30-36",
          "snippet": "static void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool overrun_detected;",
            "static unsigned long prev_overruns;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_mmiotrace",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"in %s\\n\"",
            "__func__"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic struct trace_array *mmio_trace_array;\n\nstatic void mmio_trace_reset(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\n\tdisable_mmiotrace();\n\tmmio_reset_data(tr);\n\tmmio_trace_array = NULL;\n}"
  },
  {
    "function_name": "mmio_trace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "38-46",
    "snippet": "static int mmio_trace_init(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_trace_array = tr;\n\n\tmmio_reset_data(tr);\n\tenable_mmiotrace();\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *mmio_trace_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_mmiotrace",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmio_reset_data",
          "args": [
            "tr"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_reset_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "30-36",
          "snippet": "static void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool overrun_detected;",
            "static unsigned long prev_overruns;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"in %s\\n\"",
            "__func__"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic struct trace_array *mmio_trace_array;\n\nstatic int mmio_trace_init(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_trace_array = tr;\n\n\tmmio_reset_data(tr);\n\tenable_mmiotrace();\n\treturn 0;\n}"
  },
  {
    "function_name": "mmio_reset_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "30-36",
    "snippet": "static void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool overrun_detected;",
      "static unsigned long prev_overruns;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&tr->trace_buffer"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1690-1709",
          "snippet": "void tracing_reset_online_cpus(struct trace_buffer *buf)\n{\n\tstruct ring_buffer *buffer = buf->buffer;\n\tint cpu;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_sched();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tfor_each_online_cpu(cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct trace_buffer *buf)\n{\n\tstruct ring_buffer *buffer = buf->buffer;\n\tint cpu;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_sched();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tfor_each_online_cpu(cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}"
  }
]